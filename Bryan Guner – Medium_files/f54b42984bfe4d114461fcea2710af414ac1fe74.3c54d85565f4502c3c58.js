( window.webpackJsonp = window.webpackJsonp || [] ).push( [
  [ 33 ], {
    "+3Gp": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return d
      } ) ), n.d( t, "b", ( () => {
        return h
      } ) );
      const i = n( "MNsG" ),
        o = n( "Yr1X" ),
        r = n( "/UlZ" ),
        s = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        a = i.d ? 1.5 : 1.35;

      function u( e, t ) {
        if ( "number" === typeof e ) return e;
        const n = parseFloat( e );
        return isNaN( n ) ? t : n
      }

      function l( e, t, n ) {
        return e < t ? t : e > n ? n : e
      }

      function c( e, t ) {
        return "string" !== typeof e ? t : e
      }
      var d = ( () => {
          function e( e ) {
            this.zoomLevel = e.zoomLevel, this.fontFamily = String( e.fontFamily ), this.fontWeight = String( e.fontWeight ), this.fontSize = e.fontSize, this.lineHeight = 0 | e.lineHeight, this.letterSpacing = e.letterSpacing
          }
          return e.createFromRawSettings = ( t, n ) => {
            const i = c( t.fontFamily, r.b.fontFamily );
            const s = c( t.fontWeight, r.b.fontWeight );
            let d = u( t.fontSize, r.b.fontSize );
            0 === ( d = l( d, 0, 100 ) ) ? d = r.b.fontSize : d < 8 && ( d = 8 );
            let h = ( ( e, t ) => {
              if ( "number" === typeof e ) return Math.round( e );
              const n = parseInt( e );
              return isNaN( n ) ? t : n
            } )( t.lineHeight, 0 );
            0 === ( h = l( h, 0, 150 ) ) ? h = Math.round( a * d ) : h < 8 && ( h = 8 );
            let p = u( t.letterSpacing, 0 );
            p = l( p, -5, 20 );
            const f = 1 + .1 * o.a.getZoomLevel();
            return new e( {
              zoomLevel: n,
              fontFamily: i,
              fontWeight: s,
              fontSize: d *= f,
              lineHeight: h *= f,
              letterSpacing: p
            } )
          }, e.prototype.getId = function () {
            return this.zoomLevel + "-" + this.fontFamily + "-" + this.fontWeight + "-" + this.fontSize + "-" + this.lineHeight + "-" + this.letterSpacing
          }, e;
        } )(),
        h = ( e => {
          function t( t, n ) {
            const i = e.call( this, t ) || this;
            return i.isTrusted = n, i.isMonospace = t.isMonospace, i.typicalHalfwidthCharacterWidth = t.typicalHalfwidthCharacterWidth, i.typicalFullwidthCharacterWidth = t.typicalFullwidthCharacterWidth, i.spaceWidth = t.spaceWidth, i.maxDigitWidth = t.maxDigitWidth, i
          }
          return s( t, e ), t.prototype.equals = function ( e ) {
            return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.spaceWidth === e.spaceWidth && this.maxDigitWidth === e.maxDigitWidth
          }, t
        } )( d )
    },
    "+7oY": function ( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "i", ( () => {
        return u
      } ) ), n.d( t, "c", ( () => {
        return l
      } ) ), n.d( t, "h", ( () => {
        return c
      } ) ), n.d( t, "e", ( () => {
        return d
      } ) ), n.d( t, "d", ( () => {
        return h
      } ) ), n.d( t, "f", ( () => {
        return p
      } ) ), n.d( t, "g", ( () => {
        return f
      } ) );
      var i;
      const o = n( "ic2d" );
      const r = n( "Cg/j" );
      const s = n( "CRAX" );
      var a = Object( r.c )( "configurationService" );

      function u( e, t ) {
        const n = Object.create( null );
        for ( const i in e ) l( n, i, e[ i ], t );
        return n
      }

      function l( e, t, n, i ) {
        for ( var o = t.split( "." ), r = o.pop(), s = e, a = 0; a < o.length; a++ ) {
          const u = o[ a ];
          let l = s[ u ];
          switch ( typeof l ) {
            case "undefined":
              l = s[ u ] = Object.create( null );
              break;
            case "object":
              break;
            default:
              return void i( "Ignoring " + t + " as " + o.slice( 0, a + 1 ).join( "." ) + " is " + JSON.stringify( l ) )
          }
          s = l
        }
        "object" === typeof s ? s[ r ] = n : i( "Ignoring " + t + " as " + o.join( "." ) + " is " + JSON.stringify( s ) )
      }

      function c( e, t ) {
        ! function e( t, n ) {
          const i = n.shift();
          if ( 0 === n.length ) return void delete t[ i ];
          if ( -1 !== Object.keys( t ).indexOf( i ) ) {
            const o = t[ i ];
            "object" !== typeof o || Array.isArray( o ) || ( e( o, n ), 0 === Object.keys( o ).length && delete t[ i ] )
          }
        }( e, t.split( "." ) )
      }

      function d( e, t, n ) {
        const i = ( ( e, t ) => {
          for ( var n = e, i = 0; i < t.length; i++ ) {
            if ( "object" !== typeof n || null === n ) return;
            n = n[ t[ i ] ]
          }
          return n
        } )( e, t.split( "." ) );
        return "undefined" === typeof i ? n : i
      }

      function h() {
        const e = o.a.as( s.b.Configuration ).getConfigurationProperties();
        return Object.keys( e )
      }

      function p() {
        const e = Object.create( null ),
          t = o.a.as( s.b.Configuration ).getConfigurationProperties();
        for ( const n in t ) {
          l( e, n, t[ n ].default, ( e => {
            return console.error( "Conflict in default settings: " + e )
          } ) )
        }
        return e
      }

      function f( e ) {
        return e.substring( 1, e.length - 1 )
      }!( e => {
        e[ e.USER = 1 ] = "USER", e[ e.WORKSPACE = 2 ] = "WORKSPACE", e[ e.WORKSPACE_FOLDER = 3 ] = "WORKSPACE_FOLDER", e[ e.DEFAULT = 4 ] = "DEFAULT", e[ e.MEMORY = 5 ] = "MEMORY"
      } )( i || ( i = {} ) )
    },
    "+Fos": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return a
      } ) );
      const i = n( "Ll0s" );
      const o = n( "cGHE" );
      const r = n( "aokT" );
      const s = function ( e, t, n ) {
        this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = n
      };

      var a = ( () => {
        function e() {}
        return e.left = ( e, t, n, o ) => {
          return o > t.getLineMinColumn( n ) ? i.a.isLowSurrogate( t, n, o - 2 ) ? o -= 2 : o -= 1 : n > 1 && ( n -= 1, o = t.getLineMaxColumn( n ) ), new s( n, o, 0 )
        }, e.moveLeft = ( t, n, i, o, r ) => {
          let s, a;
          if ( i.hasSelection() && !o ) s = i.selection.startLineNumber, a = i.selection.startColumn;
          else {
            const u = e.left( t, n, i.position.lineNumber, i.position.column - ( r - 1 ) );
            s = u.lineNumber, a = u.column
          }
          return i.move( o, s, a, 0 )
        }, e.right = ( e, t, n, o ) => {
          return o < t.getLineMaxColumn( n ) ? i.a.isHighSurrogate( t, n, o - 1 ) ? o += 2 : o += 1 : n < t.getLineCount() && ( n += 1, o = t.getLineMinColumn( n ) ), new s( n, o, 0 )
        }, e.moveRight = ( t, n, i, o, r ) => {
          let s, a;
          if ( i.hasSelection() && !o ) s = i.selection.endLineNumber, a = i.selection.endColumn;
          else {
            const u = e.right( t, n, i.position.lineNumber, i.position.column + ( r - 1 ) );
            s = u.lineNumber, a = u.column
          }
          return i.move( o, s, a, 0 )
        }, e.down = ( e, t, n, o, r, a, u ) => {
          const l = i.a.visibleColumnFromColumn( t.getLineContent( n ), o, e.tabSize ) + r;
          n += a;
          const c = t.getLineCount();
          return n > c ? ( n = c, u ? o = t.getLineMaxColumn( n ) : ( o = Math.min( t.getLineMaxColumn( n ), o ), i.a.isInsideSurrogatePair( t, n, o ) && ( o -= 1 ) ) ) : ( o = i.a.columnFromVisibleColumn2( e, t, n, l ), i.a.isInsideSurrogatePair( t, n, o ) && ( o -= 1 ) ), r = l - i.a.visibleColumnFromColumn( t.getLineContent( n ), o, e.tabSize ), new s( n, o, r )
        }, e.moveDown = ( t, n, i, o, r ) => {
          let s, a;
          i.hasSelection() && !o ? ( s = i.selection.endLineNumber, a = i.selection.endColumn ) : ( s = i.position.lineNumber, a = i.position.column );
          const u = e.down( t, n, s, a, i.leftoverVisibleColumns, r, !0 );
          return i.move( o, u.lineNumber, u.column, u.leftoverVisibleColumns )
        }, e.translateDown = ( t, n, s ) => {
          const a = s.selection,
            u = e.down( t, n, a.selectionStartLineNumber, a.selectionStartColumn, s.selectionStartLeftoverVisibleColumns, 1, !1 ),
            l = e.down( t, n, a.positionLineNumber, a.positionColumn, s.leftoverVisibleColumns, 1, !1 );
          return new i.f( new r.a( u.lineNumber, u.column, u.lineNumber, u.column ), u.leftoverVisibleColumns, new o.a( l.lineNumber, l.column ), l.leftoverVisibleColumns )
        }, e.up = ( e, t, n, o, r, a, u ) => {
          const l = i.a.visibleColumnFromColumn( t.getLineContent( n ), o, e.tabSize ) + r;
          return ( n -= a ) < 1 ? ( n = 1, u ? o = t.getLineMinColumn( n ) : ( o = Math.min( t.getLineMaxColumn( n ), o ), i.a.isInsideSurrogatePair( t, n, o ) && ( o -= 1 ) ) ) : ( o = i.a.columnFromVisibleColumn2( e, t, n, l ), i.a.isInsideSurrogatePair( t, n, o ) && ( o -= 1 ) ), r = l - i.a.visibleColumnFromColumn( t.getLineContent( n ), o, e.tabSize ), new s( n, o, r )
        }, e.moveUp = ( t, n, i, o, r ) => {
          let s, a;
          i.hasSelection() && !o ? ( s = i.selection.startLineNumber, a = i.selection.startColumn ) : ( s = i.position.lineNumber, a = i.position.column );
          const u = e.up( t, n, s, a, i.leftoverVisibleColumns, r, !0 );
          return i.move( o, u.lineNumber, u.column, u.leftoverVisibleColumns )
        }, e.translateUp = ( t, n, s ) => {
          const a = s.selection,
            u = e.up( t, n, a.selectionStartLineNumber, a.selectionStartColumn, s.selectionStartLeftoverVisibleColumns, 1, !1 ),
            l = e.up( t, n, a.positionLineNumber, a.positionColumn, s.leftoverVisibleColumns, 1, !1 );
          return new i.f( new r.a( u.lineNumber, u.column, u.lineNumber, u.column ), u.leftoverVisibleColumns, new o.a( l.lineNumber, l.column ), l.leftoverVisibleColumns )
        }, e.moveToBeginningOfLine = ( e, t, n, i ) => {
          let o;
          const r = n.position.lineNumber;
          const s = t.getLineMinColumn( r );
          const a = t.getLineFirstNonWhitespaceColumn( r ) || s;
          return o = n.position.column === a ? s : a, n.move( i, r, o, 0 )
        }, e.moveToEndOfLine = ( e, t, n, i ) => {
          const o = n.position.lineNumber,
            r = t.getLineMaxColumn( o );
          return n.move( i, o, r, 0 )
        }, e.moveToBeginningOfBuffer = ( e, t, n, i ) => {
          return n.move( i, 1, 1, 0 )
        }, e.moveToEndOfBuffer = ( e, t, n, i ) => {
          const o = t.getLineCount(),
            r = t.getLineMaxColumn( o );
          return n.move( i, o, r, 0 )
        }, e;
      } )();
    },
    "+KTK": function ( e, t, n ) {
      "use strict";
      n.r( t );
      n( "eA/6" ), n( "SBYE" ), n( "gJAb" ), n( "oiKk" ), n( "WQDh" ), n( "AhDq" ), n( "v+CO" ), n( "vVA1" ), n( "4sI4" );
      const i = n( "M/lh" );
      for ( const o in i ) "default" !== o && ( e => {
        n.d( t, e, ( () => {
          return i[ e ]
        } ) )
      } )( o )
    },
    "+a1H": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "handlebars",
        extensions: [ ".handlebars", ".hbs" ],
        aliases: [ "Handlebars", "handlebars" ],
        mimetypes: [ "text/x-handlebars-template" ],
        loader() {
          return o.Promise.wrap( n.e( 268 ).then( n.bind( null, "O3xE" ) ) )
        }
      } )
    },
    "+hIS": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return a
      } ) );
      const i = "undefined" === typeof monaco ? self.monaco : monaco,
        o = {};
      const r = {};

      function s( e ) {
        return r[ e ] || ( r[ e ] = ( e => {
          return ( 0, o[ e ].loader )().then( ( t => {
            i.languages.setMonarchTokensProvider( e, t.language ), i.languages.setLanguageConfiguration( e, t.conf )
          } ) );
        } )( e ) ), r[ e ];
      }

      function a( e ) {
        const t = e.id;
        o[ t ] = e, i.languages.register( e ), i.languages.onLanguage( t, ( () => {
          s( t )
        } ) )
      }
    },
    "/RFl": function ( e, t, n ) {
      "use strict";
      n.r( t );
      n( "OhnE" );
      const i = n( "pmY6" ),
        o = n( "MNsG" ),
        r = n( "sFUC" ),
        s = n( "sswD" ),
        a = n( "cGHE" ),
        u = n( "aokT" ),
        l = n( "gCVg" ),
        c = ( () => {
          function e( e, t, n ) {
            this.selection = e, this.targetPosition = t, this.copy = n
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            const n = e.getValueInRange( this.selection );
            this.copy || t.addEditOperation( this.selection, null ), t.addEditOperation( new u.a( this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column ), n ), !this.selection.containsPosition( this.targetPosition ) || this.copy && ( this.selection.getEndPosition().equals( this.targetPosition ) || this.selection.getStartPosition().equals( this.targetPosition ) ) ? this.copy ? this.targetSelection = new l.a( this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn ) : this.targetPosition.lineNumber > this.selection.endLineNumber ? this.targetSelection = new l.a( this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn ) : this.targetPosition.lineNumber < this.selection.endLineNumber ? this.targetSelection = new l.a( this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn ) : this.selection.endColumn <= this.targetPosition.column ? this.targetSelection = new l.a( this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, ( this.selection.startLineNumber, this.selection.endLineNumber, this.targetPosition.column - this.selection.endColumn + this.selection.startColumn ), this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn ) : this.targetSelection = new l.a( this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn ) : this.targetSelection = this.selection
          }, e.prototype.computeCursorState = function ( e, t ) {
            return this.targetSelection
          }, e;
        } )(),
        d = n( "tX9W" );

      function h( e ) {
        return o.d ? e.altKey : e.ctrlKey
      }
      n.d( t, "DragAndDropController", ( () => {
        return p
      } ) );
      var p = ( () => {
        function e( e ) {
          const t = this;
          this._editor = e, this._toUnhook = [], this._toUnhook.push( this._editor.onMouseDown( ( e => {
            return t._onEditorMouseDown( e )
          } ) ) ), this._toUnhook.push( this._editor.onMouseUp( ( e => {
            return t._onEditorMouseUp( e )
          } ) ) ), this._toUnhook.push( this._editor.onMouseDrag( ( e => {
            return t._onEditorMouseDrag( e )
          } ) ) ), this._toUnhook.push( this._editor.onMouseDrop( ( e => {
            return t._onEditorMouseDrop( e )
          } ) ) ), this._toUnhook.push( this._editor.onKeyDown( ( e => {
            return t.onEditorKeyDown( e )
          } ) ) ), this._toUnhook.push( this._editor.onKeyUp( ( e => {
            return t.onEditorKeyUp( e )
          } ) ) ), this._dndDecorationIds = [], this._mouseDown = !1, this._modiferPressed = !1, this._dragSelection = null
        }
        return e.prototype.onEditorKeyDown = function ( e ) {
          this._editor.getConfiguration().dragAndDrop && ( h( e ) && ( this._modiferPressed = !0 ), this._mouseDown && h( e ) && this._editor.updateOptions( {
            mouseStyle: "copy"
          } ) )
        }, e.prototype.onEditorKeyUp = function ( t ) {
          this._editor.getConfiguration().dragAndDrop && ( h( t ) && ( this._modiferPressed = !1 ), this._mouseDown && t.keyCode === e.TRIGGER_KEY_VALUE && this._editor.updateOptions( {
            mouseStyle: "default"
          } ) )
        }, e.prototype._onEditorMouseDown = function ( e ) {
          this._mouseDown = !0
        }, e.prototype._onEditorMouseUp = function ( e ) {
          this._mouseDown = !1, this._editor.updateOptions( {
            mouseStyle: "text"
          } )
        }, e.prototype._onEditorMouseDrag = function ( e ) {
          const t = e.target;
          if ( null === this._dragSelection ) {
            const n = this._editor.getSelections().filter( ( e => {
              return e.containsPosition( t.position )
            } ) );
            if ( 1 !== n.length ) return;
            this._dragSelection = n[ 0 ]
          }
          h( e.event ) ? this._editor.updateOptions( {
            mouseStyle: "copy"
          } ) : this._editor.updateOptions( {
            mouseStyle: "default"
          } ), this._dragSelection.containsPosition( t.position ) ? this._removeDecoration() : this.showAt( t.position )
        }, e.prototype._onEditorMouseDrop = function ( t ) {
          if ( t.target && ( this._hitContent( t.target ) || this._hitMargin( t.target ) ) && t.target.position ) {
            const n = new a.a( t.target.position.lineNumber, t.target.position.column );
            if ( null === this._dragSelection )
              if ( t.event.shiftKey ) {
                const i = this._editor.getSelection(),
                  o = i.startLineNumber,
                  r = i.startColumn;
                this._editor.setSelections( [ new l.a( o, r, n.lineNumber, n.column ) ] )
              } else {
                const s = this._editor.getSelections().map( ( e => {
                  return e.containsPosition( n ) ? new l.a( n.lineNumber, n.column, n.lineNumber, n.column ) : e
                } ) );
                this._editor.setSelections( s )
              }
            else( !this._dragSelection.containsPosition( n ) || ( h( t.event ) || this._modiferPressed ) && ( this._dragSelection.getEndPosition().equals( n ) || this._dragSelection.getStartPosition().equals( n ) ) ) && ( this._editor.pushUndoStop(), this._editor.executeCommand( e.ID, new c( this._dragSelection, n, h( t.event ) || this._modiferPressed ) ), this._editor.pushUndoStop() )
          }
          this._editor.updateOptions( {
            mouseStyle: "text"
          } ), this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1
        }, e.prototype.showAt = function ( t ) {
          const n = [ {
            range: new u.a( t.lineNumber, t.column, t.lineNumber, t.column ),
            options: e._DECORATION_OPTIONS
          } ];
          this._dndDecorationIds = this._editor.deltaDecorations( this._dndDecorationIds, n ), this._editor.revealPosition( t, 1 )
        }, e.prototype._removeDecoration = function () {
          this._dndDecorationIds = this._editor.deltaDecorations( this._dndDecorationIds, [] )
        }, e.prototype._hitContent = e => {
          return e.type === r.b.CONTENT_TEXT || e.type === r.b.CONTENT_EMPTY
        }, e.prototype._hitMargin = e => {
          return e.type === r.b.GUTTER_GLYPH_MARGIN || e.type === r.b.GUTTER_LINE_NUMBERS || e.type === r.b.GUTTER_LINE_DECORATIONS
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.dispose = function () {
          this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1, this._modiferPressed = !1, this._toUnhook = Object( i.d )( this._toUnhook )
        }, e.ID = "editor.contrib.dragAndDrop", e.TRIGGER_KEY_VALUE = o.d ? 6 : 5, e._DECORATION_OPTIONS = d.a.register( {
          className: "dnd-target"
        } ), e;
      } )();
      Object( s.h )( p )
    },
    "/UlZ": function ( e, t, n ) {
      "use strict";
      n.d( t, "g", ( () => {
        return i
      } ) ), n.d( t, "j", ( () => {
        return o
      } ) ), n.d( t, "h", ( () => {
        return r
      } ) ), n.d( t, "k", ( () => {
        return f
      } ) ), n.d( t, "i", ( () => {
        return s
      } ) ), n.d( t, "l", ( () => {
        return g
      } ) ), n.d( t, "e", ( () => {
        return m
      } ) ), n.d( t, "d", ( () => {
        return O
      } ) ), n.d( t, "f", ( () => {
        return L
      } ) ), n.d( t, "b", ( () => {
        return N
      } ) ), n.d( t, "c", ( () => {
        return E
      } ) ), n.d( t, "a", ( () => {
        return k
      } ) );
      var i;
      var o;
      var r;
      var s;
      const a = n( "3/fG" );
      const u = n( "MNsG" );
      const l = n( "QuOb" );
      const c = n( "0JNc" );
      const d = n( "6OMU" );
      const h = n( "qj0h" );
      const p = Object.assign || function ( e ) {
        for ( let t, n = 1, i = arguments.length; n < i; n++ )
          for ( const o in t = arguments[ n ] ) Object.prototype.hasOwnProperty.call( t, o ) && ( e[ o ] = t[ o ] );
        return e
      };

      function f( e ) {
        if ( e === r.Blink ) return "blink";
        if ( e === r.Expand ) return "expand";
        if ( e === r.Phase ) return "phase";
        if ( e === r.Smooth ) return "smooth";
        if ( e === r.Solid ) return "solid";
        throw new Error( "blinkingStyleToString: Unknown blinkingStyle" )
      }

      function g( e ) {
        if ( e === s.Line ) return "line";
        if ( e === s.Block ) return "block";
        if ( e === s.Underline ) return "underline";
        if ( e === s.LineThin ) return "line-thin";
        if ( e === s.BlockOutline ) return "block-outline";
        if ( e === s.UnderlineThin ) return "underline-thin";
        throw new Error( "cursorStyleToString: Unknown cursorStyle" )
      }!( e => {
        e[ e.None = 0 ] = "None", e[ e.Small = 1 ] = "Small", e[ e.Large = 2 ] = "Large", e[ e.SmallBlocks = 3 ] = "SmallBlocks", e[ e.LargeBlocks = 4 ] = "LargeBlocks"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.None = 0 ] = "None", e[ e.Same = 1 ] = "Same", e[ e.Indent = 2 ] = "Indent", e[ e.DeepIndent = 3 ] = "DeepIndent"
      } )( o || ( o = {} ) ), ( e => {
        e[ e.Hidden = 0 ] = "Hidden", e[ e.Blink = 1 ] = "Blink", e[ e.Smooth = 2 ] = "Smooth", e[ e.Phase = 3 ] = "Phase", e[ e.Expand = 4 ] = "Expand", e[ e.Solid = 5 ] = "Solid"
      } )( r || ( r = {} ) ), ( e => {
        e[ e.Line = 1 ] = "Line", e[ e.Block = 2 ] = "Block", e[ e.Underline = 3 ] = "Underline", e[ e.LineThin = 4 ] = "LineThin", e[ e.BlockOutline = 5 ] = "BlockOutline", e[ e.UnderlineThin = 6 ] = "UnderlineThin"
      } )( s || ( s = {} ) );
      var m = ( () => {
        function e( e ) {
          this.canUseLayerHinting = e.canUseLayerHinting, this.pixelRatio = e.pixelRatio, this.editorClassName = e.editorClassName, this.lineHeight = 0 | e.lineHeight, this.readOnly = e.readOnly, this.accessibilitySupport = e.accessibilitySupport, this.multiCursorModifier = e.multiCursorModifier, this.multiCursorMergeOverlapping = e.multiCursorMergeOverlapping, this.wordSeparators = e.wordSeparators, this.autoClosingBrackets = e.autoClosingBrackets, this.autoIndent = e.autoIndent, this.useTabStops = e.useTabStops, this.tabFocusMode = e.tabFocusMode, this.dragAndDrop = e.dragAndDrop, this.emptySelectionClipboard = e.emptySelectionClipboard, this.layoutInfo = e.layoutInfo, this.fontInfo = e.fontInfo, this.viewInfo = e.viewInfo, this.wrappingInfo = e.wrappingInfo, this.contribInfo = e.contribInfo, this.showUnused = e.showUnused
        }
        return e.prototype.equals = function ( t ) {
          return this.canUseLayerHinting === t.canUseLayerHinting && this.pixelRatio === t.pixelRatio && this.editorClassName === t.editorClassName && this.lineHeight === t.lineHeight && this.readOnly === t.readOnly && this.accessibilitySupport === t.accessibilitySupport && this.multiCursorModifier === t.multiCursorModifier && this.multiCursorMergeOverlapping === t.multiCursorMergeOverlapping && this.wordSeparators === t.wordSeparators && this.autoClosingBrackets === t.autoClosingBrackets && this.autoIndent === t.autoIndent && this.useTabStops === t.useTabStops && this.tabFocusMode === t.tabFocusMode && this.dragAndDrop === t.dragAndDrop && this.showUnused === t.showUnused && this.emptySelectionClipboard === t.emptySelectionClipboard && e._equalsLayoutInfo( this.layoutInfo, t.layoutInfo ) && this.fontInfo.equals( t.fontInfo ) && e._equalsViewOptions( this.viewInfo, t.viewInfo ) && e._equalsWrappingInfo( this.wrappingInfo, t.wrappingInfo ) && e._equalsContribOptions( this.contribInfo, t.contribInfo )
        }, e.prototype.createChangeEvent = function ( t ) {
          return {
            canUseLayerHinting: this.canUseLayerHinting !== t.canUseLayerHinting,
            pixelRatio: this.pixelRatio !== t.pixelRatio,
            editorClassName: this.editorClassName !== t.editorClassName,
            lineHeight: this.lineHeight !== t.lineHeight,
            readOnly: this.readOnly !== t.readOnly,
            accessibilitySupport: this.accessibilitySupport !== t.accessibilitySupport,
            multiCursorModifier: this.multiCursorModifier !== t.multiCursorModifier,
            multiCursorMergeOverlapping: this.multiCursorMergeOverlapping !== t.multiCursorMergeOverlapping,
            wordSeparators: this.wordSeparators !== t.wordSeparators,
            autoClosingBrackets: this.autoClosingBrackets !== t.autoClosingBrackets,
            autoIndent: this.autoIndent !== t.autoIndent,
            useTabStops: this.useTabStops !== t.useTabStops,
            tabFocusMode: this.tabFocusMode !== t.tabFocusMode,
            dragAndDrop: this.dragAndDrop !== t.dragAndDrop,
            emptySelectionClipboard: this.emptySelectionClipboard !== t.emptySelectionClipboard,
            layoutInfo: !e._equalsLayoutInfo( this.layoutInfo, t.layoutInfo ),
            fontInfo: !this.fontInfo.equals( t.fontInfo ),
            viewInfo: !e._equalsViewOptions( this.viewInfo, t.viewInfo ),
            wrappingInfo: !e._equalsWrappingInfo( this.wrappingInfo, t.wrappingInfo ),
            contribInfo: !e._equalsContribOptions( this.contribInfo, t.contribInfo )
          }
        }, e._equalsLayoutInfo = function ( e, t ) {
          return e.width === t.width && e.height === t.height && e.glyphMarginLeft === t.glyphMarginLeft && e.glyphMarginWidth === t.glyphMarginWidth && e.glyphMarginHeight === t.glyphMarginHeight && e.lineNumbersLeft === t.lineNumbersLeft && e.lineNumbersWidth === t.lineNumbersWidth && e.lineNumbersHeight === t.lineNumbersHeight && e.decorationsLeft === t.decorationsLeft && e.decorationsWidth === t.decorationsWidth && e.decorationsHeight === t.decorationsHeight && e.contentLeft === t.contentLeft && e.contentWidth === t.contentWidth && e.contentHeight === t.contentHeight && e.renderMinimap === t.renderMinimap && e.minimapLeft === t.minimapLeft && e.minimapWidth === t.minimapWidth && e.viewportColumn === t.viewportColumn && e.verticalScrollbarWidth === t.verticalScrollbarWidth && e.horizontalScrollbarHeight === t.horizontalScrollbarHeight && this._equalsOverviewRuler( e.overviewRuler, t.overviewRuler )
        }, e._equalsOverviewRuler = ( e, t ) => {
          return e.width === t.width && e.height === t.height && e.top === t.top && e.right === t.right
        }, e._equalsViewOptions = function ( e, t ) {
          return e.extraEditorClassName === t.extraEditorClassName && e.disableMonospaceOptimizations === t.disableMonospaceOptimizations && d.e( e.rulers, t.rulers ) && e.ariaLabel === t.ariaLabel && e.renderLineNumbers === t.renderLineNumbers && e.renderCustomLineNumbers === t.renderCustomLineNumbers && e.selectOnLineNumbers === t.selectOnLineNumbers && e.glyphMargin === t.glyphMargin && e.revealHorizontalRightPadding === t.revealHorizontalRightPadding && e.roundedSelection === t.roundedSelection && e.overviewRulerLanes === t.overviewRulerLanes && e.overviewRulerBorder === t.overviewRulerBorder && e.cursorBlinking === t.cursorBlinking && e.mouseWheelZoom === t.mouseWheelZoom && e.cursorStyle === t.cursorStyle && e.cursorWidth === t.cursorWidth && e.hideCursorInOverviewRuler === t.hideCursorInOverviewRuler && e.scrollBeyondLastLine === t.scrollBeyondLastLine && e.scrollBeyondLastColumn === t.scrollBeyondLastColumn && e.smoothScrolling === t.smoothScrolling && e.stopRenderingLineAfter === t.stopRenderingLineAfter && e.renderWhitespace === t.renderWhitespace && e.renderControlCharacters === t.renderControlCharacters && e.fontLigatures === t.fontLigatures && e.renderIndentGuides === t.renderIndentGuides && e.highlightActiveIndentGuide === t.highlightActiveIndentGuide && e.renderLineHighlight === t.renderLineHighlight && this._equalsScrollbarOptions( e.scrollbar, t.scrollbar ) && this._equalsMinimapOptions( e.minimap, t.minimap ) && e.fixedOverflowWidgets === t.fixedOverflowWidgets
        }, e._equalsScrollbarOptions = ( e, t ) => {
          return e.arrowSize === t.arrowSize && e.vertical === t.vertical && e.horizontal === t.horizontal && e.useShadows === t.useShadows && e.verticalHasArrows === t.verticalHasArrows && e.horizontalHasArrows === t.horizontalHasArrows && e.handleMouseWheel === t.handleMouseWheel && e.horizontalScrollbarSize === t.horizontalScrollbarSize && e.horizontalSliderSize === t.horizontalSliderSize && e.verticalScrollbarSize === t.verticalScrollbarSize && e.verticalSliderSize === t.verticalSliderSize && e.mouseWheelScrollSensitivity === t.mouseWheelScrollSensitivity
        }, e._equalsMinimapOptions = ( e, t ) => {
          return e.enabled === t.enabled && e.side === t.side && e.showSlider === t.showSlider && e.renderCharacters === t.renderCharacters && e.maxColumn === t.maxColumn
        }, e._equalFindOptions = ( e, t ) => {
          return e.seedSearchStringFromSelection === t.seedSearchStringFromSelection && e.autoFindInSelection === t.autoFindInSelection && e.globalFindClipboard === t.globalFindClipboard
        }, e._equalsHoverOptions = ( e, t ) => {
          return e.enabled === t.enabled && e.delay === t.delay && e.sticky === t.sticky
        }, e._equalsSuggestOptions = ( e, t ) => {
          return e === t || !( !e || !t ) && ( e.filterGraceful === t.filterGraceful && e.snippets === t.snippets && e.snippetsPreventQuickSuggestions === t.snippetsPreventQuickSuggestions )
        }, e._equalsWrappingInfo = ( e, t ) => {
          return e.inDiffEditor === t.inDiffEditor && e.isDominatedByLongLines === t.isDominatedByLongLines && e.isWordWrapMinified === t.isWordWrapMinified && e.isViewportWrapping === t.isViewportWrapping && e.wrappingColumn === t.wrappingColumn && e.wrappingIndent === t.wrappingIndent && e.wordWrapBreakBeforeCharacters === t.wordWrapBreakBeforeCharacters && e.wordWrapBreakAfterCharacters === t.wordWrapBreakAfterCharacters && e.wordWrapBreakObtrusiveCharacters === t.wordWrapBreakObtrusiveCharacters
        }, e._equalsContribOptions = function ( t, n ) {
          return t.selectionClipboard === n.selectionClipboard && this._equalsHoverOptions( t.hover, n.hover ) && t.links === n.links && t.contextmenu === n.contextmenu && e._equalsQuickSuggestions( t.quickSuggestions, n.quickSuggestions ) && t.quickSuggestionsDelay === n.quickSuggestionsDelay && t.parameterHints === n.parameterHints && t.iconsInSuggestions === n.iconsInSuggestions && t.formatOnType === n.formatOnType && t.formatOnPaste === n.formatOnPaste && t.suggestOnTriggerCharacters === n.suggestOnTriggerCharacters && t.acceptSuggestionOnEnter === n.acceptSuggestionOnEnter && t.acceptSuggestionOnCommitCharacter === n.acceptSuggestionOnCommitCharacter && t.wordBasedSuggestions === n.wordBasedSuggestions && t.suggestSelection === n.suggestSelection && t.suggestFontSize === n.suggestFontSize && t.suggestLineHeight === n.suggestLineHeight && this._equalsSuggestOptions( t.suggest, n.suggest ) && t.selectionHighlight === n.selectionHighlight && t.occurrencesHighlight === n.occurrencesHighlight && t.codeLens === n.codeLens && t.folding === n.folding && t.foldingStrategy === n.foldingStrategy && t.showFoldingControls === n.showFoldingControls && t.matchBrackets === n.matchBrackets && this._equalFindOptions( t.find, n.find ) && t.colorDecorators === n.colorDecorators && h.e( t.codeActionsOnSave, n.codeActionsOnSave ) && t.codeActionsOnSaveTimeout === n.codeActionsOnSaveTimeout && t.lightbulbEnabled === n.lightbulbEnabled
        }, e._equalsQuickSuggestions = ( e, t ) => {
          return "boolean" === typeof e ? "boolean" === typeof t && e === t : "boolean" !== typeof t && ( e.comments === t.comments && e.other === t.other && e.strings === t.strings )
        }, e;
      } )();

      function _( e, t ) {
        return "undefined" === typeof e ? t : "false" !== e && Boolean( e )
      }

      function v( e, t ) {
        if ( !e ) return t;
        for ( var n = Object.create( null ), i = 0, o = Object.keys( e ); i < o.length; i++ ) {
          const r = o[ i ],
            s = e[ r ];
          "boolean" === typeof s && ( n[ r ] = s )
        }
        return n
      }

      function y( e, t ) {
        return "string" !== typeof e ? t : e
      }

      function b( e, t, n ) {
        return "string" !== typeof e ? t : -1 === n.indexOf( e ) ? t : e
      }

      function C( e, t, n, i ) {
        let o;
        return "undefined" === typeof e ? o = t : ( o = parseInt( e, 10 ), isNaN( o ) && ( o = t ) ), o = Math.max( n, o ), 0 | ( o = Math.min( i, o ) )
      }

      function w( e, t ) {
        if ( "string" !== typeof e ) return t;
        switch ( e ) {
          case "blink":
            return r.Blink;
          case "smooth":
            return r.Smooth;
          case "phase":
            return r.Phase;
          case "expand":
            return r.Expand;
          case "visible":
          case "solid":
            return r.Solid
        }
        return r.Blink
      }

      function S( e, t ) {
        if ( "string" !== typeof e ) return t;
        switch ( e ) {
          case "hidden":
            return l.b.Hidden;
          case "visible":
            return l.b.Visible;
          default:
            return l.b.Auto
        }
      }

      var O = ( () => {
        function e() {}
        return e.validate = function ( e, t ) {
          let n = e.wordWrap;
          !0 === n ? n = "on" : !1 === n && ( n = "off" ), n = b( n, t.wordWrap, [ "off", "on", "wordWrapColumn", "bounded" ] );
          let i;
          const r = this._sanitizeViewInfo( e, t.viewInfo );
          const s = this._sanitizeContribInfo( e, t.contribInfo );
          "string" === typeof e.multiCursorModifier && ( i = "ctrlCmd" === e.multiCursorModifier ? u.d ? "metaKey" : "ctrlKey" : "altKey" );
          let a;
          let l;
          const c = b( i, t.multiCursorModifier, [ "altKey", "metaKey", "ctrlKey" ] );
          return {
            inDiffEditor: _( e.inDiffEditor, t.inDiffEditor ),
            wordSeparators: y( e.wordSeparators, t.wordSeparators ),
            lineNumbersMinChars: C( e.lineNumbersMinChars, t.lineNumbersMinChars, 1, 10 ),
            lineDecorationsWidth: "undefined" === typeof e.lineDecorationsWidth ? t.lineDecorationsWidth : e.lineDecorationsWidth,
            readOnly: _( e.readOnly, t.readOnly ),
            mouseStyle: b( e.mouseStyle, t.mouseStyle, [ "text", "default", "copy" ] ),
            disableLayerHinting: _( e.disableLayerHinting, t.disableLayerHinting ),
            automaticLayout: _( e.automaticLayout, t.automaticLayout ),
            wordWrap: n,
            wordWrapColumn: C( e.wordWrapColumn, t.wordWrapColumn, 1, 1073741824 ),
            wordWrapMinified: _( e.wordWrapMinified, t.wordWrapMinified ),
            wrappingIndent: ( a = e.wrappingIndent, l = t.wrappingIndent, "string" !== typeof a ? l : "same" === a ? o.Same : "indent" === a ? o.Indent : "deepIndent" === a ? o.DeepIndent : o.None ),
            wordWrapBreakBeforeCharacters: y( e.wordWrapBreakBeforeCharacters, t.wordWrapBreakBeforeCharacters ),
            wordWrapBreakAfterCharacters: y( e.wordWrapBreakAfterCharacters, t.wordWrapBreakAfterCharacters ),
            wordWrapBreakObtrusiveCharacters: y( e.wordWrapBreakObtrusiveCharacters, t.wordWrapBreakObtrusiveCharacters ),
            autoClosingBrackets: _( e.autoClosingBrackets, t.autoClosingBrackets ),
            autoIndent: _( e.autoIndent, t.autoIndent ),
            dragAndDrop: _( e.dragAndDrop, t.dragAndDrop ),
            emptySelectionClipboard: _( e.emptySelectionClipboard, t.emptySelectionClipboard ),
            useTabStops: _( e.useTabStops, t.useTabStops ),
            multiCursorModifier: c,
            multiCursorMergeOverlapping: _( e.multiCursorMergeOverlapping, t.multiCursorMergeOverlapping ),
            accessibilitySupport: b( e.accessibilitySupport, t.accessibilitySupport, [ "auto", "on", "off" ] ),
            showUnused: _( e.showUnused, t.showUnused ),
            viewInfo: r,
            contribInfo: s
          }
        }, e._sanitizeScrollbarOpts = ( e, t, n ) => {
          if ( "object" !== typeof e ) return t;
          const i = C( e.horizontalScrollbarSize, t.horizontalScrollbarSize, 0, 1e3 ),
            o = C( e.verticalScrollbarSize, t.verticalScrollbarSize, 0, 1e3 );
          return {
            vertical: S( e.vertical, t.vertical ),
            horizontal: S( e.horizontal, t.horizontal ),
            arrowSize: C( e.arrowSize, t.arrowSize, 0, 1e3 ),
            useShadows: _( e.useShadows, t.useShadows ),
            verticalHasArrows: _( e.verticalHasArrows, t.verticalHasArrows ),
            horizontalHasArrows: _( e.horizontalHasArrows, t.horizontalHasArrows ),
            horizontalScrollbarSize: i,
            horizontalSliderSize: C( e.horizontalSliderSize, i, 0, 1e3 ),
            verticalScrollbarSize: o,
            verticalSliderSize: C( e.verticalSliderSize, o, 0, 1e3 ),
            handleMouseWheel: _( e.handleMouseWheel, t.handleMouseWheel ),
            mouseWheelScrollSensitivity: n
          }
        }, e._sanitizeMinimapOpts = ( e, t ) => {
          return "object" !== typeof e ? t : {
            enabled: _( e.enabled, t.enabled ),
            side: b( e.side, t.side, [ "right", "left" ] ),
            showSlider: b( e.showSlider, t.showSlider, [ "always", "mouseover" ] ),
            renderCharacters: _( e.renderCharacters, t.renderCharacters ),
            maxColumn: C( e.maxColumn, t.maxColumn, 1, 1e4 )
          }
        }, e._santizeFindOpts = ( e, t ) => {
          return "object" !== typeof e ? t : {
            seedSearchStringFromSelection: _( e.seedSearchStringFromSelection, t.seedSearchStringFromSelection ),
            autoFindInSelection: _( e.autoFindInSelection, t.autoFindInSelection ),
            globalFindClipboard: _( e.globalFindClipboard, t.globalFindClipboard )
          }
        }, e._santizeHoverOpts = ( e, t ) => {
          let n;
          if ( "boolean" === typeof e ) n = {
            enabled: e
          };
          else {
            if ( "object" !== typeof e ) return t;
            n = e
          }
          return {
            enabled: _( n.enabled, t.enabled ),
            delay: C( n.delay, t.delay, 0, 1e4 ),
            sticky: _( n.sticky, t.sticky )
          }
        }, e._sanitizeSuggestOpts = ( e, t ) => {
          const n = e.suggest || {};
          return {
            filterGraceful: _( n.filterGraceful, t.filterGraceful ),
            snippets: b( e.snippetSuggestions, t.snippets, [ "top", "bottom", "inline", "none" ] ),
            snippetsPreventQuickSuggestions: _( n.snippetsPreventQuickSuggestions, t.filterGraceful )
          }
        }, e._sanitizeViewInfo = function ( e, t ) {
          const n = [];
          if ( Array.isArray( e.rulers ) ) {
            for ( let i = 0, o = e.rulers.length; i < o; i++ ) n.push( C( e.rulers[ i ], 0, 0, 1e4 ) );
            n.sort()
          }
          let r = t.renderLineNumbers,
            a = t.renderCustomLineNumbers;
          if ( "undefined" !== typeof e.lineNumbers ) {
            let u = e.lineNumbers;
            !0 === u ? u = "on" : !1 === u && ( u = "off" ), "function" === typeof u ? ( r = 4, a = u ) : r = "interval" === u ? 3 : "relative" === u ? 2 : "on" === u ? 1 : 0
          }
          const l = _( e.fontLigatures, t.fontLigatures );
          const c = _( e.disableMonospaceOptimizations, t.disableMonospaceOptimizations ) || l;
          let d = e.renderWhitespace;
          !0 === d ? d = "boundary" : !1 === d && ( d = "none" ), d = b( e.renderWhitespace, t.renderWhitespace, [ "none", "boundary", "all" ] );
          let h = e.renderLineHighlight;
          !0 === h ? h = "line" : !1 === h && ( h = "none" ), h = b( e.renderLineHighlight, t.renderLineHighlight, [ "none", "gutter", "line", "all" ] );
          let p = ( ( e, t ) => {
            let n = parseFloat( e );
            return isNaN( n ) && ( n = t ), n
          } )( e.mouseWheelScrollSensitivity, t.scrollbar.mouseWheelScrollSensitivity );
          0 === p && ( p = 1 );
          let f;
          let g;
          const m = this._sanitizeScrollbarOpts( e.scrollbar, t.scrollbar, p );
          const v = this._sanitizeMinimapOpts( e.minimap, t.minimap );
          return {
            extraEditorClassName: y( e.extraEditorClassName, t.extraEditorClassName ),
            disableMonospaceOptimizations: c,
            rulers: n,
            ariaLabel: y( e.ariaLabel, t.ariaLabel ),
            renderLineNumbers: r,
            renderCustomLineNumbers: a,
            selectOnLineNumbers: _( e.selectOnLineNumbers, t.selectOnLineNumbers ),
            glyphMargin: _( e.glyphMargin, t.glyphMargin ),
            revealHorizontalRightPadding: C( e.revealHorizontalRightPadding, t.revealHorizontalRightPadding, 0, 1e3 ),
            roundedSelection: _( e.roundedSelection, t.roundedSelection ),
            overviewRulerLanes: C( e.overviewRulerLanes, t.overviewRulerLanes, 0, 3 ),
            overviewRulerBorder: _( e.overviewRulerBorder, t.overviewRulerBorder ),
            cursorBlinking: w( e.cursorBlinking, t.cursorBlinking ),
            mouseWheelZoom: _( e.mouseWheelZoom, t.mouseWheelZoom ),
            cursorStyle: ( f = e.cursorStyle, g = t.cursorStyle, "string" !== typeof f ? g : "line" === f ? s.Line : "block" === f ? s.Block : "underline" === f ? s.Underline : "line-thin" === f ? s.LineThin : "block-outline" === f ? s.BlockOutline : "underline-thin" === f ? s.UnderlineThin : s.Line ),
            cursorWidth: C( e.cursorWidth, t.cursorWidth, 0, Number.MAX_VALUE ),
            hideCursorInOverviewRuler: _( e.hideCursorInOverviewRuler, t.hideCursorInOverviewRuler ),
            scrollBeyondLastLine: _( e.scrollBeyondLastLine, t.scrollBeyondLastLine ),
            scrollBeyondLastColumn: C( e.scrollBeyondLastColumn, t.scrollBeyondLastColumn, 0, 1073741824 ),
            smoothScrolling: _( e.smoothScrolling, t.smoothScrolling ),
            stopRenderingLineAfter: C( e.stopRenderingLineAfter, t.stopRenderingLineAfter, -1, 1073741824 ),
            renderWhitespace: d,
            renderControlCharacters: _( e.renderControlCharacters, t.renderControlCharacters ),
            fontLigatures: l,
            renderIndentGuides: _( e.renderIndentGuides, t.renderIndentGuides ),
            highlightActiveIndentGuide: _( e.highlightActiveIndentGuide, t.highlightActiveIndentGuide ),
            renderLineHighlight: h,
            scrollbar: m,
            minimap: v,
            fixedOverflowWidgets: _( e.fixedOverflowWidgets, t.fixedOverflowWidgets )
          }
        }, e._sanitizeContribInfo = function ( e, t ) {
          let n;
          n = "object" === typeof e.quickSuggestions ? p( {
            other: !0
          }, e.quickSuggestions ) : _( e.quickSuggestions, t.quickSuggestions ), "boolean" === typeof e.acceptSuggestionOnEnter && ( e.acceptSuggestionOnEnter = e.acceptSuggestionOnEnter ? "on" : "off" );
          const i = this._santizeFindOpts( e.find, t.find );
          return {
            selectionClipboard: _( e.selectionClipboard, t.selectionClipboard ),
            hover: this._santizeHoverOpts( e.hover, t.hover ),
            links: _( e.links, t.links ),
            contextmenu: _( e.contextmenu, t.contextmenu ),
            quickSuggestions: n,
            quickSuggestionsDelay: C( e.quickSuggestionsDelay, t.quickSuggestionsDelay, -1073741824, 1073741824 ),
            parameterHints: _( e.parameterHints, t.parameterHints ),
            iconsInSuggestions: _( e.iconsInSuggestions, t.iconsInSuggestions ),
            formatOnType: _( e.formatOnType, t.formatOnType ),
            formatOnPaste: _( e.formatOnPaste, t.formatOnPaste ),
            suggestOnTriggerCharacters: _( e.suggestOnTriggerCharacters, t.suggestOnTriggerCharacters ),
            acceptSuggestionOnEnter: b( e.acceptSuggestionOnEnter, t.acceptSuggestionOnEnter, [ "on", "smart", "off" ] ),
            acceptSuggestionOnCommitCharacter: _( e.acceptSuggestionOnCommitCharacter, t.acceptSuggestionOnCommitCharacter ),
            wordBasedSuggestions: _( e.wordBasedSuggestions, t.wordBasedSuggestions ),
            suggestSelection: b( e.suggestSelection, t.suggestSelection, [ "first", "recentlyUsed", "recentlyUsedByPrefix" ] ),
            suggestFontSize: C( e.suggestFontSize, t.suggestFontSize, 0, 1e3 ),
            suggestLineHeight: C( e.suggestLineHeight, t.suggestLineHeight, 0, 1e3 ),
            suggest: this._sanitizeSuggestOpts( e, t.suggest ),
            selectionHighlight: _( e.selectionHighlight, t.selectionHighlight ),
            occurrencesHighlight: _( e.occurrencesHighlight, t.occurrencesHighlight ),
            codeLens: _( e.codeLens, t.codeLens ),
            folding: _( e.folding, t.folding ),
            foldingStrategy: b( e.foldingStrategy, t.foldingStrategy, [ "auto", "indentation" ] ),
            showFoldingControls: b( e.showFoldingControls, t.showFoldingControls, [ "always", "mouseover" ] ),
            matchBrackets: _( e.matchBrackets, t.matchBrackets ),
            find: i,
            colorDecorators: _( e.colorDecorators, t.colorDecorators ),
            lightbulbEnabled: _( !!e.lightbulb && e.lightbulb.enabled, t.lightbulbEnabled ),
            codeActionsOnSave: v( e.codeActionsOnSave, {} ),
            codeActionsOnSaveTimeout: C( e.codeActionsOnSaveTimeout, t.codeActionsOnSaveTimeout, 1, 1e4 )
          }
        }, e;
      } )();

      var L = ( () => {
        function e() {}
        return e._tweakValidatedOptions = ( e, t ) => {
          const n = 2 === t,
            i = 1 === t;
          return {
            inDiffEditor: e.inDiffEditor,
            wordSeparators: e.wordSeparators,
            lineNumbersMinChars: e.lineNumbersMinChars,
            lineDecorationsWidth: e.lineDecorationsWidth,
            readOnly: e.readOnly,
            mouseStyle: e.mouseStyle,
            disableLayerHinting: e.disableLayerHinting,
            automaticLayout: e.automaticLayout,
            wordWrap: e.wordWrap,
            wordWrapColumn: e.wordWrapColumn,
            wordWrapMinified: e.wordWrapMinified,
            wrappingIndent: e.wrappingIndent,
            wordWrapBreakBeforeCharacters: e.wordWrapBreakBeforeCharacters,
            wordWrapBreakAfterCharacters: e.wordWrapBreakAfterCharacters,
            wordWrapBreakObtrusiveCharacters: e.wordWrapBreakObtrusiveCharacters,
            autoClosingBrackets: e.autoClosingBrackets,
            autoIndent: e.autoIndent,
            dragAndDrop: e.dragAndDrop,
            emptySelectionClipboard: e.emptySelectionClipboard,
            useTabStops: e.useTabStops,
            multiCursorModifier: e.multiCursorModifier,
            multiCursorMergeOverlapping: e.multiCursorMergeOverlapping,
            accessibilitySupport: e.accessibilitySupport,
            showUnused: e.showUnused,
            viewInfo: {
              extraEditorClassName: e.viewInfo.extraEditorClassName,
              disableMonospaceOptimizations: e.viewInfo.disableMonospaceOptimizations,
              rulers: e.viewInfo.rulers,
              ariaLabel: i ? a.a( "accessibilityOffAriaLabel", "The editor is not accessible at this time. Press Alt+F1 for options." ) : e.viewInfo.ariaLabel,
              renderLineNumbers: e.viewInfo.renderLineNumbers,
              renderCustomLineNumbers: e.viewInfo.renderCustomLineNumbers,
              selectOnLineNumbers: e.viewInfo.selectOnLineNumbers,
              glyphMargin: e.viewInfo.glyphMargin,
              revealHorizontalRightPadding: e.viewInfo.revealHorizontalRightPadding,
              roundedSelection: !n && e.viewInfo.roundedSelection,
              overviewRulerLanes: e.viewInfo.overviewRulerLanes,
              overviewRulerBorder: e.viewInfo.overviewRulerBorder,
              cursorBlinking: e.viewInfo.cursorBlinking,
              mouseWheelZoom: e.viewInfo.mouseWheelZoom,
              cursorStyle: e.viewInfo.cursorStyle,
              cursorWidth: e.viewInfo.cursorWidth,
              hideCursorInOverviewRuler: e.viewInfo.hideCursorInOverviewRuler,
              scrollBeyondLastLine: e.viewInfo.scrollBeyondLastLine,
              scrollBeyondLastColumn: e.viewInfo.scrollBeyondLastColumn,
              smoothScrolling: e.viewInfo.smoothScrolling,
              stopRenderingLineAfter: e.viewInfo.stopRenderingLineAfter,
              renderWhitespace: n ? "none" : e.viewInfo.renderWhitespace,
              renderControlCharacters: !n && e.viewInfo.renderControlCharacters,
              fontLigatures: !n && e.viewInfo.fontLigatures,
              renderIndentGuides: !n && e.viewInfo.renderIndentGuides,
              highlightActiveIndentGuide: e.viewInfo.highlightActiveIndentGuide,
              renderLineHighlight: e.viewInfo.renderLineHighlight,
              scrollbar: e.viewInfo.scrollbar,
              minimap: {
                enabled: !n && e.viewInfo.minimap.enabled,
                side: e.viewInfo.minimap.side,
                renderCharacters: e.viewInfo.minimap.renderCharacters,
                showSlider: e.viewInfo.minimap.showSlider,
                maxColumn: e.viewInfo.minimap.maxColumn
              },
              fixedOverflowWidgets: e.viewInfo.fixedOverflowWidgets
            },
            contribInfo: {
              selectionClipboard: e.contribInfo.selectionClipboard,
              hover: e.contribInfo.hover,
              links: !n && e.contribInfo.links,
              contextmenu: e.contribInfo.contextmenu,
              quickSuggestions: e.contribInfo.quickSuggestions,
              quickSuggestionsDelay: e.contribInfo.quickSuggestionsDelay,
              parameterHints: e.contribInfo.parameterHints,
              iconsInSuggestions: e.contribInfo.iconsInSuggestions,
              formatOnType: e.contribInfo.formatOnType,
              formatOnPaste: e.contribInfo.formatOnPaste,
              suggestOnTriggerCharacters: e.contribInfo.suggestOnTriggerCharacters,
              acceptSuggestionOnEnter: e.contribInfo.acceptSuggestionOnEnter,
              acceptSuggestionOnCommitCharacter: e.contribInfo.acceptSuggestionOnCommitCharacter,
              wordBasedSuggestions: e.contribInfo.wordBasedSuggestions,
              suggestSelection: e.contribInfo.suggestSelection,
              suggestFontSize: e.contribInfo.suggestFontSize,
              suggestLineHeight: e.contribInfo.suggestLineHeight,
              suggest: e.contribInfo.suggest,
              selectionHighlight: !n && e.contribInfo.selectionHighlight,
              occurrencesHighlight: !n && e.contribInfo.occurrencesHighlight,
              codeLens: !n && e.contribInfo.codeLens,
              folding: !n && e.contribInfo.folding,
              foldingStrategy: e.contribInfo.foldingStrategy,
              showFoldingControls: e.contribInfo.showFoldingControls,
              matchBrackets: !n && e.contribInfo.matchBrackets,
              find: e.contribInfo.find,
              colorDecorators: e.contribInfo.colorDecorators,
              lightbulbEnabled: e.contribInfo.lightbulbEnabled,
              codeActionsOnSave: e.contribInfo.codeActionsOnSave,
              codeActionsOnSaveTimeout: e.contribInfo.codeActionsOnSaveTimeout
            }
          }
        }, e.createInternalEditorOptions = function ( e, t ) {
          let n;
          n = "auto" === t.accessibilitySupport ? e.accessibilitySupport : "on" === t.accessibilitySupport ? 2 : 1;
          let i;
          const o = this._tweakValidatedOptions( t, n );
          "string" === typeof o.lineDecorationsWidth && /^\d+(\.\d+)?ch$/.test( o.lineDecorationsWidth ) ? i = parseFloat( o.lineDecorationsWidth.substr( 0, o.lineDecorationsWidth.length - 2 ) ) * e.fontInfo.typicalHalfwidthCharacterWidth : i = C( o.lineDecorationsWidth, 0, 0, 1e3 );
          o.contribInfo.folding && ( i += 16 );
          const r = x.compute( {
            outerWidth: e.outerWidth,
            outerHeight: e.outerHeight,
            showGlyphMargin: o.viewInfo.glyphMargin,
            lineHeight: e.fontInfo.lineHeight,
            showLineNumbers: 0 !== o.viewInfo.renderLineNumbers,
            lineNumbersMinChars: o.lineNumbersMinChars,
            lineNumbersDigitCount: e.lineNumbersDigitCount,
            lineDecorationsWidth: i,
            typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
            maxDigitWidth: e.fontInfo.maxDigitWidth,
            verticalScrollbarWidth: o.viewInfo.scrollbar.verticalScrollbarSize,
            horizontalScrollbarHeight: o.viewInfo.scrollbar.horizontalScrollbarSize,
            scrollbarArrowSize: o.viewInfo.scrollbar.arrowSize,
            verticalScrollbarHasArrows: o.viewInfo.scrollbar.verticalHasArrows,
            minimap: o.viewInfo.minimap.enabled,
            minimapSide: o.viewInfo.minimap.side,
            minimapRenderCharacters: o.viewInfo.minimap.renderCharacters,
            minimapMaxColumn: o.viewInfo.minimap.maxColumn,
            pixelRatio: e.pixelRatio
          } );
          let s = null;
          const a = o.wordWrap;
          const u = o.wordWrapColumn;
          const l = o.wordWrapMinified;
          s = 2 === n ? {
            isWordWrapMinified: !1,
            isViewportWrapping: !1,
            wrappingColumn: -1
          } : l && e.isDominatedByLongLines ? {
            isWordWrapMinified: !0,
            isViewportWrapping: !0,
            wrappingColumn: Math.max( 1, r.viewportColumn )
          } : "on" === a ? {
            isWordWrapMinified: !1,
            isViewportWrapping: !0,
            wrappingColumn: Math.max( 1, r.viewportColumn )
          } : "bounded" === a ? {
            isWordWrapMinified: !1,
            isViewportWrapping: !0,
            wrappingColumn: Math.min( Math.max( 1, r.viewportColumn ), u )
          } : "wordWrapColumn" === a ? {
            isWordWrapMinified: !1,
            isViewportWrapping: !1,
            wrappingColumn: u
          } : {
            isWordWrapMinified: !1,
            isViewportWrapping: !1,
            wrappingColumn: -1
          };
          const c = {
            inDiffEditor: o.inDiffEditor,
            isDominatedByLongLines: e.isDominatedByLongLines,
            isWordWrapMinified: s.isWordWrapMinified,
            isViewportWrapping: s.isViewportWrapping,
            wrappingColumn: s.wrappingColumn,
            wrappingIndent: o.wrappingIndent,
            wordWrapBreakBeforeCharacters: o.wordWrapBreakBeforeCharacters,
            wordWrapBreakAfterCharacters: o.wordWrapBreakAfterCharacters,
            wordWrapBreakObtrusiveCharacters: o.wordWrapBreakObtrusiveCharacters
          };
          let d = "monaco-editor";
          return o.viewInfo.extraEditorClassName && ( d += " " + o.viewInfo.extraEditorClassName ), e.extraEditorClassName && ( d += " " + e.extraEditorClassName ), o.viewInfo.fontLigatures && ( d += " enable-ligatures" ), "default" === o.mouseStyle ? d += " mouse-default" : "copy" === o.mouseStyle && ( d += " mouse-copy" ), new m( {
            canUseLayerHinting: !o.disableLayerHinting,
            pixelRatio: e.pixelRatio,
            editorClassName: d,
            lineHeight: e.fontInfo.lineHeight,
            readOnly: o.readOnly,
            accessibilitySupport: n,
            multiCursorModifier: o.multiCursorModifier,
            multiCursorMergeOverlapping: o.multiCursorMergeOverlapping,
            wordSeparators: o.wordSeparators,
            autoClosingBrackets: o.autoClosingBrackets,
            autoIndent: o.autoIndent,
            useTabStops: o.useTabStops,
            tabFocusMode: !!o.readOnly || e.tabFocusMode,
            dragAndDrop: o.dragAndDrop,
            emptySelectionClipboard: o.emptySelectionClipboard && e.emptySelectionClipboard,
            layoutInfo: r,
            fontInfo: e.fontInfo,
            viewInfo: o.viewInfo,
            wrappingInfo: c,
            contribInfo: o.contribInfo,
            showUnused: o.showUnused
          } )
        }, e;
      } )();

      const x = ( () => {
        function e() {}
        return e.compute = e => {
          const t = 0 | e.outerWidth;
          const n = 0 | e.outerHeight;
          const o = e.showGlyphMargin;
          const r = 0 | e.lineHeight;
          const s = e.showLineNumbers;
          const a = 0 | e.lineNumbersMinChars;
          const u = 0 | e.lineNumbersDigitCount;
          const l = 0 | e.lineDecorationsWidth;
          const c = e.typicalHalfwidthCharacterWidth;
          const d = e.maxDigitWidth;
          const h = 0 | e.verticalScrollbarWidth;
          const p = e.verticalScrollbarHasArrows;
          const f = 0 | e.scrollbarArrowSize;
          const g = 0 | e.horizontalScrollbarHeight;
          const m = e.minimap;
          const _ = e.minimapSide;
          const v = e.minimapRenderCharacters;
          const y = 0 | e.minimapMaxColumn;
          const b = e.pixelRatio;
          let C = 0;
          if ( s ) {
            const w = Math.max( u, a );
            C = Math.round( w * d )
          }
          let S = 0;
          o && ( S = r );
          let O;
          let L;
          let x;
          let N;
          let E = 0;
          let k = E + S;
          let I = k + C;
          let D = I + l;
          const M = t - S - C - l;
          if ( m ) {
            let T = void 0;
            b >= 2 ? ( O = v ? i.Large : i.LargeBlocks, T = 2 / b ) : ( O = v ? i.Small : i.SmallBlocks, T = 1 / b ), ( x = Math.max( 0, Math.floor( ( M - h - 2 ) * T / ( c + T ) ) ) ) / T > y && ( x = Math.floor( y * T ) ), N = M - x, "left" === _ ? ( L = 0, E += x, k += x, I += x, D += x ) : L = t - x - h
          } else L = 0, x = 0, O = i.None, N = M;
          const R = p ? f : 0;
          return {
            width: t,
            height: n,
            glyphMarginLeft: E,
            glyphMarginWidth: S,
            glyphMarginHeight: n,
            lineNumbersLeft: k,
            lineNumbersWidth: C,
            lineNumbersHeight: n,
            decorationsLeft: I,
            decorationsWidth: l,
            decorationsHeight: n,
            contentLeft: D,
            contentWidth: N,
            contentHeight: n,
            renderMinimap: O,
            minimapLeft: L,
            minimapWidth: x,
            viewportColumn: Math.max( 1, Math.floor( ( N - h - 2 ) / c ) ),
            verticalScrollbarWidth: h,
            horizontalScrollbarHeight: g,
            overviewRuler: {
              top: R,
              width: h,
              height: n - 2 * R,
              right: 0
            }
          }
        }, e;
      } )();

      var N = {
        fontFamily: u.d ? "Menlo, Monaco, 'Courier New', monospace" : u.c ? "'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'" : "Consolas, 'Courier New', monospace",
        fontWeight: "normal",
        fontSize: u.d ? 12 : 14,
        lineHeight: 0,
        letterSpacing: 0
      };
      var E = {
        tabSize: 4,
        insertSpaces: !0,
        detectIndentation: !0,
        trimAutoWhitespace: !0,
        largeFileOptimizations: !0
      };
      var k = {
        inDiffEditor: !1,
        wordSeparators: c.b,
        lineNumbersMinChars: 5,
        lineDecorationsWidth: 10,
        readOnly: !1,
        mouseStyle: "text",
        disableLayerHinting: !1,
        automaticLayout: !1,
        wordWrap: "off",
        wordWrapColumn: 80,
        wordWrapMinified: !0,
        wrappingIndent: o.Same,
        wordWrapBreakBeforeCharacters: "([{\u2018\u201c\u3008\u300a\u300c\u300e\u3010\u3014\uff08\uff3b\uff5b\uff62\xa3\xa5\uff04\uffe1\uffe5+\uff0b",
        wordWrapBreakAfterCharacters: " \t})]?|&,;\xa2\xb0\u2032\u2033\u2030\u2103\u3001\u3002\uff61\uff64\uffe0\uff0c\uff0e\uff1a\uff1b\uff1f\uff01\uff05\u30fb\uff65\u309d\u309e\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\uff67\uff68\uff69\uff6a\uff6b\uff6c\uff6d\uff6e\uff6f\uff70\u201d\u3009\u300b\u300d\u300f\u3011\u3015\uff09\uff3d\uff5d\uff63",
        wordWrapBreakObtrusiveCharacters: ".",
        autoClosingBrackets: !0,
        autoIndent: !0,
        dragAndDrop: !0,
        emptySelectionClipboard: !0,
        useTabStops: !0,
        multiCursorModifier: "altKey",
        multiCursorMergeOverlapping: !0,
        accessibilitySupport: "auto",
        showUnused: !0,
        viewInfo: {
          extraEditorClassName: "",
          disableMonospaceOptimizations: !1,
          rulers: [],
          ariaLabel: a.a( "editorViewAccessibleLabel", "Editor content" ),
          renderLineNumbers: 1,
          renderCustomLineNumbers: null,
          selectOnLineNumbers: !0,
          glyphMargin: !0,
          revealHorizontalRightPadding: 30,
          roundedSelection: !0,
          overviewRulerLanes: 2,
          overviewRulerBorder: !0,
          cursorBlinking: r.Blink,
          mouseWheelZoom: !1,
          cursorStyle: s.Line,
          cursorWidth: 0,
          hideCursorInOverviewRuler: !1,
          scrollBeyondLastLine: !0,
          scrollBeyondLastColumn: 5,
          smoothScrolling: !1,
          stopRenderingLineAfter: 1e4,
          renderWhitespace: "none",
          renderControlCharacters: !1,
          fontLigatures: !1,
          renderIndentGuides: !0,
          highlightActiveIndentGuide: !0,
          renderLineHighlight: "line",
          scrollbar: {
            vertical: l.b.Auto,
            horizontal: l.b.Auto,
            arrowSize: 11,
            useShadows: !0,
            verticalHasArrows: !1,
            horizontalHasArrows: !1,
            horizontalScrollbarSize: 10,
            horizontalSliderSize: 10,
            verticalScrollbarSize: 14,
            verticalSliderSize: 14,
            handleMouseWheel: !0,
            mouseWheelScrollSensitivity: 1
          },
          minimap: {
            enabled: !0,
            side: "right",
            showSlider: "mouseover",
            renderCharacters: !0,
            maxColumn: 120
          },
          fixedOverflowWidgets: !1
        },
        contribInfo: {
          selectionClipboard: !0,
          hover: {
            enabled: !0,
            delay: 300,
            sticky: !0
          },
          links: !0,
          contextmenu: !0,
          quickSuggestions: {
            other: !0,
            comments: !1,
            strings: !1
          },
          quickSuggestionsDelay: 10,
          parameterHints: !0,
          iconsInSuggestions: !0,
          formatOnType: !1,
          formatOnPaste: !1,
          suggestOnTriggerCharacters: !0,
          acceptSuggestionOnEnter: "on",
          acceptSuggestionOnCommitCharacter: !0,
          wordBasedSuggestions: !0,
          suggestSelection: "recentlyUsed",
          suggestFontSize: 0,
          suggestLineHeight: 0,
          suggest: {
            filterGraceful: !0,
            snippets: "inline",
            snippetsPreventQuickSuggestions: !0
          },
          selectionHighlight: !0,
          occurrencesHighlight: !0,
          codeLens: !0,
          folding: !0,
          foldingStrategy: "auto",
          showFoldingControls: "mouseover",
          matchBrackets: !0,
          find: {
            seedSearchStringFromSelection: !0,
            autoFindInSelection: !1,
            globalFindClipboard: !1
          },
          colorDecorators: !0,
          lightbulbEnabled: !0,
          codeActionsOnSave: {},
          codeActionsOnSaveTimeout: 750
        }
      };
    },
    "/cAr": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "msdax",
        extensions: [ ".dax", ".msdax" ],
        aliases: [ "DAX", "MSDAX" ],
        loader() {
          return o.Promise.wrap( n.e( 279 ).then( n.bind( null, "8m5U" ) ) )
        }
      } )
    },
    "/cxE": function ( e, t, n ) {
      "use strict";
      n.d( t, "e", ( () => {
        return s
      } ) ), n.d( t, "f", ( () => {
        return a
      } ) ), n.d( t, "g", ( () => {
        return u
      } ) ), n.d( t, "d", ( () => {
        return c
      } ) ), n.d( t, "a", ( () => {
        return d
      } ) ), n.d( t, "b", ( () => {
        return h
      } ) ), n.d( t, "c", ( () => {
        return p
      } ) );
      const i = n( "VMIq" );
      let o = {};
      i.b.addEventListener( "error", ( e => {
        const t = e.detail,
          n = t.id;
        t.parent ? t.handler && o && delete o[ n ] : ( o[ n ] = t, 1 === Object.keys( o ).length && setTimeout( ( () => {
          const e = o;
          o = {}, Object.keys( e ).forEach( ( t => {
            const n = e[ t ];
            n.exception ? s( n.exception ) : n.error && s( n.error ), console.log( "WARNING: Promise with no error callback:" + n.id ), console.log( n ), n.exception && console.log( n.exception.stack )
          } ) )
        } ), 0 ) )
      } ) );
      const r = new( ( () => {
        function e() {
          this.listeners = [], this.unexpectedErrorHandler = e => {
            setTimeout( ( () => {
              if ( e.stack ) throw new Error( e.message + "\n\n" + e.stack );
              throw e
            } ), 0 )
          }
        }
        return e.prototype.emit = function ( e ) {
          this.listeners.forEach( ( t => {
            t( e )
          } ) )
        }, e.prototype.onUnexpectedError = function ( e ) {
          this.unexpectedErrorHandler( e ), this.emit( e )
        }, e.prototype.onUnexpectedExternalError = function ( e ) {
          this.unexpectedErrorHandler( e )
        }, e;
      } )() )();

      function s( e ) {
        c( e ) || r.onUnexpectedError( e )
      }

      function a( e ) {
        c( e ) || r.onUnexpectedExternalError( e )
      }

      function u( e ) {
        return e instanceof Error ? {
          $isError: !0,
          name: e.name,
          message: e.message,
          stack: e.stacktrace || e.stack
        } : e
      }
      const l = "Canceled";

      function c( e ) {
        return e instanceof Error && e.name === l && e.message === l
      }

      function d() {
        const e = new Error( l );
        return e.name = e.message, e
      }

      function h( e ) {
        return e ? new Error( "Illegal argument: " + e ) : new Error( "Illegal argument" )
      }

      function p( e ) {
        return e ? new Error( "Illegal state: " + e ) : new Error( "Illegal state" )
      }
    },
    "/kV6": function ( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return i
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) ), n.d( t, "f", ( () => {
        return l
      } ) ), n.d( t, "e", ( () => {
        return d
      } ) ), n.d( t, "d", ( () => {
        return p
      } ) ), n.d( t, "c", ( () => {
        return f
      } ) );
      var i;
      const o = ( () => {
        function e() {
          this._keyCodeToStr = [], this._strToKeyCode = Object.create( null )
        }
        return e.prototype.define = function ( e, t ) {
          this._keyCodeToStr[ e ] = t, this._strToKeyCode[ t.toLowerCase() ] = e
        }, e.prototype.keyCodeToStr = function ( e ) {
          return this._keyCodeToStr[ e ]
        }, e.prototype.strToKeyCode = function ( e ) {
          return this._strToKeyCode[ e.toLowerCase() ] || 0
        }, e
      } )();
      const r = new o;
      const s = new o;
      const a = new o;

      function u( e, t ) {
        return ( e | ( 65535 & t ) << 16 >>> 0 ) >>> 0
      }

      function l( e, t ) {
        if ( 0 === e ) return null;
        const n = ( 65535 & e ) >>> 0,
          i = ( 4294901760 & e ) >>> 16;
        return 0 !== i ? new h( c( n, t ), c( i, t ) ) : c( n, t )
      }

      function c( e, t ) {
        const n = !!( 2048 & e ),
          i = !!( 256 & e );
        return new d( 2 === t ? i : n, !!( 1024 & e ), !!( 512 & e ), 2 === t ? n : i, 255 & e )
      }!( () => {
        function e( e, t, n, i ) {
          void 0 === n && ( n = t ), void 0 === i && ( i = n ), r.define( e, t ), s.define( e, n ), a.define( e, i )
        }
        e( 0, "unknown" ), e( 1, "Backspace" ), e( 2, "Tab" ), e( 3, "Enter" ), e( 4, "Shift" ), e( 5, "Ctrl" ), e( 6, "Alt" ), e( 7, "PauseBreak" ), e( 8, "CapsLock" ), e( 9, "Escape" ), e( 10, "Space" ), e( 11, "PageUp" ), e( 12, "PageDown" ), e( 13, "End" ), e( 14, "Home" ), e( 15, "LeftArrow", "Left" ), e( 16, "UpArrow", "Up" ), e( 17, "RightArrow", "Right" ), e( 18, "DownArrow", "Down" ), e( 19, "Insert" ), e( 20, "Delete" ), e( 21, "0" ), e( 22, "1" ), e( 23, "2" ), e( 24, "3" ), e( 25, "4" ), e( 26, "5" ), e( 27, "6" ), e( 28, "7" ), e( 29, "8" ), e( 30, "9" ), e( 31, "A" ), e( 32, "B" ), e( 33, "C" ), e( 34, "D" ), e( 35, "E" ), e( 36, "F" ), e( 37, "G" ), e( 38, "H" ), e( 39, "I" ), e( 40, "J" ), e( 41, "K" ), e( 42, "L" ), e( 43, "M" ), e( 44, "N" ), e( 45, "O" ), e( 46, "P" ), e( 47, "Q" ), e( 48, "R" ), e( 49, "S" ), e( 50, "T" ), e( 51, "U" ), e( 52, "V" ), e( 53, "W" ), e( 54, "X" ), e( 55, "Y" ), e( 56, "Z" ), e( 57, "Meta" ), e( 58, "ContextMenu" ), e( 59, "F1" ), e( 60, "F2" ), e( 61, "F3" ), e( 62, "F4" ), e( 63, "F5" ), e( 64, "F6" ), e( 65, "F7" ), e( 66, "F8" ), e( 67, "F9" ), e( 68, "F10" ), e( 69, "F11" ), e( 70, "F12" ), e( 71, "F13" ), e( 72, "F14" ), e( 73, "F15" ), e( 74, "F16" ), e( 75, "F17" ), e( 76, "F18" ), e( 77, "F19" ), e( 78, "NumLock" ), e( 79, "ScrollLock" ), e( 80, ";", ";", "OEM_1" ), e( 81, "=", "=", "OEM_PLUS" ), e( 82, ",", ",", "OEM_COMMA" ), e( 83, "-", "-", "OEM_MINUS" ), e( 84, ".", ".", "OEM_PERIOD" ), e( 85, "/", "/", "OEM_2" ), e( 86, "`", "`", "OEM_3" ), e( 110, "ABNT_C1" ), e( 111, "ABNT_C2" ), e( 87, "[", "[", "OEM_4" ), e( 88, "\\", "\\", "OEM_5" ), e( 89, "]", "]", "OEM_6" ), e( 90, "'", "'", "OEM_7" ), e( 91, "OEM_8" ), e( 92, "OEM_102" ), e( 93, "NumPad0" ), e( 94, "NumPad1" ), e( 95, "NumPad2" ), e( 96, "NumPad3" ), e( 97, "NumPad4" ), e( 98, "NumPad5" ), e( 99, "NumPad6" ), e( 100, "NumPad7" ), e( 101, "NumPad8" ), e( 102, "NumPad9" ), e( 103, "NumPad_Multiply" ), e( 104, "NumPad_Add" ), e( 105, "NumPad_Separator" ), e( 106, "NumPad_Subtract" ), e( 107, "NumPad_Decimal" ), e( 108, "NumPad_Divide" )
      } )(), ( e => {
        e.toString = e => {
          return r.keyCodeToStr( e )
        }, e.fromString = e => {
          return r.strToKeyCode( e )
        }, e.toUserSettingsUS = e => {
          return s.keyCodeToStr( e )
        }, e.toUserSettingsGeneral = e => {
          return a.keyCodeToStr( e )
        }, e.fromUserSettings = e => {
          return s.strToKeyCode( e ) || a.strToKeyCode( e )
        }
      } )( i || ( i = {} ) );
      var d = ( () => {
          function e( e, t, n, i, o ) {
            this.type = 1, this.ctrlKey = e, this.shiftKey = t, this.altKey = n, this.metaKey = i, this.keyCode = o
          }
          return e.prototype.equals = function ( e ) {
            return 1 === e.type && ( this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode )
          }, e.prototype.isModifierKey = function () {
            return 0 === this.keyCode || 5 === this.keyCode || 57 === this.keyCode || 6 === this.keyCode || 4 === this.keyCode
          }, e.prototype.isDuplicateModifierCase = function () {
            return this.ctrlKey && 5 === this.keyCode || this.shiftKey && 4 === this.keyCode || this.altKey && 6 === this.keyCode || this.metaKey && 57 === this.keyCode
          }, e
        } )(),
        h = function ( e, t ) {
          this.type = 2, this.firstPart = e, this.chordPart = t
        },
        p = function ( e, t, n, i, o, r ) {
          this.ctrlKey = e, this.shiftKey = t, this.altKey = n, this.metaKey = i, this.keyLabel = o, this.keyAriaLabel = r
        },
        f = () => {}
    },
    "0+8E": function ( e, t, n ) {
      "use strict";
      n( "i/Rh" );
      const i = n( "3/fG" ),
        o = n( "D3Dy" ),
        r = n( "EffR" ),
        s = n( "o1O+" ),
        a = n( "OBOq" ),
        u = n( "WqXY" ),
        l = n( "vKxM" ),
        c = n( "MI8n" ),
        d = n( "G300" ),
        h = n( "zrhQ" ),
        p = n( "qj0h" ),
        f = n( "JYp7" ),
        g = ( () => {
          function e( e, t ) {
            void 0 === e && ( e = [] ), void 0 === t && ( t = 10 ), this._initialize( e ), this._limit = t, this._onChange()
          }
          return e.prototype.add = function ( e ) {
            this._history.delete( e ), this._history.add( e ), this._onChange()
          }, e.prototype.next = function () {
            return this._navigator.next()
          }, e.prototype.previous = function () {
            return this._navigator.previous()
          }, e.prototype.current = function () {
            return this._navigator.current()
          }, e.prototype.parent = () => {
            return null
          }, e.prototype.first = function () {
            return this._navigator.first()
          }, e.prototype.last = function () {
            return this._navigator.last()
          }, e.prototype.has = function ( e ) {
            return this._history.has( e )
          }, e.prototype._onChange = function () {
            this._reduceToLimit(), this._navigator = new f.b( this._elements, 0, this._elements.length, this._elements.length )
          }, e.prototype._reduceToLimit = function () {
            const e = this._elements;
            e.length > this._limit && this._initialize( e.slice( e.length - this._limit ) )
          }, e.prototype._initialize = function ( e ) {
            this._history = new Set;
            for ( let t = 0, n = e; t < n.length; t++ ) {
              const i = n[ t ];
              this._history.add( i )
            }
          }, Object.defineProperty( e.prototype, "_elements", {
            get() {
              const e = [];
              return this._history.forEach( ( t => {
                return e.push( t )
              } ) ), e;
            },
            enumerable: !0,
            configurable: !0
          } ), e;
        } )();
      n.d( t, "b", ( () => {
        return b
      } ) ), n.d( t, "a", ( () => {
        return C
      } ) );
      let m;
      const _ = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const v = r.a;
      !( e => {
        e[ e.INFO = 1 ] = "INFO", e[ e.WARNING = 2 ] = "WARNING", e[ e.ERROR = 3 ] = "ERROR"
      } )( m || ( m = {} ) );
      const y = {
        inputBackground: h.a.fromHex( "#3C3C3C" ),
        inputForeground: h.a.fromHex( "#CCCCCC" ),
        inputValidationInfoBorder: h.a.fromHex( "#55AAFF" ),
        inputValidationInfoBackground: h.a.fromHex( "#063B49" ),
        inputValidationWarningBorder: h.a.fromHex( "#B89500" ),
        inputValidationWarningBackground: h.a.fromHex( "#352A05" ),
        inputValidationErrorBorder: h.a.fromHex( "#BE1100" ),
        inputValidationErrorBackground: h.a.fromHex( "#5A1D1D" )
      };

      var b = ( e => {
        function t( t, n, i ) {
          const s = e.call( this ) || this;
          s.state = "idle", s._onDidChange = s._register( new c.a ), s.onDidChange = s._onDidChange.event, s._onDidHeightChange = s._register( new c.a ), s.contextViewProvider = n, s.options = i || Object.create( null ), Object( p.g )( s.options, y, !1 ), s.message = null, s.cachedHeight = null, s.placeholder = s.options.placeholder || "", s.ariaLabel = s.options.ariaLabel || "", s.inputBackground = s.options.inputBackground, s.inputForeground = s.options.inputForeground, s.inputBorder = s.options.inputBorder, s.inputValidationInfoBorder = s.options.inputValidationInfoBorder, s.inputValidationInfoBackground = s.options.inputValidationInfoBackground, s.inputValidationWarningBorder = s.options.inputValidationWarningBorder, s.inputValidationWarningBackground = s.options.inputValidationWarningBackground, s.inputValidationErrorBorder = s.options.inputValidationErrorBorder, s.inputValidationErrorBackground = s.options.inputValidationErrorBackground, s.options.validationOptions && ( s.validation = s.options.validationOptions.validation ), s.element = r.k( t, v( ".monaco-inputbox.idle" ) );
          const a = s.options.flexibleHeight ? "textarea" : "input",
            l = r.k( s.element, v( ".wrapper" ) );
          return s.input = r.k( l, v( a + ".input" ) ), s.input.setAttribute( "autocorrect", "off" ), s.input.setAttribute( "autocapitalize", "off" ), s.input.setAttribute( "spellcheck", "false" ), s.onfocus( s.input, ( () => {
            return r.f( s.element, "synthetic-focus" )
          } ) ), s.onblur( s.input, ( () => {
            return r.G( s.element, "synthetic-focus" )
          } ) ), s.options.flexibleHeight ? s.mirror = r.k( l, v( "div.mirror" ) ) : ( s.input.type = s.options.type || "text", s.input.setAttribute( "wrap", "off" ) ), s.ariaLabel && s.input.setAttribute( "aria-label", s.ariaLabel ), s.placeholder && s.setPlaceHolder( s.placeholder ), s.oninput( s.input, ( () => {
            return s.onValueChange()
          } ) ), s.onblur( s.input, ( () => {
            return s.onBlur()
          } ) ), s.onfocus( s.input, ( () => {
            return s.onFocus()
          } ) ), s.placeholder && o.k && s.onclick( s.input, ( e => {
            r.c.stop( e, !0 ), s.input.focus()
          } ) ), setTimeout( ( () => {
            s.input && s.updateMirror()
          } ), 0 ), s.options.actions && ( s.actionbar = s._register( new u.a( s.element ) ), s.actionbar.push( s.options.actions, {
            icon: !0,
            label: !1
          } ) ), s.applyStyles(), s;
        }
        return _( t, e ), t.prototype.onBlur = function () {
          this._hideMessage()
        }, t.prototype.onFocus = function () {
          this._showMessage()
        }, t.prototype.setPlaceHolder = function ( e ) {
          this.input && ( this.input.setAttribute( "placeholder", e ), this.input.title = e )
        }, t.prototype.setAriaLabel = function ( e ) {
          this.ariaLabel = e, this.input && ( e ? this.input.setAttribute( "aria-label", this.ariaLabel ) : this.input.removeAttribute( "aria-label" ) )
        }, Object.defineProperty( t.prototype, "inputElement", {
          get() {
            return this.input
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( t.prototype, "value", {
          get() {
            return this.input.value
          },
          set( e ) {
            this.input.value !== e && ( this.input.value = e, this.onValueChange() )
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.focus = function () {
          this.input.focus()
        }, t.prototype.blur = function () {
          this.input.blur()
        }, t.prototype.hasFocus = function () {
          return document.activeElement === this.input
        }, t.prototype.select = function ( e ) {
          void 0 === e && ( e = null ), this.input.select(), e && this.input.setSelectionRange( e.start, e.end )
        }, t.prototype.enable = function () {
          this.input.removeAttribute( "disabled" )
        }, t.prototype.disable = function () {
          this.input.disabled = !0, this._hideMessage()
        }, t.prototype.setEnabled = function ( e ) {
          e ? this.enable() : this.disable()
        }, Object.defineProperty( t.prototype, "width", {
          get() {
            return r.y( this.input )
          },
          set( e ) {
            this.input.style.width = e + "px"
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.showMessage = function ( e, t ) {
          this.message = e, r.G( this.element, "idle" ), r.G( this.element, "info" ), r.G( this.element, "warning" ), r.G( this.element, "error" ), r.f( this.element, this.classForType( e.type ) );
          let n;
          const o = this.stylesForType( this.message.type );
          this.element.style.border = o.border ? "1px solid " + o.border : null, n = e.type === m.ERROR ? i.a( "alertErrorMessage", "Error: {0}", e.content ) : e.type === m.WARNING ? i.a( "alertWarningMessage", "Warning: {0}", e.content ) : i.a( "alertInfoMessage", "Info: {0}", e.content ), a.a( n ), ( this.hasFocus() || t ) && this._showMessage()
        }, t.prototype.hideMessage = function () {
          this.message = null, r.G( this.element, "info" ), r.G( this.element, "warning" ), r.G( this.element, "error" ), r.f( this.element, "idle" ), this._hideMessage(), this.applyStyles()
        }, t.prototype.validate = function () {
          let e = null;
          return this.validation && ( ( e = this.validation( this.value ) ) ? ( this.inputElement.setAttribute( "aria-invalid", "true" ), this.showMessage( e ) ) : this.inputElement.hasAttribute( "aria-invalid" ) && ( this.inputElement.removeAttribute( "aria-invalid" ), this.hideMessage() ) ), !e
        }, t.prototype.stylesForType = function ( e ) {
          switch ( e ) {
            case m.INFO:
              return {
                border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground
              };
            case m.WARNING:
              return {
                border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground
              };
            default:
              return {
                border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground
              }
          }
        }, t.prototype.classForType = e => {
          switch ( e ) {
            case m.INFO:
              return "info";
            case m.WARNING:
              return "warning";
            default:
              return "error"
          }
        }, t.prototype._showMessage = function () {
          const e = this;
          if ( this.contextViewProvider && this.message ) {
            let t;
            const n = () => {
              return t.style.width = r.y( e.element ) + "px"
            };
            this.state = "open", this.contextViewProvider.showContextView( {
              getAnchor() {
                return e.element
              },
              anchorAlignment: l.a.RIGHT,
              render( i ) {
                t = r.k( i, v( ".monaco-inputbox-container" ) ), n();
                const o = {
                    inline: !0,
                    className: "monaco-inputbox-message"
                  },
                  a = e.message.formatContent ? Object( s.a )( e.message.content, o ) : Object( s.c )( e.message.content, o );
                r.f( a, e.classForType( e.message.type ) );
                const u = e.stylesForType( e.message.type );
                return a.style.backgroundColor = u.background ? u.background.toString() : null, a.style.border = u.border ? "1px solid " + u.border : null, r.k( t, a ), null
              },
              layout: n
            } )
          }
        }, t.prototype._hideMessage = function () {
          this.contextViewProvider && "open" === this.state && ( this.state = "idle", this.contextViewProvider.hideContextView() )
        }, t.prototype.onValueChange = function () {
          this._onDidChange.fire( this.value ), this.validate(), this.updateMirror(), "open" === this.state && this.contextViewProvider.layout()
        }, t.prototype.updateMirror = function () {
          if ( this.mirror ) {
            const e = this.value || this.placeholder,
              t = 10 === e.charCodeAt( e.length - 1 ) ? " " : "";
            this.mirror.textContent = e + t, this.layout()
          }
        }, t.prototype.style = function ( e ) {
          this.inputBackground = e.inputBackground, this.inputForeground = e.inputForeground, this.inputBorder = e.inputBorder, this.inputValidationInfoBackground = e.inputValidationInfoBackground, this.inputValidationInfoBorder = e.inputValidationInfoBorder, this.inputValidationWarningBackground = e.inputValidationWarningBackground, this.inputValidationWarningBorder = e.inputValidationWarningBorder, this.inputValidationErrorBackground = e.inputValidationErrorBackground, this.inputValidationErrorBorder = e.inputValidationErrorBorder, this.applyStyles()
        }, t.prototype.applyStyles = function () {
          if ( this.element ) {
            const e = this.inputBackground ? this.inputBackground.toString() : null,
              t = this.inputForeground ? this.inputForeground.toString() : null,
              n = this.inputBorder ? this.inputBorder.toString() : null;
            this.element.style.backgroundColor = e, this.element.style.color = t, this.input.style.backgroundColor = e, this.input.style.color = t, this.element.style.borderWidth = n ? "1px" : null, this.element.style.borderStyle = n ? "solid" : null, this.element.style.borderColor = n
          }
        }, t.prototype.layout = function () {
          if ( this.mirror ) {
            const e = this.cachedHeight;
            this.cachedHeight = r.x( this.mirror ), e !== this.cachedHeight && ( this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire( this.cachedHeight ) )
          }
        }, t.prototype.dispose = function () {
          this._hideMessage(), this.element = null, this.input = null, this.contextViewProvider = null, this.message = null, this.placeholder = null, this.ariaLabel = null, this.validation = null, this.state = null, this.actionbar = null, e.prototype.dispose.call( this )
        }, t;
      } )( d.a );

      var C = ( e => {
        function t( t, n, i ) {
          const o = e.call( this, t, n, i ) || this;
          return o.history = new g( i.history, 100 ), o
        }
        return _( t, e ), t.prototype.addToHistory = function () {
          this.value && this.value !== this.getCurrentValue() && this.history.add( this.value )
        }, t.prototype.showNextValue = function () {
          this.history.has( this.value ) || this.addToHistory();
          let e = this.getNextValue();
          e && ( e = e === this.value ? this.getNextValue() : e ), e && ( this.value = e, a.c( this.value ) )
        }, t.prototype.showPreviousValue = function () {
          this.history.has( this.value ) || this.addToHistory();
          let e = this.getPreviousValue();
          e && ( e = e === this.value ? this.getPreviousValue() : e ), e && ( this.value = e, a.c( this.value ) )
        }, t.prototype.getCurrentValue = function () {
          let e = this.history.current();
          return e || ( e = this.history.last(), this.history.next() ), e
        }, t.prototype.getPreviousValue = function () {
          return this.history.previous() || this.history.first()
        }, t.prototype.getNextValue = function () {
          return this.history.next() || this.history.last()
        }, t;
      } )( b );
    },
    "0/Sa": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "aokT" );
      var o = ( () => {
        function e() {}
        return e.insert = ( e, t ) => {
          return {
            range: new i.a( e.lineNumber, e.column, e.lineNumber, e.column ),
            text: t,
            forceMoveMarkers: !0
          }
        }, e.delete = e => {
          return {
            range: e,
            text: null
          }
        }, e.replace = ( e, t ) => {
          return {
            range: e,
            text: t
          }
        }, e.replaceMove = ( e, t ) => {
          return {
            range: e,
            text: t,
            forceMoveMarkers: !0
          }
        }, e;
      } )();
    },
    "03kh": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return f
      } ) );
      const i = n( "qj0h" );
      const o = n( "Cg/j" );
      const r = n( "nnTU" );
      const s = n( "T8No" );
      const a = n( "Vxe3" );
      const u = n( "nB0o" );
      const l = n( "t9D7" );
      const c = n( "sM1p" );
      const d = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const h = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const p = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      var f = ( e => {
        function t( t, n, i, o, r, s, a, u, l ) {
          const c = e.call( this, t, i.getRawConfiguration(), {}, o, r, s, a, u, l ) || this;
          return c._parentEditor = i, c._overwriteOptions = n, e.prototype.updateOptions.call( c, c._overwriteOptions ), c._register( i.onDidChangeConfiguration( ( e => {
            return c._onParentConfigurationChanged( e )
          } ) ) ), c;
        }
        return d( t, e ), t.prototype.getParentEditor = function () {
          return this._parentEditor
        }, t.prototype._onParentConfigurationChanged = function ( t ) {
          e.prototype.updateOptions.call( this, this._parentEditor.getRawConfiguration() ), e.prototype.updateOptions.call( this, this._overwriteOptions )
        }, t.prototype.updateOptions = function ( t ) {
          i.g( this._overwriteOptions, t, !0 ), e.prototype.updateOptions.call( this, this._overwriteOptions )
        }, t = h( [ p( 3, o.a ), p( 4, a.a ), p( 5, r.b ), p( 6, s.e ), p( 7, l.c ), p( 8, c.a ) ], t )
      } )( u.a );
    },
    "09fa": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "logService" );
      var r = ( () => {
        function e() {}
        return e.prototype.trace = function ( e ) {
          for ( let t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ]
        }, e.prototype.error = function ( e ) {
          for ( let t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ]
        }, e.prototype.dispose = () => {}, e;
      } )();
    },
    "0JNc": function ( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return i
      } ) ), n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "c", ( () => {
        return r
      } ) ), n.d( t, "d", ( () => {
        return s
      } ) );
      var i = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
      var o = ( e => {
        void 0 === e && ( e = "" );
        for ( var t = "(-?\\d*\\.\\d\\w*)|([^", n = 0; n < i.length; n++ ) e.indexOf( i[ n ] ) >= 0 || ( t += "\\" + i[ n ] );
        return t += "\\s]+)", new RegExp( t, "g" )
      } )();

      function r( e ) {
        let t = o;
        if ( e && e instanceof RegExp )
          if ( e.global ) t = e;
          else {
            let n = "g";
            e.ignoreCase && ( n += "i" ), e.multiline && ( n += "m" ), t = new RegExp( e.source, n )
          } return t.lastIndex = 0, t
      }

      function s( e, t, n, i ) {
        t.lastIndex = 0;
        const o = t.exec( n );
        if ( !o ) return null;
        const r = o[ 0 ].indexOf( " " ) >= 0 ? ( ( e, t, n, i ) => {
          let o;
          const r = e - 1 - i;
          for ( t.lastIndex = 0; o = t.exec( n ); ) {
            if ( o.index > r ) return null;
            if ( t.lastIndex >= r ) return {
              word: o[ 0 ],
              startColumn: i + 1 + o.index,
              endColumn: i + 1 + t.lastIndex
            }
          }
          return null
        } )( e, t, n, i ) : ( ( e, t, n, i ) => {
          let o;
          const r = e - 1 - i;
          const s = n.lastIndexOf( " ", r - 1 ) + 1;
          let a = n.indexOf( " ", r );
          for ( -1 === a && ( a = n.length ), t.lastIndex = s; o = t.exec( n ); )
            if ( o.index <= r && t.lastIndex >= r ) return {
              word: o[ 0 ],
              startColumn: i + 1 + o.index,
              endColumn: i + 1 + t.lastIndex
            };
          return null
        } )( e, t, n, i );
        return t.lastIndex = 0, r
      }
    },
    "0Lb2": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return l
      } ) );
      const i = n( "FWmy" );
      const o = n( "qj0h" );
      const r = n( "aokT" );
      const s = n( "pmY6" );
      const a = n( "MI8n" );
      const u = {
        followsCaret: !0,
        ignoreCharChanges: !0,
        alwaysRevealFirst: !0
      };
      var l = ( () => {
        function e( e, t ) {
          void 0 === t && ( t = {} );
          const n = this;
          this._onDidUpdate = new a.a, this._editor = e, this._options = o.g( t, u, !1 ), this.disposed = !1, this._disposables = [], this.nextIdx = -1, this.ranges = [], this.ignoreSelectionChange = !1, this.revealFirst = this._options.alwaysRevealFirst, this._disposables.push( this._editor.onDidDispose( ( () => {
            return n.dispose()
          } ) ) ), this._disposables.push( this._editor.onDidUpdateDiff( ( () => {
            return n._onDiffUpdated()
          } ) ) ), this._options.followsCaret && this._disposables.push( this._editor.getModifiedEditor().onDidChangeCursorPosition( ( e => {
            n.ignoreSelectionChange || ( n.nextIdx = -1 )
          } ) ) ), this._options.alwaysRevealFirst && this._disposables.push( this._editor.getModifiedEditor().onDidChangeModel( ( e => {
            n.revealFirst = !0
          } ) ) ), this._init()
        }
        return e.prototype._init = function () {
          this._editor.getLineChanges()
        }, e.prototype._onDiffUpdated = function () {
          this._init(), this._compute( this._editor.getLineChanges() ), this.revealFirst && null !== this._editor.getLineChanges() && ( this.revealFirst = !1, this.nextIdx = -1, this.next( 1 ) )
        }, e.prototype._compute = function ( e ) {
          const t = this;
          this.ranges = [], e && e.forEach( ( e => {
            !t._options.ignoreCharChanges && e.charChanges ? e.charChanges.forEach( ( e => {
              t.ranges.push( {
                rhs: !0,
                range: new r.a( e.modifiedStartLineNumber, e.modifiedStartColumn, e.modifiedEndLineNumber, e.modifiedEndColumn )
              } )
            } ) ) : t.ranges.push( {
              rhs: !0,
              range: new r.a( e.modifiedStartLineNumber, 1, e.modifiedStartLineNumber, 1 )
            } )
          } ) ), this.ranges.sort( ( ( e, t ) => {
            return e.range.getStartPosition().isBeforeOrEqual( t.range.getStartPosition() ) ? -1 : t.range.getStartPosition().isBeforeOrEqual( e.range.getStartPosition() ) ? 1 : 0
          } ) ), this._onDidUpdate.fire( this )
        }, e.prototype._initIdx = function ( e ) {
          for ( var t = !1, n = this._editor.getPosition(), i = 0, o = this.ranges.length; i < o && !t; i++ ) {
            const r = this.ranges[ i ].range;
            n.isBeforeOrEqual( r.getStartPosition() ) && ( this.nextIdx = i + ( e ? 0 : -1 ), t = !0 )
          }
          t || ( this.nextIdx = e ? 0 : this.ranges.length - 1 ), this.nextIdx < 0 && ( this.nextIdx = this.ranges.length - 1 )
        }, e.prototype._move = function ( e, t ) {
          if ( i.a( !this.disposed, "Illegal State - diff navigator has been disposed" ), this.canNavigate() ) {
            -1 === this.nextIdx ? this._initIdx( e ) : e ? ( this.nextIdx += 1, this.nextIdx >= this.ranges.length && ( this.nextIdx = 0 ) ) : ( this.nextIdx -= 1, this.nextIdx < 0 && ( this.nextIdx = this.ranges.length - 1 ) );
            const n = this.ranges[ this.nextIdx ];
            this.ignoreSelectionChange = !0;
            try {
              const o = n.range.getStartPosition();
              this._editor.setPosition( o ), this._editor.revealPositionInCenter( o, t )
            } finally {
              this.ignoreSelectionChange = !1
            }
          }
        }, e.prototype.canNavigate = function () {
          return this.ranges && this.ranges.length > 0
        }, e.prototype.next = function ( e ) {
          void 0 === e && ( e = 0 ), this._move( !0, e )
        }, e.prototype.previous = function ( e ) {
          void 0 === e && ( e = 0 ), this._move( !1, e )
        }, e.prototype.dispose = function () {
          Object( s.d )( this._disposables ), this._disposables.length = 0, this._onDidUpdate.dispose(), this.ranges = null, this.disposed = !0
        }, e;
      } )();
    },
    "0VEe": function ( e, t, n ) {
      "use strict";
      const i = n( "VMIq" ),
        o = n( "N0LK" ),
        r = n( "bY76" ),
        s = n( "EffR" ),
        a = n( "iuje" ),
        u = n( "M1Kb" ),
        l = n( "MI8n" ),
        c = ( () => {
          function e() {
            this._codeEditors = Object.create( null ), this._diffEditors = Object.create( null ), this._onCodeEditorAdd = new l.a, this._onCodeEditorRemove = new l.a, this._onDiffEditorAdd = new l.a, this._onDiffEditorRemove = new l.a
          }
          return e.prototype.addCodeEditor = function ( e ) {
            this._codeEditors[ e.getId() ] = e, this._onCodeEditorAdd.fire( e )
          }, Object.defineProperty( e.prototype, "onCodeEditorAdd", {
            get() {
              return this._onCodeEditorAdd.event
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.removeCodeEditor = function ( e ) {
            delete this._codeEditors[ e.getId() ] && this._onCodeEditorRemove.fire( e )
          }, e.prototype.listCodeEditors = function () {
            const e = this;
            return Object.keys( this._codeEditors ).map( ( t => {
              return e._codeEditors[ t ]
            } ) );
          }, e.prototype.addDiffEditor = function ( e ) {
            this._diffEditors[ e.getId() ] = e, this._onDiffEditorAdd.fire( e )
          }, e.prototype.removeDiffEditor = function ( e ) {
            delete this._diffEditors[ e.getId() ] && this._onDiffEditorRemove.fire( e )
          }, e.prototype.listDiffEditors = function () {
            const e = this;
            return Object.keys( this._diffEditors ).map( ( t => {
              return e._diffEditors[ t ]
            } ) );
          }, e.prototype.getFocusedCodeEditor = function () {
            for ( var e = null, t = this.listCodeEditors(), n = 0; n < t.length; n++ ) {
              const i = t[ n ];
              if ( i.hasTextFocus() ) return i;
              i.hasWidgetFocus() && ( e = i )
            }
            return e
          }, e;
        } )(),
        d = n( "pmY6" ),
        h = n( "t9D7" ),
        p = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        f = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        g = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        m = ( e => {
          function t( t, n ) {
            void 0 === n && ( n = s.o() );
            const i = e.call( this ) || this;
            return i._styleSheet = n, i._decorationOptionProviders = Object.create( null ), i._themeService = t, i
          }
          return p( t, e ), t.prototype.registerDecorationType = function ( e, t, n ) {
            let i = this._decorationOptionProviders[ e ];
            if ( !i ) {
              const o = {
                styleSheet: this._styleSheet,
                key: e,
                parentTypeKey: n,
                options: t || Object.create( null )
              };
              i = n ? new _( this._themeService, o ) : new v( this._themeService, o ), this._decorationOptionProviders[ e ] = i
            }
            i.refCount++
          }, t.prototype.removeDecorationType = function ( e ) {
            const t = this._decorationOptionProviders[ e ];
            t && ( t.refCount--, t.refCount <= 0 && ( delete this._decorationOptionProviders[ e ], t.dispose(), this.listCodeEditors().forEach( ( t => {
              return t.removeDecorations( e )
            } ) ) ) )
          }, t.prototype.resolveDecorationOptions = function ( e, t ) {
            const n = this._decorationOptionProviders[ e ];
            if ( !n ) throw new Error( "Unknown decoration type key: " + e );
            return n.getOptions( this, t )
          }, t = f( [ g( 0, h.c ) ], t );
        } )( c ),
        _ = ( () => {
          function e( e, t ) {
            this._parentTypeKey = t.parentTypeKey, this.refCount = 0, this._beforeContentRules = new b( 3, t, e ), this._afterContentRules = new b( 4, t, e )
          }
          return e.prototype.getOptions = function ( e, t ) {
            const n = e.resolveDecorationOptions( this._parentTypeKey, !0 );
            return this._beforeContentRules && ( n.beforeContentClassName = this._beforeContentRules.className ), this._afterContentRules && ( n.afterContentClassName = this._afterContentRules.className ), n
          }, e.prototype.dispose = function () {
            this._beforeContentRules && ( this._beforeContentRules.dispose(), this._beforeContentRules = null ), this._afterContentRules && ( this._afterContentRules.dispose(), this._afterContentRules = null )
          }, e;
        } )(),
        v = ( () => {
          function e( e, t ) {
            const n = this;
            this.refCount = 0, this._disposables = [];
            const i = i => {
              const o = new b( i, t, e );
              if ( o.hasContent ) return n._disposables.push( o ), o.className
            };
            this.className = i( 0 );
            const o = ( i => {
              const o = new b( i, t, e );
              return o.hasContent ? ( n._disposables.push( o ), {
                className: o.className,
                hasLetterSpacing: o.hasLetterSpacing
              } ) : null
            } )( 1 );
            o && ( this.inlineClassName = o.className, this.inlineClassNameAffectsLetterSpacing = o.hasLetterSpacing ), this.beforeContentClassName = i( 3 ), this.afterContentClassName = i( 4 ), this.glyphMarginClassName = i( 2 );
            const r = t.options;
            this.isWholeLine = Boolean( r.isWholeLine ), this.stickiness = r.rangeBehavior;
            const s = r.light && r.light.overviewRulerColor || r.overviewRulerColor,
              a = r.dark && r.dark.overviewRulerColor || r.overviewRulerColor;
            "undefined" === typeof s && "undefined" === typeof a || ( this.overviewRuler = {
              color: s || a,
              darkColor: a || s,
              position: r.overviewRulerLane || u.f.Center
            } )
          }
          return e.prototype.getOptions = function ( e, t ) {
            return t ? {
              inlineClassName: this.inlineClassName,
              beforeContentClassName: this.beforeContentClassName,
              afterContentClassName: this.afterContentClassName,
              className: this.className,
              glyphMarginClassName: this.glyphMarginClassName,
              isWholeLine: this.isWholeLine,
              overviewRuler: this.overviewRuler,
              stickiness: this.stickiness
            } : this
          }, e.prototype.dispose = function () {
            this._disposables = Object( d.d )( this._disposables )
          }, e
        } )(),
        y = {
          color: "color:{0} !important;",
          opacity: "opacity:{0}; will-change: opacity;",
          backgroundColor: "background-color:{0};",
          outline: "outline:{0};",
          outlineColor: "outline-color:{0};",
          outlineStyle: "outline-style:{0};",
          outlineWidth: "outline-width:{0};",
          border: "border:{0};",
          borderColor: "border-color:{0};",
          borderRadius: "border-radius:{0};",
          borderSpacing: "border-spacing:{0};",
          borderStyle: "border-style:{0};",
          borderWidth: "border-width:{0};",
          fontStyle: "font-style:{0};",
          fontWeight: "font-weight:{0};",
          textDecoration: "text-decoration:{0};",
          cursor: "cursor:{0};",
          letterSpacing: "letter-spacing:{0};",
          gutterIconPath: "background:url('{0}') center center no-repeat;",
          gutterIconSize: "background-size:{0};",
          contentText: "content:'{0}';",
          contentIconPath: "content:url('{0}');",
          margin: "margin:{0};",
          width: "width:{0};",
          height: "height:{0};"
        },
        b = ( () => {
          function e( e, t, n ) {
            const i = this;
            this._theme = n.getTheme(), this._ruleType = e, this._providerArgs = t, this._usesThemeColors = !1, this._hasContent = !1, this._hasLetterSpacing = !1;
            let o = C.getClassName( this._providerArgs.key, e );
            this._providerArgs.parentTypeKey && ( o = o + " " + C.getClassName( this._providerArgs.parentTypeKey, e ) ), this._className = o, this._unThemedSelector = C.getSelector( this._providerArgs.key, this._providerArgs.parentTypeKey, e ), this._buildCSS(), this._usesThemeColors && ( this._themeListener = n.onThemeChange( ( e => {
              i._theme = n.getTheme(), i._removeCSS(), i._buildCSS()
            } ) ) )
          }
          return e.prototype.dispose = function () {
            this._hasContent && ( this._removeCSS(), this._hasContent = !1 ), this._themeListener && ( this._themeListener.dispose(), this._themeListener = null )
          }, Object.defineProperty( e.prototype, "hasContent", {
            get() {
              return this._hasContent
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "hasLetterSpacing", {
            get() {
              return this._hasLetterSpacing
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "className", {
            get() {
              return this._className
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype._buildCSS = function () {
            let e;
            let t;
            let n;
            const i = this._providerArgs.options;
            switch ( this._ruleType ) {
              case 0:
                e = this.getCSSTextForModelDecorationClassName( i ), t = this.getCSSTextForModelDecorationClassName( i.light ), n = this.getCSSTextForModelDecorationClassName( i.dark );
                break;
              case 1:
                e = this.getCSSTextForModelDecorationInlineClassName( i ), t = this.getCSSTextForModelDecorationInlineClassName( i.light ), n = this.getCSSTextForModelDecorationInlineClassName( i.dark );
                break;
              case 2:
                e = this.getCSSTextForModelDecorationGlyphMarginClassName( i ), t = this.getCSSTextForModelDecorationGlyphMarginClassName( i.light ), n = this.getCSSTextForModelDecorationGlyphMarginClassName( i.dark );
                break;
              case 3:
                e = this.getCSSTextForModelDecorationContentClassName( i.before ), t = this.getCSSTextForModelDecorationContentClassName( i.light && i.light.before ), n = this.getCSSTextForModelDecorationContentClassName( i.dark && i.dark.before );
                break;
              case 4:
                e = this.getCSSTextForModelDecorationContentClassName( i.after ), t = this.getCSSTextForModelDecorationContentClassName( i.light && i.light.after ), n = this.getCSSTextForModelDecorationContentClassName( i.dark && i.dark.after );
                break;
              default:
                throw new Error( "Unknown rule type: " + this._ruleType )
            }
            const o = this._providerArgs.styleSheet.sheet;
            let r = !1;
            e.length > 0 && ( o.insertRule( this._unThemedSelector + " {" + e + "}", 0 ), r = !0 ), t.length > 0 && ( o.insertRule( ".vs" + this._unThemedSelector + " {" + t + "}", 0 ), r = !0 ), n.length > 0 && ( o.insertRule( ".vs-dark" + this._unThemedSelector + ", .hc-black" + this._unThemedSelector + " {" + n + "}", 0 ), r = !0 ), this._hasContent = r
          }, e.prototype._removeCSS = function () {
            s.F( this._unThemedSelector, this._providerArgs.styleSheet )
          }, e.prototype.getCSSTextForModelDecorationClassName = function ( e ) {
            if ( !e ) return "";
            const t = [];
            return this.collectCSSText( e, [ "backgroundColor" ], t ), this.collectCSSText( e, [ "outline", "outlineColor", "outlineStyle", "outlineWidth" ], t ), this.collectBorderSettingsCSSText( e, t ), t.join( "" )
          }, e.prototype.getCSSTextForModelDecorationInlineClassName = function ( e ) {
            if ( !e ) return "";
            const t = [];
            return this.collectCSSText( e, [ "fontStyle", "fontWeight", "textDecoration", "cursor", "color", "opacity", "letterSpacing" ], t ), e.letterSpacing && ( this._hasLetterSpacing = !0 ), t.join( "" )
          }, e.prototype.getCSSTextForModelDecorationContentClassName = function ( e ) {
            if ( !e ) return "";
            const t = [];
            if ( "undefined" !== typeof e ) {
              if ( this.collectBorderSettingsCSSText( e, t ), "undefined" !== typeof e.contentIconPath && ( "string" === typeof e.contentIconPath ? t.push( o.format( y.contentIconPath, r.a.file( e.contentIconPath ).toString().replace( /'/g, "%27" ) ) ) : t.push( o.format( y.contentIconPath, r.a.revive( e.contentIconPath ).toString( !0 ).replace( /'/g, "%27" ) ) ) ), "string" === typeof e.contentText ) {
                const n = e.contentText.match( /^.*$/m )[ 0 ].replace( /['\\]/g, "\\$&" );
                t.push( o.format( y.contentText, n ) )
              }
              this.collectCSSText( e, [ "fontStyle", "fontWeight", "textDecoration", "color", "opacity", "backgroundColor", "margin" ], t ), this.collectCSSText( e, [ "width", "height" ], t ) && t.push( "display:inline-block;" )
            }
            return t.join( "" )
          }, e.prototype.getCSSTextForModelDecorationGlyphMarginClassName = e => {
            if ( !e ) return "";
            const t = [];
            return "undefined" !== typeof e.gutterIconPath && ( "string" === typeof e.gutterIconPath ? t.push( o.format( y.gutterIconPath, r.a.file( e.gutterIconPath ).toString() ) ) : t.push( o.format( y.gutterIconPath, r.a.revive( e.gutterIconPath ).toString( !0 ).replace( /'/g, "%27" ) ) ), "undefined" !== typeof e.gutterIconSize && t.push( o.format( y.gutterIconSize, e.gutterIconSize ) ) ), t.join( "" )
          }, e.prototype.collectBorderSettingsCSSText = function ( e, t ) {
            return !!this.collectCSSText( e, [ "border", "borderColor", "borderRadius", "borderSpacing", "borderStyle", "borderWidth" ], t ) && ( t.push( o.format( "box-sizing: border-box;" ) ), !0 )
          }, e.prototype.collectCSSText = function ( e, t, n ) {
            for ( var i = n.length, r = 0, s = t; r < s.length; r++ ) {
              const a = s[ r ],
                u = this.resolveValue( e[ a ] );
              "string" === typeof u && n.push( o.format( y[ a ], u ) )
            }
            return n.length !== i
          }, e.prototype.resolveValue = function ( e ) {
            if ( Object( a.c )( e ) ) {
              this._usesThemeColors = !0;
              const t = this._theme.getColor( e.id );
              return t ? t.toString() : "transparent"
            }
            return e
          }, e;
        } )(),
        C = ( () => {
          function e() {}
          return e.getClassName = ( e, t ) => {
            return "ced-" + e + "-" + t
          }, e.getSelector = function ( e, t, n ) {
            let i = ".monaco-editor ." + this.getClassName( e, n );
            return t && ( i = i + "." + this.getClassName( t, n ) ), 3 === n ? i += "::before" : 4 === n && ( i += "::after" ), i
          }, e;
        } )(),
        w = n( "tYmi" );
      n.d( t, "a", ( () => {
        return O
      } ) );
      const S = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var O = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return S( t, e ), t.prototype.getActiveCodeEditor = () => {
          return null
        }, t.prototype.openCodeEditor = function ( e, t, n ) {
          return t ? i.b.as( this.doOpenEditor( t, e ) ) : i.b.as( null )
        }, t.prototype.doOpenEditor = function ( e, t ) {
          if ( !this.findModel( e, t.resource ) ) {
            if ( t.resource ) {
              const n = t.resource.scheme;
              if ( n === w.a.http || n === w.a.https ) return Object( s.P )( t.resource.toString() ), e
            }
            return null
          }
          const i = t.options.selection;
          if ( i )
            if ( "number" === typeof i.endLineNumber && "number" === typeof i.endColumn ) e.setSelection( i ), e.revealRangeInCenter( i, 1 );
            else {
              const o = {
                lineNumber: i.startLineNumber,
                column: i.startColumn
              };
              e.setPosition( o ), e.revealPositionInCenter( o, 1 )
            } return e
        }, t.prototype.findModel = ( e, t ) => {
          const n = e.getModel();
          return n.uri.toString() !== t.toString() ? null : n
        }, t;
      } )( m );
    },
    "0oIH": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "graphql",
        extensions: [ ".graphql", ".gql" ],
        aliases: [ "GraphQL", "graphql", "gql" ],
        mimetypes: [ "application/graphql" ],
        loader() {
          return o.Promise.wrap( n.e( 267 ).then( n.bind( null, "Eg73" ) ) )
        }
      } )
    },
    "10Fh": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "6OMU" ),
        r = n( "VMIq" ),
        s = n( "Cg/j" ),
        a = n( "aokT" ),
        u = n( "wQH0" ),
        l = n( "sswD" ),
        c = n( "G2kB" ),
        d = n( "BFtn" ),
        h = n( "EIAu" ),
        p = n( "cMvZ" ),
        f = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        g = ( () => {
          function e() {}
          return Object.defineProperty( e.prototype, "range", {
            get() {
              return new a.a( this.start.lineNumber, this.start.column, this.end.lineNumber, this.end.column )
            },
            enumerable: !0,
            configurable: !0
          } ), e;
        } )(),
        m = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return f( t, e ), Object.defineProperty( t.prototype, "hasChildren", {
            get() {
              return this.children && this.children.length > 0
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( t.prototype, "isEmpty", {
            get() {
              return !this.hasChildren && !this.parent
            },
            enumerable: !0,
            configurable: !0
          } ), t.prototype.append = function ( e ) {
            return !!e && ( e.parent = this, this.children || ( this.children = [] ), e instanceof t ? e.children && this.children.push.apply( this.children, e.children ) : this.children.push( e ), !0 )
          }, t;
        } )( g ),
        _ = ( e => {
          function t() {
            const t = e.call( this ) || this;
            return t.elements = new m, t.elements.parent = t, t
          }
          return f( t, e ), t
        } )( g ),
        v = function ( e, t, n ) {
          this.range = e, this.bracket = t, this.bracketType = n
        };

      function y( e ) {
        const t = new g;
        return t.start = e.range.getStartPosition(), t.end = e.range.getEndPosition(), t
      }
      const b = function ( e, t, n ) {
          this.lineNumber = n, this.lineText = e.getLineContent(), this.startOffset = e.getStartOffset( t ), this.endOffset = e.getEndOffset( t ), this.type = e.getStandardTokenType( t ), this.languageId = e.getLanguageId( t )
        },
        C = ( () => {
          function e( e ) {
            this._model = e, this._lineCount = this._model.getLineCount(), this._versionId = this._model.getVersionId(), this._lineNumber = 0, this._tokenIndex = 0, this._lineTokens = null, this._advance()
          }
          return e.prototype._advance = function () {
            for ( this._lineTokens && ( this._tokenIndex++, this._tokenIndex >= this._lineTokens.getCount() && ( this._lineTokens = null ) ); this._lineNumber < this._lineCount && !this._lineTokens; ) this._lineNumber++, this._model.forceTokenization( this._lineNumber ), this._lineTokens = this._model.getLineTokens( this._lineNumber ), this._tokenIndex = 0, 0 === this._lineTokens.getCount() && ( this._lineTokens = null )
          }, e.prototype.next = function () {
            if ( !this._lineTokens ) return null;
            if ( this._model.getVersionId() !== this._versionId ) return null;
            const e = new b( this._lineTokens, this._tokenIndex, this._lineNumber );
            return this._advance(), e
          }, e;
        } )(),
        w = ( () => {
          function e( e ) {
            this._rawTokenScanner = new C( e ), this._nextBuff = [], this._cachedLanguageBrackets = null, this._cachedLanguageId = -1
          }
          return e.prototype.next = function () {
            if ( this._nextBuff.length > 0 ) return this._nextBuff.shift();
            const e = this._rawTokenScanner.next();
            if ( !e ) return null;
            const t = e.lineNumber;
            const n = e.lineText;
            const i = e.type;
            let o = e.startOffset;
            const r = e.endOffset;
            this._cachedLanguageId !== e.languageId && ( this._cachedLanguageId = e.languageId, this._cachedLanguageBrackets = p.a.getBracketsSupport( this._cachedLanguageId ) );
            let s;
            const u = this._cachedLanguageBrackets;
            if ( !u || Object( d.b )( i ) ) return new v( new a.a( t, o + 1, t, r + 1 ), 0, null );
            do {
              if ( s = h.a.findNextBracketInToken( u.forwardRegex, t, n, o, r ) ) {
                const l = s.startColumn - 1,
                  c = s.endColumn - 1;
                o < l && this._nextBuff.push( new v( new a.a( t, o + 1, t, l + 1 ), 0, null ) );
                let f = n.substring( l, c );
                f = f.toLowerCase();
                const g = u.textIsBracket[ f ],
                  m = u.textIsOpenBracket[ f ];
                this._nextBuff.push( new v( new a.a( t, l + 1, t, c + 1 ), m ? 1 : -1, g.languageIdentifier.language + ";" + g.open + ";" + g.close ) ), o = c
              }
            } while ( s );
            return o < r && this._nextBuff.push( new v( new a.a( t, o + 1, t, r + 1 ), 0, null ) ), this._nextBuff.shift()
          }, e;
        } )(),
        S = ( () => {
          function e( e ) {
            this._stack = [], this._scanner = new w( e )
          }
          return e.prototype.build = function () {
            for ( var e = new m; e.append( this._line() || this._any() ); );
            return e
          }, e.prototype._accept = function ( e ) {
            const t = this._stack.pop() || this._scanner.next();
            if ( !t ) return !1;
            const n = e( t );
            return n ? this._currentToken = t : ( this._stack.push( t ), this._currentToken = null ), n
          }, e.prototype._peek = function ( e ) {
            let t = !1;
            return this._accept( ( n => {
              return t = e( n ), !1
            } ) ), t;
          }, e.prototype._line = function () {
            let e;
            const t = new m;
            for ( this._peek( ( t => {
                return e = t.range.startLineNumber, !1
              } ) ); this._peek( ( t => {
                return t.range.startLineNumber === e
              } ) ) && t.append( this._token() || this._block() ); );
            return t.children && 0 !== t.children.length ? 1 === t.children.length ? t.children[ 0 ] : t : null
          }, e.prototype._token = function () {
            return this._accept( ( e => {
              return 0 === e.bracket
            } ) ) ? y( this._currentToken ) : null;
          }, e.prototype._block = function () {
            let e;
            if ( !this._accept( ( t => {
                return e = t.bracketType, 1 === t.bracket
              } ) ) ) return null;
            const t = new _;
            for ( t.open = y( this._currentToken ); t.elements.append( this._line() ); );
            if ( !this._accept( ( t => {
                return -1 === t.bracket && t.bracketType === e
              } ) ) ) {
              const n = new m;
              return n.append( t.open ), n.append( t.elements ), n
            }
            return t.close = y( this._currentToken ), t
          }, e.prototype._any = function () {
            return this._accept( ( e => {
              return !0
            } ) ) ? y( this._currentToken ) : null;
          }, e;
        } )();
      const O = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        L = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        x = ( () => {
          function e( e ) {
            this._modelService = e
          }
          return e.prototype.getRangesToPosition = function ( e, t ) {
            return r.b.as( this.getRangesToPositionSync( e, t ) )
          }, e.prototype.getRangesToPositionSync = function ( e, t ) {
            const n = this._modelService.getModel( e ),
              i = [];
            return n && this._doGetRangesToPosition( n, t ).forEach( ( e => {
              i.push( {
                type: void 0,
                range: e
              } )
            } ) ), i;
          }, e.prototype._doGetRangesToPosition = ( e, t ) => {
            let n, i;
            n = function e( t, n ) {
              if ( t instanceof m && t.isEmpty ) return null;
              if ( !a.a.containsPosition( t.range, n ) ) return null;
              let i;
              if ( t instanceof m ) {
                if ( t.hasChildren )
                  for ( let o = 0, r = t.children.length; o < r && !i; o++ ) i = e( t.children[ o ], n )
              } else t instanceof _ && ( i = e( t.open, n ) || e( t.elements, n ) || e( t.close, n ) );
              return i || t
            }( ( e => {
              return new S( e ).build()
            } )( e ), t );
            for ( var o = []; n; ) i && a.a.equalsRange( i, n.range ) || o.push( n.range ), i = n.range, n = n.parent;
            return o = o.reverse()
          }, e = O( [ L( 0, c.a ) ], e );
        } )(),
        N = n( "fjLI" ),
        E = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        k = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        I = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        D = function ( e ) {
          this.editor = e, this.next = null, this.previous = null, this.selection = e.getSelection()
        },
        M = ( () => {
          function e( e, t ) {
            this.editor = e, this._tokenSelectionSupport = t.createInstance( x ), this._state = null, this._ignoreSelection = !1
          }
          return e.get = t => {
            return t.getContribution( e.ID )
          }, e.prototype.dispose = () => {}, e.prototype.getId = () => {
            return e.ID
          }, e.prototype.run = function ( e ) {
            const t = this,
              n = this.editor.getSelection(),
              i = this.editor.getModel();
            this._state && this._state.editor !== this.editor && ( this._state = null );
            let s = r.b.as( null );
            return this._state || ( s = this._tokenSelectionSupport.getRangesToPosition( i.uri, n.getStartPosition() ).then( ( e => {
              if ( !o.k( e ) ) {
                let n;
                e.filter( ( e => {
                  const n = t.editor.getSelection(),
                    i = new a.a( e.range.startLineNumber, e.range.startColumn, e.range.endLineNumber, e.range.endColumn );
                  return i.containsPosition( n.getStartPosition() ) && i.containsPosition( n.getEndPosition() )
                } ) ).forEach( ( e => {
                  const i = e.range,
                    o = new D( t.editor );
                  o.selection = new a.a( i.startLineNumber, i.startColumn, i.endLineNumber, i.endColumn ), n && ( o.next = n, n.previous = o ), n = o
                } ) );
                const i = new D( t.editor );
                i.next = n, n && ( n.previous = i ), t._state = i;
                const r = t.editor.onDidChangeCursorPosition( ( e => {
                  t._ignoreSelection || ( t._state = null, r.dispose() )
                } ) );
              }
            } ) ) ), s.then( ( () => {
              if ( t._state && ( t._state = e ? t._state.next : t._state.previous, t._state ) ) {
                t._ignoreSelection = !0;
                try {
                  t.editor.setSelection( t._state.selection )
                } finally {
                  t._ignoreSelection = !1
                }
              }
            } ) );
          }, e.ID = "editor.contrib.smartSelectController", e = k( [ I( 1, s.a ) ], e );
        } )(),
        T = ( e => {
          function t( t, n ) {
            const i = e.call( this, n ) || this;
            return i._forward = t, i
          }
          return E( t, e ), t.prototype.run = function ( e, t ) {
            const n = M.get( t );
            if ( n ) return n.run( this._forward )
          }, t;
        } )( l.b ),
        R = ( e => {
          function t() {
            return e.call( this, !0, {
              id: "editor.action.smartSelect.grow",
              label: i.a( "smartSelect.grow", "Expand Select" ),
              alias: "Expand Select",
              precondition: null,
              kbOpts: {
                kbExpr: u.a.editorTextFocus,
                primary: 1553,
                mac: {
                  primary: 3345
                },
                weight: 100
              },
              menubarOpts: {
                menuId: N.b.MenubarSelectionMenu,
                group: "1_basic",
                title: i.a( {
                  key: "miSmartSelectGrow",
                  comment: [ "&& denotes a mnemonic" ]
                }, "&&Expand Selection" ),
                order: 2
              }
            } ) || this
          }
          return E( t, e ), t
        } )( T ),
        P = ( e => {
          function t() {
            return e.call( this, !1, {
              id: "editor.action.smartSelect.shrink",
              label: i.a( "smartSelect.shrink", "Shrink Select" ),
              alias: "Shrink Select",
              precondition: null,
              kbOpts: {
                kbExpr: u.a.editorTextFocus,
                primary: 1551,
                mac: {
                  primary: 3343
                },
                weight: 100
              },
              menubarOpts: {
                menuId: N.b.MenubarSelectionMenu,
                group: "1_basic",
                title: i.a( {
                  key: "miSmartSelectShrink",
                  comment: [ "&& denotes a mnemonic" ]
                }, "&&Shrink Selection" ),
                order: 3
              }
            } ) || this
          }
          return E( t, e ), t
        } )( T );
      Object( l.h )( M ), Object( l.f )( R ), Object( l.f )( P )
    },
    "1I1M": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return l
      } ) ), n.d( t, "b", ( () => {
        return h
      } ) );
      const i = n( "Ll0s" );
      const o = n( "cGHE" );
      const r = n( "5v8Y" );
      const s = n( "N0LK" );
      const a = n( "aokT" );
      const u = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      var l = ( () => {
        function e() {}
        return e._createWord = ( e, t, n, i, o ) => {
          return {
            start: i,
            end: o,
            wordType: t,
            nextCharClass: n
          }
        }, e._findPreviousWordOnLine = function ( e, t, n ) {
          const i = t.getLineContent( n.lineNumber );
          return this._doFindPreviousWordOnLine( i, e, n )
        }, e._doFindPreviousWordOnLine = function ( e, t, n ) {
          for ( var i = 0, o = n.column - 2; o >= 0; o-- ) {
            const r = e.charCodeAt( o ),
              s = t.get( r );
            if ( 0 === s ) {
              if ( 2 === i ) return this._createWord( e, i, s, o + 1, this._findEndOfWord( e, t, i, o + 1 ) );
              i = 1
            } else if ( 2 === s ) {
              if ( 1 === i ) return this._createWord( e, i, s, o + 1, this._findEndOfWord( e, t, i, o + 1 ) );
              i = 2
            } else if ( 1 === s && 0 !== i ) return this._createWord( e, i, s, o + 1, this._findEndOfWord( e, t, i, o + 1 ) )
          }
          return 0 !== i ? this._createWord( e, i, 1, 0, this._findEndOfWord( e, t, i, 0 ) ) : null
        }, e._findEndOfWord = ( e, t, n, i ) => {
          for ( var o = e.length, r = i; r < o; r++ ) {
            const s = e.charCodeAt( r ),
              a = t.get( s );
            if ( 1 === a ) return r;
            if ( 1 === n && 2 === a ) return r;
            if ( 2 === n && 0 === a ) return r
          }
          return o
        }, e._findNextWordOnLine = function ( e, t, n ) {
          const i = t.getLineContent( n.lineNumber );
          return this._doFindNextWordOnLine( i, e, n )
        }, e._doFindNextWordOnLine = function ( e, t, n ) {
          for ( var i = 0, o = e.length, r = n.column - 1; r < o; r++ ) {
            const s = e.charCodeAt( r ),
              a = t.get( s );
            if ( 0 === a ) {
              if ( 2 === i ) return this._createWord( e, i, a, this._findStartOfWord( e, t, i, r - 1 ), r );
              i = 1
            } else if ( 2 === a ) {
              if ( 1 === i ) return this._createWord( e, i, a, this._findStartOfWord( e, t, i, r - 1 ), r );
              i = 2
            } else if ( 1 === a && 0 !== i ) return this._createWord( e, i, a, this._findStartOfWord( e, t, i, r - 1 ), r )
          }
          return 0 !== i ? this._createWord( e, i, 1, this._findStartOfWord( e, t, i, o - 1 ), o ) : null
        }, e._findStartOfWord = ( e, t, n, i ) => {
          for ( let o = i; o >= 0; o-- ) {
            const r = e.charCodeAt( o ),
              s = t.get( r );
            if ( 1 === s ) return o + 1;
            if ( 1 === n && 2 === s ) return o + 1;
            if ( 2 === n && 0 === s ) return o + 1
          }
          return 0
        }, e.moveWordLeft = ( t, n, i, r ) => {
          let s = i.lineNumber,
            a = i.column;
          1 === a && s > 1 && ( s -= 1, a = n.getLineMaxColumn( s ) );
          let u = e._findPreviousWordOnLine( t, n, new o.a( s, a ) );
          return 0 === r ? ( u && 2 === u.wordType && u.end - u.start === 1 && 0 === u.nextCharClass && ( u = e._findPreviousWordOnLine( t, n, new o.a( s, u.start + 1 ) ) ), a = u ? u.start + 1 : 1 ) : ( u && a <= u.end + 1 && ( u = e._findPreviousWordOnLine( t, n, new o.a( s, u.start + 1 ) ) ), a = u ? u.end + 1 : 1 ), new o.a( s, a )
        }, e.moveWordRight = ( t, n, i, r ) => {
          let s = i.lineNumber,
            a = i.column;
          a === n.getLineMaxColumn( s ) && s < n.getLineCount() && ( s += 1, a = 1 );
          let u = e._findNextWordOnLine( t, n, new o.a( s, a ) );
          return 1 === r ? ( u && 2 === u.wordType && u.end - u.start === 1 && 0 === u.nextCharClass && ( u = e._findNextWordOnLine( t, n, new o.a( s, u.end + 1 ) ) ), a = u ? u.end + 1 : n.getLineMaxColumn( s ) ) : ( u && a >= u.start + 1 && ( u = e._findNextWordOnLine( t, n, new o.a( s, u.end + 1 ) ) ), a = u ? u.start + 1 : n.getLineMaxColumn( s ) ), new o.a( s, a )
        }, e._deleteWordLeftWhitespace = ( e, t ) => {
          const n = e.getLineContent( t.lineNumber ),
            i = t.column - 2,
            o = s.lastNonWhitespaceIndex( n, i );
          return o + 1 < i ? new a.a( t.lineNumber, o + 2, t.lineNumber, t.column ) : null
        }, e.deleteWordLeft = function ( t, n, i, r, s ) {
          if ( !i.isEmpty() ) return i;
          const u = new o.a( i.positionLineNumber, i.positionColumn );
          let l = u.lineNumber;
          let c = u.column;
          if ( 1 === l && 1 === c ) return null;
          if ( r ) {
            const d = this._deleteWordLeftWhitespace( n, u );
            if ( d ) return d
          }
          let h = e._findPreviousWordOnLine( t, n, u );
          return 0 === s ? h ? c = h.start + 1 : c > 1 ? c = 1 : ( l--, c = n.getLineMaxColumn( l ) ) : ( h && c <= h.end + 1 && ( h = e._findPreviousWordOnLine( t, n, new o.a( l, h.start + 1 ) ) ), h ? c = h.end + 1 : c > 1 ? c = 1 : ( l--, c = n.getLineMaxColumn( l ) ) ), new a.a( l, c, u.lineNumber, u.column )
        }, e._findFirstNonWhitespaceChar = ( e, t ) => {
          for ( var n = e.length, i = t; i < n; i++ ) {
            const o = e.charAt( i );
            if ( " " !== o && "\t" !== o ) return i
          }
          return n
        }, e._deleteWordRightWhitespace = function ( e, t ) {
          const n = e.getLineContent( t.lineNumber ),
            i = t.column - 1,
            o = this._findFirstNonWhitespaceChar( n, i );
          return i + 1 < o ? new a.a( t.lineNumber, t.column, t.lineNumber, o + 1 ) : null
        }, e.deleteWordRight = function ( t, n, i, r, s ) {
          if ( !i.isEmpty() ) return i;
          const u = new o.a( i.positionLineNumber, i.positionColumn );
          let l = u.lineNumber;
          let c = u.column;
          const d = n.getLineCount();
          const h = n.getLineMaxColumn( l );
          if ( l === d && c === h ) return null;
          if ( r ) {
            const p = this._deleteWordRightWhitespace( n, u );
            if ( p ) return p
          }
          let f = e._findNextWordOnLine( t, n, u );
          return 1 === s ? f ? c = f.end + 1 : c < h || l === d ? c = h : ( l++, c = ( f = e._findNextWordOnLine( t, n, new o.a( l, 1 ) ) ) ? f.start + 1 : n.getLineMaxColumn( l ) ) : ( f && c >= f.start + 1 && ( f = e._findNextWordOnLine( t, n, new o.a( l, f.end + 1 ) ) ), f ? c = f.start + 1 : c < h || l === d ? c = h : ( l++, c = ( f = e._findNextWordOnLine( t, n, new o.a( l, 1 ) ) ) ? f.start + 1 : n.getLineMaxColumn( l ) ) ), new a.a( l, c, u.lineNumber, u.column )
        }, e.word = ( t, n, s, u, l ) => {
          const c = Object( r.a )( t.wordSeparators ),
            d = e._findPreviousWordOnLine( c, n, l ),
            h = e._findNextWordOnLine( c, n, l );
          if ( !u ) {
            let p;
            let f;
            const g = d && 1 === d.wordType && d.start <= l.column - 1 && l.column - 1 <= d.end;
            const m = h && 1 === h.wordType && h.start <= l.column - 1 && l.column - 1 <= h.end;
            return g ? ( p = d.start + 1, f = d.end + 1 ) : m ? ( p = h.start + 1, f = h.end + 1 ) : ( p = d ? d.end + 1 : 1, f = h ? h.start + 1 : n.getLineMaxColumn( l.lineNumber ) ), new i.f( new a.a( l.lineNumber, p, l.lineNumber, f ), 0, new o.a( l.lineNumber, f ), 0 )
          }
          let _;
          let v;
          const y = d && 1 === d.wordType && d.start < l.column - 1 && l.column - 1 < d.end;
          const b = h && 1 === h.wordType && h.start < l.column - 1 && l.column - 1 < h.end;
          y ? ( _ = d.start + 1, v = d.end + 1 ) : b ? ( _ = h.start + 1, v = h.end + 1 ) : ( _ = l.column, v = l.column );
          let C;
          const w = l.lineNumber;
          if ( s.selectionStart.containsPosition( l ) ) C = s.selectionStart.endColumn;
          else if ( l.isBeforeOrEqual( s.selectionStart.getStartPosition() ) ) {
            C = _;
            var S = new o.a( w, C );
            s.selectionStart.containsPosition( S ) && ( C = s.selectionStart.endColumn )
          } else {
            C = v;
            S = new o.a( w, C );
            s.selectionStart.containsPosition( S ) && ( C = s.selectionStart.startColumn )
          }
          return s.move( !0, w, C, 0 )
        }, e;
      } )();

      function c( e, t ) {
        void 0 === t && ( t = e.length - 1 );
        for ( let n = !s.isLowerAsciiLetter( e.charCodeAt( t + 1 ) ), i = t; i >= 0; i-- ) {
          const o = e.charCodeAt( i );
          if ( 32 === o || 9 === o || !n && s.isUpperAsciiLetter( o ) || 95 === o ) return i - 1;
          if ( n && i < t && s.isLowerAsciiLetter( o ) ) return i;
          n = n && s.isUpperAsciiLetter( o )
        }
        return -1
      }

      function d( e, t ) {
        void 0 === t && ( t = 0 );
        const n = e.charCodeAt( t - 1 );
        let i = e.charCodeAt( t );
        if ( ( 32 === n || 9 === n ) && ( s.isLowerAsciiLetter( i ) || s.isUpperAsciiLetter( i ) ) ) return t + 1;
        for ( let o = s.isUpperAsciiLetter( i ), r = t; r < e.length; ++r ) {
          if ( 32 === ( i = e.charCodeAt( r ) ) || 9 === i || !o && s.isUpperAsciiLetter( i ) ) return r + 1;
          if ( o && s.isLowerAsciiLetter( i ) ) return r;
          if ( o = o && s.isUpperAsciiLetter( i ), 95 === i ) return r + 2
        }
        return e.length + 1
      }
      var h = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return u( t, e ), t.deleteWordPartLeft = ( e, t, n, i, r ) => {
          if ( !n.isEmpty() ) return n;
          const s = new o.a( n.positionLineNumber, n.positionColumn ),
            u = s.lineNumber,
            d = s.column;
          if ( 1 === u && 1 === d ) return null;
          if ( i ) {
            const h = l._deleteWordLeftWhitespace( t, s );
            if ( h ) return h
          }
          const p = l.deleteWordLeft( e, t, n, i, r ),
            f = c( t.getLineContent( s.lineNumber ), s.column - 2 ),
            g = new a.a( u, d, u, f + 2 );
          return g.getStartPosition().isBeforeOrEqual( p.getStartPosition() ) ? p : g
        }, t.deleteWordPartRight = ( e, t, n, i, r ) => {
          if ( !n.isEmpty() ) return n;
          const s = new o.a( n.positionLineNumber, n.positionColumn ),
            u = s.lineNumber,
            c = s.column,
            h = t.getLineCount(),
            p = t.getLineMaxColumn( u );
          if ( u === h && c === p ) return null;
          if ( i ) {
            const f = l._deleteWordRightWhitespace( t, s );
            if ( f ) return f
          }
          const g = l.deleteWordRight( e, t, n, i, r ),
            m = d( t.getLineContent( s.lineNumber ), s.column ),
            _ = new a.a( u, c, u, m );
          return g.getEndPosition().isBeforeOrEqual( _.getEndPosition() ) ? g : _
        }, t.moveWordPartLeft = ( e, t, n, i ) => {
          const r = n.lineNumber,
            s = n.column;
          if ( 1 === s ) return r > 1 ? new o.a( r - 1, t.getLineMaxColumn( r - 1 ) ) : n;
          const a = l.moveWordLeft( e, t, n, i ),
            u = c( t.getLineContent( r ), s - 2 ),
            d = new o.a( r, u + 2 );
          return d.isBeforeOrEqual( a ) ? a : d
        }, t.moveWordPartRight = ( e, t, n, i ) => {
          const r = n.lineNumber,
            s = n.column;
          if ( s === t.getLineMaxColumn( r ) ) return r < t.getLineCount() ? new o.a( r + 1, 1 ) : n;
          const a = l.moveWordRight( e, t, n, i ),
            u = d( t.getLineContent( r ), s ),
            c = new o.a( r, u );
          return a.isBeforeOrEqual( c ) ? a : c
        }, t;
      } )( l )
    },
    "1YUG": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "cGHE" ),
        r = n( "aokT" ),
        s = n( "iuje" ),
        a = n( "Ll0s" ),
        u = n( "uzpd" ),
        l = n( "oAeH" ),
        c = n( "sswD" ),
        d = ( () => {
          function e() {}
          return e._columnSelect = ( e, t, n, i, s, u ) => {
            for ( var l = Math.abs( s - n ) + 1, c = n > s, d = i > u, h = i < u, p = [], f = 0; f < l; f++ ) {
              const g = n + ( c ? -f : f ),
                m = a.a.columnFromVisibleColumn2( e, t, g, i ),
                _ = a.a.columnFromVisibleColumn2( e, t, g, u ),
                v = a.a.visibleColumnFromColumn2( e, t, new o.a( g, m ) ),
                y = a.a.visibleColumnFromColumn2( e, t, new o.a( g, _ ) );
              if ( h ) {
                if ( v > u ) continue;
                if ( y < i ) continue
              }
              if ( d ) {
                if ( y > i ) continue;
                if ( v < u ) continue
              }
              p.push( new a.f( new r.a( g, m, g, m ), 0, new o.a( g, _ ), 0 ) )
            }
            return {
              viewStates: p,
              reversed: c,
              toLineNumber: s,
              toVisualColumn: u
            }
          }, e.columnSelect = ( t, n, i, r, s ) => {
            const u = new o.a( i.selectionStartLineNumber, i.selectionStartColumn ),
              l = a.a.visibleColumnFromColumn2( t, n, u );
            return e._columnSelect( t, n, u.lineNumber, l, r, s )
          }, e.columnSelectLeft = function ( e, t, n, i, o ) {
            return o > 1 && o--, this.columnSelect( e, t, n.selection, i, o )
          }, e.columnSelectRight = function ( e, t, n, i, r ) {
            for ( var s = 0, u = Math.min( n.position.lineNumber, i ), l = Math.max( n.position.lineNumber, i ), c = u; c <= l; c++ ) {
              const d = t.getLineMaxColumn( c ),
                h = a.a.visibleColumnFromColumn2( e, t, new o.a( c, d ) );
              s = Math.max( s, h )
            }
            return r < s && r++, this.columnSelect( e, t, n.selection, i, r )
          }, e.columnSelectUp = function ( e, t, n, i, o, r ) {
            return ( o -= i ? e.pageSize : 1 ) < 1 && ( o = 1 ), this.columnSelect( e, t, n.selection, o, r )
          }, e.columnSelectDown = function ( e, t, n, i, o, r ) {
            return ( o += i ? e.pageSize : 1 ) > t.getLineCount() && ( o = t.getLineCount() ), this.columnSelect( e, t, n.selection, o, r )
          }, e;
        } )(),
        h = n( "wQH0" ),
        p = n( "Vxe3" ),
        f = n( "T8No" ),
        g = n( "746U" ),
        m = n( "GR/f" ),
        _ = n( "snIX" ),
        v = n( "fjLI" );
      n.d( t, "CoreEditorCommand", ( () => {
        return k
      } ) ), n.d( t, "EditorScroll_", ( () => {
        return y
      } ) ), n.d( t, "RevealLine_", ( () => {
        return C
      } ) ), n.d( t, "CoreNavigationCommands", ( () => {
        return S
      } ) ), n.d( t, "CoreEditingCommands", ( () => {
        return O
      } ) );
      var y;
      let b;
      var C;
      let w;
      var S;
      var O;
      let L;
      const x = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const N = s.b;
      const E = 0;
      var k = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return x( t, e ), t.prototype.runEditorCommand = function ( e, t, n ) {
          const i = t._getCursors();
          i && this.runCoreEditorCommand( i, n || {} )
        }, t;
      } )( c.c );

      function I( e ) {
        return e.get( p.a ).getFocusedCodeEditor()
      }

      function D( e ) {
        e.register()
      }( b = y || ( y = {} ) ).description = {
        description: "Scroll editor in the given direction",
        args: [ {
          name: "Editor scroll argument object",
          description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory direction value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'up', 'down'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'line', 'wrappedLine', 'page', 'halfPage'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n\t\t\t\t",
          constraint( e ) {
            if ( !g.g( e ) ) return !1;
            const t = e;
            return !!g.h( t.to ) && !( !g.i( t.by ) && !g.h( t.by ) ) && !( !g.i( t.value ) && !g.f( t.value ) ) && !( !g.i( t.revealCursor ) && !g.c( t.revealCursor ) )
          }
        } ]
      }, b.RawDirection = {
        Up: "up",
        Down: "down"
      }, b.RawUnit = {
        Line: "line",
        WrappedLine: "wrappedLine",
        Page: "page",
        HalfPage: "halfPage"
      }, b.parse = e => {
        let t, n;
        switch ( e.to ) {
          case b.RawDirection.Up:
            t = 1;
            break;
          case b.RawDirection.Down:
            t = 2;
            break;
          default:
            return null
        }
        switch ( e.by ) {
          case b.RawUnit.Line:
            n = 1;
            break;
          case b.RawUnit.WrappedLine:
            n = 2;
            break;
          case b.RawUnit.Page:
            n = 3;
            break;
          case b.RawUnit.HalfPage:
            n = 4;
            break;
          default:
            n = 2
        }
        return {
          direction: t,
          unit: n,
          value: Math.floor( e.value || 1 ),
          revealCursor: !!e.revealCursor,
          select: !!e.select
        }
      }, ( w = C || ( C = {} ) ).description = {
        description: "Reveal the given line at the given logical position",
        args: [ {
          name: "Reveal line argument object",
          description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'lineNumber': A mandatory line number value.\n\t\t\t\t\t* 'at': Logical position at which line has to be revealed .\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'top', 'center', 'bottom'\n\t\t\t\t\t\t```\n\t\t\t\t",
          constraint( e ) {
            if ( !g.g( e ) ) return !1;
            const t = e;
            return !!g.f( t.lineNumber ) && !( !g.i( t.at ) && !g.h( t.at ) )
          }
        } ]
      }, w.RawAtArgument = {
        Top: "top",
        Center: "center",
        Bottom: "bottom"
      }, ( e => {
        const t = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._inSelectionMode = t.inSelectionMode, n
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, [ l.b.moveTo( e.context, e.getPrimaryCursor(), this._inSelectionMode, t.position, t.viewPosition ) ] ), e.reveal( !0, 0, 0 )
          }, t
        } )( k );
        e.MoveTo = Object( c.g )( new t( {
          id: "_moveTo",
          inSelectionMode: !1,
          precondition: null
        } ) ), e.MoveToSelect = Object( c.g )( new t( {
          id: "_moveToSelect",
          inSelectionMode: !0,
          precondition: null
        } ) );
        const n = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement();
            const n = this._getColumnSelectResult( e.context, e.getPrimaryCursor(), e.getColumnSelectData(), t );
            e.setStates( t.source, u.a.Explicit, n.viewStates.map( ( e => {
              return a.d.fromViewState( e )
            } ) ) ), e.setColumnSelectData( {
              toViewLineNumber: n.toLineNumber,
              toViewVisualColumn: n.toVisualColumn
            } ), e.reveal( !0, n.reversed ? 1 : 2, 0 )
          }, t;
        } )( k );
        e.ColumnSelect = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "columnSelect",
              precondition: null
            } ) || this
          }
          return x( t, e ), t.prototype._getColumnSelectResult = ( e, t, n, i ) => {
            let r;
            const s = e.model.validatePosition( i.position );
            return r = i.viewPosition ? e.validateViewPosition( new o.a( i.viewPosition.lineNumber, i.viewPosition.column ), s ) : e.convertModelPositionToViewPosition( s ), d.columnSelect( e.config, e.viewModel, t.viewState.selection, r.lineNumber, i.mouseColumn - 1 )
          }, t;
        } )( n ) )() ), e.CursorColumnSelectLeft = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "cursorColumnSelectLeft",
              precondition: null,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 3599,
                linux: {
                  primary: 0
                }
              }
            } ) || this
          }
          return x( t, e ), t.prototype._getColumnSelectResult = ( e, t, n, i ) => {
            return d.columnSelectLeft( e.config, e.viewModel, t.viewState, n.toViewLineNumber, n.toViewVisualColumn )
          }, t;
        } )( n ) )() ), e.CursorColumnSelectRight = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "cursorColumnSelectRight",
              precondition: null,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 3601,
                linux: {
                  primary: 0
                }
              }
            } ) || this
          }
          return x( t, e ), t.prototype._getColumnSelectResult = ( e, t, n, i ) => {
            return d.columnSelectRight( e.config, e.viewModel, t.viewState, n.toViewLineNumber, n.toViewVisualColumn )
          }, t;
        } )( n ) )() );
        const i = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._isPaged = t.isPaged, n
          }
          return x( t, e ), t.prototype._getColumnSelectResult = function ( e, t, n, i ) {
            return d.columnSelectUp( e.config, e.viewModel, t.viewState, this._isPaged, n.toViewLineNumber, n.toViewVisualColumn )
          }, t
        } )( n );
        e.CursorColumnSelectUp = Object( c.g )( new i( {
          isPaged: !1,
          id: "cursorColumnSelectUp",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 3600,
            linux: {
              primary: 0
            }
          }
        } ) ), e.CursorColumnSelectPageUp = Object( c.g )( new i( {
          isPaged: !0,
          id: "cursorColumnSelectPageUp",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 3595,
            linux: {
              primary: 0
            }
          }
        } ) );
        const s = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._isPaged = t.isPaged, n
          }
          return x( t, e ), t.prototype._getColumnSelectResult = function ( e, t, n, i ) {
            return d.columnSelectDown( e.config, e.viewModel, t.viewState, this._isPaged, n.toViewLineNumber, n.toViewVisualColumn )
          }, t
        } )( n );
        e.CursorColumnSelectDown = Object( c.g )( new s( {
          isPaged: !1,
          id: "cursorColumnSelectDown",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 3602,
            linux: {
              primary: 0
            }
          }
        } ) ), e.CursorColumnSelectPageDown = Object( c.g )( new s( {
          isPaged: !0,
          id: "cursorColumnSelectPageDown",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 3596,
            linux: {
              primary: 0
            }
          }
        } ) );
        const p = ( e => {
          function t() {
            return e.call( this, {
              id: "cursorMove",
              precondition: null,
              description: l.a.description
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            const n = l.a.parse( t );
            n && this._runCursorMove( e, t.source, n )
          }, t.prototype._runCursorMove = ( e, t, n ) => {
            e.context.model.pushStackElement(), e.setStates( t, u.a.Explicit, l.b.move( e.context, e.getAll(), n ) ), e.reveal( !0, 0, 0 )
          }, t;
        } )( k );
        e.CursorMoveImpl = p, e.CursorMove = Object( c.g )( new p );
        const f = ( t => {
          function n( e ) {
            const n = t.call( this, e ) || this;
            return n._staticArgs = e.args, n
          }
          return x( n, t ), n.prototype.runCoreEditorCommand = function ( t, n ) {
            let i = this._staticArgs; - 1 === this._staticArgs.value && ( i = {
              direction: this._staticArgs.direction,
              unit: this._staticArgs.unit,
              select: this._staticArgs.select,
              value: t.context.config.pageSize
            } ), e.CursorMove._runCursorMove( t, n.source, i )
          }, n;
        } )( k );
        e.CursorLeft = Object( c.g )( new f( {
          args: {
            direction: 0,
            unit: 0,
            select: !1,
            value: 1
          },
          id: "cursorLeft",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 15,
            mac: {
              primary: 15,
              secondary: [ 288 ]
            }
          }
        } ) ), e.CursorLeftSelect = Object( c.g )( new f( {
          args: {
            direction: 0,
            unit: 0,
            select: !0,
            value: 1
          },
          id: "cursorLeftSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 1039
          }
        } ) ), e.CursorRight = Object( c.g )( new f( {
          args: {
            direction: 1,
            unit: 0,
            select: !1,
            value: 1
          },
          id: "cursorRight",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 17,
            mac: {
              primary: 17,
              secondary: [ 292 ]
            }
          }
        } ) ), e.CursorRightSelect = Object( c.g )( new f( {
          args: {
            direction: 1,
            unit: 0,
            select: !0,
            value: 1
          },
          id: "cursorRightSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 1041
          }
        } ) ), e.CursorUp = Object( c.g )( new f( {
          args: {
            direction: 2,
            unit: 2,
            select: !1,
            value: 1
          },
          id: "cursorUp",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 16,
            mac: {
              primary: 16,
              secondary: [ 302 ]
            }
          }
        } ) ), e.CursorUpSelect = Object( c.g )( new f( {
          args: {
            direction: 2,
            unit: 2,
            select: !0,
            value: 1
          },
          id: "cursorUpSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 1040,
            secondary: [ 3088 ],
            mac: {
              primary: 1040
            },
            linux: {
              primary: 1040
            }
          }
        } ) ), e.CursorPageUp = Object( c.g )( new f( {
          args: {
            direction: 2,
            unit: 2,
            select: !1,
            value: -1
          },
          id: "cursorPageUp",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 11
          }
        } ) ), e.CursorPageUpSelect = Object( c.g )( new f( {
          args: {
            direction: 2,
            unit: 2,
            select: !0,
            value: -1
          },
          id: "cursorPageUpSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 1035
          }
        } ) ), e.CursorDown = Object( c.g )( new f( {
          args: {
            direction: 3,
            unit: 2,
            select: !1,
            value: 1
          },
          id: "cursorDown",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 18,
            mac: {
              primary: 18,
              secondary: [ 300 ]
            }
          }
        } ) ), e.CursorDownSelect = Object( c.g )( new f( {
          args: {
            direction: 3,
            unit: 2,
            select: !0,
            value: 1
          },
          id: "cursorDownSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 1042,
            secondary: [ 3090 ],
            mac: {
              primary: 1042
            },
            linux: {
              primary: 1042
            }
          }
        } ) ), e.CursorPageDown = Object( c.g )( new f( {
          args: {
            direction: 3,
            unit: 2,
            select: !1,
            value: -1
          },
          id: "cursorPageDown",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 12
          }
        } ) ), e.CursorPageDownSelect = Object( c.g )( new f( {
          args: {
            direction: 3,
            unit: 2,
            select: !0,
            value: -1
          },
          id: "cursorPageDownSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 1036
          }
        } ) ), e.CreateCursor = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "createCursor",
              precondition: null
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = ( e, t ) => {
            let n;
            const i = e.context;
            n = t.wholeLine ? l.b.line( i, e.getPrimaryCursor(), !1, t.position, t.viewPosition ) : l.b.moveTo( i, e.getPrimaryCursor(), !1, t.position, t.viewPosition );
            const o = e.getAll();
            if ( o.length > 1 )
              for ( let r = n.modelState ? n.modelState.position : null, s = n.viewState ? n.viewState.position : null, a = 0, c = o.length; a < c; a++ ) {
                const d = o[ a ];
                if ( ( !r || d.modelState.selection.containsPosition( r ) ) && ( !s || d.viewState.selection.containsPosition( s ) ) ) return o.splice( a, 1 ), e.context.model.pushStackElement(), void e.setStates( t.source, u.a.Explicit, o )
              }
            o.push( n ), e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, o )
          }, t;
        } )( k ) )() ), e.LastCursorMoveToSelect = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "_lastCursorMoveToSelect",
              precondition: null
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = ( e, t ) => {
            const n = e.context,
              i = e.getLastAddedCursorIndex(),
              o = e.getAll().slice( 0 );
            o[ i ] = l.b.moveTo( n, o[ i ], !0, t.position, t.viewPosition ), e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, o )
          }, t;
        } )( k ) )() );
        const g = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._inSelectionMode = t.inSelectionMode, n
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, l.b.moveToBeginningOfLine( e.context, e.getAll(), this._inSelectionMode ) ), e.reveal( !0, 0, 0 )
          }, t
        } )( k );
        e.CursorHome = Object( c.g )( new g( {
          inSelectionMode: !1,
          id: "cursorHome",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 14,
            mac: {
              primary: 14,
              secondary: [ 2063 ]
            }
          }
        } ) ), e.CursorHomeSelect = Object( c.g )( new g( {
          inSelectionMode: !0,
          id: "cursorHomeSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 1038,
            mac: {
              primary: 1038,
              secondary: [ 3087 ]
            }
          }
        } ) ), e.CursorLineStart = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "cursorLineStart",
              precondition: null,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 0,
                mac: {
                  primary: 287
                }
              }
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, this._exec( e.context, e.getAll() ) ), e.reveal( !0, 0, 0 )
          }, t.prototype._exec = ( e, t ) => {
            for ( var n = [], i = 0, o = t.length; i < o; i++ ) {
              const r = t[ i ],
                s = r.modelState.position.lineNumber;
              n[ i ] = a.d.fromModelState( r.modelState.move( !1, s, 1, 0 ) )
            }
            return n
          }, t;
        } )( k ) )() );
        const m = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._inSelectionMode = t.inSelectionMode, n
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, l.b.moveToEndOfLine( e.context, e.getAll(), this._inSelectionMode ) ), e.reveal( !0, 0, 0 )
          }, t
        } )( k );
        e.CursorEnd = Object( c.g )( new m( {
          inSelectionMode: !1,
          id: "cursorEnd",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 13,
            mac: {
              primary: 13,
              secondary: [ 2065 ]
            }
          }
        } ) ), e.CursorEndSelect = Object( c.g )( new m( {
          inSelectionMode: !0,
          id: "cursorEndSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 1037,
            mac: {
              primary: 1037,
              secondary: [ 3089 ]
            }
          }
        } ) ), e.CursorLineEnd = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "cursorLineEnd",
              precondition: null,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 0,
                mac: {
                  primary: 291
                }
              }
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, this._exec( e.context, e.getAll() ) ), e.reveal( !0, 0, 0 )
          }, t.prototype._exec = ( e, t ) => {
            for ( var n = [], i = 0, o = t.length; i < o; i++ ) {
              const r = t[ i ],
                s = r.modelState.position.lineNumber,
                u = e.model.getLineMaxColumn( s );
              n[ i ] = a.d.fromModelState( r.modelState.move( !1, s, u, 0 ) )
            }
            return n
          }, t;
        } )( k ) )() );
        const _ = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._inSelectionMode = t.inSelectionMode, n
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, l.b.moveToBeginningOfBuffer( e.context, e.getAll(), this._inSelectionMode ) ), e.reveal( !0, 0, 0 )
          }, t
        } )( k );
        e.CursorTop = Object( c.g )( new _( {
          inSelectionMode: !1,
          id: "cursorTop",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 2062,
            mac: {
              primary: 2064
            }
          }
        } ) ), e.CursorTopSelect = Object( c.g )( new _( {
          inSelectionMode: !0,
          id: "cursorTopSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 3086,
            mac: {
              primary: 3088
            }
          }
        } ) );
        const v = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._inSelectionMode = t.inSelectionMode, n
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, l.b.moveToEndOfBuffer( e.context, e.getAll(), this._inSelectionMode ) ), e.reveal( !0, 0, 0 )
          }, t
        } )( k );
        e.CursorBottom = Object( c.g )( new v( {
          inSelectionMode: !1,
          id: "cursorBottom",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 2061,
            mac: {
              primary: 2066
            }
          }
        } ) ), e.CursorBottomSelect = Object( c.g )( new v( {
          inSelectionMode: !0,
          id: "cursorBottomSelect",
          precondition: null,
          kbOpts: {
            weight: E,
            kbExpr: h.a.textInputFocus,
            primary: 3085,
            mac: {
              primary: 3090
            }
          }
        } ) );
        const b = ( e => {
          function t() {
            return e.call( this, {
              id: "editorScroll",
              precondition: null,
              description: y.description
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            const n = y.parse( t );
            n && this._runEditorScroll( e, t.source, n )
          }, t.prototype._runEditorScroll = function ( e, t, n ) {
            const i = this._computeDesiredScrollTop( e.context, n );
            if ( n.revealCursor ) {
              const o = e.context.getCompletelyVisibleViewRangeAtScrollTop( i );
              e.setStates( t, u.a.Explicit, [ l.b.findPositionInViewportIfOutside( e.context, e.getPrimaryCursor(), o, n.select ) ] )
            }
            e.scrollTo( i )
          }, t.prototype._computeDesiredScrollTop = ( e, t ) => {
            if ( 1 === t.unit ) {
              const n = e.getCompletelyVisibleModelRange();
              let i = void 0;
              i = 1 === t.direction ? Math.max( 1, n.startLineNumber - t.value ) : Math.min( e.model.getLineCount(), n.startLineNumber + t.value );
              const r = e.convertModelPositionToViewPosition( new o.a( i, 1 ) );
              return e.getVerticalOffsetForViewLine( r.lineNumber )
            }
            let s;
            s = 3 === t.unit ? e.config.pageSize * t.value : 4 === t.unit ? Math.round( e.config.pageSize / 2 ) * t.value : t.value;
            const a = ( 1 === t.direction ? -1 : 1 ) * s;
            return e.getCurrentScrollTop() + a * e.config.lineHeight
          }, t;
        } )( k );
        e.EditorScrollImpl = b, e.EditorScroll = Object( c.g )( new b ), e.ScrollLineUp = Object( c.g )( new( ( t => {
          function n() {
            return t.call( this, {
              id: "scrollLineUp",
              precondition: null,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 2064,
                mac: {
                  primary: 267
                }
              }
            } ) || this
          }
          return x( n, t ), n.prototype.runCoreEditorCommand = ( t, n ) => {
            e.EditorScroll._runEditorScroll( t, n.source, {
              direction: 1,
              unit: 2,
              value: 1,
              revealCursor: !1,
              select: !1
            } )
          }, n;
        } )( k ) )() ), e.ScrollPageUp = Object( c.g )( new( ( t => {
          function n() {
            return t.call( this, {
              id: "scrollPageUp",
              precondition: null,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 2059,
                win: {
                  primary: 523
                },
                linux: {
                  primary: 523
                }
              }
            } ) || this
          }
          return x( n, t ), n.prototype.runCoreEditorCommand = ( t, n ) => {
            e.EditorScroll._runEditorScroll( t, n.source, {
              direction: 1,
              unit: 3,
              value: 1,
              revealCursor: !1,
              select: !1
            } )
          }, n;
        } )( k ) )() ), e.ScrollLineDown = Object( c.g )( new( ( t => {
          function n() {
            return t.call( this, {
              id: "scrollLineDown",
              precondition: null,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 2066,
                mac: {
                  primary: 268
                }
              }
            } ) || this
          }
          return x( n, t ), n.prototype.runCoreEditorCommand = ( t, n ) => {
            e.EditorScroll._runEditorScroll( t, n.source, {
              direction: 2,
              unit: 2,
              value: 1,
              revealCursor: !1,
              select: !1
            } )
          }, n;
        } )( k ) )() ), e.ScrollPageDown = Object( c.g )( new( ( t => {
          function n() {
            return t.call( this, {
              id: "scrollPageDown",
              precondition: null,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 2060,
                win: {
                  primary: 524
                },
                linux: {
                  primary: 524
                }
              }
            } ) || this
          }
          return x( n, t ), n.prototype.runCoreEditorCommand = ( t, n ) => {
            e.EditorScroll._runEditorScroll( t, n.source, {
              direction: 2,
              unit: 3,
              value: 1,
              revealCursor: !1,
              select: !1
            } )
          }, n;
        } )( k ) )() );
        const w = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._inSelectionMode = t.inSelectionMode, n
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, [ l.b.word( e.context, e.getPrimaryCursor(), this._inSelectionMode, t.position ) ] ), e.reveal( !0, 0, 0 )
          }, t
        } )( k );
        e.WordSelect = Object( c.g )( new w( {
          inSelectionMode: !1,
          id: "_wordSelect",
          precondition: null
        } ) ), e.WordSelectDrag = Object( c.g )( new w( {
          inSelectionMode: !0,
          id: "_wordSelectDrag",
          precondition: null
        } ) ), e.LastCursorWordSelect = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "lastCursorWordSelect",
              precondition: null
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = ( e, t ) => {
            const n = e.context,
              i = e.getLastAddedCursorIndex(),
              o = e.getAll().slice( 0 ),
              r = o[ i ];
            o[ i ] = l.b.word( n, r, r.modelState.hasSelection(), t.position ), n.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, o )
          }, t;
        } )( k ) )() );
        const S = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._inSelectionMode = t.inSelectionMode, n
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, [ l.b.line( e.context, e.getPrimaryCursor(), this._inSelectionMode, t.position, t.viewPosition ) ] ), e.reveal( !1, 0, 0 )
          }, t
        } )( k );
        e.LineSelect = Object( c.g )( new S( {
          inSelectionMode: !1,
          id: "_lineSelect",
          precondition: null
        } ) ), e.LineSelectDrag = Object( c.g )( new S( {
          inSelectionMode: !0,
          id: "_lineSelectDrag",
          precondition: null
        } ) );
        const O = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._inSelectionMode = t.inSelectionMode, n
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = function ( e, t ) {
            const n = e.getLastAddedCursorIndex(),
              i = e.getAll().slice( 0 );
            i[ n ] = l.b.line( e.context, i[ n ], this._inSelectionMode, t.position, t.viewPosition ), e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, i )
          }, t;
        } )( k );
        e.LastCursorLineSelect = Object( c.g )( new O( {
          inSelectionMode: !1,
          id: "lastCursorLineSelect",
          precondition: null
        } ) ), e.LastCursorLineSelectDrag = Object( c.g )( new O( {
          inSelectionMode: !0,
          id: "lastCursorLineSelectDrag",
          precondition: null
        } ) ), e.ExpandLineSelection = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "expandLineSelection",
              precondition: null,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 2087
              }
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = ( e, t ) => {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, l.b.expandLineSelection( e.context, e.getAll() ) ), e.reveal( !0, 0, 0 )
          }, t;
        } )( k ) )() ), e.CancelSelection = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "cancelSelection",
              precondition: h.a.hasNonEmptySelection,
              kbOpts: {
                weight: E,
                kbExpr: h.a.textInputFocus,
                primary: 9,
                secondary: [ 1033 ]
              }
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = ( e, t ) => {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, [ l.b.cancelSelection( e.context, e.getPrimaryCursor() ) ] ), e.reveal( !0, 0, 0 )
          }, t;
        } )( k ) )() ), e.RemoveSecondaryCursors = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "removeSecondaryCursors",
              precondition: h.a.hasMultipleSelections,
              kbOpts: {
                weight: E + 1,
                kbExpr: h.a.textInputFocus,
                primary: 9,
                secondary: [ 1033 ]
              }
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = ( e, t ) => {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, [ e.getPrimaryCursor() ] ), e.reveal( !0, 0, 0 )
          }, t;
        } )( k ) )() ), e.RevealLine = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "revealLine",
              precondition: null,
              description: C.description
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = ( e, t ) => {
            const n = t;
            let i = n.lineNumber + 1;
            i < 1 && ( i = 1 );
            const o = e.context.model.getLineCount();
            i > o && ( i = o );
            const s = new r.a( i, 1, i, e.context.model.getLineMaxColumn( i ) );
            let a = 0;
            if ( n.at ) switch ( n.at ) {
              case C.RawAtArgument.Top:
                a = 3;
                break;
              case C.RawAtArgument.Center:
                a = 1;
                break;
              case C.RawAtArgument.Bottom:
                a = 4
            }
            const u = e.context.convertModelRangeToViewRange( s );
            e.revealRange( !1, u, a, 0 )
          }, t;
        } )( k ) )() ), e.SelectAll = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "selectAll",
              precondition: null
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = ( e, t ) => {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, [ l.b.selectAll( e.context, e.getPrimaryCursor() ) ] )
          }, t;
        } )( k ) )() ), e.SetSelection = Object( c.g )( new( ( e => {
          function t() {
            return e.call( this, {
              id: "setSelection",
              precondition: null
            } ) || this
          }
          return x( t, e ), t.prototype.runCoreEditorCommand = ( e, t ) => {
            e.context.model.pushStackElement(), e.setStates( t.source, u.a.Explicit, [ a.d.fromModelSelection( t.selection ) ] )
          }, t;
        } )( k ) )() )
      } )( S || ( S = {} ) ), ( L = O || ( O = {} ) ).LineBreakInsert = Object( c.g )( new( ( e => {
        function t() {
          return e.call( this, {
            id: "lineBreakInsert",
            precondition: h.a.writable,
            kbOpts: {
              weight: E,
              kbExpr: h.a.textInputFocus,
              primary: null,
              mac: {
                primary: 301
              }
            }
          } ) || this
        }
        return x( t, e ), t.prototype.runEditorCommand = function ( e, t, n ) {
          t.pushUndoStop(), t.executeCommands( this.id, m.TypeOperations.lineBreakInsert( t._getCursorConfiguration(), t.getModel(), t.getSelections() ) )
        }, t
      } )( c.c ) )() ), L.Outdent = Object( c.g )( new( ( e => {
        function t() {
          return e.call( this, {
            id: "outdent",
            precondition: h.a.writable,
            kbOpts: {
              weight: E,
              kbExpr: f.d.and( h.a.editorTextFocus, h.a.tabDoesNotMoveFocus ),
              primary: 1026
            }
          } ) || this
        }
        return x( t, e ), t.prototype.runEditorCommand = function ( e, t, n ) {
          t.pushUndoStop(), t.executeCommands( this.id, m.TypeOperations.outdent( t._getCursorConfiguration(), t.getModel(), t.getSelections() ) ), t.pushUndoStop()
        }, t
      } )( c.c ) )() ), L.Tab = Object( c.g )( new( ( e => {
        function t() {
          return e.call( this, {
            id: "tab",
            precondition: h.a.writable,
            kbOpts: {
              weight: E,
              kbExpr: f.d.and( h.a.editorTextFocus, h.a.tabDoesNotMoveFocus ),
              primary: 2
            }
          } ) || this
        }
        return x( t, e ), t.prototype.runEditorCommand = function ( e, t, n ) {
          t.pushUndoStop(), t.executeCommands( this.id, m.TypeOperations.tab( t._getCursorConfiguration(), t.getModel(), t.getSelections() ) ), t.pushUndoStop()
        }, t
      } )( c.c ) )() ), L.DeleteLeft = Object( c.g )( new( ( e => {
        function t() {
          return e.call( this, {
            id: "deleteLeft",
            precondition: h.a.writable,
            kbOpts: {
              weight: E,
              kbExpr: h.a.textInputFocus,
              primary: 1,
              secondary: [ 1025 ],
              mac: {
                primary: 1,
                secondary: [ 1025, 294, 257 ]
              }
            }
          } ) || this
        }
        return x( t, e ), t.prototype.runEditorCommand = function ( e, t, n ) {
          const i = t._getCursors(),
            o = _.a.deleteLeft( i.getPrevEditOperationType(), t._getCursorConfiguration(), t.getModel(), t.getSelections() ),
            r = o[ 0 ],
            s = o[ 1 ];
          r && t.pushUndoStop(), t.executeCommands( this.id, s ), i.setPrevEditOperationType( 2 )
        }, t;
      } )( c.c ) )() ), L.DeleteRight = Object( c.g )( new( ( e => {
        function t() {
          return e.call( this, {
            id: "deleteRight",
            precondition: h.a.writable,
            kbOpts: {
              weight: E,
              kbExpr: h.a.textInputFocus,
              primary: 20,
              mac: {
                primary: 20,
                secondary: [ 290, 276 ]
              }
            }
          } ) || this
        }
        return x( t, e ), t.prototype.runEditorCommand = function ( e, t, n ) {
          const i = t._getCursors(),
            o = _.a.deleteRight( i.getPrevEditOperationType(), t._getCursorConfiguration(), t.getModel(), t.getSelections() ),
            r = o[ 0 ],
            s = o[ 1 ];
          r && t.pushUndoStop(), t.executeCommands( this.id, s ), i.setPrevEditOperationType( 3 )
        }, t;
      } )( c.c ) )() );
      const M = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._editorHandler = t.editorHandler, n._inputHandler = t.inputHandler, n
          }
          return x( t, e ), t.prototype.runCommand = function ( e, t ) {
            const n = I( e );
            if ( n && n.hasTextFocus() ) return this._runEditorHandler( n, t );
            const i = document.activeElement;
            if ( !( i && [ "input", "textarea" ].indexOf( i.tagName.toLowerCase() ) >= 0 ) ) {
              const o = e.get( p.a ).getActiveCodeEditor();
              return o ? ( o.focus(), this._runEditorHandler( o, t ) ) : void 0
            }
            document.execCommand( this._inputHandler )
          }, t.prototype._runEditorHandler = function ( e, t ) {
            const n = this._editorHandler;
            "string" === typeof n ? e.trigger( "keyboard", n, t ) : ( ( t = t || {} ).source = "keyboard", n.runEditorCommand( null, e, t ) )
          }, t;
        } )( c.a ),
        T = ( e => {
          function t( t, n ) {
            const i = e.call( this, {
              id: t,
              precondition: null
            } ) || this;
            return i._handlerId = n, i
          }
          return x( t, e ), t.prototype.runCommand = function ( e, t ) {
            const n = I( e );
            n && n.trigger( "keyboard", this._handlerId, t )
          }, t;
        } )( c.a );

      function R( e ) {
        D( new T( "default:" + e, e ) ), D( new T( e, e ) )
      }
      D( new M( {
        editorHandler: S.SelectAll,
        inputHandler: "selectAll",
        id: "editor.action.selectAll",
        precondition: h.a.textInputFocus,
        kbOpts: {
          weight: E,
          kbExpr: null,
          primary: 2079
        },
        menubarOpts: {
          menuId: v.b.MenubarSelectionMenu,
          group: "1_basic",
          title: i.a( {
            key: "miSelectAll",
            comment: [ "&& denotes a mnemonic" ]
          }, "&&Select All" ),
          order: 1
        }
      } ) ), D( new M( {
        editorHandler: N.Undo,
        inputHandler: "undo",
        id: N.Undo,
        precondition: h.a.writable,
        kbOpts: {
          weight: E,
          kbExpr: h.a.textInputFocus,
          primary: 2104
        },
        menubarOpts: {
          menuId: v.b.MenubarEditMenu,
          group: "1_do",
          title: i.a( {
            key: "miUndo",
            comment: [ "&& denotes a mnemonic" ]
          }, "&&Undo" ),
          order: 1
        }
      } ) ), D( new T( "default:" + N.Undo, N.Undo ) ), D( new M( {
        editorHandler: N.Redo,
        inputHandler: "redo",
        id: N.Redo,
        precondition: h.a.writable,
        kbOpts: {
          weight: E,
          kbExpr: h.a.textInputFocus,
          primary: 2103,
          secondary: [ 3128 ],
          mac: {
            primary: 3128
          }
        },
        menubarOpts: {
          menuId: v.b.MenubarEditMenu,
          group: "1_do",
          title: i.a( {
            key: "miRedo",
            comment: [ "&& denotes a mnemonic" ]
          }, "&&Redo" ),
          order: 2
        }
      } ) ), D( new T( "default:" + N.Redo, N.Redo ) ), R( N.Type ), R( N.ReplacePreviousChar ), R( N.CompositionStart ), R( N.CompositionEnd ), R( N.Paste ), R( N.Cut )
    },
    "1lwE": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "aes",
        extensions: [ ".aes" ],
        aliases: [ "aes", "sophia", "Sophia" ],
        loader() {
          return o.Promise.wrap( n.e( 306 ).then( n.bind( null, "cOMg" ) ) )
        }
      } )
    },
    "23p7": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "apex",
        extensions: [ ".cls" ],
        aliases: [ "Apex", "apex" ],
        mimetypes: [ "text/x-apex-source", "text/x-apex" ],
        loader() {
          return o.Promise.wrap( n.e( 253 ).then( n.bind( null, "aA7r" ) ) )
        }
      } )
    },
    "24hK": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = function ( e ) {
        this.element = e
      };

      var o = ( () => {
        function e() {}
        return e.prototype.isEmpty = function () {
          return !this._first
        }, e.prototype.unshift = function ( e ) {
          return this.insert( e, !1 )
        }, e.prototype.push = function ( e ) {
          return this.insert( e, !0 )
        }, e.prototype.insert = function ( e, t ) {
          const n = this,
            o = new i( e );
          if ( this._first )
            if ( t ) {
              const r = this._last;
              this._last = o, o.prev = r, r.next = o
            } else {
              const s = this._first;
              this._first = o, o.next = s, s.prev = o
            }
          else this._first = o, this._last = o;
          return () => {
            for ( let e = n._first; e instanceof i; e = e.next )
              if ( e === o ) {
                if ( e.prev && e.next ) {
                  const t = e.prev;
                  t.next = e.next, e.next.prev = t
                } else e.prev || e.next ? e.next ? e.prev || ( n._first = n._first.next, n._first.prev = void 0 ) : ( n._last = n._last.prev, n._last.next = void 0 ) : ( n._first = void 0, n._last = void 0 );
                break
              }
          };
        }, e.prototype.iterator = function () {
          const e = {
            done: void 0,
            value: void 0
          };
          let t = this._first;
          return {
            next() {
              return t ? ( e.done = !1, e.value = t.element, t = t.next ) : ( e.done = !0, e.value = void 0 ), e
            }
          };
        }, e;
      } )();
    },
    "2ESN": function ( e, t, n ) {
      "use strict";
      n.r( t );
      n( "YHy6" );
      const i = n( "3/fG" ),
        o = n( "/cxE" ),
        r = n( "MNsG" ),
        s = n( "W9cx" ),
        a = n( "sswD" ),
        u = n( "twdY" ),
        l = n( "sFUC" ),
        c = n( "bY76" ),
        d = n( "VMIq" ),
        h = n( "aokT" ),
        p = n( "X+cX" ),
        f = n( "nnTU" ),
        g = n( "G2kB" ),
        m = n( "JQT/" ),
        _ = ( () => {
          function e( e, t ) {
            this._link = e, this._provider = t
          }
          return e.prototype.toJSON = function () {
            return {
              range: this.range,
              url: this.url
            }
          }, Object.defineProperty( e.prototype, "range", {
            get() {
              return this._link.range
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "url", {
            get() {
              return this._link.url
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.resolve = function () {
            const e = this;
            if ( this._link.url ) try {
              return d.b.as( c.a.parse( this._link.url ) )
            } catch ( t ) {
              return d.b.wrapError( new Error( "invalid" ) )
            }
            return "function" === typeof this._provider.resolveLink ? Object( p.h )( ( t => {
              return e._provider.resolveLink( e._link, t )
            } ) ).then( ( t => {
              return e._link = t || e._link, e._link.url ? e.resolve() : d.b.wrapError( new Error( "missing" ) )
            } ) ) : d.b.wrapError( new Error( "missing" ) );
          }, e;
        } )();

      function v( e, t ) {
        let n = [];

        const i = u.p.ordered( e ).reverse().map( ( i => {
          return Promise.resolve( i.provideLinks( e, t ) ).then( ( e => {
            if ( Array.isArray( e ) ) {
              const t = e.map( ( e => {
                return new _( e, i )
              } ) );
              n = ( ( e, t ) => {
                let n;
                let i;
                let o;
                let r;
                const s = [];
                for ( n = 0, o = 0, i = e.length, r = t.length; n < i && o < r; ) {
                  const a = e[ n ],
                    u = t[ o ];
                  if ( h.a.areIntersectingOrTouching( a.range, u.range ) ) n++;
                  else h.a.compareRangesUsingStarts( a.range, u.range ) < 0 ? ( s.push( a ), n++ ) : ( s.push( u ), o++ )
                }
                for ( ; n < i; n++ ) s.push( e[ n ] );
                for ( ; o < r; o++ ) s.push( t[ o ] );
                return s
              } )( n, t )
            }
          } ), o.f );
        } ) );

        return Promise.all( i ).then( ( () => {
          return n
        } ) );
      }
      f.a.registerCommand( "_executeLinkProvider", ( function ( e ) {
        for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
        const i = t[ 0 ];
        if ( i instanceof c.a ) {
          const o = e.get( g.a ).getModel( i );
          if ( o ) return v( o, m.a.None )
        }
      } ) );
      const y = n( "pmY6" ),
        b = n( "t9D7" ),
        C = n( "MD5Z" ),
        w = n( "tX9W" ),
        S = n( "BBpZ" ),
        O = n( "eLzo" ),
        L = n( "M1Kb" ),
        x = n( "sM1p" ),
        N = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        E = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        k = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        I = ( e, t, n, i ) => {
          return new( n || ( n = Promise ) )( ( ( o, r ) => {
            function s( e ) {
              try {
                u( i.next( e ) )
              } catch ( t ) {
                r( t )
              }
            }

            function a( e ) {
              try {
                u( i.throw( e ) )
              } catch ( t ) {
                r( t )
              }
            }

            function u( e ) {
              e.done ? o( e.value ) : new n( ( t => {
                t( e.value )
              } ) ).then( s, a )
            }
            u( ( i = i.apply( e, t || [] ) ).next() )
          } ) );
        },
        D = ( e, t ) => {
          let n, i, o, r, s = {
            label: 0,
            sent() {
              if ( 1 & o[ 0 ] ) throw o[ 1 ];
              return o[ 1 ]
            },
            trys: [],
            ops: []
          };
          return r = {
            next: a( 0 ),
            throw: a( 1 ),
            return: a( 2 )
          }, "function" === typeof Symbol && ( r[ Symbol.iterator ] = function () {
            return this
          } ), r;

          function a( r ) {
            return a => {
              return ( r => {
                if ( n ) throw new TypeError( "Generator is already executing." );
                for ( ; s; ) try {
                  if ( n = 1, i && ( o = 2 & r[ 0 ] ? i.return : r[ 0 ] ? i.throw || ( ( o = i.return ) && o.call( i ), 0 ) : i.next ) && !( o = o.call( i, r[ 1 ] ) ).done ) return o;
                  switch ( i = 0, o && ( r = [ 2 & r[ 0 ], o.value ] ), r[ 0 ] ) {
                    case 0:
                    case 1:
                      o = r;
                      break;
                    case 4:
                      return s.label++, {
                        value: r[ 1 ],
                        done: !1
                      };
                    case 5:
                      s.label++, i = r[ 1 ], r = [ 0 ];
                      continue;
                    case 7:
                      r = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if ( !( o = ( o = s.trys ).length > 0 && o[ o.length - 1 ] ) && ( 6 === r[ 0 ] || 2 === r[ 0 ] ) ) {
                        s = 0;
                        continue
                      }
                      if ( 3 === r[ 0 ] && ( !o || r[ 1 ] > o[ 0 ] && r[ 1 ] < o[ 3 ] ) ) {
                        s.label = r[ 1 ];
                        break
                      }
                      if ( 6 === r[ 0 ] && s.label < o[ 1 ] ) {
                        s.label = o[ 1 ], o = r;
                        break
                      }
                      if ( o && s.label < o[ 2 ] ) {
                        s.label = o[ 2 ], s.ops.push( r );
                        break
                      }
                      o[ 2 ] && s.ops.pop(), s.trys.pop();
                      continue
                  }
                  r = t.call( e, s )
                } catch ( a ) {
                  r = [ 6, a ], i = 0
                } finally {
                  n = o = 0
                }
                if ( 5 & r[ 0 ] ) throw r[ 1 ];
                return {
                  value: r[ 0 ] ? r[ 1 ] : void 0,
                  done: !0
                }
              } )( [ r, a ] );
            };
          }
        },
        M = ( new O.a ).appendText( r.d ? i.a( "links.navigate.mac", "Cmd + click to follow link" ) : i.a( "links.navigate", "Ctrl + click to follow link" ) ),
        T = ( new O.a ).appendText( r.d ? i.a( "links.command.mac", "Cmd + click to execute command" ) : i.a( "links.command", "Ctrl + click to execute command" ) ),
        R = ( new O.a ).appendText( r.d ? i.a( "links.navigate.al.mac", "Option + click to follow link" ) : i.a( "links.navigate.al", "Alt + click to follow link" ) ),
        P = ( new O.a ).appendText( r.d ? i.a( "links.command.al.mac", "Option + click to execute command" ) : i.a( "links.command.al", "Alt + click to execute command" ) ),
        A = {
          meta: w.a.register( {
            stickiness: L.h.NeverGrowsWhenTypingAtEdges,
            inlineClassName: "detected-link",
            hoverMessage: M
          } ),
          metaActive: w.a.register( {
            stickiness: L.h.NeverGrowsWhenTypingAtEdges,
            inlineClassName: "detected-link-active",
            hoverMessage: M
          } ),
          alt: w.a.register( {
            stickiness: L.h.NeverGrowsWhenTypingAtEdges,
            inlineClassName: "detected-link",
            hoverMessage: R
          } ),
          altActive: w.a.register( {
            stickiness: L.h.NeverGrowsWhenTypingAtEdges,
            inlineClassName: "detected-link-active",
            hoverMessage: R
          } ),
          altCommand: w.a.register( {
            stickiness: L.h.NeverGrowsWhenTypingAtEdges,
            inlineClassName: "detected-link",
            hoverMessage: P
          } ),
          altCommandActive: w.a.register( {
            stickiness: L.h.NeverGrowsWhenTypingAtEdges,
            inlineClassName: "detected-link-active",
            hoverMessage: P
          } ),
          metaCommand: w.a.register( {
            stickiness: L.h.NeverGrowsWhenTypingAtEdges,
            inlineClassName: "detected-link",
            hoverMessage: T
          } ),
          metaCommandActive: w.a.register( {
            stickiness: L.h.NeverGrowsWhenTypingAtEdges,
            inlineClassName: "detected-link-active",
            hoverMessage: T
          } )
        },
        F = ( () => {
          function e( e, t ) {
            this.link = e, this.decorationId = t
          }
          return e.decoration = ( t, n ) => {
            return {
              range: t.range,
              options: e._getOptions( t, n, !1 )
            }
          }, e._getOptions = ( e, t, n ) => {
            return /^command:/i.test( e.url ) ? t ? n ? A.metaCommandActive : A.metaCommand : n ? A.altCommandActive : A.altCommand : t ? n ? A.metaActive : A.meta : n ? A.altActive : A.alt
          }, e.prototype.activate = function ( t, n ) {
            t.changeDecorationOptions( this.decorationId, e._getOptions( this.link, n, !0 ) )
          }, e.prototype.deactivate = function ( t, n ) {
            t.changeDecorationOptions( this.decorationId, e._getOptions( this.link, n, !1 ) )
          }, e;
        } )(),
        W = ( () => {
          function e( e, t, n ) {
            const i = this;
            this.editor = e, this.openerService = t, this.notificationService = n, this.listenersToRemove = [];
            const o = new S.a( e );
            this.listenersToRemove.push( o ), this.listenersToRemove.push( o.onMouseMoveOrRelevantKeyDown( ( e => {
              const t = e[ 0 ],
                n = e[ 1 ];
              i._onEditorMouseMove( t, n )
            } ) ) ), this.listenersToRemove.push( o.onExecute( ( e => {
              i.onEditorMouseUp( e )
            } ) ) ), this.listenersToRemove.push( o.onCancel( ( e => {
              i.cleanUpActiveLinkDecoration()
            } ) ) ), this.enabled = e.getConfiguration().contribInfo.links, this.listenersToRemove.push( e.onDidChangeConfiguration( ( t => {
              const n = e.getConfiguration().contribInfo.links;
              i.enabled !== n && ( i.enabled = n, i.updateDecorations( [] ), i.stop(), i.beginCompute() )
            } ) ) ), this.listenersToRemove.push( e.onDidChangeModelContent( ( e => {
              return i.onChange()
            } ) ) ), this.listenersToRemove.push( e.onDidChangeModel( ( e => {
              return i.onModelChanged()
            } ) ) ), this.listenersToRemove.push( e.onDidChangeModelLanguage( ( e => {
              return i.onModelModeChanged()
            } ) ) ), this.listenersToRemove.push( u.p.onDidChange( ( e => {
              return i.onModelModeChanged()
            } ) ) ), this.timeout = new p.f, this.computePromise = null, this.currentOccurrences = {}, this.activeLinkDecorationId = null, this.beginCompute()
          }
          return e.get = t => {
            return t.getContribution( e.ID )
          }, e.prototype.getId = () => {
            return e.ID
          }, e.prototype.onModelChanged = function () {
            this.currentOccurrences = {}, this.activeLinkDecorationId = null, this.stop(), this.beginCompute()
          }, e.prototype.onModelModeChanged = function () {
            this.stop(), this.beginCompute()
          }, e.prototype.onChange = function () {
            const t = this;
            this.timeout.setIfNotSet( ( () => {
              return t.beginCompute()
            } ), e.RECOMPUTE_TIME )
          }, e.prototype.beginCompute = function () {
            return I( this, void 0, void 0, ( function () {
              let e;
              let t;
              const n = this;
              return D( this, ( function ( i ) {
                switch ( i.label ) {
                  case 0:
                    if ( !this.editor.getModel() || !this.enabled ) return [ 2 ];
                    if ( !u.p.has( this.editor.getModel() ) ) return [ 2 ];
                    this.computePromise = p.i( ( e => {
                      return v( n.editor.getModel(), e )
                    } ) ), i.label = 1;
                  case 1:
                    return i.trys.push( [ 1, 3, 4, 5 ] ), [ 4, this.computePromise ];
                  case 2:
                    return e = i.sent(), this.updateDecorations( e ), [ 3, 5 ];
                  case 3:
                    return t = i.sent(), Object( o.e )( t ), [ 3, 5 ];
                  case 4:
                    return this.computePromise = null, [ 7 ];
                  case 5:
                    return [ 2 ]
                }
              } ) );
            } ) );
          }, e.prototype.updateDecorations = function ( e ) {
            for ( var t = "altKey" === this.editor.getConfiguration().multiCursorModifier, n = [], i = Object.keys( this.currentOccurrences ), o = 0, r = i.length; o < r; o++ ) {
              const s = i[ o ];
              var a = this.currentOccurrences[ s ];
              n.push( a.decorationId )
            }
            const u = [];
            if ( e )
              for ( o = 0; o < e.length; o++ ) u.push( F.decoration( e[ o ], t ) );
            const l = this.editor.deltaDecorations( n, u );
            this.currentOccurrences = {}, this.activeLinkDecorationId = null;
            for ( o = 0, r = l.length; o < r; o++ ) {
              a = new F( e[ o ], l[ o ] );
              this.currentOccurrences[ a.decorationId ] = a
            }
          }, e.prototype._onEditorMouseMove = function ( e, t ) {
            const n = this,
              i = "altKey" === this.editor.getConfiguration().multiCursorModifier;
            if ( this.isEnabled( e, t ) ) {
              this.cleanUpActiveLinkDecoration();
              const o = this.getLinkOccurrence( e.target.position );
              o && this.editor.changeDecorations( ( e => {
                o.activate( e, i ), n.activeLinkDecorationId = o.decorationId
              } ) )
            } else this.cleanUpActiveLinkDecoration()
          }, e.prototype.cleanUpActiveLinkDecoration = function () {
            const e = "altKey" === this.editor.getConfiguration().multiCursorModifier;
            if ( this.activeLinkDecorationId ) {
              const t = this.currentOccurrences[ this.activeLinkDecorationId ];
              t && this.editor.changeDecorations( ( n => {
                t.deactivate( n, e )
              } ) ), this.activeLinkDecorationId = null
            }
          }, e.prototype.onEditorMouseUp = function ( e ) {
            if ( this.isEnabled( e ) ) {
              const t = this.getLinkOccurrence( e.target.position );
              t && this.openLinkOccurrence( t, e.hasSideBySideModifier )
            }
          }, e.prototype.openLinkOccurrence = function ( e, t ) {
            const n = this;
            if ( this.openerService ) {
              const r = e.link;
              r.resolve().then( ( e => {
                return n.openerService.open( e, {
                  openToSide: t
                } )
              } ), ( e => {
                "invalid" === e ? n.notificationService.warn( i.a( "invalid.url", "Failed to open this link because it is not well-formed: {0}", r.url ) ) : "missing" === e ? n.notificationService.warn( i.a( "missing.url", "Failed to open this link because its target is missing." ) ) : Object( o.e )( e )
              } ) ).done( null, o.e )
            }
          }, e.prototype.getLinkOccurrence = function ( e ) {
            for ( let t = this.editor.getModel().getDecorationsInRange( {
                startLineNumber: e.lineNumber,
                startColumn: e.column,
                endLineNumber: e.lineNumber,
                endColumn: e.column
              }, 0, !0 ), n = 0; n < t.length; n++ ) {
              const i = t[ n ],
                o = this.currentOccurrences[ i.id ];
              if ( o ) return o
            }
            return null
          }, e.prototype.isEnabled = ( e, t ) => {
            return e.target.type === l.b.CONTENT_TEXT && ( e.hasTriggerModifier || t && t.keyCodeIsTriggerKey )
          }, e.prototype.stop = function () {
            this.timeout.cancel(), this.computePromise && ( this.computePromise.cancel(), this.computePromise = null )
          }, e.prototype.dispose = function () {
            this.listenersToRemove = Object( y.d )( this.listenersToRemove ), this.stop(), this.timeout.dispose()
          }, e.ID = "editor.linkDetector", e.RECOMPUTE_TIME = 1e3, e = E( [ k( 1, s.a ), k( 2, x.a ) ], e );
        } )(),
        j = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.openLink",
              label: i.a( "label", "Open Link" ),
              alias: "Open Link",
              precondition: null
            } ) || this
          }
          return N( t, e ), t.prototype.run = ( e, t ) => {
            const n = W.get( t );
            if ( n )
              for ( let i = 0, o = t.getSelections(); i < o.length; i++ ) {
                const r = o[ i ],
                  s = n.getLinkOccurrence( r.getEndPosition() );
                s && n.openLinkOccurrence( s, !1 )
              }
          }, t;
        } )( a.b );
      Object( a.h )( W ), Object( a.f )( j ), Object( b.e )( ( ( e, t ) => {
        const n = e.getColor( C.m );
        n && t.addRule( ".monaco-editor .detected-link-active { color: " + n + " !important; }" )
      } ) )
    },
    "2MPD": function ( e, t, n ) {},
    "2Tsy": function ( e, t, n ) {},
    "2jrX": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "uriDisplay" );
    },
    "2qqv": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "julia",
        extensions: [ ".jl" ],
        aliases: [ "julia", "Julia" ],
        loader() {
          return o.Promise.wrap( n.e( 273 ).then( n.bind( null, "kx9O" ) ) )
        }
      } )
    },
    "3/fG": function ( e, t, n ) {
      "use strict";

      function i( e, t ) {
        for ( var n = [], i = 2; i < arguments.length; i++ ) n[ i - 2 ] = arguments[ i ];
        return ( ( e, t ) => {
          return 0 === t.length ? e : e.replace( /\{(\d+)\}/g, ( ( e, n ) => {
            const i = n[ 0 ];
            return "undefined" !== typeof t[ i ] ? t[ i ] : e
          } ) );
        } )( t, n );
      }
      n.d( t, "a", ( () => {
        return i
      } ) )
    },
    "3eme": function ( e, t, n ) {},
    "3qCu": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return f
      } ) );
      const i = n( "o1O+" );
      const o = n( "W9cx" );
      const r = n( "WBhO" );
      const s = n( "bY76" );
      const a = n( "/cxE" );
      const u = n( "TQUy" );
      const l = n( "Cg/j" );
      const c = n( "MI8n" );
      const d = n( "pmY6" );

      const h = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const p = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      var f = ( () => {
        function e( e, t, n ) {
          void 0 === n && ( n = o.b ), this._editor = e, this._modeService = t, this._openerService = n, this._onDidRenderCodeBlock = new c.a, this.onDidRenderCodeBlock = this._onDidRenderCodeBlock.event
        }
        return e.prototype.getOptions = function ( e ) {
          const t = this;
          return {
            codeBlockRenderer( e, n ) {
              const i = e ? t._modeService.getModeIdForLanguageName( e ) : t._editor.getModel().getLanguageIdentifier().language;
              return t._modeService.getOrCreateMode( i ).then( ( e => {
                return Object( u.b )( n, i )
              } ) ).then( ( e => {
                return '<span style="font-family: ' + t._editor.getConfiguration().fontInfo.fontFamily + '">' + e + "</span>"
              } ) );
            },
            codeBlockRenderCallback() {
              return t._onDidRenderCodeBlock.fire()
            },
            actionHandler: {
              callback( e ) {
                t._openerService.open( s.a.parse( e ) ).then( void 0, a.e )
              },
              disposeables: e
            }
          };
        }, e.prototype.render = function ( e ) {
          const t = [];
          return {
            element: e ? Object( i.b )( e, this.getOptions( t ) ) : document.createElement( "span" ),
            dispose() {
              return Object( d.d )( t )
            }
          };
        }, e = h( [ p( 1, r.a ), p( 2, Object( l.d )( o.a ) ) ], e );
      } )();
    },
    "3rx1": function ( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return l
      } ) ), n.d( t, "a", ( () => {
        return c
      } ) );
      const i = n( "bY76" ),
        o = n( "4J+e" ),
        r = n( "N0LK" ),
        s = n( "tYmi" ),
        a = n( "MNsG" ),
        u = n( "gslv" );

      function l( e, t, n ) {
        if ( !e ) return null;
        "string" === typeof e && ( e = i.a.file( e ) );
        const l = n ? n.getWorkspaceFolder( e ) : null;
        if ( l ) {
          const c = n.getWorkspace().folders.length > 1;
          let f = void 0;
          if ( f = Object( u.c )( l.uri, e, !a.c ) ? "" : Object( o.h )( Object( r.ltrim )( e.path.substr( l.uri.path.length ), o.i ), !0 ), c ) {
            const g = l && l.name ? l.name : Object( o.a )( l.uri.fsPath );
            f = f ? g + " \u2022 " + f : g
          }
          return f
        }
        if ( e.scheme !== s.a.file && e.scheme !== s.a.untitled ) return e.with( {
          query: null,
          fragment: null
        } ).toString( !0 );
        if ( d( e.fsPath ) ) return Object( o.h )( h( e.fsPath ), !0 );
        let m = Object( o.h )( e.fsPath, !0 );
        return !a.g && t && ( m = ( ( e, t ) => {
          if ( a.g || !e || !t ) return e;
          let n = p.original === t ? p.normalized : void 0;
          n || ( n = "" + Object( r.rtrim )( t, o.i ) + o.i, p = {
            original: t,
            normalized: n
          } );
          ( a.c ? Object( r.startsWith )( e, n ) : Object( r.startsWithIgnoreCase )( e, n ) ) && ( e = "~/" + e.substr( n.length ) );
          return e
        } )( m, t.userHome ) ), m;
      }

      function c( e ) {
        if ( !e ) return null;
        "string" === typeof e && ( e = i.a.file( e ) );
        const t = Object( o.a )( e.path ) || ( e.scheme === s.a.file ? e.fsPath : e.path );
        return d( t ) ? h( t ) : t
      }

      function d( e ) {
        return a.g && e && ":" === e[ 1 ]
      }

      function h( e ) {
        return d( e ) ? e.charAt( 0 ).toUpperCase() + e.slice( 1 ) : e
      }
      var p = Object.create( null )
    },
    "4J+e": function ( e, t, n ) {
      "use strict";
      n.d( t, "i", ( () => {
        return r
      } ) ), n.d( t, "g", ( () => {
        return s
      } ) ), n.d( t, "b", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) ), n.d( t, "c", ( () => {
        return l
      } ) ), n.d( t, "h", ( () => {
        return h
      } ) ), n.d( t, "f", ( () => {
        return f
      } ) ), n.d( t, "e", ( () => {
        return g
      } ) ), n.d( t, "d", ( () => {
        return m
      } ) );
      const i = n( "MNsG" );
      const o = n( "N0LK" );
      var r = "/";
      var s = i.g ? "\\" : "/";

      function a( e ) {
        const t = ~e.lastIndexOf( "/" ) || ~e.lastIndexOf( "\\" );
        if ( 0 === t ) return ".";
        if ( 0 === ~t ) return e[ 0 ];
        if ( ~t === e.length - 1 ) return a( e.substring( 0, e.length - 1 ) );
        let n = e.substring( 0, ~t );
        return i.g && ":" === n[ n.length - 1 ] && ( n += s ), n
      }

      function u( e ) {
        const t = ~e.lastIndexOf( "/" ) || ~e.lastIndexOf( "\\" );
        return 0 === t ? e : ~t === e.length - 1 ? u( e.substring( 0, e.length - 1 ) ) : e.substr( 1 + ~t )
      }

      function l( e ) {
        const t = ~( e = u( e ) ).lastIndexOf( "." );
        return t ? e.substring( ~t ) : ""
      }
      const c = /(\/\.\.?\/)|(\/\.\.?)$|^(\.\.?\/)|(\/\/+)|(\\)/,
        d = /(\\\.\.?\\)|(\\\.\.?)$|^(\.\.?\\)|(\\\\+)|(\/)/;

      function h( e, t ) {
        if ( null === e || void 0 === e ) return e;
        const n = e.length;
        if ( 0 === n ) return ".";
        const o = i.g && t;
        if ( ( ( e, t ) => {
            return t ? !d.test( e ) : !c.test( e )
          } )( e, o ) )
          return e;
        for ( var r = o ? "\\" : "/", s = ( ( e, t ) => {
            void 0 === t && ( t = "/" );
            if ( !e ) return "";
            const n = e.length;
            let i = e.charCodeAt( 0 );
            if ( 47 === i || 92 === i ) {
              if ( ( 47 === ( i = e.charCodeAt( 1 ) ) || 92 === i ) && 47 !== ( i = e.charCodeAt( 2 ) ) && 92 !== i ) {
                for ( var o = 3, r = o; o < n && ( 47 !== ( i = e.charCodeAt( o ) ) && 92 !== i ); o++ );
                if ( i = e.charCodeAt( o + 1 ), r !== o && 47 !== i && 92 !== i )
                  for ( o += 1; o < n; o++ )
                    if ( 47 === ( i = e.charCodeAt( o ) ) || 92 === i ) return e.slice( 0, o + 1 ).replace( /[\\/]/g, t )
              }
              return t
            }
            if ( ( i >= 65 && i <= 90 || i >= 97 && i <= 122 ) && 58 === e.charCodeAt( 1 ) ) return 47 === ( i = e.charCodeAt( 2 ) ) || 92 === i ? e.slice( 0, 2 ) + t : e.slice( 0, 2 );
            let s = e.indexOf( "://" );
            if ( -1 !== s )
              for ( s += 3; s < n; s++ )
                if ( 47 === ( i = e.charCodeAt( s ) ) || 92 === i ) return e.slice( 0, s + 1 );
            return ""
          } )( e, r ), a = s.length, u = !1, l = "", h = s.length; h <= n; h++ )
          if ( h === n || 47 === e.charCodeAt( h ) || 92 === e.charCodeAt( h ) ) {
            if ( p( e, a, h, ".." ) ) {
              const f = l.lastIndexOf( r ),
                g = l.slice( f + 1 );
              ( s || g.length > 0 ) && ".." !== g && ( l = -1 === f ? "" : l.slice( 0, f ), u = !0 )
            } else p( e, a, h, "." ) && ( s || l || h < n - 1 ) && ( u = !0 );
            if ( !u ) {
              const m = e.slice( a, h );
              "" !== l && l[ l.length - 1 ] !== r && ( l += r ), l += m
            }
            a = h + 1, u = !1
          } return s + l
      }

      function p( e, t, n, i ) {
        return t + i.length === n && e.indexOf( i, t ) === t
      }
      var f = function () {
        for ( var e = "", t = 0; t < arguments.length; t++ ) {
          const n = arguments[ t ];
          if ( t > 0 ) {
            const i = e.charCodeAt( e.length - 1 );
            if ( 47 !== i && 92 !== i ) {
              const o = n.charCodeAt( 0 );
              47 !== o && 92 !== o && ( e += r )
            }
          }
          e += n
        }
        return h( e )
      };

      function g( e, t, n, i ) {
        if ( void 0 === i && ( i = s ), e === t ) return !0;
        if ( !e || !t ) return !1;
        if ( t.length > e.length ) return !1;
        if ( n ) {
          if ( !Object( o.startsWithIgnoreCase )( e, t ) ) return !1;
          if ( t.length === e.length ) return !0;
          let r = t.length;
          return t.charAt( t.length - 1 ) === i && r--, e.charAt( r ) === i
        }
        return t.charAt( t.length - 1 ) !== i && ( t += i ), 0 === e.indexOf( t )
      }

      function m( e ) {
        return i.g ? ( e => {
          if ( !e ) return !1;
          const t = e.charCodeAt( 0 );
          if ( 47 === t || 92 === t ) return !0;
          if ( ( t >= 65 && t <= 90 || t >= 97 && t <= 122 ) && e.length > 2 && 58 === e.charCodeAt( 1 ) ) {
            const n = e.charCodeAt( 2 );
            if ( 47 === n || 92 === n ) return !0
          }
          return !1
        } )( e ) : ( e => {
          return e && 47 === e.charCodeAt( 0 )
        } )( e );
      }
    },
    "4bUh": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "twdY" );
      var o = ( () => {
        function e( e, t ) {
          this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t
        }
        return e.prototype.equals = function ( t ) {
          return t instanceof e && this.slicedEquals( t, 0, this._tokensCount )
        }, e.prototype.slicedEquals = function ( e, t, n ) {
          if ( this._text !== e._text ) return !1;
          if ( this._tokensCount !== e._tokensCount ) return !1;
          for ( let i = t << 1, o = i + ( n << 1 ), r = i; r < o; r++ )
            if ( this._tokens[ r ] !== e._tokens[ r ] ) return !1;
          return !0
        }, e.prototype.getLineContent = function () {
          return this._text
        }, e.prototype.getCount = function () {
          return this._tokensCount
        }, e.prototype.getStartOffset = function ( e ) {
          return e > 0 ? this._tokens[ e - 1 << 1 ] : 0
        }, e.prototype.getLanguageId = function ( e ) {
          const t = this._tokens[ 1 + ( e << 1 ) ];
          return i.x.getLanguageId( t )
        }, e.prototype.getStandardTokenType = function ( e ) {
          const t = this._tokens[ 1 + ( e << 1 ) ];
          return i.x.getTokenType( t )
        }, e.prototype.getForeground = function ( e ) {
          const t = this._tokens[ 1 + ( e << 1 ) ];
          return i.x.getForeground( t )
        }, e.prototype.getClassName = function ( e ) {
          const t = this._tokens[ 1 + ( e << 1 ) ];
          return i.x.getClassNameFromMetadata( t )
        }, e.prototype.getInlineStyle = function ( e, t ) {
          const n = this._tokens[ 1 + ( e << 1 ) ];
          return i.x.getInlineStyleFromMetadata( n, t )
        }, e.prototype.getEndOffset = function ( e ) {
          return this._tokens[ e << 1 ]
        }, e.prototype.findTokenIndexAtOffset = function ( t ) {
          return e.findIndexInTokensArray( this._tokens, t )
        }, e.prototype.inflate = function () {
          return this
        }, e.prototype.sliceAndInflate = function ( e, t, n ) {
          return new r( this, e, t, n )
        }, e.convertToEndOffset = ( e, t ) => {
          for ( var n = ( e.length >>> 1 ) - 1, i = 0; i < n; i++ ) e[ i << 1 ] = e[ i + 1 << 1 ];
          e[ n << 1 ] = t
        }, e.findIndexInTokensArray = ( e, t ) => {
          if ( e.length <= 2 ) return 0;
          for ( var n = 0, i = ( e.length >>> 1 ) - 1; n < i; ) {
            const o = n + Math.floor( ( i - n ) / 2 ),
              r = e[ o << 1 ];
            if ( r === t ) return o + 1;
            r < t ? n = o + 1 : r > t && ( i = o )
          }
          return n
        }, e;
      } )();
      const r = ( () => {
        function e( e, t, n, i ) {
          this._source = e, this._startOffset = t, this._endOffset = n, this._deltaOffset = i, this._firstTokenIndex = e.findTokenIndexAtOffset( t ), this._tokensCount = 0;
          for ( let o = this._firstTokenIndex, r = e.getCount(); o < r; o++ ) {
            if ( e.getStartOffset( o ) >= n ) break;
            this._tokensCount++
          }
        }
        return e.prototype.equals = function ( t ) {
          return t instanceof e && ( this._startOffset === t._startOffset && this._endOffset === t._endOffset && this._deltaOffset === t._deltaOffset && this._source.slicedEquals( t._source, this._firstTokenIndex, this._tokensCount ) )
        }, e.prototype.getCount = function () {
          return this._tokensCount
        }, e.prototype.getForeground = function ( e ) {
          return this._source.getForeground( this._firstTokenIndex + e )
        }, e.prototype.getEndOffset = function ( e ) {
          const t = this._source.getEndOffset( this._firstTokenIndex + e );
          return Math.min( this._endOffset, t ) - this._startOffset + this._deltaOffset
        }, e.prototype.getClassName = function ( e ) {
          return this._source.getClassName( this._firstTokenIndex + e )
        }, e.prototype.getInlineStyle = function ( e, t ) {
          return this._source.getInlineStyle( this._firstTokenIndex + e, t )
        }, e.prototype.findTokenIndexAtOffset = function ( e ) {
          return this._source.findTokenIndexAtOffset( e + this._startOffset - this._deltaOffset ) - this._firstTokenIndex
        }, e;
      } )();
    },
    "4rho": function ( e, t, n ) {},
    "4sI4": function ( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "StandaloneReferencesController", ( () => {
        return f
      } ) );
      const i = n( "Vxe3" );
      const o = n( "Cg/j" );
      const r = n( "T8No" );
      const s = n( "+7oY" );
      const a = n( "A+jI" );
      const u = n( "sswD" );
      const l = n( "sM1p" );
      const c = n( "qkNm" );
      const d = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const h = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const p = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      var f = ( e => {
        function t( t, n, i, o, r, s, a ) {
          return e.call( this, !0, t, n, i, o, r, s, a ) || this
        }
        return d( t, e ), t = h( [ p( 1, r.e ), p( 2, i.a ), p( 3, l.a ), p( 4, o.a ), p( 5, a.a ), p( 6, s.b ) ], t )
      } )( c.a );
      Object( u.h )( f )
    },
    "4y0V": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) );
      const i = n( "MI8n" );
      var o = ( e, t, n ) => {
        const o = e => {
            return r.fire( e )
          },
          r = new i.a( {
            onFirstListenerAdd() {
              e.addEventListener( t, o, n )
            },
            onLastListenerRemove() {
              e.removeEventListener( t, o, n )
            }
          } );
        return r.event
      };

      function r( e ) {
        return Object( i.j )( e, ( e => {
          return e.preventDefault(), e.stopPropagation(), e
        } ) );
      }
    },
    "51f4": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return a
      } ) );
      let i = !1,
        o = null;

      function r( e ) {
        if ( !e.parent || e.parent === e ) return null;
        try {
          const t = e.location,
            n = e.parent.location;
          if ( t.protocol !== n.protocol || t.hostname !== n.hostname || t.port !== n.port ) return i = !0, null
        } catch ( o ) {
          return i = !0, null
        }
        return e.parent
      }

      function s( e, t ) {
        for ( let n, i = e.document.getElementsByTagName( "iframe" ), o = 0, r = i.length; o < r; o++ )
          if ( ( n = i[ o ] ).contentWindow === t ) return n;
        return null
      }
      var a = ( () => {
        function e() {}
        return e.getSameOriginWindowChain = () => {
          if ( !o ) {
            o = [];
            let e, t = window;
            do {
              ( e = r( t ) ) ? o.push( {
                window: t,
                iframeElement: s( e, t )
              } ): o.push( {
                window: t,
                iframeElement: null
              } ), t = e
            } while ( t )
          }
          return o.slice( 0 )
        }, e.hasDifferentOriginAncestor = function () {
          return o || this.getSameOriginWindowChain(), i
        }, e.getPositionOfChildWindowRelativeToAncestorWindow = function ( e, t ) {
          if ( !t || e === t ) return {
            top: 0,
            left: 0
          };
          for ( var n = 0, i = 0, o = this.getSameOriginWindowChain(), r = 0; r < o.length; r++ ) {
            const s = o[ r ];
            if ( s.window === t ) break;
            if ( !s.iframeElement ) break;
            const a = s.iframeElement.getBoundingClientRect();
            n += a.top, i += a.left
          }
          return {
            top: n,
            left: i
          }
        }, e;
      } )()
    },
    "5DEy": function ( e, t, n ) {},
    "5RaG": function ( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "CursorUndoController", ( () => {
        return l
      } ) ), n.d( t, "CursorUndo", ( () => {
        return c
      } ) );
      const i = n( "3/fG" );
      const o = n( "sswD" );
      const r = n( "pmY6" );
      const s = n( "wQH0" );
      const a = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const u = ( () => {
        function e( e ) {
          this.selections = e
        }
        return e.prototype.equals = function ( e ) {
          const t = this.selections.length;
          if ( t !== e.selections.length ) return !1;
          for ( let n = 0; n < t; n++ )
            if ( !this.selections[ n ].equalsSelection( e.selections[ n ] ) ) return !1;
          return !0
        }, e;
      } )();
      var l = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n._editor = t, n._isCursorUndo = !1, n._undoStack = [], n._prevState = n._readState(), n._register( t.onDidChangeModel( ( e => {
            n._undoStack = [], n._prevState = null
          } ) ) ), n._register( t.onDidChangeModelContent( ( e => {
            n._undoStack = [], n._prevState = null
          } ) ) ), n._register( t.onDidChangeCursorSelection( ( e => {
            !n._isCursorUndo && n._prevState && ( n._undoStack.push( n._prevState ), n._undoStack.length > 50 && n._undoStack.shift() ), n._prevState = n._readState()
          } ) ) ), n;
        }
        return a( t, e ), t.get = e => {
          return e.getContribution( t.ID )
        }, t.prototype._readState = function () {
          return this._editor.getModel() ? new u( this._editor.getSelections() ) : null
        }, t.prototype.getId = () => {
          return t.ID
        }, t.prototype.cursorUndo = function () {
          for ( const e = new u( this._editor.getSelections() ); this._undoStack.length > 0; ) {
            const t = this._undoStack.pop();
            if ( !t.equals( e ) ) return this._isCursorUndo = !0, this._editor.setSelections( t.selections ), this._editor.revealRangeInCenterIfOutsideViewport( t.selections[ 0 ], 0 ), void( this._isCursorUndo = !1 )
          }
        }, t.ID = "editor.contrib.cursorUndoController", t;
      } )( r.a );
      var c = ( e => {
        function t() {
          return e.call( this, {
            id: "cursorUndo",
            label: i.a( "cursor.undo", "Soft Undo" ),
            alias: "Soft Undo",
            precondition: null,
            kbOpts: {
              kbExpr: s.a.textInputFocus,
              primary: 2099,
              weight: 100
            }
          } ) || this
        }
        return a( t, e ), t.prototype.run = ( e, t, n ) => {
          l.get( t ).cursorUndo()
        }, t;
      } )( o.b );
      Object( o.h )( l ), Object( o.f )( c )
    },
    "5TxY": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return p
      } ) ), n.d( t, "b", ( () => {
        return f
      } ) );
      const i = n( "X+cX" );
      const o = n( "gCVg" );
      const r = n( "N0LK" );
      const s = n( "MI8n" );
      const a = n( "pmY6" );
      const u = n( "Comh" );
      const l = n( "D3Dy" );
      const c = n( "MNsG" );
      const d = n( "EffR" );
      const h = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var p = {
        forceCopyWithSyntaxHighlighting: !1
      };

      var f = ( e => {
        function t( t, n ) {
          const a = e.call( this ) || this;
          a._onFocus = a._register( new s.a ), a.onFocus = a._onFocus.event, a._onBlur = a._register( new s.a ), a.onBlur = a._onBlur.event, a._onKeyDown = a._register( new s.a ), a.onKeyDown = a._onKeyDown.event, a._onKeyUp = a._register( new s.a ), a.onKeyUp = a._onKeyUp.event, a._onCut = a._register( new s.a ), a.onCut = a._onCut.event, a._onPaste = a._register( new s.a ), a.onPaste = a._onPaste.event, a._onType = a._register( new s.a ), a.onType = a._onType.event, a._onCompositionStart = a._register( new s.a ), a.onCompositionStart = a._onCompositionStart.event, a._onCompositionUpdate = a._register( new s.a ), a.onCompositionUpdate = a._onCompositionUpdate.event, a._onCompositionEnd = a._register( new s.a ), a.onCompositionEnd = a._onCompositionEnd.event, a._onSelectionChangeRequest = a._register( new s.a ), a.onSelectionChangeRequest = a._onSelectionChangeRequest.event, a._host = t, a._textArea = a._register( new m( n ) ), a._lastTextAreaEvent = 0, a._asyncTriggerCut = a._register( new i.c( ( () => {
            return a._onCut.fire()
          } ), 0 ) ), a._textAreaState = u.b.EMPTY, a.writeScreenReaderContent( "ctor" ), a._hasFocus = !1, a._isDoingComposition = !1, a._nextCommand = 0, a._register( d.j( n.domNode, "keydown", ( e => {
            !a._isDoingComposition || 109 !== e.keyCode && 1 !== e.keyCode || e.stopPropagation(), e.equals( 9 ) && e.preventDefault(), a._onKeyDown.fire( e )
          } ) ) ), a._register( d.j( n.domNode, "keyup", ( e => {
            a._onKeyUp.fire( e )
          } ) ) ), a._register( d.g( n.domNode, "compositionstart", ( e => {
            a._lastTextAreaEvent = 1, a._isDoingComposition || ( a._isDoingComposition = !0, l.h || a._setAndWriteTextAreaState( "compositionstart", u.b.EMPTY ), a._onCompositionStart.fire() )
          } ) ) );
          const h = ( e, t ) => {
              const n = a._textAreaState,
                i = u.b.readFromTextArea( a._textArea );
              return [ i, u.b.deduceInput( n, i, e, t ) ]
            },
            p = e => {
              const t = a._textAreaState,
                n = u.b.selectedText( e );
              return [ n, {
                text: n.value,
                replaceCharCnt: t.selectionEnd - t.selectionStart
              } ]
            },
            f = e => {
              return !( !l.h || "ja" !== e ) || !( !l.k || 0 !== e.indexOf( "zh-Han" ) )
            };
          a._register( d.g( n.domNode, "compositionupdate", ( e => {
            if ( a._lastTextAreaEvent = 2, f( e.locale ) ) {
              const t = h( !1, !1 ),
                n = t[ 0 ],
                i = t[ 1 ];
              return a._textAreaState = n, a._onType.fire( i ), void a._onCompositionUpdate.fire( e )
            }
            const o = p( e.data ),
              r = o[ 0 ],
              s = o[ 1 ];
            a._textAreaState = r, a._onType.fire( s ), a._onCompositionUpdate.fire( e )
          } ) ) ), a._register( d.g( n.domNode, "compositionend", ( e => {
            if ( a._lastTextAreaEvent = 3, f( e.locale ) ) {
              const t = h( !1, !1 );
              var n = t[ 0 ];
              var i = t[ 1 ];
              a._textAreaState = n, a._onType.fire( i )
            } else {
              const o = p( e.data );
              n = o[ 0 ], i = o[ 1 ];
              a._textAreaState = n, a._onType.fire( i )
            }( l.h || l.f ) && ( a._textAreaState = u.b.readFromTextArea( a._textArea ) ), a._isDoingComposition && ( a._isDoingComposition = !1, a._onCompositionEnd.fire() )
          } ) ) ), a._register( d.g( n.domNode, "input", ( () => {
            const e = 8 === a._lastTextAreaEvent;
            if ( a._lastTextAreaEvent = 4, a._textArea.setIgnoreSelectionChangeTime( "received input event" ), !a._isDoingComposition ) {
              const t = h( c.d, e && c.d ),
                n = t[ 0 ],
                i = t[ 1 ];
              0 === i.replaceCharCnt && 1 === i.text.length && r.isHighSurrogate( i.text.charCodeAt( 0 ) ) || ( a._textAreaState = n, 0 === a._nextCommand ? "" !== i.text && a._onType.fire( i ) : ( "" !== i.text && a._onPaste.fire( {
                text: i.text
              } ), a._nextCommand = 0 ) )
            }
          } ) ) ), a._register( d.g( n.domNode, "cut", ( e => {
            a._lastTextAreaEvent = 5, a._textArea.setIgnoreSelectionChangeTime( "received cut event" ), a._ensureClipboardGetsEditorSelection( e ), a._asyncTriggerCut.schedule()
          } ) ) ), a._register( d.g( n.domNode, "copy", ( e => {
            a._lastTextAreaEvent = 6, a._ensureClipboardGetsEditorSelection( e )
          } ) ) ), a._register( d.g( n.domNode, "paste", ( e => {
            if ( a._lastTextAreaEvent = 7, a._textArea.setIgnoreSelectionChangeTime( "received paste event" ), g.canUseTextData( e ) ) {
              const t = g.getTextData( e );
              "" !== t && a._onPaste.fire( {
                text: t
              } )
            } else a._textArea.getSelectionStart() !== a._textArea.getSelectionEnd() && a._setAndWriteTextAreaState( "paste", u.b.EMPTY ), a._nextCommand = 1
          } ) ) ), a._register( d.g( n.domNode, "focus", ( () => {
            a._lastTextAreaEvent = 8, a._setHasFocus( !0 )
          } ) ) ), a._register( d.g( n.domNode, "blur", ( () => {
            a._lastTextAreaEvent = 9, a._setHasFocus( !1 )
          } ) ) );
          let _ = 0;
          return a._register( d.g( document, "selectionchange", ( e => {
            if ( a._hasFocus && !a._isDoingComposition && l.f && c.g ) {
              const t = Date.now(),
                n = t - _;
              if ( _ = t, !( n < 5 ) ) {
                const i = t - a._textArea.getIgnoreSelectionChangeTime();
                if ( a._textArea.resetSelectionChangeTime(), !( i < 100 ) && a._textAreaState.selectionStartPosition && a._textAreaState.selectionEndPosition ) {
                  const r = a._textArea.getValue();
                  if ( a._textAreaState.value === r ) {
                    const s = a._textArea.getSelectionStart(),
                      u = a._textArea.getSelectionEnd();
                    if ( a._textAreaState.selectionStart !== s || a._textAreaState.selectionEnd !== u ) {
                      const d = a._textAreaState.deduceEditorPosition( s ),
                        h = a._host.deduceModelPosition( d[ 0 ], d[ 1 ], d[ 2 ] ),
                        p = a._textAreaState.deduceEditorPosition( u ),
                        f = a._host.deduceModelPosition( p[ 0 ], p[ 1 ], p[ 2 ] ),
                        g = new o.a( h.lineNumber, h.column, f.lineNumber, f.column );
                      a._onSelectionChangeRequest.fire( g )
                    }
                  }
                }
              }
            }
          } ) ) ), a;
        }
        return h( t, e ), t.prototype.dispose = function () {
          e.prototype.dispose.call( this )
        }, t.prototype.focusTextArea = function () {
          this._setHasFocus( !0 )
        }, t.prototype.isFocused = function () {
          return this._hasFocus
        }, t.prototype._setHasFocus = function ( e ) {
          this._hasFocus !== e && ( this._hasFocus = e, this._hasFocus && ( l.g ? this._setAndWriteTextAreaState( "focusgain", u.b.EMPTY ) : this.writeScreenReaderContent( "focusgain" ) ), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire() )
        }, t.prototype._setAndWriteTextAreaState = function ( e, t ) {
          this._hasFocus || ( t = t.collapseSelection() ), t.writeToTextArea( e, this._textArea, this._hasFocus ), this._textAreaState = t
        }, t.prototype.writeScreenReaderContent = function ( e ) {
          this._isDoingComposition || this._setAndWriteTextAreaState( e, this._host.getScreenReaderContent( this._textAreaState ) )
        }, t.prototype._ensureClipboardGetsEditorSelection = function ( e ) {
          const t = this._host.getPlainTextToCopy();
          if ( g.canUseTextData( e ) ) {
            let n = null;
            l.e() && ( t.length < 65536 || p.forceCopyWithSyntaxHighlighting ) && ( n = this._host.getHTMLToCopy() ), g.setTextData( e, t, n )
          } else this._setAndWriteTextAreaState( "copy or cut", u.b.selectedText( t ) )
        }, t;
      } )( a.a );

      const g = ( () => {
        function e() {}
        return e.canUseTextData = e => {
          return !!e.clipboardData || !!window.clipboardData
        }, e.getTextData = e => {
          if ( e.clipboardData ) return e.preventDefault(), e.clipboardData.getData( "text/plain" );
          if ( window.clipboardData ) return e.preventDefault(), window.clipboardData.getData( "Text" );
          throw new Error( "ClipboardEventUtils.getTextData: Cannot use text data!" )
        }, e.setTextData = ( e, t, n ) => {
          if ( e.clipboardData ) return e.clipboardData.setData( "text/plain", t ), null !== n && e.clipboardData.setData( "text/html", n ), void e.preventDefault();
          if ( window.clipboardData ) return window.clipboardData.setData( "Text", t ), void e.preventDefault();
          throw new Error( "ClipboardEventUtils.setTextData: Cannot use text data!" )
        }, e;
      } )();
      const m = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n._actual = t, n._ignoreSelectionChangeTime = 0, n
        }
        return h( t, e ), t.prototype.setIgnoreSelectionChangeTime = function ( e ) {
          this._ignoreSelectionChangeTime = Date.now()
        }, t.prototype.getIgnoreSelectionChangeTime = function () {
          return this._ignoreSelectionChangeTime
        }, t.prototype.resetSelectionChangeTime = function () {
          this._ignoreSelectionChangeTime = 0
        }, t.prototype.getValue = function () {
          return this._actual.domNode.value
        }, t.prototype.setValue = function ( e, t ) {
          const n = this._actual.domNode;
          n.value !== t && ( this.setIgnoreSelectionChangeTime( "setValue" ), n.value = t )
        }, t.prototype.getSelectionStart = function () {
          return this._actual.domNode.selectionStart
        }, t.prototype.getSelectionEnd = function () {
          return this._actual.domNode.selectionEnd
        }, t.prototype.setSelectionRange = function ( e, t, n ) {
          const i = this._actual.domNode,
            o = document.activeElement === i,
            r = i.selectionStart,
            s = i.selectionEnd;
          if ( o && r === t && s === n ) l.j && window.parent !== window && i.focus();
          else {
            if ( o ) return this.setIgnoreSelectionChangeTime( "setSelectionRange" ), i.setSelectionRange( t, n ), void( l.j && window.parent !== window && i.focus() );
            try {
              const a = d.K( i );
              this.setIgnoreSelectionChangeTime( "setSelectionRange" ), i.focus(), i.setSelectionRange( t, n ), d.I( i, a )
            } catch ( u ) {}
          }
        }, t;
      } )( a.a );
    },
    "5aqo": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "c", ( () => {
        return v
      } ) ), n.d( t, "b", ( () => {
        return b
      } ) );
      n( "3eme" );
      var i;
      const o = n( "3/fG" );
      const r = n( "8HAY" );
      const s = n( "N0LK" );
      const a = n( "qj0h" );
      const u = n( "lCHf" );
      const l = n( "MI8n" );
      const c = n( "EffR" );
      const d = n( "WqXY" );
      const h = n( "Vxe3" );
      const p = n( "cnVm" );
      const f = n( "03kh" );
      const g = n( "T8No" );
      const m = n( "zrhQ" );
      const _ = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      function v( e ) {
        const t = e.get( h.a ).getFocusedCodeEditor();
        return t instanceof f.a ? t.getParentEditor() : t
      }!( e => {
        e.inPeekEditor = new g.f( "inReferenceSearchEditor", !0 ), e.notInPeekEditor = e.inPeekEditor.toNegated()
      } )( i || ( i = {} ) );
      const y = {
        headerBackgroundColor: m.a.white,
        primaryHeadingColor: m.a.fromHex( "#333333" ),
        secondaryHeadingColor: m.a.fromHex( "#6c6c6cb3" )
      };
      var b = ( e => {
        function t( t, n ) {
          void 0 === n && ( n = {} );
          const i = e.call( this, t, n ) || this;
          return i._onDidClose = new l.a, a.g( i.options, y, !1 ), i
        }
        return _( t, e ), t.prototype.dispose = function () {
          e.prototype.dispose.call( this ), this._onDidClose.fire( this )
        }, Object.defineProperty( t.prototype, "onDidClose", {
          get() {
            return this._onDidClose.event
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.style = function ( t ) {
          const n = this.options;
          t.headerBackgroundColor && ( n.headerBackgroundColor = t.headerBackgroundColor ), t.primaryHeadingColor && ( n.primaryHeadingColor = t.primaryHeadingColor ), t.secondaryHeadingColor && ( n.secondaryHeadingColor = t.secondaryHeadingColor ), e.prototype.style.call( this, t )
        }, t.prototype._applyStyles = function () {
          e.prototype._applyStyles.call( this );
          const t = this.options;
          this._headElement && ( this._headElement.style.backgroundColor = t.headerBackgroundColor.toString() ), this._primaryHeading && ( this._primaryHeading.style.color = t.primaryHeadingColor.toString() ), this._secondaryHeading && ( this._secondaryHeading.style.color = t.secondaryHeadingColor.toString() ), this._bodyElement && ( this._bodyElement.style.borderColor = t.frameColor.toString() )
        }, t.prototype._fillContainer = function ( e ) {
          this.setCssClass( "peekview-widget" ), this._headElement = Object( u.a )( ".head" ).getHTMLElement(), this._bodyElement = Object( u.a )( ".body" ).getHTMLElement(), this._fillHead( this._headElement ), this._fillBody( this._bodyElement ), e.appendChild( this._headElement ), e.appendChild( this._bodyElement )
        }, t.prototype._fillHead = function ( e ) {
          const t = this,
            n = Object( u.a )( ".peekview-title" ).on( c.d.CLICK, ( e => {
              return t._onTitleClick( e )
            } ) ).appendTo( this._headElement ).getHTMLElement();
          this._primaryHeading = Object( u.a )( "span.filename" ).appendTo( n ).getHTMLElement(), this._secondaryHeading = Object( u.a )( "span.dirname" ).appendTo( n ).getHTMLElement(), this._metaHeading = Object( u.a )( "span.meta" ).appendTo( n ).getHTMLElement();
          const i = Object( u.a )( ".peekview-actions" ).appendTo( this._headElement ),
            s = this._getActionBarOptions();
          this._actionbarWidget = new d.a( i.getHTMLElement(), s ), this._disposables.push( this._actionbarWidget ), this._actionbarWidget.push( new r.a( "peekview.close", o.a( "label.close", "Close" ), "close-peekview-action", !0, ( () => {
            return t.dispose(), null
          } ) ), {
            label: !1,
            icon: !0
          } )
        }, t.prototype._getActionBarOptions = () => {
          return {}
        }, t.prototype._onTitleClick = e => {}, t.prototype.setTitle = function ( e, t ) {
          Object( u.a )( this._primaryHeading ).safeInnerHtml( e ), this._primaryHeading.setAttribute( "aria-label", e ), t ? Object( u.a )( this._secondaryHeading ).safeInnerHtml( t ) : c.l( this._secondaryHeading )
        }, t.prototype.setMetaTitle = function ( e ) {
          e ? Object( u.a )( this._metaHeading ).safeInnerHtml( e ) : c.l( this._metaHeading )
        }, t.prototype._doLayout = function ( e, t ) {
          if ( !this._isShowing && e < 0 ) this.dispose();
          else {
            const n = Math.ceil( 1.2 * this.editor.getConfiguration().lineHeight ),
              i = e - ( n + 2 );
            this._doLayoutHead( n, t ), this._doLayoutBody( i, t )
          }
        }, t.prototype._doLayoutHead = function ( e, t ) {
          this._headElement.style.height = s.format( "{0}px", e ), this._headElement.style.lineHeight = this._headElement.style.height
        }, t.prototype._doLayoutBody = function ( e, t ) {
          this._bodyElement.style.height = s.format( "{0}px", e )
        }, t;
      } )( p.a );
    },
    "5v8Y": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return s
      } ) );
      const i = n( "MXAL" ),
        o = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        r = ( e => {
          function t( t ) {
            for ( var n = e.call( this, 0 ) || this, i = 0, o = t.length; i < o; i++ ) n.set( t.charCodeAt( i ), 2 );
            return n.set( 32, 1 ), n.set( 9, 1 ), n
          }
          return o( t, e ), t
        } )( i.a );
      var s = ( e => {
        const t = {};
        return n => {
          return t.hasOwnProperty( n ) || ( t[ n ] = e( n ) ), t[ n ]
        };
      } )( e => {
        return new r( e )
      } )
    },
    "628j": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "qbasic",
        extensions: [ ".bas" ],
        aliases: [ "qbasic", "QBasic", "QBASIC" ],
        loader() {
          return o.Promise.wrap( n.e( 292 ).then( n.bind( null, "uR9n" ) ) )
        }
      } )
    },
    "6OMU": function ( e, t, n ) {
      "use strict";

      function i( e, t ) {
        return void 0 === t && ( t = 0 ), e[ e.length - ( 1 + t ) ]
      }

      function o( e, t, n ) {
        if ( void 0 === n && ( n = ( e, t ) => {
            return e === t
          } ), e.length !== t.length ) return !1;
        for ( let i = 0, o = e.length; i < o; i++ )
          if ( !n( e[ i ], t[ i ] ) ) return !1;
        return !0
      }

      function r( e, t, n ) {
        for ( var i = 0, o = e.length - 1; i <= o; ) {
          const r = ( i + o ) / 2 | 0,
            s = n( e[ r ], t );
          if ( s < 0 ) i = r + 1;
          else {
            if ( !( s > 0 ) ) return r;
            o = r - 1
          }
        }
        return -( i + 1 )
      }

      function s( e, t ) {
        let n = 0,
          i = e.length;
        if ( 0 === i ) return 0;
        for ( ; n < i; ) {
          const o = Math.floor( ( n + i ) / 2 );
          t( e[ o ] ) ? i = o : n = o + 1
        }
        return n
      }

      function a( e, t ) {
        return function e( t, n, i, o, r ) {
          if ( o <= i ) return;
          const s = i + ( o - i ) / 2 | 0;
          if ( e( t, n, i, s, r ), e( t, n, s + 1, o, r ), n( t[ s ], t[ s + 1 ] ) <= 0 ) return;
          !( ( e, t, n, i, o, r ) => {
            for ( var s = n, a = i + 1, u = n; u <= o; u++ ) r[ u ] = e[ u ];
            for ( u = n; u <= o; u++ ) s > i ? e[ u ] = r[ a++ ] : a > o ? e[ u ] = r[ s++ ] : t( r[ a ], r[ s ] ) < 0 ? e[ u ] = r[ a++ ] : e[ u ] = r[ s++ ]
          } )( t, n, i, s, o, r )
        }( e, t, 0, e.length - 1, [] ), e;
      }

      function u( e, t ) {
        for ( var n, i = [], o = 0, r = a( e.slice( 0 ), t ); o < r.length; o++ ) {
          const s = r[ o ];
          n && 0 === t( n[ 0 ], s ) ? n.push( s ) : ( n = [ s ], i.push( n ) )
        }
        return i
      }

      function l( e, t ) {
        if ( !e && !t ) return e;
        if ( !t ) return e.filter( ( e => {
          return !!e
        } ) );
        for ( var n = 0, i = 0; i < e.length; i++ ) e[ i ] && ( e[ n ] = e[ i ], n += 1 );
        e.length = n
      }

      function c( e ) {
        return !Array.isArray( e ) || 0 === e.length
      }

      function d( e, t ) {
        if ( !t ) return e.filter( ( ( t, n ) => {
          return e.indexOf( t ) === n
        } ) );
        const n = Object.create( null );
        return e.filter( ( e => {
          const i = t( e );
          return !n[ i ] && ( n[ i ] = !0, !0 )
        } ) );
      }

      function h( e, t ) {
        for ( let n = 0; n < e.length; n++ ) {
          if ( t( e[ n ] ) ) return n
        }
        return -1
      }

      function p( e, t, n ) {
        void 0 === n && ( n = null );
        const i = h( e, t );
        return i < 0 ? n : e[ i ]
      }

      function f( e ) {
        return [].concat.apply( [], e )
      }

      function g( e, t ) {
        let n = "number" === typeof t ? e : 0;
        "number" === typeof t ? n = e : ( n = 0, t = e );
        const i = [];
        if ( n <= t )
          for ( var o = n; o < t; o++ ) i.push( o );
        else
          for ( o = n; o > t; o-- ) i.push( o );
        return i
      }

      function m( e, t, n ) {
        const i = e.slice( 0, t ),
          o = e.slice( t );
        return i.concat( n, o )
      }
      n.d( t, "n", ( () => {
        return i
      } ) ), n.d( t, "e", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) ), n.d( t, "f", ( () => {
        return s
      } ) ), n.d( t, "l", ( () => {
        return a
      } ) ), n.d( t, "j", ( () => {
        return u
      } ) ), n.d( t, "c", ( () => {
        return l
      } ) ), n.d( t, "k", ( () => {
        return c
      } ) ), n.d( t, "d", ( () => {
        return d
      } ) ), n.d( t, "h", ( () => {
        return h
      } ) ), n.d( t, "g", ( () => {
        return p
      } ) ), n.d( t, "i", ( () => {
        return f
      } ) ), n.d( t, "m", ( () => {
        return g
      } ) ), n.d( t, "a", ( () => {
        return m
      } ) )
    },
    "6lNC": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "pascal",
        extensions: [ ".pas", ".pp" ],
        aliases: [ "Pascal", "pas", "Delphi" ],
        mimetypes: [ "text/x-pascal-source", "text/x-pascal" ],
        loader() {
          return o.Promise.wrap( n.e( 282 ).then( n.bind( null, "meXB" ) ) )
        }
      } )
    },
    "6rrl": function ( e, t, n ) {
      "use strict";
      n( "vMFT" );
      let i;
      let o;
      const r = n( "X8W9" );
      const s = n( "FWmy" );
      const a = n( "/cxE" );
      const u = n( "pmY6" );
      const l = n( "VMIq" );
      const c = n( "MI8n" );
      const d = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const h = ( () => {
        function e( e ) {
          this._onDispose = new c.a, this.onDispose = this._onDispose.event, this._item = e
        }
        return Object.defineProperty( e.prototype, "item", {
          get() {
            return this._item
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.dispose = function () {
          this._onDispose && ( this._onDispose.fire(), this._onDispose.dispose(), this._onDispose = null )
        }, e;
      } )();

      const p = ( () => {
        function e() {
          this.locks = Object.create( {} )
        }
        return e.prototype.isLocked = function ( e ) {
          return !!this.locks[ e.id ]
        }, e.prototype.run = function ( e, t ) {
          let n;
          let i;
          const o = this;
          const r = this.getLock( e );
          return r ? new l.b( ( ( i, s ) => {
            n = Object( c.k )( r.onDispose )( ( () => {
              return o.run( e, t ).then( i, s )
            } ) )
          } ), ( () => {
            n.dispose()
          } ) ) : new l.b( ( ( n, r ) => {
            if ( e.isDisposed() ) return r( new Error( "Item is disposed." ) );
            const s = o.locks[ e.id ] = new h( e );
            return i = t().then( ( t => {
              return delete o.locks[ e.id ], s.dispose(), t
            } ) ).then( n, r );
          } ), ( () => {
            return i.cancel()
          } ) );
        }, e.prototype.getLock = function ( e ) {
          let t;
          for ( t in this.locks ) {
            const n = this.locks[ t ];
            if ( e.intersects( n.item ) ) return n
          }
          return null
        }, e;
      } )();

      const f = ( () => {
        function e() {
          this._isDisposed = !1, this._onDidRevealItem = new c.d, this.onDidRevealItem = this._onDidRevealItem.event, this._onExpandItem = new c.d, this.onExpandItem = this._onExpandItem.event, this._onDidExpandItem = new c.d, this.onDidExpandItem = this._onDidExpandItem.event, this._onCollapseItem = new c.d, this.onCollapseItem = this._onCollapseItem.event, this._onDidCollapseItem = new c.d, this.onDidCollapseItem = this._onDidCollapseItem.event, this._onDidAddTraitItem = new c.d, this.onDidAddTraitItem = this._onDidAddTraitItem.event, this._onDidRemoveTraitItem = new c.d, this.onDidRemoveTraitItem = this._onDidRemoveTraitItem.event, this._onDidRefreshItem = new c.d, this.onDidRefreshItem = this._onDidRefreshItem.event, this._onRefreshItemChildren = new c.d, this.onRefreshItemChildren = this._onRefreshItemChildren.event, this._onDidRefreshItemChildren = new c.d, this.onDidRefreshItemChildren = this._onDidRefreshItemChildren.event, this._onDidDisposeItem = new c.d, this.onDidDisposeItem = this._onDidDisposeItem.event, this.items = {}
        }
        return e.prototype.register = function ( e ) {
          s.a( !this.isRegistered( e.id ), "item already registered: " + e.id );
          const t = Object( u.c )( [ this._onDidRevealItem.add( e.onDidReveal ), this._onExpandItem.add( e.onExpand ), this._onDidExpandItem.add( e.onDidExpand ), this._onCollapseItem.add( e.onCollapse ), this._onDidCollapseItem.add( e.onDidCollapse ), this._onDidAddTraitItem.add( e.onDidAddTrait ), this._onDidRemoveTraitItem.add( e.onDidRemoveTrait ), this._onDidRefreshItem.add( e.onDidRefresh ), this._onRefreshItemChildren.add( e.onRefreshChildren ), this._onDidRefreshItemChildren.add( e.onDidRefreshChildren ), this._onDidDisposeItem.add( e.onDidDispose ) ] );
          this.items[ e.id ] = {
            item: e,
            disposable: t
          }
        }, e.prototype.deregister = function ( e ) {
          s.a( this.isRegistered( e.id ), "item not registered: " + e.id ), this.items[ e.id ].disposable.dispose(), delete this.items[ e.id ]
        }, e.prototype.isRegistered = function ( e ) {
          return this.items.hasOwnProperty( e )
        }, e.prototype.getItem = function ( e ) {
          const t = this.items[ e ];
          return t ? t.item : null
        }, e.prototype.dispose = function () {
          this.items = null, this._onDidRevealItem.dispose(), this._onExpandItem.dispose(), this._onDidExpandItem.dispose(), this._onCollapseItem.dispose(), this._onDidCollapseItem.dispose(), this._onDidAddTraitItem.dispose(), this._onDidRemoveTraitItem.dispose(), this._onDidRefreshItem.dispose(), this._onRefreshItemChildren.dispose(), this._onDidRefreshItemChildren.dispose(), this._isDisposed = !0
        }, e.prototype.isDisposed = function () {
          return this._isDisposed
        }, e;
      } )();

      const g = ( () => {
        function e( e, t, n, i, o ) {
          this._onDidCreate = new c.a, this._onDidReveal = new c.a, this.onDidReveal = this._onDidReveal.event, this._onExpand = new c.a, this.onExpand = this._onExpand.event, this._onDidExpand = new c.a, this.onDidExpand = this._onDidExpand.event, this._onCollapse = new c.a, this.onCollapse = this._onCollapse.event, this._onDidCollapse = new c.a, this.onDidCollapse = this._onDidCollapse.event, this._onDidAddTrait = new c.a, this.onDidAddTrait = this._onDidAddTrait.event, this._onDidRemoveTrait = new c.a, this.onDidRemoveTrait = this._onDidRemoveTrait.event, this._onDidRefresh = new c.a, this.onDidRefresh = this._onDidRefresh.event, this._onRefreshChildren = new c.a, this.onRefreshChildren = this._onRefreshChildren.event, this._onDidRefreshChildren = new c.a, this.onDidRefreshChildren = this._onDidRefreshChildren.event, this._onDidDispose = new c.a, this.onDidDispose = this._onDidDispose.event, this.registry = t, this.context = n, this.lock = i, this.element = o, this.id = e, this.registry.register( this ), this.doesHaveChildren = this.context.dataSource.hasChildren( this.context.tree, this.element ), this.needsChildrenRefresh = !0, this.parent = null, this.previous = null, this.next = null, this.firstChild = null, this.lastChild = null, this.traits = {}, this.depth = 0, this.expanded = this.context.dataSource.shouldAutoexpand && this.context.dataSource.shouldAutoexpand( this.context.tree, o ), this._onDidCreate.fire( this ), this.visible = this._isVisible(), this.height = this._getHeight(), this._isDisposed = !1
        }
        return e.prototype.getElement = function () {
          return this.element
        }, e.prototype.hasChildren = function () {
          return this.doesHaveChildren
        }, e.prototype.getDepth = function () {
          return this.depth
        }, e.prototype.isVisible = function () {
          return this.visible
        }, e.prototype.setVisible = function ( e ) {
          this.visible = e
        }, e.prototype.isExpanded = function () {
          return this.expanded
        }, e.prototype._setExpanded = function ( e ) {
          this.expanded = e
        }, e.prototype.reveal = function ( e ) {
          void 0 === e && ( e = null );
          const t = {
            item: this,
            relativeTop: e
          };
          this._onDidReveal.fire( t )
        }, e.prototype.expand = function () {
          const e = this;
          return this.isExpanded() || !this.doesHaveChildren || this.lock.isLocked( this ) ? l.b.as( !1 ) : this.lock.run( this, ( () => {
            const t = {
              item: e
            };
            return e._onExpand.fire( t ), ( e.needsChildrenRefresh ? e.refreshChildren( !1, !0, !0 ) : l.b.as( null ) ).then( ( () => {
              return e._setExpanded( !0 ), e._onDidExpand.fire( t ), !0
            } ) );
          } ) ).then( ( t => {
            return !e.isDisposed() && ( e.context.options.autoExpandSingleChildren && t && null !== e.firstChild && e.firstChild === e.lastChild && e.firstChild.isVisible() ? e.firstChild.expand().then( ( () => {
              return !0
            } ) ) : t );
          } ) );
        }, e.prototype.collapse = function ( e ) {
          const t = this;
          if ( void 0 === e && ( e = !1 ), e ) {
            let n = l.b.as( null );
            return this.forEachChild( ( e => {
              n = n.then( ( () => {
                return e.collapse( !0 )
              } ) )
            } ) ), n.then( ( () => {
              return t.collapse( !1 )
            } ) );
          }
          return !this.isExpanded() || this.lock.isLocked( this ) ? l.b.as( !1 ) : this.lock.run( this, ( () => {
            const e = {
              item: t
            };
            return t._onCollapse.fire( e ), t._setExpanded( !1 ), t._onDidCollapse.fire( e ), l.b.as( !0 )
          } ) );
        }, e.prototype.addTrait = function ( e ) {
          const t = {
            item: this,
            trait: e
          };
          this.traits[ e ] = !0, this._onDidAddTrait.fire( t )
        }, e.prototype.removeTrait = function ( e ) {
          const t = {
            item: this,
            trait: e
          };
          delete this.traits[ e ], this._onDidRemoveTrait.fire( t )
        }, e.prototype.hasTrait = function ( e ) {
          return this.traits[ e ] || !1
        }, e.prototype.getAllTraits = function () {
          let e;
          const t = [];
          for ( e in this.traits ) this.traits.hasOwnProperty( e ) && this.traits[ e ] && t.push( e );
          return t
        }, e.prototype.getHeight = function () {
          return this.height
        }, e.prototype.refreshChildren = function ( t, n, i ) {
          const o = this;
          if ( void 0 === n && ( n = !1 ), void 0 === i && ( i = !1 ), !i && !this.isExpanded() ) return this.needsChildrenRefresh = !0, l.b.as( this );
          this.needsChildrenRefresh = !1;
          const r = () => {
            const i = {
              item: o,
              isNested: n
            };
            return o._onRefreshChildren.fire( i ), ( o.doesHaveChildren ? o.context.dataSource.getChildren( o.context.tree, o.element ) : l.b.as( [] ) ).then( ( n => {
              if ( o.isDisposed() || o.registry.isDisposed() ) return l.b.as( null );
              if ( !Array.isArray( n ) ) return l.b.wrapError( new Error( "Please return an array of children." ) );
              n = n ? n.slice( 0 ) : [], n = o.sort( n );
              for ( var i = {}; null !== o.firstChild; ) i[ o.firstChild.id ] = o.firstChild, o.removeChild( o.firstChild );
              for ( let r = 0, s = n.length; r < s; r++ ) {
                const a = n[ r ],
                  u = o.context.dataSource.getId( o.context.tree, a ),
                  c = i[ u ] || new e( u, o.registry, o.context, o.lock, a );
                c.element = a, t && ( c.needsChildrenRefresh = t ), delete i[ u ], o.addChild( c )
              }
              for ( const d in i ) i.hasOwnProperty( d ) && i[ d ].dispose();
              return t ? l.a.join( o.mapEachChild( ( e => {
                return e.doRefresh( t, !0 )
              } ) ) ) : ( o.mapEachChild( ( e => {
                return e.updateVisibility()
              } ) ), l.b.as( null ) );
            } ) ).then( null, a.e ).then( ( () => {
              return o._onDidRefreshChildren.fire( i )
            } ) );
          };
          return n ? r() : this.lock.run( this, r )
        }, e.prototype.doRefresh = function ( e, t ) {
          return void 0 === t && ( t = !1 ), this.doesHaveChildren = this.context.dataSource.hasChildren( this.context.tree, this.element ), this.height = this._getHeight(), this.updateVisibility(), this._onDidRefresh.fire( this ), this.refreshChildren( e, t )
        }, e.prototype.updateVisibility = function () {
          this.setVisible( this._isVisible() )
        }, e.prototype.refresh = function ( e ) {
          return this.doRefresh( e )
        }, e.prototype.getNavigator = function () {
          return new _( this )
        }, e.prototype.intersects = function ( e ) {
          return this.isAncestorOf( e ) || e.isAncestorOf( this )
        }, e.prototype.isAncestorOf = function ( e ) {
          for ( ; e; ) {
            if ( e.id === this.id ) return !0;
            e = e.parent
          }
          return !1
        }, e.prototype.addChild = function ( e, t ) {
          void 0 === t && ( t = this.lastChild );
          const n = null === this.firstChild,
            i = null === t,
            o = t === this.lastChild;
          n ? ( this.firstChild = this.lastChild = e, e.next = e.previous = null ) : i ? ( this.firstChild.previous = e, e.next = this.firstChild, e.previous = null, this.firstChild = e ) : o ? ( this.lastChild.next = e, e.next = null, e.previous = this.lastChild, this.lastChild = e ) : ( e.previous = t, e.next = t.next, t.next.previous = e, t.next = e ), e.parent = this, e.depth = this.depth + 1
        }, e.prototype.removeChild = function ( e ) {
          const t = this.firstChild === e,
            n = this.lastChild === e;
          t && n ? this.firstChild = this.lastChild = null : t ? ( e.next.previous = null, this.firstChild = e.next ) : n ? ( e.previous.next = null, this.lastChild = e.previous ) : ( e.next.previous = e.previous, e.previous.next = e.next ), e.parent = null, e.depth = null
        }, e.prototype.forEachChild = function ( e ) {
          for ( let t, n = this.firstChild; n; ) t = n.next, e( n ), n = t
        }, e.prototype.mapEachChild = function ( e ) {
          const t = [];
          return this.forEachChild( ( n => {
            t.push( e( n ) )
          } ) ), t;
        }, e.prototype.sort = function ( e ) {
          const t = this;
          return this.context.sorter ? e.sort( ( ( e, n ) => {
            return t.context.sorter.compare( t.context.tree, e, n )
          } ) ) : e;
        }, e.prototype._getHeight = function () {
          return this.context.renderer.getHeight( this.context.tree, this.element )
        }, e.prototype._isVisible = function () {
          return this.context.filter.isVisible( this.context.tree, this.element )
        }, e.prototype.isDisposed = function () {
          return this._isDisposed
        }, e.prototype.dispose = function () {
          this.forEachChild( ( e => {
            return e.dispose()
          } ) ), this.parent = null, this.previous = null, this.next = null, this.firstChild = null, this.lastChild = null, this._onDidDispose.fire( this ), this.registry.deregister( this ), this._onDidCreate.dispose(), this._onDidReveal.dispose(), this._onExpand.dispose(), this._onDidExpand.dispose(), this._onCollapse.dispose(), this._onDidCollapse.dispose(), this._onDidAddTrait.dispose(), this._onDidRemoveTrait.dispose(), this._onDidRefresh.dispose(), this._onRefreshChildren.dispose(), this._onDidRefreshChildren.dispose(), this._onDidDispose.dispose(), this._isDisposed = !0
        }, e;
      } )();

      const m = ( e => {
        function t( t, n, i, o, r ) {
          return e.call( this, t, n, i, o, r ) || this
        }
        return d( t, e ), t.prototype.isVisible = () => {
          return !1
        }, t.prototype.setVisible = e => {}, t.prototype.isExpanded = () => {
          return !0
        }, t.prototype._setExpanded = e => {}, t.prototype._getHeight = () => {
          return 0
        }, t.prototype._isVisible = () => {
          return !1
        }, t;
      } )( g );
      const _ = ( () => {
        function e( e, t ) {
          void 0 === t && ( t = !0 ), this.item = e, this.start = t ? e : null
        }
        return e.lastDescendantOf = t => {
          return t ? t instanceof m ? e.lastDescendantOf( t.lastChild ) : t.isVisible() ? t.isExpanded() && null !== t.lastChild ? e.lastDescendantOf( t.lastChild ) : t : e.lastDescendantOf( t.previous ) : null
        }, e.prototype.current = function () {
          return this.item || null
        }, e.prototype.next = function () {
          if ( this.item )
            do {
              if ( ( this.item instanceof m || this.item.isVisible() && this.item.isExpanded() ) && this.item.firstChild ) this.item = this.item.firstChild;
              else if ( this.item === this.start ) this.item = null;
              else {
                for ( ; this.item && this.item !== this.start && !this.item.next; ) this.item = this.item.parent;
                this.item === this.start && ( this.item = null ), this.item = this.item ? this.item.next : null
              }
            } while ( this.item && !this.item.isVisible() );
          return this.item || null
        }, e.prototype.previous = function () {
          if ( this.item )
            do {
              const t = e.lastDescendantOf( this.item.previous );
              t ? this.item = t : this.item.parent && this.item.parent !== this.start && this.item.parent.isVisible() ? this.item = this.item.parent : this.item = null
            } while ( this.item && !this.item.isVisible() );
          return this.item || null
        }, e.prototype.parent = function () {
          if ( this.item ) {
            const e = this.item.parent;
            e && e !== this.start && e.isVisible() ? this.item = e : this.item = null
          }
          return this.item || null
        }, e.prototype.first = function () {
          return this.item = this.start, this.next(), this.item || null
        }, e.prototype.last = function () {
          return e.lastDescendantOf( this.start )
        }, e;
      } )();

      const v = ( () => {
        function e( e ) {
          this._onSetInput = new c.a, this.onSetInput = this._onSetInput.event, this._onDidSetInput = new c.a, this.onDidSetInput = this._onDidSetInput.event, this._onRefresh = new c.a, this.onRefresh = this._onRefresh.event, this._onDidRefresh = new c.a, this.onDidRefresh = this._onDidRefresh.event, this._onDidHighlight = new c.a, this.onDidHighlight = this._onDidHighlight.event, this._onDidSelect = new c.a, this.onDidSelect = this._onDidSelect.event, this._onDidFocus = new c.a, this.onDidFocus = this._onDidFocus.event, this._onDidRevealItem = new c.e, this.onDidRevealItem = this._onDidRevealItem.event, this._onExpandItem = new c.e, this.onExpandItem = this._onExpandItem.event, this._onDidExpandItem = new c.e, this.onDidExpandItem = this._onDidExpandItem.event, this._onCollapseItem = new c.e, this.onCollapseItem = this._onCollapseItem.event, this._onDidCollapseItem = new c.e, this.onDidCollapseItem = this._onDidCollapseItem.event, this._onDidAddTraitItem = new c.e, this.onDidAddTraitItem = this._onDidAddTraitItem.event, this._onDidRemoveTraitItem = new c.e, this.onDidRemoveTraitItem = this._onDidRemoveTraitItem.event, this._onDidRefreshItem = new c.e, this.onDidRefreshItem = this._onDidRefreshItem.event, this._onRefreshItemChildren = new c.e, this.onRefreshItemChildren = this._onRefreshItemChildren.event, this._onDidRefreshItemChildren = new c.e, this.onDidRefreshItemChildren = this._onDidRefreshItemChildren.event, this._onDidDisposeItem = new c.e, this.context = e, this.input = null, this.traitsToItems = {}
        }
        return e.prototype.setInput = function ( e ) {
          const t = this;
          let n = {
            item: this.input
          };
          this._onSetInput.fire( n ), this.setSelection( [] ), this.setFocus(), this.setHighlight(), this.lock = new p, this.input && this.input.dispose(), this.registry && ( this.registry.dispose(), this.registryDisposable.dispose() ), this.registry = new f, this._onDidRevealItem.input = this.registry.onDidRevealItem, this._onExpandItem.input = this.registry.onExpandItem, this._onDidExpandItem.input = this.registry.onDidExpandItem, this._onCollapseItem.input = this.registry.onCollapseItem, this._onDidCollapseItem.input = this.registry.onDidCollapseItem, this._onDidAddTraitItem.input = this.registry.onDidAddTraitItem, this._onDidRemoveTraitItem.input = this.registry.onDidRemoveTraitItem, this._onDidRefreshItem.input = this.registry.onDidRefreshItem, this._onRefreshItemChildren.input = this.registry.onRefreshItemChildren, this._onDidRefreshItemChildren.input = this.registry.onDidRefreshItemChildren, this._onDidDisposeItem.input = this.registry.onDidDisposeItem, this.registryDisposable = this.registry.onDidDisposeItem( ( e => {
            return e.getAllTraits().forEach( ( n => {
              return delete t.traitsToItems[ n ][ e.id ]
            } ) );
          } ) );
          const i = this.context.dataSource.getId( this.context.tree, e );
          return this.input = new m( i, this.registry, this.context, this.lock, e ), n = {
            item: this.input
          }, this._onDidSetInput.fire( n ), this.refresh( this.input )
        }, e.prototype.getInput = function () {
          return this.input ? this.input.getElement() : null
        }, e.prototype.refresh = function ( e, t ) {
          const n = this;
          void 0 === e && ( e = null ), void 0 === t && ( t = !0 );
          const i = this.getItem( e );
          if ( !i ) return l.b.as( null );
          const o = {
            item: i,
            recursive: t
          };
          return this._onRefresh.fire( o ), i.refresh( t ).then( ( () => {
            n._onDidRefresh.fire( o )
          } ) );
        }, e.prototype.expand = function ( e ) {
          const t = this.getItem( e );
          return t ? t.expand() : l.b.as( !1 )
        }, e.prototype.collapse = function ( e, t ) {
          void 0 === t && ( t = !1 );
          const n = this.getItem( e );
          return n ? n.collapse( t ) : l.b.as( !1 )
        }, e.prototype.toggleExpansion = function ( e, t ) {
          return void 0 === t && ( t = !1 ), this.isExpanded( e ) ? this.collapse( e, t ) : this.expand( e )
        }, e.prototype.isExpanded = function ( e ) {
          const t = this.getItem( e );
          return !!t && t.isExpanded()
        }, e.prototype.reveal = function ( e, t ) {
          const n = this;
          return void 0 === t && ( t = null ), this.resolveUnknownParentChain( e ).then( ( e => {
            let t = l.b.as( null );
            return e.forEach( ( e => {
              t = t.then( ( () => {
                return n.expand( e )
              } ) )
            } ) ), t;
          } ) ).then( ( () => {
            const i = n.getItem( e );
            if ( i ) return i.reveal( t )
          } ) );
        }, e.prototype.resolveUnknownParentChain = function ( e ) {
          const t = this;
          return this.context.dataSource.getParent( this.context.tree, e ).then( ( e => {
            return e ? t.resolveUnknownParentChain( e ).then( ( t => {
              return t.push( e ), t
            } ) ) : l.b.as( [] );
          } ) );
        }, e.prototype.setHighlight = function ( e, t ) {
          this.setTraits( "highlighted", e ? [ e ] : [] );
          const n = {
            highlight: this.getHighlight(),
            payload: t
          };
          this._onDidHighlight.fire( n )
        }, e.prototype.getHighlight = function ( e ) {
          const t = this.getElementsWithTrait( "highlighted", e );
          return 0 === t.length ? null : t[ 0 ]
        }, e.prototype.setSelection = function ( e, t ) {
          this.setTraits( "selected", e );
          const n = {
            selection: this.getSelection(),
            payload: t
          };
          this._onDidSelect.fire( n )
        }, e.prototype.getSelection = function ( e ) {
          return this.getElementsWithTrait( "selected", e )
        }, e.prototype.setFocus = function ( e, t ) {
          this.setTraits( "focused", e ? [ e ] : [] );
          const n = {
            focus: this.getFocus(),
            payload: t
          };
          this._onDidFocus.fire( n )
        }, e.prototype.getFocus = function ( e ) {
          const t = this.getElementsWithTrait( "focused", e );
          return 0 === t.length ? null : t[ 0 ]
        }, e.prototype.focusNext = function ( e, t ) {
          void 0 === e && ( e = 1 );
          for ( var n, i = this.getFocus() || this.input, o = this.getNavigator( i, !1 ), r = 0; r < e && ( n = o.next() ); r++ ) i = n;
          this.setFocus( i, t )
        }, e.prototype.focusPrevious = function ( e, t ) {
          void 0 === e && ( e = 1 );
          for ( var n, i = this.getFocus() || this.input, o = this.getNavigator( i, !1 ), r = 0; r < e && ( n = o.previous() ); r++ ) i = n;
          this.setFocus( i, t )
        }, e.prototype.focusParent = function ( e ) {
          const t = this.getFocus() || this.input,
            n = this.getNavigator( t, !1 ).parent();
          n && this.setFocus( n, e )
        }, e.prototype.focusFirstChild = function ( e ) {
          const t = this.getItem( this.getFocus() || this.input ),
            n = this.getNavigator( t, !1 ),
            i = n.next();
          n.parent() === t && this.setFocus( i, e )
        }, e.prototype.focusFirst = function ( e, t ) {
          this.focusNth( 0, e, t )
        }, e.prototype.focusNth = function ( e, t, n ) {
          for ( var i = this.getParent( n ), o = this.getNavigator( i ), r = o.first(), s = 0; s < e; s++ ) r = o.next();
          r && this.setFocus( r, t )
        }, e.prototype.focusLast = function ( e, t ) {
          let n;
          const i = this.getParent( t );
          t ? n = i.lastChild : n = this.getNavigator( i ).last();
          n && this.setFocus( n, e )
        }, e.prototype.getParent = function ( e ) {
          if ( e ) {
            const t = this.getItem( e );
            if ( t && t.parent ) return t.parent
          }
          return this.getItem( this.input )
        }, e.prototype.getNavigator = function ( e, t ) {
          return void 0 === e && ( e = null ), void 0 === t && ( t = !0 ), new _( this.getItem( e ), t )
        }, e.prototype.getItem = function ( e ) {
          return void 0 === e && ( e = null ), null === e ? this.input : e instanceof g ? e : "string" === typeof e ? this.registry.getItem( e ) : this.registry.getItem( this.context.dataSource.getId( this.context.tree, e ) )
        }, e.prototype.removeTraits = function ( e, t ) {
          let n;
          let i;
          const o = this.traitsToItems[ e ] || {};
          if ( 0 === t.length ) {
            for ( i in o ) o.hasOwnProperty( i ) && ( n = o[ i ] ).removeTrait( e );
            delete this.traitsToItems[ e ]
          } else
            for ( let r = 0, s = t.length; r < s; r++ )( n = this.getItem( t[ r ] ) ) && ( n.removeTrait( e ), delete o[ n.id ] )
        }, e.prototype.setTraits = function ( e, t ) {
          if ( 0 === t.length ) this.removeTraits( e, t );
          else {
            for ( var n, i = {}, o = 0, r = t.length; o < r; o++ )( n = this.getItem( t[ o ] ) ) && ( i[ n.id ] = n );
            let s;
            const a = this.traitsToItems[ e ] || {};
            const u = [];
            for ( s in a ) a.hasOwnProperty( s ) && ( i.hasOwnProperty( s ) ? delete i[ s ] : u.push( a[ s ] ) );
            for ( o = 0, r = u.length; o < r; o++ )( n = u[ o ] ).removeTrait( e ), delete a[ n.id ];
            for ( s in i ) i.hasOwnProperty( s ) && ( ( n = i[ s ] ).addTrait( e ), a[ s ] = n );
            this.traitsToItems[ e ] = a
          }
        }, e.prototype.getElementsWithTrait = function ( e, t ) {
          let n;
          const i = [];
          const o = this.traitsToItems[ e ] || {};
          for ( n in o ) o.hasOwnProperty( n ) && ( o[ n ].isVisible() || t ) && i.push( o[ n ].getElement() );
          return i
        }, e.prototype.dispose = function () {
          this.registry && ( this.registry.dispose(), this.registry = null ), this._onSetInput.dispose(), this._onDidSetInput.dispose(), this._onRefresh.dispose(), this._onDidRefresh.dispose(), this._onDidHighlight.dispose(), this._onDidSelect.dispose(), this._onDidFocus.dispose(), this._onDidRevealItem.dispose(), this._onExpandItem.dispose(), this._onDidExpandItem.dispose(), this._onCollapseItem.dispose(), this._onDidCollapseItem.dispose(), this._onDidAddTraitItem.dispose(), this._onDidRemoveTraitItem.dispose(), this._onDidRefreshItem.dispose(), this._onRefreshItemChildren.dispose(), this._onDidRefreshItemChildren.dispose(), this._onDidDisposeItem.dispose()
        }, e;
      } )();

      const y = n( "MNsG" );
      const b = n( "D3Dy" );
      const C = n( "EffR" );
      const w = n( "Gw4z" );
      const S = n( "pg8w" );
      const O = n( "N0LK" );
      const L = n( "XSiN" );
      const x = n( "uDWl" );
      const N = ( () => {
        function e( e ) {
          this.elements = e
        }
        return e.prototype.update = e => {}, e;
      } )();
      const E = ( () => {
        function e( e ) {
          this.elements = e
        }
        return e.prototype.update = e => {}, e;
      } )();
      const k = ( () => {
        function e() {
          this.types = [], this.files = []
        }
        return e.prototype.update = function ( e ) {
          e.dataTransfer.types && ( this.types = [], Array.prototype.push.apply( this.types, e.dataTransfer.types ) ), e.dataTransfer.files && ( this.files = [], Array.prototype.push.apply( this.files, e.dataTransfer.files ), this.files = this.files.filter( ( e => {
            return e.size || e.type
          } ) ) )
        }, e;
      } )();
      const I = n( "JYp7" );
      const D = n( "GJhM" );
      const M = n( "QuOb" );
      const T = ( () => {
        function e() {
          this.heightMap = [], this.indexes = {}
        }
        return e.prototype.getContentHeight = function () {
          const e = this.heightMap[ this.heightMap.length - 1 ];
          return e ? e.top + e.height : 0
        }, e.prototype.onInsertItems = function ( e, t ) {
          let n, i, o, r, s;
          void 0 === t && ( t = null );
          let a = 0;
          if ( null === t ) o = 0, s = 0;
          else {
            if ( o = this.indexes[ t ] + 1, !( i = this.heightMap[ o - 1 ] ) ) return void console.error( "view item doesnt exist" );
            s = i.top + i.height
          }
          for ( var u = this.heightMap.splice.bind( this.heightMap, o, 0 ), l = []; n = e.next(); )( i = this.createViewItem( n ) ).top = s + a, this.indexes[ n.id ] = o++, l.push( i ), a += i.height;
          for ( u.apply( this.heightMap, l ), r = o; r < this.heightMap.length; r++ )( i = this.heightMap[ r ] ).top += a, this.indexes[ i.model.id ] = r;
          for ( r = l.length - 1; r >= 0; r-- ) this.onInsertItem( l[ r ] );
          for ( r = this.heightMap.length - 1; r >= o; r-- ) this.onRefreshItem( this.heightMap[ r ] );
          return a
        }, e.prototype.onInsertItem = e => {}, e.prototype.onRemoveItems = function ( e ) {
          for ( var t, n, i, o = null, r = 0; t = e.next(); ) {
            if ( i = this.indexes[ t ], !( n = this.heightMap[ i ] ) ) return void console.error( "view item doesnt exist" );
            r -= n.height, delete this.indexes[ t ], this.onRemoveItem( n ), null === o && ( o = i )
          }
          if ( 0 !== r )
            for ( this.heightMap.splice( o, i - o + 1 ), i = o; i < this.heightMap.length; i++ )( n = this.heightMap[ i ] ).top += r, this.indexes[ n.model.id ] = i, this.onRefreshItem( n )
        }, e.prototype.onRemoveItem = e => {}, e.prototype.onRefreshItemSet = function ( e ) {
          const t = this,
            n = e.sort( ( ( e, n ) => {
              return t.indexes[ e.id ] - t.indexes[ n.id ]
            } ) );
          this.onRefreshItems( new I.a( n ) )
        }, e.prototype.onRefreshItems = function ( e ) {
          for ( var t, n, i, o, r = null, s = 0; t = e.next(); ) {
            for ( o = this.indexes[ t.id ]; 0 !== s && null !== r && r < o; r++ )( n = this.heightMap[ r ] ).top += s, this.onRefreshItem( n );
            n = this.heightMap[ o ], i = t.getHeight(), n.top += s, s += i - n.height, n.height = i, this.onRefreshItem( n, !0 ), r = o + 1
          }
          if ( 0 !== s && null !== r )
            for ( ; r < this.heightMap.length; r++ )( n = this.heightMap[ r ] ).top += s, this.onRefreshItem( n )
        }, e.prototype.onRefreshItem = ( e, t ) => {
          void 0 === t && ( t = !1 )
        }, e.prototype.indexAt = function ( e ) {
          for ( let t, n, i = 0, o = this.heightMap.length; i < o; )
            if ( t = Math.floor( ( i + o ) / 2 ), e < ( n = this.heightMap[ t ] ).top ) o = t;
            else {
              if ( !( e >= n.top + n.height ) ) return t;
              if ( i === t ) break;
              i = t
            } return this.heightMap.length
        }, e.prototype.indexAfter = function ( e ) {
          return Math.min( this.indexAt( e ) + 1, this.heightMap.length )
        }, e.prototype.itemAtIndex = function ( e ) {
          return this.heightMap[ e ]
        }, e.prototype.itemAfter = function ( e ) {
          return this.heightMap[ this.indexes[ e.model.id ] + 1 ] || null
        }, e.prototype.createViewItem = e => {
          throw new Error( "not implemented" )
        }, e.prototype.dispose = function () {
          this.heightMap = null, this.indexes = null
        }, e;
      } )();
      const R = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const P = ( () => {
        function e( e, t, n ) {
          this._posx = e, this._posy = t, this._target = n
        }
        return e.prototype.preventDefault = () => {}, e.prototype.stopPropagation = () => {}, Object.defineProperty( e.prototype, "target", {
          get() {
            return this._target
          },
          enumerable: !0,
          configurable: !0
        } ), e;
      } )();
      const A = ( e => {
        function t( t ) {
          const n = e.call( this, t.posx, t.posy, t.target ) || this;
          return n.originalEvent = t, n
        }
        return R( t, e ), t.prototype.preventDefault = function () {
          this.originalEvent.preventDefault()
        }, t.prototype.stopPropagation = function () {
          this.originalEvent.stopPropagation()
        }, t
      } )( P );
      const F = ( e => {
        function t( t, n, i ) {
          const o = e.call( this, t, n, i.target ) || this;
          return o.originalEvent = i, o
        }
        return R( t, e ), t.prototype.preventDefault = function () {
          this.originalEvent.preventDefault()
        }, t.prototype.stopPropagation = function () {
          this.originalEvent.stopPropagation()
        }, t
      } )( P );
      !( e => {
        e[ e.COPY = 0 ] = "COPY", e[ e.MOVE = 1 ] = "MOVE"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.BUBBLE_DOWN = 0 ] = "BUBBLE_DOWN", e[ e.BUBBLE_UP = 1 ] = "BUBBLE_UP"
      } )( o || ( o = {} ) );
      const W = "ResourceURLs",
        j = n( "X+cX" ),
        V = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )();
      const B = ( () => {
          function e( e ) {
            this.context = e, this._cache = {
              "": []
            }
          }
          return e.prototype.alloc = function ( e ) {
            let t = this.cache( e ).pop();
            if ( !t ) {
              const n = document.createElement( "div" );
              n.className = "content";
              const i = document.createElement( "div" );
              i.appendChild( n ), t = {
                element: i,
                templateId: e,
                templateData: this.context.renderer.renderTemplate( this.context.tree, e, n )
              }
            }
            return t
          }, e.prototype.release = function ( e, t ) {
            !( e => {
              try {
                e.parentElement.removeChild( e )
              } catch ( t ) {}
            } )( t.element ), this.cache( e ).push( t )
          }, e.prototype.cache = function ( e ) {
            return this._cache[ e ] || ( this._cache[ e ] = [] )
          }, e.prototype.garbageCollect = function () {
            const e = this;
            this._cache && Object.keys( this._cache ).forEach( ( t => {
              e._cache[ t ].forEach( ( n => {
                e.context.renderer.disposeTemplate( e.context.tree, t, n.templateData ), n.element = null, n.templateData = null
              } ) ), delete e._cache[ t ]
            } ) )
          }, e.prototype.dispose = function () {
            this.garbageCollect(), this._cache = null, this.context = null
          }, e;
        } )(),
        H = ( () => {
          function e( e, t ) {
            const n = this;
            this.width = 0, this.context = e, this.model = t, this.id = this.model.id, this.row = null, this.top = 0, this.height = t.getHeight(), this._styles = {}, t.getAllTraits().forEach( ( e => {
              return n._styles[ e ] = !0
            } ) ), t.isExpanded() && this.addClass( "expanded" )
          }
          return Object.defineProperty( e.prototype, "expanded", {
            set( e ) {
              e ? this.addClass( "expanded" ) : this.removeClass( "expanded" )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "loading", {
            set( e ) {
              e ? this.addClass( "loading" ) : this.removeClass( "loading" )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "draggable", {
            get() {
              return this._draggable
            },
            set( e ) {
              this._draggable = e, this.render( !0 )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "dropTarget", {
            set( e ) {
              e ? this.addClass( "drop-target" ) : this.removeClass( "drop-target" )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "element", {
            get() {
              return this.row && this.row.element
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "templateId", {
            get() {
              return this._templateId || ( this._templateId = this.context.renderer.getTemplateId && this.context.renderer.getTemplateId( this.context.tree, this.model.getElement() ) )
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.addClass = function ( e ) {
            this._styles[ e ] = !0, this.render( !0 )
          }, e.prototype.removeClass = function ( e ) {
            delete this._styles[ e ], this.render( !0 )
          }, e.prototype.render = function ( e ) {
            const t = this;
            if ( void 0 === e && ( e = !1 ), this.model && this.element ) {
              const n = [ "monaco-tree-row" ];
              n.push.apply( n, Object.keys( this._styles ) ), this.model.hasChildren() && n.push( "has-children" ), this.element.className = n.join( " " ), this.element.draggable = this.draggable, this.element.style.height = this.height + "px", this.element.setAttribute( "role", "treeitem" );
              const i = this.context.accessibilityProvider,
                o = i.getAriaLabel( this.context.tree, this.model.getElement() );
              if ( o && this.element.setAttribute( "aria-label", o ), i.getPosInSet && i.getSetSize && ( this.element.setAttribute( "aria-setsize", i.getSetSize() ), this.element.setAttribute( "aria-posinset", i.getPosInSet( this.context.tree, this.model.getElement() ) ) ), this.model.hasTrait( "focused" ) ) {
                const r = O.safeBtoa( this.model.id );
                this.element.setAttribute( "aria-selected", "true" ), this.element.setAttribute( "id", r )
              } else this.element.setAttribute( "aria-selected", "false" ), this.element.removeAttribute( "id" );
              this.model.hasChildren() ? this.element.setAttribute( "aria-expanded", String( !!this._styles.expanded ) ) : this.element.removeAttribute( "aria-expanded" ), this.element.setAttribute( "aria-level", String( this.model.getDepth() ) ), this.context.options.paddingOnRow ? this.element.style.paddingLeft = this.context.options.twistiePixels + ( this.model.getDepth() - 1 ) * this.context.options.indentPixels + "px" : ( this.element.style.paddingLeft = ( this.model.getDepth() - 1 ) * this.context.options.indentPixels + "px", this.row.element.firstElementChild.style.paddingLeft = this.context.options.twistiePixels + "px" );
              const s = this.context.dnd.getDragURI( this.context.tree, this.model.getElement() );
              if ( s !== this.uri && ( this.unbindDragStart && ( this.unbindDragStart.dispose(), this.unbindDragStart = null ), s ? ( this.uri = s, this.draggable = !0, this.unbindDragStart = C.g( this.element, "dragstart", ( e => {
                  t.onDragStart( e )
                } ) ) ) : this.uri = null ), !e && this.element ) {
                const a = window.getComputedStyle( this.element ),
                  u = parseFloat( a.paddingLeft );
                this.context.horizontalScrolling && ( this.element.style.width = "fit-content" ), this.context.renderer.renderElement( this.context.tree, this.model.getElement(), this.templateId, this.row.templateData ), this.context.horizontalScrolling && ( this.width = C.t( this.element ) + u, this.element.style.width = "" )
              }
            }
          }, e.prototype.insertInDOM = function ( e, t ) {
            if ( this.row || ( this.row = this.context.cache.alloc( this.templateId ), this.element[ U.BINDING ] = this ), !this.element.parentElement ) {
              if ( null === t ) e.appendChild( this.element );
              else try {
                e.insertBefore( this.element, t )
              } catch ( n ) {
                console.warn( "Failed to locate previous tree element" ), e.appendChild( this.element )
              }
              this.render()
            }
          }, e.prototype.removeFromDOM = function () {
            this.row && ( this.unbindDragStart && ( this.unbindDragStart.dispose(), this.unbindDragStart = null ), this.uri = null, this.element[ U.BINDING ] = null, this.context.cache.release( this.templateId, this.row ), this.row = null )
          }, e.prototype.dispose = function () {
            this.row = null, this.model = null
          }, e;
        } )(),
        z = ( e => {
          function t( t, n, i ) {
            const o = e.call( this, t, n ) || this;
            return o.row = {
              element: i,
              templateData: null,
              templateId: null
            }, o
          }
          return V( t, e ), t.prototype.render = function () {
            if ( this.model && this.element ) {
              const e = [ "monaco-tree-wrapper" ];
              e.push.apply( e, Object.keys( this._styles ) ), this.model.hasChildren() && e.push( "has-children" ), this.element.className = e.join( " " )
            }
          }, t.prototype.insertInDOM = ( e, t ) => {}, t.prototype.removeFromDOM = () => {}, t;
        } )( H );

      var U = ( e => {
        function t( n, i ) {
          const o = e.call( this ) || this;
          o.lastClickTimeStamp = 0, o.contentWidthUpdateDelayer = new j.a( 50 ), o.isRefreshing = !1, o.refreshingPreviousChildrenIds = {}, o._onDOMFocus = new c.a, o._onDOMBlur = new c.a, o._onDidScroll = new c.a, t.counter++, o.instance = t.counter;
          const s = "undefined" === typeof n.options.horizontalScrollMode ? M.b.Hidden : n.options.horizontalScrollMode;
          o.horizontalScrolling = s !== M.b.Hidden, o.context = {
            dataSource: n.dataSource,
            renderer: n.renderer,
            controller: n.controller,
            dnd: n.dnd,
            filter: n.filter,
            sorter: n.sorter,
            tree: n.tree,
            accessibilityProvider: n.accessibilityProvider,
            options: n.options,
            cache: new B( n ),
            horizontalScrolling: o.horizontalScrolling
          }, o.modelListeners = [], o.viewListeners = [], o.model = null, o.items = {}, o.domNode = document.createElement( "div" ), o.domNode.className = "monaco-tree no-focused-item monaco-tree-instance-" + o.instance, o.domNode.tabIndex = n.options.preventRootFocus ? -1 : 0, o.styleElement = C.o( o.domNode ), o.treeStyler = n.styler, o.treeStyler || ( o.treeStyler = new r.f( o.styleElement, "monaco-tree-instance-" + o.instance ) ), o.domNode.setAttribute( "role", "tree" ), o.context.options.ariaLabel && o.domNode.setAttribute( "aria-label", o.context.options.ariaLabel ), o.context.options.alwaysFocused && C.f( o.domNode, "focused" ), o.context.options.paddingOnRow || C.f( o.domNode, "no-row-padding" ), o.wrapper = document.createElement( "div" ), o.wrapper.className = "monaco-tree-wrapper", o.scrollableElement = new D.b( o.wrapper, {
            alwaysConsumeMouseWheel: !0,
            horizontal: s,
            vertical: "undefined" !== typeof n.options.verticalScrollMode ? n.options.verticalScrollMode : M.b.Auto,
            useShadows: n.options.useShadows
          } ), o.scrollableElement.onScroll( ( e => {
            o.render( e.scrollTop, e.height, e.scrollLeft, e.width, e.scrollWidth ), o._onDidScroll.fire()
          } ) ), b.k ? ( o.wrapper.style.msTouchAction = "none", o.wrapper.style.msContentZooming = "none" ) : S.b.addTarget( o.wrapper ), o.rowsContainer = document.createElement( "div" ), o.rowsContainer.className = "monaco-tree-rows", n.options.showTwistie && ( o.rowsContainer.className += " show-twisties" );
          const a = C.O( o.domNode );
          return o.viewListeners.push( a.onDidFocus( ( () => {
            return o.onFocus()
          } ) ) ), o.viewListeners.push( a.onDidBlur( ( () => {
            return o.onBlur()
          } ) ) ), o.viewListeners.push( a ), o.viewListeners.push( C.g( o.domNode, "keydown", ( e => {
            return o.onKeyDown( e )
          } ) ) ), o.viewListeners.push( C.g( o.domNode, "keyup", ( e => {
            return o.onKeyUp( e )
          } ) ) ), o.viewListeners.push( C.g( o.domNode, "mousedown", ( e => {
            return o.onMouseDown( e )
          } ) ) ), o.viewListeners.push( C.g( o.domNode, "mouseup", ( e => {
            return o.onMouseUp( e )
          } ) ) ), o.viewListeners.push( C.g( o.wrapper, "click", ( e => {
            return o.onClick( e )
          } ) ) ), o.viewListeners.push( C.g( o.wrapper, "auxclick", ( e => {
            return o.onClick( e )
          } ) ) ), o.viewListeners.push( C.g( o.domNode, "contextmenu", ( e => {
            return o.onContextMenu( e )
          } ) ) ), o.viewListeners.push( C.g( o.wrapper, S.a.Tap, ( e => {
            return o.onTap( e )
          } ) ) ), o.viewListeners.push( C.g( o.wrapper, S.a.Change, ( e => {
            return o.onTouchChange( e )
          } ) ) ), b.k && ( o.viewListeners.push( C.g( o.wrapper, "MSPointerDown", ( e => {
            return o.onMsPointerDown( e )
          } ) ) ), o.viewListeners.push( C.g( o.wrapper, "MSGestureTap", ( e => {
            return o.onMsGestureTap( e )
          } ) ) ), o.viewListeners.push( C.i( o.wrapper, "MSGestureChange", ( e => {
            return o.onThrottledMsGestureChange( e )
          } ), ( ( e, t ) => {
            t.stopPropagation(), t.preventDefault();
            const n = {
              translationY: t.translationY,
              translationX: t.translationX
            };
            return e && ( n.translationY += e.translationY, n.translationX += e.translationX ), n
          } ) ) ) ), o.viewListeners.push( C.g( window, "dragover", ( e => {
            return o.onDragOver( e )
          } ) ) ), o.viewListeners.push( C.g( o.wrapper, "drop", ( e => {
            return o.onDrop( e )
          } ) ) ), o.viewListeners.push( C.g( window, "dragend", ( e => {
            return o.onDragEnd( e )
          } ) ) ), o.viewListeners.push( C.g( window, "dragleave", ( e => {
            return o.onDragOver( e )
          } ) ) ), o.wrapper.appendChild( o.rowsContainer ), o.domNode.appendChild( o.scrollableElement.getDomNode() ), i.appendChild( o.domNode ), o.lastRenderTop = 0, o.lastRenderHeight = 0, o.didJustPressContextMenuKey = !1, o.currentDropTarget = null, o.currentDropTargets = [], o.shouldInvalidateDropReaction = !1, o.dragAndDropScrollInterval = null, o.dragAndDropScrollTimeout = null, o.onHiddenScrollTop = null, o.onRowsChanged(), o.layout(), o.setupMSGesture(), o.applyStyles( n.options ), o;
        }
        return V( t, e ), Object.defineProperty( t.prototype, "onDOMFocus", {
          get() {
            return this._onDOMFocus.event
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.applyStyles = function ( e ) {
          this.treeStyler.style( e )
        }, t.prototype.createViewItem = function ( e ) {
          return new H( this.context, e )
        }, t.prototype.getHTMLElement = function () {
          return this.domNode
        }, t.prototype.focus = function () {
          this.domNode.focus()
        }, t.prototype.isFocused = function () {
          return document.activeElement === this.domNode
        }, t.prototype.blur = function () {
          this.domNode.blur()
        }, t.prototype.setupMSGesture = function () {
          const e = this;
          window.MSGesture && ( this.msGesture = new MSGesture, setTimeout( ( () => {
            return e.msGesture.target = e.wrapper
          } ), 100 ) )
        }, t.prototype.isTreeVisible = function () {
          return null === this.onHiddenScrollTop
        }, t.prototype.layout = function ( e, t ) {
          this.isTreeVisible() && ( this.viewHeight = e || C.s( this.wrapper ), this.scrollHeight = this.getContentHeight(), this.horizontalScrolling && ( this.viewWidth = t || C.t( this.wrapper ) ) )
        }, t.prototype.render = function ( e, t, n, i, o ) {
          let r;
          let s;
          const a = e;
          const u = e + t;
          const l = this.lastRenderTop + this.lastRenderHeight;
          for ( r = this.indexAfter( u ) - 1, s = this.indexAt( Math.max( l, a ) ); r >= s; r-- ) this.insertItemInDOM( this.itemAtIndex( r ) );
          for ( r = Math.min( this.indexAt( this.lastRenderTop ), this.indexAfter( u ) ) - 1, s = this.indexAt( a ); r >= s; r-- ) this.insertItemInDOM( this.itemAtIndex( r ) );
          for ( r = this.indexAt( this.lastRenderTop ), s = Math.min( this.indexAt( a ), this.indexAfter( l ) ); r < s; r++ ) this.removeItemFromDOM( this.itemAtIndex( r ) );
          for ( r = Math.max( this.indexAfter( u ), this.indexAt( this.lastRenderTop ) ), s = this.indexAfter( l ); r < s; r++ ) this.removeItemFromDOM( this.itemAtIndex( r ) );
          const c = this.itemAtIndex( this.indexAt( a ) );
          c && ( this.rowsContainer.style.top = c.top - a + "px" ), this.horizontalScrolling && ( this.rowsContainer.style.left = -n + "px", this.rowsContainer.style.width = Math.max( o, i ) + "px" ), this.lastRenderTop = a, this.lastRenderHeight = u - a
        }, t.prototype.setModel = function ( e ) {
          this.releaseModel(), this.model = e, this.model.onRefresh( this.onRefreshing, this, this.modelListeners ), this.model.onDidRefresh( this.onRefreshed, this, this.modelListeners ), this.model.onSetInput( this.onClearingInput, this, this.modelListeners ), this.model.onDidSetInput( this.onSetInput, this, this.modelListeners ), this.model.onDidFocus( this.onModelFocusChange, this, this.modelListeners ), this.model.onRefreshItemChildren( this.onItemChildrenRefreshing, this, this.modelListeners ), this.model.onDidRefreshItemChildren( this.onItemChildrenRefreshed, this, this.modelListeners ), this.model.onDidRefreshItem( this.onItemRefresh, this, this.modelListeners ), this.model.onExpandItem( this.onItemExpanding, this, this.modelListeners ), this.model.onDidExpandItem( this.onItemExpanded, this, this.modelListeners ), this.model.onCollapseItem( this.onItemCollapsing, this, this.modelListeners ), this.model.onDidRevealItem( this.onItemReveal, this, this.modelListeners ), this.model.onDidAddTraitItem( this.onItemAddTrait, this, this.modelListeners ), this.model.onDidRemoveTraitItem( this.onItemRemoveTrait, this, this.modelListeners )
        }, t.prototype.onRefreshing = function () {
          this.isRefreshing = !0
        }, t.prototype.onRefreshed = function () {
          this.isRefreshing = !1, this.onRowsChanged()
        }, t.prototype.onRowsChanged = function ( e ) {
          void 0 === e && ( e = this.scrollTop ), this.isRefreshing || ( this.scrollTop = e, this.updateScrollWidth() )
        }, t.prototype.updateScrollWidth = function () {
          const e = this;
          this.horizontalScrolling && this.contentWidthUpdateDelayer.trigger( ( () => {
            for ( var t = 0, n = 0, i = Object.keys( e.items ); n < i.length; n++ ) {
              const o = i[ n ];
              t = Math.max( t, e.items[ o ].width )
            }
            e.scrollWidth = t + 10
          } ) )
        }, t.prototype.focusNextPage = function ( e ) {
          const t = this;
          let n = this.indexAt( this.scrollTop + this.viewHeight );
          n = 0 === n ? 0 : n - 1;
          const i = this.itemAtIndex( n ).model.getElement();
          if ( this.model.getFocus() !== i ) this.model.setFocus( i, e );
          else {
            const o = this.scrollTop;
            this.scrollTop += this.viewHeight, this.scrollTop !== o && setTimeout( ( () => {
              t.focusNextPage( e )
            } ), 0 )
          }
        }, t.prototype.focusPreviousPage = function ( e ) {
          let t;
          const n = this;
          t = 0 === this.scrollTop ? this.indexAt( this.scrollTop ) : this.indexAfter( this.scrollTop - 1 );
          const i = this.itemAtIndex( t ).model.getElement();
          if ( this.model.getFocus() !== i ) this.model.setFocus( i, e );
          else {
            const o = this.scrollTop;
            this.scrollTop -= this.viewHeight, this.scrollTop !== o && setTimeout( ( () => {
              n.focusPreviousPage( e )
            } ), 0 )
          }
        }, Object.defineProperty( t.prototype, "viewHeight", {
          get() {
            return this.scrollableElement.getScrollDimensions().height
          },
          set( e ) {
            this.scrollableElement.setScrollDimensions( {
              height: e
            } )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( t.prototype, "scrollHeight", {
          set( e ) {
            this.scrollableElement.setScrollDimensions( {
              scrollHeight: e
            } )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( t.prototype, "viewWidth", {
          get() {
            return this.scrollableElement.getScrollDimensions().width
          },
          set( e ) {
            this.scrollableElement.setScrollDimensions( {
              width: e
            } )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( t.prototype, "scrollWidth", {
          set( e ) {
            this.scrollableElement.setScrollDimensions( {
              scrollWidth: e
            } )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( t.prototype, "scrollTop", {
          get() {
            return this.scrollableElement.getScrollPosition().scrollTop
          },
          set( e ) {
            this.scrollableElement.setScrollDimensions( {
              scrollHeight: this.getContentHeight()
            } ), this.scrollableElement.setScrollPosition( {
              scrollTop: e
            } )
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.onClearingInput = function ( e ) {
          const t = e.item;
          t && ( this.onRemoveItems( new I.c( t.getNavigator(), ( e => {
            return e && e.id
          } ) ) ), this.onRowsChanged() )
        }, t.prototype.onSetInput = function ( e ) {
          this.context.cache.garbageCollect(), this.inputItem = new z( this.context, e.item, this.wrapper )
        }, t.prototype.onItemChildrenRefreshing = function ( e ) {
          const n = e.item,
            i = this.items[ n.id ];
          if ( i && this.context.options.showLoading && ( i.loadingTimer = setTimeout( ( () => {
              i.loadingTimer = 0, i.loading = !0
            } ), t.LOADING_DECORATION_DELAY ) ), !e.isNested ) {
            for ( var o, r = [], s = n.getNavigator(); o = s.next(); ) r.push( o.id );
            this.refreshingPreviousChildrenIds[ n.id ] = r
          }
        }, t.prototype.onItemChildrenRefreshed = function ( e ) {
          const t = this,
            n = e.item,
            i = this.items[ n.id ];
          if ( i && ( i.loadingTimer && ( clearTimeout( i.loadingTimer ), i.loadingTimer = 0 ), i.loading = !1 ), !e.isNested ) {
            for ( var o, r = this.refreshingPreviousChildrenIds[ n.id ], s = [], a = n.getNavigator(); o = a.next(); ) s.push( o );
            const u = Math.abs( r.length - s.length ) > 1e3;
            let l = void 0;
            let c = void 0;
            if ( !u ) c = ( l = new w.a( {
              getLength() {
                return r.length
              },
              getElementAtIndex( e ) {
                return r[ e ]
              }
            }, {
              getLength() {
                return s.length
              },
              getElementAtIndex( e ) {
                return s[ e ].id
              }
            }, null ).ComputeDiff( !1 ) ).some( ( e => {
              if ( e.modifiedLength > 0 )
                for ( let n = e.modifiedStart, i = e.modifiedStart + e.modifiedLength; n < i; n++ )
                  if ( t.items.hasOwnProperty( s[ n ].id ) ) return !0;
              return !1
            } ) );
            if ( !u && !c && l.length < 50 )
              for ( let d = 0, h = l.length; d < h; d++ ) {
                const p = l[ d ];
                if ( p.originalLength > 0 && this.onRemoveItems( new I.a( r, p.originalStart, p.originalStart + p.originalLength ) ), p.modifiedLength > 0 ) {
                  let f = s[ p.modifiedStart - 1 ] || n;
                  f = f.getDepth() > 0 ? f : null, this.onInsertItems( new I.a( s, p.modifiedStart, p.modifiedStart + p.modifiedLength ), f ? f.id : null )
                }
              } else( u || l.length ) && ( this.onRemoveItems( new I.a( r ) ), this.onInsertItems( new I.a( s ), n.getDepth() > 0 ? n.id : null ) );
            ( u || l.length ) && this.onRowsChanged()
          }
        }, t.prototype.onItemRefresh = function ( e ) {
          this.onItemsRefresh( [ e ] )
        }, t.prototype.onItemsRefresh = function ( e ) {
          const t = this;
          this.onRefreshItemSet( e.filter( ( e => {
            return t.items.hasOwnProperty( e.id )
          } ) ) ), this.onRowsChanged()
        }, t.prototype.onItemExpanding = function ( e ) {
          const t = this.items[ e.item.id ];
          t && ( t.expanded = !0 )
        }, t.prototype.onItemExpanded = function ( e ) {
          const t = e.item,
            n = this.items[ t.id ];
          if ( n ) {
            n.expanded = !0;
            const i = this.onInsertItems( t.getNavigator(), t.id );
            let o = this.scrollTop;
            n.top + n.height <= this.scrollTop && ( o += i ), this.onRowsChanged( o )
          }
        }, t.prototype.onItemCollapsing = function ( e ) {
          const t = e.item,
            n = this.items[ t.id ];
          n && ( n.expanded = !1, this.onRemoveItems( new I.c( t.getNavigator(), ( e => {
            return e && e.id
          } ) ) ), this.onRowsChanged() )
        }, t.prototype.onItemReveal = function ( e ) {
          const t = e.item;
          let n = e.relativeTop;
          const i = this.items[ t.id ];
          if ( i )
            if ( null !== n ) {
              n = ( n = n < 0 ? 0 : n ) > 1 ? 1 : n;
              const o = i.height - this.viewHeight;
              this.scrollTop = o * n + i.top
            } else {
              const r = i.top + i.height,
                s = this.scrollTop + this.viewHeight;
              i.top < this.scrollTop ? this.scrollTop = i.top : r >= s && ( this.scrollTop = r - this.viewHeight )
            }
        }, t.prototype.onItemAddTrait = function ( e ) {
          const t = e.item,
            n = e.trait,
            i = this.items[ t.id ];
          i && i.addClass( n ), "highlighted" === n && ( C.f( this.domNode, n ), i && ( this.highlightedItemWasDraggable = !!i.draggable, i.draggable && ( i.draggable = !1 ) ) )
        }, t.prototype.onItemRemoveTrait = function ( e ) {
          const t = e.item,
            n = e.trait,
            i = this.items[ t.id ];
          i && i.removeClass( n ), "highlighted" === n && ( C.G( this.domNode, n ), this.highlightedItemWasDraggable && ( i.draggable = !0 ), this.highlightedItemWasDraggable = !1 )
        }, t.prototype.onModelFocusChange = function () {
          const e = this.model && this.model.getFocus();
          C.N( this.domNode, "no-focused-item", !e ), e ? this.domNode.setAttribute( "aria-activedescendant", O.safeBtoa( this.context.dataSource.getId( this.context.tree, e ) ) ) : this.domNode.removeAttribute( "aria-activedescendant" )
        }, t.prototype.onInsertItem = function ( e ) {
          const t = this;
          e.onDragStart = n => {
            t.onDragStart( e, n )
          }, e.needsRender = !0, this.refreshViewItem( e ), this.items[ e.id ] = e
        }, t.prototype.onRefreshItem = function ( e, t ) {
          void 0 === t && ( t = !1 ), e.needsRender = e.needsRender || t, this.refreshViewItem( e )
        }, t.prototype.onRemoveItem = function ( e ) {
          this.removeItemFromDOM( e ), e.dispose(), delete this.items[ e.id ]
        }, t.prototype.refreshViewItem = function ( e ) {
          e.render(), this.shouldBeRendered( e ) ? this.insertItemInDOM( e ) : this.removeItemFromDOM( e )
        }, t.prototype.onClick = function ( e ) {
          if ( !this.lastPointerType || "mouse" === this.lastPointerType ) {
            const t = new L.b( e ),
              n = this.getItemAround( t.target );
            n && ( b.k && Date.now() - this.lastClickTimeStamp < 300 && ( t.detail = 2 ), this.lastClickTimeStamp = Date.now(), this.context.controller.onClick( this.context.tree, n.model.getElement(), t ) )
          }
        }, t.prototype.onMouseDown = function ( e ) {
          if ( this.didJustPressContextMenuKey = !1, this.context.controller.onMouseDown && ( !this.lastPointerType || "mouse" === this.lastPointerType ) ) {
            const t = new L.b( e );
            if ( !( t.ctrlKey && y.e && y.d ) ) {
              const n = this.getItemAround( t.target );
              n && this.context.controller.onMouseDown( this.context.tree, n.model.getElement(), t )
            }
          }
        }, t.prototype.onMouseUp = function ( e ) {
          if ( this.context.controller.onMouseUp && ( !this.lastPointerType || "mouse" === this.lastPointerType ) ) {
            const t = new L.b( e );
            if ( !( t.ctrlKey && y.e && y.d ) ) {
              const n = this.getItemAround( t.target );
              n && this.context.controller.onMouseUp( this.context.tree, n.model.getElement(), t )
            }
          }
        }, t.prototype.onTap = function ( e ) {
          const t = this.getItemAround( e.initialTarget );
          t && this.context.controller.onTap( this.context.tree, t.model.getElement(), e )
        }, t.prototype.onTouchChange = function ( e ) {
          e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY
        }, t.prototype.onContextMenu = function ( e ) {
          let t, n;
          if ( e instanceof KeyboardEvent || this.didJustPressContextMenuKey ) {
            this.didJustPressContextMenuKey = !1;
            let i;
            const o = new x.a( e );
            if ( n = this.model.getFocus() ) {
              const r = this.context.dataSource.getId( this.context.tree, n ),
                s = this.items[ r ];
              i = C.u( s.element )
            } else n = this.model.getInput(), i = C.u( this.inputItem.element );
            t = new F( i.left + i.width, i.top, o )
          } else {
            const a = new L.b( e ),
              u = this.getItemAround( a.target );
            if ( !u ) return;
            n = u.model.getElement(), t = new A( a )
          }
          this.context.controller.onContextMenu( this.context.tree, n, t )
        }, t.prototype.onKeyDown = function ( e ) {
          const t = new x.a( e );
          this.didJustPressContextMenuKey = 58 === t.keyCode || t.shiftKey && 68 === t.keyCode, this.didJustPressContextMenuKey && ( t.preventDefault(), t.stopPropagation() ), t.target && t.target.tagName && "input" === t.target.tagName.toLowerCase() || this.context.controller.onKeyDown( this.context.tree, t )
        }, t.prototype.onKeyUp = function ( e ) {
          this.didJustPressContextMenuKey && this.onContextMenu( e ), this.didJustPressContextMenuKey = !1, this.context.controller.onKeyUp( this.context.tree, new x.a( e ) )
        }, t.prototype.onDragStart = function ( e, n ) {
          if ( !this.model.getHighlight() ) {
            let i;
            const o = e.model.getElement();
            const r = this.model.getSelection();
            if ( i = r.indexOf( o ) > -1 ? r : [ o ], n.dataTransfer.effectAllowed = "copyMove", n.dataTransfer.setData( W, JSON.stringify( [ e.uri ] ) ), n.dataTransfer.setDragImage ) {
              let s = void 0;
              s = this.context.dnd.getDragLabel ? this.context.dnd.getDragLabel( this.context.tree, i ) : String( i.length );
              const a = document.createElement( "div" );
              a.className = "monaco-tree-drag-image", a.textContent = s, document.body.appendChild( a ), n.dataTransfer.setDragImage( a, -10, -10 ), setTimeout( ( () => {
                return document.body.removeChild( a )
              } ), 0 )
            }
            this.currentDragAndDropData = new N( i ), t.currentExternalDragAndDropData = new E( i ), this.context.dnd.onDragStart( this.context.tree, this.currentDragAndDropData, new L.a( n ) )
          }
        }, t.prototype.setupDragAndDropScrollInterval = function () {
          const e = this,
            t = C.w( this.wrapper ).top;
          this.dragAndDropScrollInterval || ( this.dragAndDropScrollInterval = window.setInterval( ( () => {
            if ( void 0 !== e.dragAndDropMouseY ) {
              const n = e.dragAndDropMouseY - t;
              let i = 0;
              const o = e.viewHeight - 35;
              n < 35 ? i = Math.max( -14, .2 * ( n - 35 ) ) : n > o && ( i = Math.min( 14, .2 * ( n - o ) ) ), e.scrollTop += i
            }
          } ), 10 ), this.cancelDragAndDropScrollTimeout(), this.dragAndDropScrollTimeout = window.setTimeout( ( () => {
            e.cancelDragAndDropScrollInterval(), e.dragAndDropScrollTimeout = null
          } ), 1e3 ) )
        }, t.prototype.cancelDragAndDropScrollInterval = function () {
          this.dragAndDropScrollInterval && ( window.clearInterval( this.dragAndDropScrollInterval ), this.dragAndDropScrollInterval = null ), this.cancelDragAndDropScrollTimeout()
        }, t.prototype.cancelDragAndDropScrollTimeout = function () {
          this.dragAndDropScrollTimeout && ( window.clearTimeout( this.dragAndDropScrollTimeout ), this.dragAndDropScrollTimeout = null )
        }, t.prototype.onDragOver = function ( e ) {
          let n;
          const r = this;
          const s = new L.a( e );
          let a = this.getItemAround( s.target );
          if ( !a || 0 === s.posx && 0 === s.posy && s.browserEvent.type === C.d.DRAG_LEAVE ) return this.currentDropTarget && ( this.currentDropTargets.forEach( ( e => {
            return e.dropTarget = !1
          } ) ), this.currentDropTargets = [], this.currentDropPromise && ( this.currentDropPromise.cancel(), this.currentDropPromise = null ) ), this.cancelDragAndDropScrollInterval(), this.currentDropTarget = null, this.currentDropElement = null, this.dragAndDropMouseY = null, !1;
          if ( this.setupDragAndDropScrollInterval(), this.dragAndDropMouseY = s.posy, !this.currentDragAndDropData )
            if ( t.currentExternalDragAndDropData ) this.currentDragAndDropData = t.currentExternalDragAndDropData;
            else {
              if ( !s.dataTransfer.types ) return !1;
              this.currentDragAndDropData = new k
            } this.currentDragAndDropData.update( s );
          let u, c = a.model;
          do {
            if ( n = c ? c.getElement() : this.model.getInput(), !( u = this.context.dnd.onDragOver( this.context.tree, this.currentDragAndDropData, n, s ) ) || u.bubble !== o.BUBBLE_UP ) break;
            c = c && c.parent
          } while ( c );
          if ( !c ) return this.currentDropElement = null, !1;
          const d = u && u.accept;
          d ? ( this.currentDropElement = c.getElement(), s.preventDefault(), s.dataTransfer.dropEffect = u.effect === i.COPY ? "copy" : "move" ) : this.currentDropElement = null;
          let h;
          let p;
          const f = c.id === this.inputItem.id ? this.inputItem : this.items[ c.id ];
          if ( ( this.shouldInvalidateDropReaction || this.currentDropTarget !== f || ( h = this.currentDropElementReaction, p = u, !( !h && !p || h && p && h.accept === p.accept && h.bubble === p.bubble && h.effect === p.effect ) ) ) && ( this.shouldInvalidateDropReaction = !1, this.currentDropTarget && ( this.currentDropTargets.forEach( ( e => {
              return e.dropTarget = !1
            } ) ), this.currentDropTargets = [], this.currentDropPromise && ( this.currentDropPromise.cancel(), this.currentDropPromise = null ) ), this.currentDropTarget = f, this.currentDropElementReaction = u, d ) ) {
            if ( this.currentDropTarget && ( this.currentDropTarget.dropTarget = !0, this.currentDropTargets.push( this.currentDropTarget ) ), u.bubble === o.BUBBLE_DOWN )
              for ( let g, m = c.getNavigator(); g = m.next(); )( a = this.items[ g.id ] ) && ( a.dropTarget = !0, this.currentDropTargets.push( a ) );
            u.autoExpand && ( this.currentDropPromise = l.b.timeout( 500 ).then( ( () => {
              return r.context.tree.expand( r.currentDropElement )
            } ) ).then( ( () => {
              return r.shouldInvalidateDropReaction = !0
            } ) ) )
          }
          return !0
        }, t.prototype.onDrop = function ( e ) {
          if ( this.currentDropElement ) {
            const t = new L.a( e );
            t.preventDefault(), this.currentDragAndDropData.update( t ), this.context.dnd.drop( this.context.tree, this.currentDragAndDropData, this.currentDropElement, t ), this.onDragEnd( e )
          }
          this.cancelDragAndDropScrollInterval()
        }, t.prototype.onDragEnd = function ( e ) {
          this.currentDropTarget && ( this.currentDropTargets.forEach( ( e => {
            return e.dropTarget = !1
          } ) ), this.currentDropTargets = [] ), this.currentDropPromise && ( this.currentDropPromise.cancel(), this.currentDropPromise = null ), this.cancelDragAndDropScrollInterval(), this.currentDragAndDropData = null, t.currentExternalDragAndDropData = null, this.currentDropElement = null, this.currentDropTarget = null, this.dragAndDropMouseY = null
        }, t.prototype.onFocus = function () {
          this.context.options.alwaysFocused || C.f( this.domNode, "focused" ), this._onDOMFocus.fire()
        }, t.prototype.onBlur = function () {
          this.context.options.alwaysFocused || C.G( this.domNode, "focused" ), this.domNode.removeAttribute( "aria-activedescendant" ), this._onDOMBlur.fire()
        }, t.prototype.onMsPointerDown = function ( e ) {
          if ( this.msGesture ) {
            const t = e.pointerType;
            t !== ( e.MSPOINTER_TYPE_MOUSE || "mouse" ) ? t === ( e.MSPOINTER_TYPE_TOUCH || "touch" ) && ( this.lastPointerType = "touch", e.stopPropagation(), e.preventDefault(), this.msGesture.addPointer( e.pointerId ) ) : this.lastPointerType = "mouse"
          }
        }, t.prototype.onThrottledMsGestureChange = function ( e ) {
          this.scrollTop -= e.translationY
        }, t.prototype.onMsGestureTap = function ( e ) {
          e.initialTarget = document.elementFromPoint( e.clientX, e.clientY ), this.onTap( e )
        }, t.prototype.insertItemInDOM = function ( e ) {
          let t = null;
          const n = this.itemAfter( e );
          n && n.element && ( t = n.element ), e.insertInDOM( this.rowsContainer, t )
        }, t.prototype.removeItemFromDOM = e => {
          e && e.removeFromDOM()
        }, t.prototype.shouldBeRendered = function ( e ) {
          return e.top < this.lastRenderTop + this.lastRenderHeight && e.top + e.height > this.lastRenderTop
        }, t.prototype.getItemAround = function ( e ) {
          let n = this.inputItem;
          do {
            if ( e[ t.BINDING ] && ( n = e[ t.BINDING ] ), e === this.wrapper || e === this.domNode ) return n;
            if ( e === document.body ) return null
          } while ( e = e.parentElement )
        }, t.prototype.releaseModel = function () {
          this.model && ( this.modelListeners = u.d( this.modelListeners ), this.model = null )
        }, t.prototype.dispose = function () {
          const t = this;
          this.scrollableElement.dispose(), this.releaseModel(), this.modelListeners = null, this.viewListeners = u.d( this.viewListeners ), this._onDOMFocus.dispose(), this._onDOMBlur.dispose(), this.domNode.parentNode && this.domNode.parentNode.removeChild( this.domNode ), this.domNode = null, this.items && ( Object.keys( this.items ).forEach( ( e => {
            return t.items[ e ].removeFromDOM()
          } ) ), this.items = null ), this.context.cache && ( this.context.cache.dispose(), this.context.cache = null ), e.prototype.dispose.call( this )
        }, t.BINDING = "monaco-tree-row", t.LOADING_DECORATION_DELAY = 800, t.counter = 0, t.currentExternalDragAndDropData = null, t;
      } )( T );

      const K = n( "zrhQ" );
      const q = n( "qj0h" );
      n.d( t, "a", ( () => {
        return X
      } ) );
      const G = function ( e, t, n ) {
        if ( void 0 === n && ( n = {} ), this.tree = e, this.configuration = t, this.options = n, !t.dataSource ) throw new Error( "You must provide a Data Source to the tree." );
        this.dataSource = t.dataSource, this.renderer = t.renderer, this.controller = t.controller || new r.c( {
          clickBehavior: r.a.ON_MOUSE_UP,
          keyboardSupport: "boolean" !== typeof n.keyboardSupport || n.keyboardSupport
        } ), this.dnd = t.dnd || new r.d, this.filter = t.filter || new r.e, this.sorter = t.sorter || null, this.accessibilityProvider = t.accessibilityProvider || new r.b, this.styler = t.styler || null
      };
      const Y = {
        listFocusBackground: K.a.fromHex( "#073655" ),
        listActiveSelectionBackground: K.a.fromHex( "#0E639C" ),
        listActiveSelectionForeground: K.a.fromHex( "#FFFFFF" ),
        listFocusAndSelectionBackground: K.a.fromHex( "#094771" ),
        listFocusAndSelectionForeground: K.a.fromHex( "#FFFFFF" ),
        listInactiveSelectionBackground: K.a.fromHex( "#3F3F46" ),
        listHoverBackground: K.a.fromHex( "#2A2D2E" ),
        listDropBackground: K.a.fromHex( "#383B3D" )
      };
      var X = ( () => {
        function e( e, t, n ) {
          void 0 === n && ( n = {} ), this._onDidChangeFocus = new c.e, this.onDidChangeFocus = this._onDidChangeFocus.event, this._onDidChangeSelection = new c.e, this.onDidChangeSelection = this._onDidChangeSelection.event, this._onHighlightChange = new c.e, this._onDidExpandItem = new c.e, this._onDidCollapseItem = new c.e, this._onDispose = new c.a, this.onDidDispose = this._onDispose.event, this.container = e, Object( q.g )( n, Y, !1 ), n.twistiePixels = "number" === typeof n.twistiePixels ? n.twistiePixels : 32, n.showTwistie = !1 !== n.showTwistie, n.indentPixels = "number" === typeof n.indentPixels ? n.indentPixels : 12, n.alwaysFocused = !0 === n.alwaysFocused, n.useShadows = !1 !== n.useShadows, n.paddingOnRow = !1 !== n.paddingOnRow, n.showLoading = !1 !== n.showLoading, this.context = new G( this, t, n ), this.model = new v( this.context ), this.view = new U( this.context, this.container ), this.view.setModel( this.model ), this._onDidChangeFocus.input = this.model.onDidFocus, this._onDidChangeSelection.input = this.model.onDidSelect, this._onHighlightChange.input = this.model.onDidHighlight, this._onDidExpandItem.input = this.model.onDidExpandItem, this._onDidCollapseItem.input = this.model.onDidCollapseItem
        }
        return e.prototype.style = function ( e ) {
          this.view.applyStyles( e )
        }, Object.defineProperty( e.prototype, "onDidFocus", {
          get() {
            return this.view && this.view.onDOMFocus
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.getHTMLElement = function () {
          return this.view.getHTMLElement()
        }, e.prototype.layout = function ( e, t ) {
          this.view.layout( e, t )
        }, e.prototype.domFocus = function () {
          this.view.focus()
        }, e.prototype.isDOMFocused = function () {
          return this.view.isFocused()
        }, e.prototype.domBlur = function () {
          this.view.blur()
        }, e.prototype.setInput = function ( e ) {
          return this.model.setInput( e )
        }, e.prototype.getInput = function () {
          return this.model.getInput()
        }, e.prototype.refresh = function ( e, t ) {
          return void 0 === e && ( e = null ), void 0 === t && ( t = !0 ), this.model.refresh( e, t )
        }, e.prototype.expand = function ( e ) {
          return this.model.expand( e )
        }, e.prototype.collapse = function ( e, t ) {
          return void 0 === t && ( t = !1 ), this.model.collapse( e, t )
        }, e.prototype.toggleExpansion = function ( e, t ) {
          return void 0 === t && ( t = !1 ), this.model.toggleExpansion( e, t )
        }, e.prototype.isExpanded = function ( e ) {
          return this.model.isExpanded( e )
        }, e.prototype.reveal = function ( e, t ) {
          return void 0 === t && ( t = null ), this.model.reveal( e, t )
        }, e.prototype.getHighlight = function () {
          return this.model.getHighlight()
        }, e.prototype.clearHighlight = function ( e ) {
          this.model.setHighlight( null, e )
        }, e.prototype.setSelection = function ( e, t ) {
          this.model.setSelection( e, t )
        }, e.prototype.getSelection = function () {
          return this.model.getSelection()
        }, e.prototype.clearSelection = function ( e ) {
          this.model.setSelection( [], e )
        }, e.prototype.setFocus = function ( e, t ) {
          this.model.setFocus( e, t )
        }, e.prototype.getFocus = function () {
          return this.model.getFocus()
        }, e.prototype.focusNext = function ( e, t ) {
          this.model.focusNext( e, t )
        }, e.prototype.focusPrevious = function ( e, t ) {
          this.model.focusPrevious( e, t )
        }, e.prototype.focusParent = function ( e ) {
          this.model.focusParent( e )
        }, e.prototype.focusFirstChild = function ( e ) {
          this.model.focusFirstChild( e )
        }, e.prototype.focusFirst = function ( e, t ) {
          this.model.focusFirst( e, t )
        }, e.prototype.focusNth = function ( e, t ) {
          this.model.focusNth( e, t )
        }, e.prototype.focusLast = function ( e, t ) {
          this.model.focusLast( e, t )
        }, e.prototype.focusNextPage = function ( e ) {
          this.view.focusNextPage( e )
        }, e.prototype.focusPreviousPage = function ( e ) {
          this.view.focusPreviousPage( e )
        }, e.prototype.clearFocus = function ( e ) {
          this.model.setFocus( null, e )
        }, e.prototype.dispose = function () {
          this._onDispose.fire(), null !== this.model && ( this.model.dispose(), this.model = null ), null !== this.view && ( this.view.dispose(), this.view = null ), this._onDidChangeFocus.dispose(), this._onDidChangeSelection.dispose(), this._onHighlightChange.dispose(), this._onDidExpandItem.dispose(), this._onDidCollapseItem.dispose(), this._onDispose.dispose()
        }, e;
      } )();
    },
    "746U": function ( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return o
      } ) ), n.d( t, "h", ( () => {
        return r
      } ) ), n.d( t, "g", ( () => {
        return s
      } ) ), n.d( t, "f", ( () => {
        return a
      } ) ), n.d( t, "c", ( () => {
        return u
      } ) ), n.d( t, "i", ( () => {
        return l
      } ) ), n.d( t, "j", ( () => {
        return c
      } ) ), n.d( t, "d", ( () => {
        return h
      } ) ), n.d( t, "e", ( () => {
        return p
      } ) ), n.d( t, "k", ( () => {
        return f
      } ) ), n.d( t, "a", ( () => {
        return m
      } ) );
      const i = {
        number: "number",
        string: "string",
        undefined: "undefined",
        object: "object",
        function: "function"
      };

      function o( e ) {
        return Array.isArray ? Array.isArray( e ) : !( !e || typeof e.length !== i.number || e.constructor !== Array )
      }

      function r( e ) {
        return typeof e === i.string || e instanceof String
      }

      function s( e ) {
        return typeof e === i.object && null !== e && !Array.isArray( e ) && !( e instanceof RegExp ) && !( e instanceof Date )
      }

      function a( e ) {
        return ( typeof e === i.number || e instanceof Number ) && !isNaN( e )
      }

      function u( e ) {
        return !0 === e || !1 === e
      }

      function l( e ) {
        return typeof e === i.undefined
      }

      function c( e ) {
        return l( e ) || null === e
      }
      const d = Object.prototype.hasOwnProperty;

      function h( e ) {
        if ( !s( e ) ) return !1;
        for ( const t in e )
          if ( d.call( e, t ) ) return !1;
        return !0
      }

      function p( e ) {
        return typeof e === i.function
      }

      function f( e, t ) {
        for ( let n = Math.min( e.length, t.length ), i = 0; i < n; i++ ) g( e[ i ], t[ i ] )
      }

      function g( e, t ) {
        if ( r( t ) ) {
          if ( typeof e !== t ) throw new Error( "argument does not match constraint: typeof " + t )
        } else if ( p( t ) ) {
          if ( e instanceof t ) return;
          if ( !c( e ) && e.constructor === t ) return;
          if ( 1 === t.length && !0 === t.call( void 0, e ) ) return;
          throw new Error( "argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true" )
        }
      }

      function m( e ) {
        for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
        const i = Object.create( e.prototype );
        return e.apply( i, t ), i
      }
    },
    "7lZ/": function ( e, t, n ) {
      "use strict";
      const i = n( "EffR" ),
        o = n( "qj0h" ),
        r = n( "N0LK" );

      function s( e ) {
        return Object( r.escape )( e )
      }
      n.d( t, "a", ( () => {
        return a
      } ) );
      var a = ( () => {
        function e( e ) {
          this.domNode = document.createElement( "span" ), this.domNode.className = "monaco-highlighted-label", this.didEverRender = !1, e.appendChild( this.domNode )
        }
        return Object.defineProperty( e.prototype, "element", {
          get() {
            return this.domNode
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.set = function ( t, n, i, r ) {
          void 0 === n && ( n = [] ), void 0 === i && ( i = "" ), t || ( t = "" ), r && ( t = e.escapeNewLines( t, n ) ), this.didEverRender && this.text === t && this.title === i && o.e( this.highlights, n ) || ( Array.isArray( n ) || ( n = [] ), this.text = t, this.title = i, this.highlights = n, this.render() )
        }, e.prototype.render = function () {
          i.l( this.domNode );
          for ( var e, t = [], n = 0, o = 0; o < this.highlights.length; o++ )( e = this.highlights[ o ] ).end !== e.start && ( n < e.start && ( t.push( "<span>" ), t.push( s( this.text.substring( n, e.start ) ) ), t.push( "</span>" ), n = e.end ), t.push( '<span class="highlight">' ), t.push( s( this.text.substring( e.start, e.end ) ) ), t.push( "</span>" ), n = e.end );
          n < this.text.length && ( t.push( "<span>" ), t.push( s( this.text.substring( n ) ) ), t.push( "</span>" ) ), this.domNode.innerHTML = t.join( "" ), this.domNode.title = this.title, this.didEverRender = !0
        }, e.prototype.dispose = function () {
          this.text = null, this.highlights = null
        }, e.escapeNewLines = ( e, t ) => {
          let n = 0,
            i = 0;
          return e.replace( /\r\n|\r|\n/, ( ( e, o ) => {
            i = "\r\n" === e ? -1 : 0, o += n;
            for ( let r = 0, s = t; r < s.length; r++ ) {
              const a = s[ r ];
              a.end <= o || ( a.start >= o && ( a.start += i ), a.end >= o && ( a.end += i ) )
            }
            return n += i, "\u23ce"
          } ) );
        }, e;
      } )()
    },
    "7zd4": function ( e, t, n ) {},
    "8ATB": function ( e, t, n ) {},
    "8HAY": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return r
      } ) ), n.d( t, "b", ( () => {
        return s
      } ) );
      const i = n( "VMIq" );
      const o = n( "MI8n" );
      var r = ( () => {
        function e( e, t, n, i, r ) {
          void 0 === t && ( t = "" ), void 0 === n && ( n = "" ), void 0 === i && ( i = !0 ), this._onDidChange = new o.a, this._id = e, this._label = t, this._cssClass = n, this._enabled = i, this._actionCallback = r
        }
        return e.prototype.dispose = function () {
          this._onDidChange.dispose()
        }, Object.defineProperty( e.prototype, "onDidChange", {
          get() {
            return this._onDidChange.event
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "id", {
          get() {
            return this._id
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "label", {
          get() {
            return this._label
          },
          set( e ) {
            this._setLabel( e )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype._setLabel = function ( e ) {
          this._label !== e && ( this._label = e, this._onDidChange.fire( {
            label: e
          } ) )
        }, Object.defineProperty( e.prototype, "tooltip", {
          get() {
            return this._tooltip
          },
          set( e ) {
            this._setTooltip( e )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype._setTooltip = function ( e ) {
          this._tooltip !== e && ( this._tooltip = e, this._onDidChange.fire( {
            tooltip: e
          } ) )
        }, Object.defineProperty( e.prototype, "class", {
          get() {
            return this._cssClass
          },
          set( e ) {
            this._setClass( e )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype._setClass = function ( e ) {
          this._cssClass !== e && ( this._cssClass = e, this._onDidChange.fire( {
            class: e
          } ) )
        }, Object.defineProperty( e.prototype, "enabled", {
          get() {
            return this._enabled
          },
          set( e ) {
            this._setEnabled( e )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype._setEnabled = function ( e ) {
          this._enabled !== e && ( this._enabled = e, this._onDidChange.fire( {
            enabled: e
          } ) )
        }, Object.defineProperty( e.prototype, "checked", {
          get() {
            return this._checked
          },
          set( e ) {
            this._setChecked( e )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "radio", {
          get() {
            return this._radio
          },
          set( e ) {
            this._setRadio( e )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype._setChecked = function ( e ) {
          this._checked !== e && ( this._checked = e, this._onDidChange.fire( {
            checked: e
          } ) )
        }, e.prototype._setRadio = function ( e ) {
          this._radio !== e && ( this._radio = e, this._onDidChange.fire( {
            radio: e
          } ) )
        }, Object.defineProperty( e.prototype, "order", {
          get() {
            return this._order
          },
          set( e ) {
            this._order = e
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.run = function ( e, t ) {
          return void 0 !== this._actionCallback ? this._actionCallback( e ) : i.b.as( !0 )
        }, e;
      } )();
      var s = ( () => {
        function e() {
          this._onDidBeforeRun = new o.a, this._onDidRun = new o.a
        }
        return Object.defineProperty( e.prototype, "onDidRun", {
          get() {
            return this._onDidRun.event
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "onDidBeforeRun", {
          get() {
            return this._onDidBeforeRun.event
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.run = function ( e, t ) {
          const n = this;
          return e.enabled ? ( this._onDidBeforeRun.fire( {
            action: e
          } ), this.runAction( e, t ).then( ( t => {
            n._onDidRun.fire( {
              action: e,
              result: t
            } )
          } ), ( t => {
            n._onDidRun.fire( {
              action: e,
              error: t
            } )
          } ) ) ) : i.b.as( null );
        }, e.prototype.runAction = ( e, t ) => {
          const n = t ? e.run( t ) : e.run();
          return i.b.is( n ) ? n : i.b.wrap( n )
        }, e.prototype.dispose = function () {
          this._onDidBeforeRun.dispose(), this._onDidRun.dispose()
        }, e;
      } )();
    },
    "8HsV": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) );
      var i = ( () => {
        function e() {
          for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
          this._entries = new Map;
          for ( let n = 0, i = e; n < i.length; n++ ) {
            const o = i[ n ],
              r = o[ 0 ],
              s = o[ 1 ];
            this.set( r, s )
          }
        }
        return e.prototype.set = function ( e, t ) {
          const n = this._entries.get( e );
          return this._entries.set( e, t ), n
        }, e.prototype.forEach = function ( e ) {
          this._entries.forEach( ( ( t, n ) => {
            return e( n, t )
          } ) )
        }, e.prototype.has = function ( e ) {
          return this._entries.has( e )
        }, e.prototype.get = function ( e ) {
          return this._entries.get( e )
        }, e;
      } )()
    },
    "8XyJ": function ( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "InsertCursorAbove", ( () => {
        return C
      } ) ), n.d( t, "InsertCursorBelow", ( () => {
        return w
      } ) ), n.d( t, "MultiCursorSessionResult", ( () => {
        return O
      } ) ), n.d( t, "MultiCursorSession", ( () => {
        return L
      } ) ), n.d( t, "MultiCursorSelectionController", ( () => {
        return x
      } ) ), n.d( t, "MultiCursorSelectionControllerAction", ( () => {
        return N
      } ) ), n.d( t, "AddSelectionToNextFindMatchAction", ( () => {
        return E
      } ) ), n.d( t, "AddSelectionToPreviousFindMatchAction", ( () => {
        return k
      } ) ), n.d( t, "MoveSelectionToNextFindMatchAction", ( () => {
        return I
      } ) ), n.d( t, "MoveSelectionToPreviousFindMatchAction", ( () => {
        return D
      } ) ), n.d( t, "SelectHighlightsAction", ( () => {
        return M
      } ) ), n.d( t, "CompatChangeAll", ( () => {
        return T
      } ) ), n.d( t, "SelectionHighlighter", ( () => {
        return P
      } ) );
      const i = n( "3/fG" );
      const o = n( "pmY6" );
      const r = n( "/kV6" );
      const s = n( "X+cX" );
      const a = n( "M1Kb" );
      const u = n( "wQH0" );
      const l = n( "sswD" );
      const c = n( "aokT" );
      const d = n( "gCVg" );
      const h = n( "uzpd" );
      const p = n( "oAeH" );
      const f = n( "twdY" );
      const g = n( "oQaD" );
      const m = n( "tX9W" );
      const _ = n( "MD5Z" );
      const v = n( "t9D7" );
      const y = n( "fjLI" );
      const b = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var C = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.insertCursorAbove",
            label: i.a( "mutlicursor.insertAbove", "Add Cursor Above" ),
            alias: "Add Cursor Above",
            precondition: null,
            kbOpts: {
              kbExpr: u.a.editorTextFocus,
              primary: 2576,
              linux: {
                primary: 1552,
                secondary: [ 3088 ]
              },
              weight: 100
            },
            menubarOpts: {
              menuId: y.b.MenubarSelectionMenu,
              group: "3_multi",
              title: i.a( {
                key: "miInsertCursorAbove",
                comment: [ "&& denotes a mnemonic" ]
              }, "&&Add Cursor Above" ),
              order: 2
            }
          } ) || this
        }
        return b( t, e ), t.prototype.run = ( e, t, n ) => {
          const i = n && !0 === n.logicalLine,
            o = t._getCursors(),
            r = o.context;
          r.config.readOnly || ( r.model.pushStackElement(), o.setStates( n.source, h.a.Explicit, p.b.addCursorUp( r, o.getAll(), i ) ), o.reveal( !0, 1, 0 ) )
        }, t;
      } )( l.b );
      var w = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.insertCursorBelow",
            label: i.a( "mutlicursor.insertBelow", "Add Cursor Below" ),
            alias: "Add Cursor Below",
            precondition: null,
            kbOpts: {
              kbExpr: u.a.editorTextFocus,
              primary: 2578,
              linux: {
                primary: 1554,
                secondary: [ 3090 ]
              },
              weight: 100
            },
            menubarOpts: {
              menuId: y.b.MenubarSelectionMenu,
              group: "3_multi",
              title: i.a( {
                key: "miInsertCursorBelow",
                comment: [ "&& denotes a mnemonic" ]
              }, "A&&dd Cursor Below" ),
              order: 3
            }
          } ) || this
        }
        return b( t, e ), t.prototype.run = ( e, t, n ) => {
          const i = n && !0 === n.logicalLine,
            o = t._getCursors(),
            r = o.context;
          r.config.readOnly || ( r.model.pushStackElement(), o.setStates( n.source, h.a.Explicit, p.b.addCursorDown( r, o.getAll(), i ) ), o.reveal( !0, 2, 0 ) )
        }, t;
      } )( l.b );
      const S = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.insertCursorAtEndOfEachLineSelected",
            label: i.a( "mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends" ),
            alias: "Add Cursors to Line Ends",
            precondition: null,
            kbOpts: {
              kbExpr: u.a.editorTextFocus,
              primary: 1575,
              weight: 100
            },
            menubarOpts: {
              menuId: y.b.MenubarSelectionMenu,
              group: "3_multi",
              title: i.a( {
                key: "miInsertCursorAtEndOfEachLineSelected",
                comment: [ "&& denotes a mnemonic" ]
              }, "Add C&&ursors to Line Ends" ),
              order: 4
            }
          } ) || this
        }
        return b( t, e ), t.prototype.getCursorsForSelection = ( e, t, n ) => {
          if ( !e.isEmpty() ) {
            for ( let i = e.startLineNumber; i < e.endLineNumber; i++ ) {
              const o = t.getLineMaxColumn( i );
              n.push( new d.a( i, o, i, o ) )
            }
            e.endColumn > 1 && n.push( new d.a( e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn ) )
          }
        }, t.prototype.run = function ( e, t ) {
          const n = this,
            i = t.getModel(),
            o = t.getSelections(),
            r = [];
          o.forEach( ( e => {
            return n.getCursorsForSelection( e, i, r )
          } ) ), r.length > 0 && t.setSelections( r )
        }, t;
      } )( l.b );
      var O = function ( e, t, n ) {
        this.selections = e, this.revealRange = t, this.revealScrollType = n
      };

      var L = ( () => {
        function e( e, t, n, i, o, r, s ) {
          this._editor = e, this.findController = t, this.isDisconnectedFromFindController = n, this.searchText = i, this.wholeWord = o, this.matchCase = r, this.currentMatch = s
        }
        return e.create = ( t, n ) => {
          const i = n.getState();
          if ( !t.hasTextFocus() && i.isRevealed && i.searchString.length > 0 ) return new e( t, n, !1, i.searchString, i.wholeWord, i.matchCase, null );
          let o;
          let r;
          let s = !1;
          const a = t.getSelections();
          1 === a.length && a[ 0 ].isEmpty() ? ( s = !0, o = !0, r = !0 ) : ( o = i.wholeWord, r = i.matchCase );
          let u;
          const l = t.getSelection();
          let c = null;
          if ( l.isEmpty() ) {
            const h = t.getModel().getWordAtPosition( l.getStartPosition() );
            if ( !h ) return null;
            u = h.word, c = new d.a( l.startLineNumber, h.startColumn, l.startLineNumber, h.endColumn )
          } else u = t.getModel().getValueInRange( l ).replace( /\r\n/g, "\n" );
          return new e( t, n, s, u, o, r, c )
        }, e.prototype.addSelectionToNextFindMatch = function () {
          const e = this._getNextMatch();
          if ( !e ) return null;
          const t = this._editor.getSelections();
          return new O( t.concat( e ), e, 0 )
        }, e.prototype.moveSelectionToNextFindMatch = function () {
          const e = this._getNextMatch();
          if ( !e ) return null;
          const t = this._editor.getSelections();
          return new O( t.slice( 0, t.length - 1 ).concat( e ), e, 0 )
        }, e.prototype._getNextMatch = function () {
          if ( this.currentMatch ) {
            const e = this.currentMatch;
            return this.currentMatch = null, e
          }
          this.findController.highlightFindOptions();
          const t = this._editor.getSelections(),
            n = t[ t.length - 1 ],
            i = this._editor.getModel().findNextMatch( this.searchText, n.getEndPosition(), !1, this.matchCase, this.wholeWord ? this._editor.getConfiguration().wordSeparators : null, !1 );
          return i ? new d.a( i.range.startLineNumber, i.range.startColumn, i.range.endLineNumber, i.range.endColumn ) : null
        }, e.prototype.addSelectionToPreviousFindMatch = function () {
          const e = this._getPreviousMatch();
          if ( !e ) return null;
          const t = this._editor.getSelections();
          return new O( t.concat( e ), e, 0 )
        }, e.prototype.moveSelectionToPreviousFindMatch = function () {
          const e = this._getPreviousMatch();
          if ( !e ) return null;
          const t = this._editor.getSelections();
          return new O( t.slice( 0, t.length - 1 ).concat( e ), e, 0 )
        }, e.prototype._getPreviousMatch = function () {
          if ( this.currentMatch ) {
            const e = this.currentMatch;
            return this.currentMatch = null, e
          }
          this.findController.highlightFindOptions();
          const t = this._editor.getSelections(),
            n = t[ t.length - 1 ],
            i = this._editor.getModel().findPreviousMatch( this.searchText, n.getStartPosition(), !1, this.matchCase, this.wholeWord ? this._editor.getConfiguration().wordSeparators : null, !1 );
          return i ? new d.a( i.range.startLineNumber, i.range.startColumn, i.range.endLineNumber, i.range.endColumn ) : null
        }, e.prototype.selectAll = function () {
          return this.findController.highlightFindOptions(), this._editor.getModel().findMatches( this.searchText, !0, !1, this.matchCase, this.wholeWord ? this._editor.getConfiguration().wordSeparators : null, !1, 1073741824 )
        }, e;
      } )();

      var x = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n._editor = t, n._ignoreSelectionChange = !1, n._session = null, n._sessionDispose = [], n
        }
        return b( t, e ), t.get = e => {
          return e.getContribution( t.ID )
        }, t.prototype.dispose = function () {
          this._endSession(), e.prototype.dispose.call( this )
        }, t.prototype.getId = () => {
          return t.ID
        }, t.prototype._beginSessionIfNeeded = function ( e ) {
          const t = this;
          if ( !this._session ) {
            const n = L.create( this._editor, e );
            if ( !n ) return;
            this._session = n;
            const i = {
              searchString: this._session.searchText
            };
            this._session.isDisconnectedFromFindController && ( i.wholeWordOverride = 1, i.matchCaseOverride = 1, i.isRegexOverride = 2 ), e.getState().change( i, !1 ), this._sessionDispose = [ this._editor.onDidChangeCursorSelection( ( e => {
              t._ignoreSelectionChange || t._endSession()
            } ) ), this._editor.onDidBlurEditorText( ( () => {
              t._endSession()
            } ) ), e.getState().onFindReplaceStateChange( ( e => {
              ( e.matchCase || e.wholeWord ) && t._endSession()
            } ) ) ]
          }
        }, t.prototype._endSession = function () {
          if ( this._sessionDispose = Object( o.d )( this._sessionDispose ), this._session && this._session.isDisconnectedFromFindController ) {
            this._session.findController.getState().change( {
              wholeWordOverride: 0,
              matchCaseOverride: 0,
              isRegexOverride: 0
            }, !1 )
          }
          this._session = null
        }, t.prototype._setSelections = function ( e ) {
          this._ignoreSelectionChange = !0, this._editor.setSelections( e ), this._ignoreSelectionChange = !1
        }, t.prototype._expandEmptyToWord = ( e, t ) => {
          if ( !t.isEmpty() ) return t;
          const n = e.getWordAtPosition( t.getStartPosition() );
          return n ? new d.a( t.startLineNumber, n.startColumn, t.startLineNumber, n.endColumn ) : t
        }, t.prototype._applySessionResult = function ( e ) {
          e && ( this._setSelections( e.selections ), e.revealRange && this._editor.revealRangeInCenterIfOutsideViewport( e.revealRange, e.revealScrollType ) )
        }, t.prototype.getSession = function ( e ) {
          return this._session
        }, t.prototype.addSelectionToNextFindMatch = function ( e ) {
          if ( !this._session ) {
            const t = this._editor.getSelections();
            if ( t.length > 1 ) {
              const n = e.getState().matchCase;
              if ( !A( this._editor.getModel(), t, n ) ) {
                for ( var i = this._editor.getModel(), o = [], r = 0, s = t.length; r < s; r++ ) o[ r ] = this._expandEmptyToWord( i, t[ r ] );
                return void this._editor.setSelections( o )
              }
            }
          }
          this._beginSessionIfNeeded( e ), this._session && this._applySessionResult( this._session.addSelectionToNextFindMatch() )
        }, t.prototype.addSelectionToPreviousFindMatch = function ( e ) {
          this._beginSessionIfNeeded( e ), this._session && this._applySessionResult( this._session.addSelectionToPreviousFindMatch() )
        }, t.prototype.moveSelectionToNextFindMatch = function ( e ) {
          this._beginSessionIfNeeded( e ), this._session && this._applySessionResult( this._session.moveSelectionToNextFindMatch() )
        }, t.prototype.moveSelectionToPreviousFindMatch = function ( e ) {
          this._beginSessionIfNeeded( e ), this._session && this._applySessionResult( this._session.moveSelectionToPreviousFindMatch() )
        }, t.prototype.selectAll = function ( e ) {
          let t = null;
          const n = e.getState();
          if ( n.isRevealed && n.searchString.length > 0 && n.isRegex ) t = this._editor.getModel().findMatches( n.searchString, !0, n.isRegex, n.matchCase, n.wholeWord ? this._editor.getConfiguration().wordSeparators : null, !1, 1073741824 );
          else {
            if ( this._beginSessionIfNeeded( e ), !this._session ) return;
            t = this._session.selectAll()
          }
          if ( t.length > 0 ) {
            for ( let i = this._editor.getSelection(), o = 0, r = t.length; o < r; o++ ) {
              const s = t[ o ];
              if ( s.range.intersectRanges( i ) ) {
                t[ o ] = t[ 0 ], t[ 0 ] = s;
                break
              }
            }
            this._setSelections( t.map( ( e => {
              return new d.a( e.range.startLineNumber, e.range.startColumn, e.range.endLineNumber, e.range.endColumn )
            } ) ) )
          }
        }, t.ID = "editor.contrib.multiCursorController", t;
      } )( o.a );

      var N = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return b( t, e ), t.prototype.run = function ( e, t ) {
          const n = x.get( t );
          if ( n ) {
            const i = g.CommonFindController.get( t );
            if ( !i ) return null;
            this._run( n, i )
          }
        }, t;
      } )( l.b );
      var E = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.addSelectionToNextFindMatch",
            label: i.a( "addSelectionToNextFindMatch", "Add Selection To Next Find Match" ),
            alias: "Add Selection To Next Find Match",
            precondition: null,
            kbOpts: {
              kbExpr: u.a.focus,
              primary: 2082,
              weight: 100
            },
            menubarOpts: {
              menuId: y.b.MenubarSelectionMenu,
              group: "3_multi",
              title: i.a( {
                key: "miAddSelectionToNextFindMatch",
                comment: [ "&& denotes a mnemonic" ]
              }, "Add &&Next Occurrence" ),
              order: 5
            }
          } ) || this
        }
        return b( t, e ), t.prototype._run = ( e, t ) => {
          e.addSelectionToNextFindMatch( t )
        }, t;
      } )( N );
      var k = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.addSelectionToPreviousFindMatch",
            label: i.a( "addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match" ),
            alias: "Add Selection To Previous Find Match",
            precondition: null,
            menubarOpts: {
              menuId: y.b.MenubarSelectionMenu,
              group: "3_multi",
              title: i.a( {
                key: "miAddSelectionToPreviousFindMatch",
                comment: [ "&& denotes a mnemonic" ]
              }, "Add P&&revious Occurrence" ),
              order: 6
            }
          } ) || this
        }
        return b( t, e ), t.prototype._run = ( e, t ) => {
          e.addSelectionToPreviousFindMatch( t )
        }, t;
      } )( N );
      var I = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.moveSelectionToNextFindMatch",
            label: i.a( "moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match" ),
            alias: "Move Last Selection To Next Find Match",
            precondition: null,
            kbOpts: {
              kbExpr: u.a.focus,
              primary: Object( r.a )( 2089, 2082 ),
              weight: 100
            }
          } ) || this
        }
        return b( t, e ), t.prototype._run = ( e, t ) => {
          e.moveSelectionToNextFindMatch( t )
        }, t;
      } )( N );
      var D = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.moveSelectionToPreviousFindMatch",
            label: i.a( "moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match" ),
            alias: "Move Last Selection To Previous Find Match",
            precondition: null
          } ) || this
        }
        return b( t, e ), t.prototype._run = ( e, t ) => {
          e.moveSelectionToPreviousFindMatch( t )
        }, t;
      } )( N );
      var M = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.selectHighlights",
            label: i.a( "selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match" ),
            alias: "Select All Occurrences of Find Match",
            precondition: null,
            kbOpts: {
              kbExpr: u.a.focus,
              primary: 3114,
              weight: 100
            },
            menubarOpts: {
              menuId: y.b.MenubarSelectionMenu,
              group: "3_multi",
              title: i.a( {
                key: "miSelectHighlights",
                comment: [ "&& denotes a mnemonic" ]
              }, "Select All &&Occurrences" ),
              order: 7
            }
          } ) || this
        }
        return b( t, e ), t.prototype._run = ( e, t ) => {
          e.selectAll( t )
        }, t;
      } )( N );
      var T = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.changeAll",
            label: i.a( "changeAll.label", "Change All Occurrences" ),
            alias: "Change All Occurrences",
            precondition: u.a.writable,
            kbOpts: {
              kbExpr: u.a.editorTextFocus,
              primary: 2108,
              weight: 100
            },
            menuOpts: {
              group: "1_modification",
              order: 1.2
            }
          } ) || this
        }
        return b( t, e ), t.prototype._run = ( e, t ) => {
          e.selectAll( t )
        }, t;
      } )( N );
      const R = ( () => {
        function e( e, t, n, i ) {
          this.lastWordUnderCursor = e, this.searchText = t, this.matchCase = n, this.wordSeparators = i
        }
        return e.softEquals = ( e, t ) => {
          return !e && !t || !( !e || !t ) && ( e.searchText === t.searchText && e.matchCase === t.matchCase && e.wordSeparators === t.wordSeparators )
        }, e;
      } )();

      var P = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n.editor = t, n._isEnabled = t.getConfiguration().contribInfo.selectionHighlight, n.decorations = [], n.updateSoon = n._register( new s.c( ( () => {
            return n._update()
          } ), 300 ) ), n.state = null, n._register( t.onDidChangeConfiguration( ( e => {
            n._isEnabled = t.getConfiguration().contribInfo.selectionHighlight
          } ) ) ), n._register( t.onDidChangeCursorSelection( ( e => {
            n._isEnabled && ( e.selection.isEmpty() ? e.reason === h.a.Explicit ? ( !n.state || n.state.lastWordUnderCursor && n.state.lastWordUnderCursor.containsPosition( e.selection.getStartPosition() ) || n._setState( null ), n.updateSoon.schedule() ) : n._setState( null ) : n._update() )
          } ) ) ), n._register( t.onDidChangeModel( ( e => {
            n._setState( null )
          } ) ) ), n._register( g.CommonFindController.get( t ).getState().onFindReplaceStateChange( ( e => {
            n._update()
          } ) ) ), n;
        }
        return b( t, e ), t.prototype.getId = () => {
          return t.ID
        }, t.prototype._update = function () {
          this._setState( t._createState( this._isEnabled, this.editor ) )
        }, t._createState = ( e, t ) => {
          if ( !e ) return null;
          const n = t.getModel();
          if ( !n ) return null;
          const i = t.getSelection();
          if ( i.startLineNumber !== i.endLineNumber ) return null;
          const o = x.get( t );
          if ( !o ) return null;
          const r = g.CommonFindController.get( t );
          if ( !r ) return null;
          let s = o.getSession( r );
          if ( !s ) {
            const a = t.getSelections();
            if ( a.length > 1 ) {
              const u = r.getState().matchCase;
              if ( !A( t.getModel(), a, u ) ) return null
            }
            s = L.create( t, r )
          }
          if ( !s ) return null;
          let l = null;
          const c = f.h.has( n );
          if ( s.currentMatch ) {
            if ( c ) return null;
            if ( !t.getConfiguration().contribInfo.occurrencesHighlight ) return null;
            l = s.currentMatch
          }
          if ( /^[ \t]+$/.test( s.searchText ) ) return null;
          if ( s.searchText.length > 200 ) return null;
          const d = r.getState(),
            h = d.matchCase;
          if ( d.isRevealed ) {
            let p = d.searchString;
            h || ( p = p.toLowerCase() );
            let m = s.searchText;
            if ( h || ( m = m.toLowerCase() ), p === m && s.matchCase === d.matchCase && s.wholeWord === d.wholeWord && !d.isRegex ) return null
          }
          return new R( l, s.searchText, s.matchCase, s.wholeWord ? t.getConfiguration().wordSeparators : null )
        }, t.prototype._setState = function ( e ) {
          if ( R.softEquals( this.state, e ) ) this.state = e;
          else if ( this.state = e, this.state ) {
            const n = this.editor.getModel();
            if ( !n.isTooLargeForTokenization() ) {
              const i = f.h.has( n ),
                o = n.findMatches( this.state.searchText, !0, !1, this.state.matchCase, this.state.wordSeparators, !1 ).map( ( e => {
                  return e.range
                } ) );
              o.sort( c.a.compareRangesUsingStarts );
              const r = this.editor.getSelections();
              r.sort( c.a.compareRangesUsingStarts );
              for ( var s = [], a = 0, u = 0, l = o.length, d = r.length; a < l; ) {
                const h = o[ a ];
                if ( u >= d ) s.push( h ), a++;
                else {
                  const p = c.a.compareRangesUsingStarts( h, r[ u ] );
                  p < 0 ? ( !r[ u ].isEmpty() && c.a.areIntersecting( h, r[ u ] ) || s.push( h ), a++ ) : p > 0 ? u++ : ( a++, u++ )
                }
              }
              const g = s.map( ( e => {
                return {
                  range: e,
                  options: i ? t._SELECTION_HIGHLIGHT : t._SELECTION_HIGHLIGHT_OVERVIEW
                }
              } ) );
              this.decorations = this.editor.deltaDecorations( this.decorations, g )
            }
          } else this.decorations = this.editor.deltaDecorations( this.decorations, [] )
        }, t.prototype.dispose = function () {
          this._setState( null ), e.prototype.dispose.call( this )
        }, t.ID = "editor.contrib.selectionHighlighter", t._SELECTION_HIGHLIGHT_OVERVIEW = m.a.register( {
          stickiness: a.h.NeverGrowsWhenTypingAtEdges,
          className: "selectionHighlight",
          overviewRuler: {
            color: Object( v.f )( _.gb ),
            darkColor: Object( v.f )( _.gb ),
            position: a.f.Center
          }
        } ), t._SELECTION_HIGHLIGHT = m.a.register( {
          stickiness: a.h.NeverGrowsWhenTypingAtEdges,
          className: "selectionHighlight"
        } ), t;
      } )( o.a );

      function A( e, t, n ) {
        for ( let i = F( e, t[ 0 ], !n ), o = 1, r = t.length; o < r; o++ ) {
          const s = t[ o ];
          if ( s.isEmpty() ) return !1;
          if ( i !== F( e, s, !n ) ) return !1
        }
        return !0
      }

      function F( e, t, n ) {
        const i = e.getValueInRange( t );
        return n ? i.toLowerCase() : i
      }
      Object( l.h )( x ), Object( l.h )( P ), Object( l.f )( C ), Object( l.f )( w ), Object( l.f )( S ), Object( l.f )( E ), Object( l.f )( k ), Object( l.f )( I ), Object( l.f )( D ), Object( l.f )( M ), Object( l.f )( T )
    },
    "8gvo": function ( e, t, n ) {},
    "8z58": function ( e, t, n ) {
      "use strict";
      n.r( t );
      let i;
      let o;
      const r = n( "MI8n" );
      const s = n( "/kV6" );
      const a = n( "cGHE" );
      const u = n( "aokT" );
      const l = n( "gCVg" );
      const c = n( "VMIq" );
      const d = n( "JQT/" );
      const h = n( "Tcc1" );
      const p = n( "bY76" );
      !( e => {
        e[ e.Unnecessary = 1 ] = "Unnecessary"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.Hint = 1 ] = "Hint", e[ e.Info = 2 ] = "Info", e[ e.Warning = 4 ] = "Warning", e[ e.Error = 8 ] = "Error"
      } )( o || ( o = {} ) );
      let f;
      const g = ( () => {
        function e() {}
        return e.chord = ( e, t ) => {
          return Object( s.a )( e, t )
        }, e.CtrlCmd = 2048, e.Shift = 1024, e.Alt = 512, e.WinCtrl = 256, e;
      } )();

      function m() {
        return {
          editor: void 0,
          languages: void 0,
          CancellationTokenSource: d.b,
          Emitter: r.a,
          KeyCode: f,
          KeyMod: g,
          Position: a.a,
          Range: u.a,
          Selection: l.a,
          SelectionDirection: l.b,
          MarkerSeverity: o,
          MarkerTag: i,
          Promise: c.b,
          Uri: p.a,
          Token: h.a
        }
      }!( e => {
        e[ e.Unknown = 0 ] = "Unknown", e[ e.Backspace = 1 ] = "Backspace", e[ e.Tab = 2 ] = "Tab", e[ e.Enter = 3 ] = "Enter", e[ e.Shift = 4 ] = "Shift", e[ e.Ctrl = 5 ] = "Ctrl", e[ e.Alt = 6 ] = "Alt", e[ e.PauseBreak = 7 ] = "PauseBreak", e[ e.CapsLock = 8 ] = "CapsLock", e[ e.Escape = 9 ] = "Escape", e[ e.Space = 10 ] = "Space", e[ e.PageUp = 11 ] = "PageUp", e[ e.PageDown = 12 ] = "PageDown", e[ e.End = 13 ] = "End", e[ e.Home = 14 ] = "Home", e[ e.LeftArrow = 15 ] = "LeftArrow", e[ e.UpArrow = 16 ] = "UpArrow", e[ e.RightArrow = 17 ] = "RightArrow", e[ e.DownArrow = 18 ] = "DownArrow", e[ e.Insert = 19 ] = "Insert", e[ e.Delete = 20 ] = "Delete", e[ e.KEY_0 = 21 ] = "KEY_0", e[ e.KEY_1 = 22 ] = "KEY_1", e[ e.KEY_2 = 23 ] = "KEY_2", e[ e.KEY_3 = 24 ] = "KEY_3", e[ e.KEY_4 = 25 ] = "KEY_4", e[ e.KEY_5 = 26 ] = "KEY_5", e[ e.KEY_6 = 27 ] = "KEY_6", e[ e.KEY_7 = 28 ] = "KEY_7", e[ e.KEY_8 = 29 ] = "KEY_8", e[ e.KEY_9 = 30 ] = "KEY_9", e[ e.KEY_A = 31 ] = "KEY_A", e[ e.KEY_B = 32 ] = "KEY_B", e[ e.KEY_C = 33 ] = "KEY_C", e[ e.KEY_D = 34 ] = "KEY_D", e[ e.KEY_E = 35 ] = "KEY_E", e[ e.KEY_F = 36 ] = "KEY_F", e[ e.KEY_G = 37 ] = "KEY_G", e[ e.KEY_H = 38 ] = "KEY_H", e[ e.KEY_I = 39 ] = "KEY_I", e[ e.KEY_J = 40 ] = "KEY_J", e[ e.KEY_K = 41 ] = "KEY_K", e[ e.KEY_L = 42 ] = "KEY_L", e[ e.KEY_M = 43 ] = "KEY_M", e[ e.KEY_N = 44 ] = "KEY_N", e[ e.KEY_O = 45 ] = "KEY_O", e[ e.KEY_P = 46 ] = "KEY_P", e[ e.KEY_Q = 47 ] = "KEY_Q", e[ e.KEY_R = 48 ] = "KEY_R", e[ e.KEY_S = 49 ] = "KEY_S", e[ e.KEY_T = 50 ] = "KEY_T", e[ e.KEY_U = 51 ] = "KEY_U", e[ e.KEY_V = 52 ] = "KEY_V", e[ e.KEY_W = 53 ] = "KEY_W", e[ e.KEY_X = 54 ] = "KEY_X", e[ e.KEY_Y = 55 ] = "KEY_Y", e[ e.KEY_Z = 56 ] = "KEY_Z", e[ e.Meta = 57 ] = "Meta", e[ e.ContextMenu = 58 ] = "ContextMenu", e[ e.F1 = 59 ] = "F1", e[ e.F2 = 60 ] = "F2", e[ e.F3 = 61 ] = "F3", e[ e.F4 = 62 ] = "F4", e[ e.F5 = 63 ] = "F5", e[ e.F6 = 64 ] = "F6", e[ e.F7 = 65 ] = "F7", e[ e.F8 = 66 ] = "F8", e[ e.F9 = 67 ] = "F9", e[ e.F10 = 68 ] = "F10", e[ e.F11 = 69 ] = "F11", e[ e.F12 = 70 ] = "F12", e[ e.F13 = 71 ] = "F13", e[ e.F14 = 72 ] = "F14", e[ e.F15 = 73 ] = "F15", e[ e.F16 = 74 ] = "F16", e[ e.F17 = 75 ] = "F17", e[ e.F18 = 76 ] = "F18", e[ e.F19 = 77 ] = "F19", e[ e.NumLock = 78 ] = "NumLock", e[ e.ScrollLock = 79 ] = "ScrollLock", e[ e.US_SEMICOLON = 80 ] = "US_SEMICOLON", e[ e.US_EQUAL = 81 ] = "US_EQUAL", e[ e.US_COMMA = 82 ] = "US_COMMA", e[ e.US_MINUS = 83 ] = "US_MINUS", e[ e.US_DOT = 84 ] = "US_DOT", e[ e.US_SLASH = 85 ] = "US_SLASH", e[ e.US_BACKTICK = 86 ] = "US_BACKTICK", e[ e.US_OPEN_SQUARE_BRACKET = 87 ] = "US_OPEN_SQUARE_BRACKET", e[ e.US_BACKSLASH = 88 ] = "US_BACKSLASH", e[ e.US_CLOSE_SQUARE_BRACKET = 89 ] = "US_CLOSE_SQUARE_BRACKET", e[ e.US_QUOTE = 90 ] = "US_QUOTE", e[ e.OEM_8 = 91 ] = "OEM_8", e[ e.OEM_102 = 92 ] = "OEM_102", e[ e.NUMPAD_0 = 93 ] = "NUMPAD_0", e[ e.NUMPAD_1 = 94 ] = "NUMPAD_1", e[ e.NUMPAD_2 = 95 ] = "NUMPAD_2", e[ e.NUMPAD_3 = 96 ] = "NUMPAD_3", e[ e.NUMPAD_4 = 97 ] = "NUMPAD_4", e[ e.NUMPAD_5 = 98 ] = "NUMPAD_5", e[ e.NUMPAD_6 = 99 ] = "NUMPAD_6", e[ e.NUMPAD_7 = 100 ] = "NUMPAD_7", e[ e.NUMPAD_8 = 101 ] = "NUMPAD_8", e[ e.NUMPAD_9 = 102 ] = "NUMPAD_9", e[ e.NUMPAD_MULTIPLY = 103 ] = "NUMPAD_MULTIPLY", e[ e.NUMPAD_ADD = 104 ] = "NUMPAD_ADD", e[ e.NUMPAD_SEPARATOR = 105 ] = "NUMPAD_SEPARATOR", e[ e.NUMPAD_SUBTRACT = 106 ] = "NUMPAD_SUBTRACT", e[ e.NUMPAD_DECIMAL = 107 ] = "NUMPAD_DECIMAL", e[ e.NUMPAD_DIVIDE = 108 ] = "NUMPAD_DIVIDE", e[ e.KEY_IN_COMPOSITION = 109 ] = "KEY_IN_COMPOSITION", e[ e.ABNT_C1 = 110 ] = "ABNT_C1", e[ e.ABNT_C2 = 111 ] = "ABNT_C2", e[ e.MAX_VALUE = 112 ] = "MAX_VALUE"
      } )( f || ( f = {} ) );
      n( "siPX" );
      const _ = n( "iuje" );
      const v = n( "sFUC" );
      const y = n( "pmY6" );
      const b = n( "Uzvx" );
      const C = n( "Cg/j" );
      const w = n( "nnTU" );
      const S = n( "bexQ" );
      const O = n( "T8No" );
      const L = n( "Vxe3" );
      const x = n( "pAvP" );
      const N = n( "PGsk" );
      const E = n( "nB0o" );
      const k = n( "SmQN" );
      const I = n( "scqD" );
      const D = n( "9Y+e" );
      const M = n( "fjLI" );
      const T = n( "t9D7" );
      const R = n( "OBOq" );
      const P = n( "3/fG" );
      const A = n( "D3Dy" );
      const F = n( "sM1p" );
      const W = n( "+7oY" );
      const j = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const V = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const B = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      let H = 0;
      let z = !1;
      const U = ( e => {
          function t( t, n, i, o, r, s, a, u, l ) {
            let c = this;
            return ( n = n || {} ).ariaLabel = n.ariaLabel || P.a( "editorViewAccessibleLabel", "Editor content" ), n.ariaLabel = n.ariaLabel + ";" + ( A.k ? P.a( "accessibilityHelpMessageIE", "Press Ctrl+F1 for Accessibility Options." ) : P.a( "accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options." ) ), c = e.call( this, t, n, {}, i, o, r, s, u, l ) || this, a instanceof N.m && ( c._standaloneKeybindingService = a ), z || ( z = !0, R.b( document.body ) ), c
          }
          return j( t, e ), t.prototype.addCommand = function ( e, t, n ) {
            if ( !this._standaloneKeybindingService ) return console.warn( "Cannot add command because the editor is configured with an unrecognized KeybindingService" ), null;
            const i = "DYNAMIC_" + ++H,
              o = O.d.deserialize( n );
            return this._standaloneKeybindingService.addDynamicKeybinding( i, e, t, o ), i
          }, t.prototype.createContextKey = function ( e, t ) {
            return this._contextKeyService.createKey( e, t )
          }, t.prototype.addAction = function ( e ) {
            const t = this;
            if ( "string" !== typeof e.id || "string" !== typeof e.label || "function" !== typeof e.run ) throw new Error( "Invalid action descriptor, `id`, `label` and `run` are required properties!" );
            if ( !this._standaloneKeybindingService ) return console.warn( "Cannot add keybinding because the editor is configured with an unrecognized KeybindingService" ), y.a.None;
            const n = e.id;
            const i = e.label;
            const o = O.d.and( O.d.equals( "editorId", this.getId() ), O.d.deserialize( e.precondition ) );
            const r = e.keybindings;
            const s = O.d.and( o, O.d.deserialize( e.keybindingContext ) );
            const a = e.contextMenuGroupId || null;
            const u = e.contextMenuOrder || 0;
            const l = () => {
              const n = e.run( t );
              return n || c.b.as( void 0 )
            };
            let d = [];
            const h = this.getId() + ":" + n;
            if ( d.push( w.a.registerCommand( h, l ) ), a ) {
              const p = {
                command: {
                  id: h,
                  title: i
                },
                when: o,
                group: a,
                order: u
              };
              d.push( M.d.appendMenuItem( M.b.EditorContext, p ) )
            }
            Array.isArray( r ) && ( d = d.concat( r.map( ( e => {
              return t._standaloneKeybindingService.addDynamicKeybinding( h, e, l, s )
            } ) ) ) );
            const f = new D.a( h, i, i, o, l, this._contextKeyService );
            return this._actions[ n ] = f, d.push( Object( y.f )( ( () => {
              delete t._actions[ n ]
            } ) ) ), Object( y.c )( d );
          }, t = V( [ B( 2, C.a ), B( 3, L.a ), B( 4, w.b ), B( 5, O.e ), B( 6, S.a ), B( 7, T.c ), B( 8, F.a ) ], t );
        } )( E.a ),
        K = ( e => {
          function t( t, n, i, o, r, s, a, u, l, c, d, h ) {
            let p = this;
            Object( N.o )( h, n, !1 ), "string" === typeof ( n = n || {} ).theme && c.setTheme( n.theme );
            let f = n.model;
            if ( delete n.model, ( p = e.call( this, t, n, o, r, s, a, u, c, d ) || this )._contextViewService = l, p._configurationService = h, p._register( i ), "undefined" === typeof f ? ( f = self.monaco.editor.createModel( n.value || "", n.language || "text/plain" ), p._ownsModel = !0 ) : p._ownsModel = !1, p._attachModel( f ), f ) {
              const g = {
                oldModelUrl: null,
                newModelUrl: f.uri
              };
              p._onDidChangeModel.fire( g )
            }
            return p
          }
          return j( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype.updateOptions = function ( t ) {
            Object( N.o )( this._configurationService, t, !1 ), e.prototype.updateOptions.call( this, t )
          }, t.prototype._attachModel = function ( t ) {
            e.prototype._attachModel.call( this, t ), this._view && this._contextViewService.setContainer( this._view.domNode.domNode )
          }, t.prototype._postDetachModelCleanup = function ( t ) {
            e.prototype._postDetachModelCleanup.call( this, t ), t && this._ownsModel && ( t.dispose(), this._ownsModel = !1 )
          }, t = V( [ B( 3, C.a ), B( 4, L.a ), B( 5, w.b ), B( 6, O.e ), B( 7, S.a ), B( 8, b.b ), B( 9, I.a ), B( 10, F.a ), B( 11, W.b ) ], t )
        } )( U ),
        q = ( e => {
          function t( t, n, i, o, r, s, a, u, l, c, d, h ) {
            let p = this;
            return Object( N.o )( h, n, !0 ), "string" === typeof ( n = n || {} ).theme && ( n.theme = c.setTheme( n.theme ) ), ( p = e.call( this, t, n, u, r, o, l, c, d ) || this )._contextViewService = a, p._configurationService = h, p._register( i ), p._contextViewService.setContainer( p._containerDomElement ), p
          }
          return j( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype.updateOptions = function ( t ) {
            Object( N.o )( this._configurationService, t, !0 ), e.prototype.updateOptions.call( this, t )
          }, t.prototype._createInnerEditor = ( e, t, n ) => {
            return e.createInstance( U, t, n )
          }, t.prototype.getOriginalEditor = function () {
            return e.prototype.getOriginalEditor.call( this )
          }, t.prototype.getModifiedEditor = function () {
            return e.prototype.getModifiedEditor.call( this )
          }, t.prototype.addCommand = function ( e, t, n ) {
            return this.getModifiedEditor().addCommand( e, t, n )
          }, t.prototype.createContextKey = function ( e, t ) {
            return this.getModifiedEditor().createContextKey( e, t )
          }, t.prototype.addAction = function ( e ) {
            return this.getModifiedEditor().addAction( e )
          }, t = V( [ B( 3, C.a ), B( 4, O.e ), B( 5, S.a ), B( 6, b.b ), B( 7, x.a ), B( 8, L.a ), B( 9, I.a ), B( 10, F.a ), B( 11, W.b ) ], t );
        } )( k.a ),
        G = n( "QuOb" ),
        Y = ( n( "eizg" ), n( "lCHf" ) ),
        X = n( "XSiN" ),
        $ = n( "8HAY" ),
        Z = ( n( "CHaL" ), n( "WqXY" ) ),
        Q = n( "EffR" ),
        J = n( "uDWl" ),
        ee = n( "X+cX" ),
        te = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        ne = ( e => {
          function t( t, n, i ) {
            const o = e.call( this, i || "submenu", t, "", !0 ) || this;
            return o.entries = n, o
          }
          return te( t, e ), t
        } )( $.a ),
        ie = ( () => {
          function e( e, t, n ) {
            void 0 === n && ( n = {} );
            const i = this;
            Object( Q.f )( e, "monaco-menu-container" ), e.setAttribute( "role", "presentation" );
            const o = document.createElement( "div" );
            Object( Q.f )( o, "monaco-menu" ), o.setAttribute( "role", "presentation" ), e.appendChild( o );
            const r = {
              parent: this
            };
            this.actionBar = new Z.a( o, {
              orientation: Z.c.VERTICAL,
              actionItemProvider( e ) {
                return i.doGetActionItem( e, n, r )
              },
              context: n.context,
              actionRunner: n.actionRunner,
              isMenu: !0,
              ariaLabel: n.ariaLabel
            } ), this.actionBar.push( t, {
              icon: !0,
              label: !0,
              isMenu: !0
            } )
          }
          return e.prototype.doGetActionItem = ( e, t, n ) => {
            if ( e instanceof Z.e ) return new Z.b( t.context, e, {
              icon: !0
            } );
            if ( e instanceof ne ) return new re( e, e.entries, n, t );
            const i = {};
            if ( t.getKeyBinding ) {
              const o = t.getKeyBinding( e );
              o && ( i.keybinding = o.getLabel() )
            }
            return new oe( t.context, e, i )
          }, Object.defineProperty( e.prototype, "onDidCancel", {
            get() {
              return this.actionBar.onDidCancel
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onDidBlur", {
            get() {
              return this.actionBar.onDidBlur
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.focus = function ( e ) {
            void 0 === e && ( e = !0 ), this.actionBar && this.actionBar.focus( e )
          }, e.prototype.dispose = function () {
            this.actionBar && ( this.actionBar.dispose(), this.actionBar = null ), this.listener && ( this.listener.dispose(), this.listener = null )
          }, e;
        } )(),
        oe = ( e => {
          function t( t, n, i ) {
            void 0 === i && ( i = {} );
            let o = this;
            return i.isMenu = !0, ( o = e.call( this, n, n, i ) || this ).options = i, o.options.icon = void 0 !== i.icon && i.icon, o.options.label = void 0 === i.label || i.label, o.cssClass = "", o
          }
          return te( t, e ), t.prototype.render = function ( t ) {
            e.prototype.render.call( this, t ), this.$e = Object( Y.a )( "a.action-menu-item" ).appendTo( this.builder ), this._action.id === Z.e.ID ? this.$e.attr( {
              role: "presentation"
            } ) : this.$e.attr( {
              role: "menuitem"
            } ), this.$label = Object( Y.a )( "span.action-label" ).appendTo( this.$e ), this.options.label && this.options.keybinding && Object( Y.a )( "span.keybinding" ).text( this.options.keybinding ).appendTo( this.$e ), this._updateClass(), this._updateLabel(), this._updateTooltip(), this._updateEnabled(), this._updateChecked()
          }, t.prototype._updateLabel = function () {
            if ( this.options.label ) {
              let e = this.getAction().label;
              if ( e ) {
                const n = t.MNEMONIC_REGEX.exec( e );
                if ( n && 2 === n.length ) {
                  const i = n[ 1 ],
                    o = e.replace( t.MNEMONIC_REGEX, i );
                  this.$e.getHTMLElement().accessKey = i.toLocaleLowerCase(), this.$label.attr( "aria-label", o )
                } else this.$label.attr( "aria-label", e );
                e = e.replace( t.MNEMONIC_REGEX, "$1\u0332" )
              }
              this.$label.text( e )
            }
          }, t.prototype._updateTooltip = function () {
            let e = null;
            this.getAction().tooltip ? e = this.getAction().tooltip : !this.options.label && this.getAction().label && this.options.icon && ( e = this.getAction().label, this.options.keybinding && ( e = P.a( {
              key: "titleLabel",
              comment: [ "action title", "action keybinding" ]
            }, "{0} ({1})", e, this.options.keybinding ) ) ), e && this.$e.attr( {
              title: e
            } )
          }, t.prototype._updateClass = function () {
            this.cssClass && this.$e.removeClass( this.cssClass ), this.options.icon ? ( this.cssClass = this.getAction().class, this.$label.addClass( "icon" ), this.cssClass && this.$label.addClass( this.cssClass ), this._updateEnabled() ) : this.$label.removeClass( "icon" )
          }, t.prototype._updateEnabled = function () {
            this.getAction().enabled ? ( this.builder.removeClass( "disabled" ), this.$e.removeClass( "disabled" ), this.$e.attr( {
              tabindex: 0
            } ) ) : ( this.builder.addClass( "disabled" ), this.$e.addClass( "disabled" ), Object( Q.H )( this.$e.getHTMLElement() ) )
          }, t.prototype._updateChecked = function () {
            this.getAction().checked ? this.$label.addClass( "checked" ) : this.$label.removeClass( "checked" )
          }, t.MNEMONIC_REGEX = /&&(.)/g, t;
        } )( Z.d ),
        re = ( e => {
          function t( t, n, i, o ) {
            const r = e.call( this, t, t, {
              label: !0,
              isMenu: !0
            } ) || this;
            return r.submenuActions = n, r.parentData = i, r.submenuOptions = o, r.showScheduler = new ee.c( ( () => {
              r.mouseOver && ( r.cleanupExistingSubmenu( !1 ), r.createSubmenu( !1 ) )
            } ), 250 ), r.hideScheduler = new ee.c( ( () => {
              Object( Q.B )( document.activeElement, r.builder.getHTMLElement() ) || r.parentData.submenu !== r.mysubmenu || ( r.parentData.parent.focus( !1 ), r.cleanupExistingSubmenu( !0 ) )
            } ), 750 ), r;
          }
          return te( t, e ), t.prototype.render = function ( t ) {
            const n = this;
            e.prototype.render.call( this, t ), this.$e.addClass( "monaco-submenu-item" ), this.$e.attr( "aria-haspopup", "true" ), Object( Y.a )( "span.submenu-indicator" ).text( "\u25b6" ).appendTo( this.$e ), Object( Y.a )( this.builder ).on( Q.d.KEY_UP, ( e => {
              new J.a( e ).equals( 17 ) && ( Q.c.stop( e, !0 ), n.createSubmenu( !0 ) )
            } ) ), Object( Y.a )( this.builder ).on( Q.d.KEY_DOWN, ( e => {
              new J.a( e ).equals( 17 ) && Q.c.stop( e, !0 )
            } ) ), Object( Y.a )( this.builder ).on( Q.d.MOUSE_OVER, ( e => {
              n.mouseOver || ( n.mouseOver = !0, n.showScheduler.schedule() )
            } ) ), Object( Y.a )( this.builder ).on( Q.d.MOUSE_LEAVE, ( e => {
              n.mouseOver = !1
            } ) ), Object( Y.a )( this.builder ).on( Q.d.FOCUS_OUT, ( e => {
              Object( Q.B )( document.activeElement, n.builder.getHTMLElement() ) || n.hideScheduler.schedule()
            } ) )
          }, t.prototype.onClick = function ( e ) {
            Q.c.stop( e, !0 ), this.createSubmenu( !1 )
          }, t.prototype.cleanupExistingSubmenu = function ( e ) {
            this.parentData.submenu && ( e || this.parentData.submenu !== this.mysubmenu ) && ( this.parentData.submenu.dispose(), this.parentData.submenu = null, this.submenuContainer && ( this.submenuContainer.dispose(), this.submenuContainer = null ) )
          }, t.prototype.createSubmenu = function ( e ) {
            const t = this;
            void 0 === e && ( e = !0 ), this.parentData.submenu ? this.parentData.submenu.focus( !1 ) : ( this.submenuContainer = Object( Y.a )( this.builder ).div( {
              class: "monaco-submenu menubar-menu-items-holder context-view"
            } ), Object( Y.a )( this.submenuContainer ).style( {
              left: Object( Y.a )( this.builder ).getClientArea().width + "px"
            } ), Object( Y.a )( this.submenuContainer ).on( Q.d.KEY_UP, ( e => {
              new J.a( e ).equals( 15 ) && ( Q.c.stop( e, !0 ), t.parentData.parent.focus(), t.parentData.submenu.dispose(), t.parentData.submenu = null, t.submenuContainer.dispose(), t.submenuContainer = null )
            } ) ), Object( Y.a )( this.submenuContainer ).on( Q.d.KEY_DOWN, ( e => {
              new J.a( e ).equals( 15 ) && Q.c.stop( e, !0 )
            } ) ), this.parentData.submenu = new ie( this.submenuContainer.getHTMLElement(), this.submenuActions, this.submenuOptions ), this.parentData.submenu.focus( e ), this.mysubmenu = this.parentData.submenu )
          }, t.prototype.dispose = function () {
            e.prototype.dispose.call( this ), this.hideScheduler.dispose(), this.mysubmenu && ( this.mysubmenu.dispose(), this.mysubmenu = null ), this.submenuContainer && ( this.submenuContainer.dispose(), this.submenuContainer = null )
          }, t;
        } )( oe ),
        se = ( () => {
          function e( e, t, n, i ) {
            this.setContainer( e ), this.contextViewService = t, this.telemetryService = n, this.notificationService = i, this.menuContainerElement = null
          }
          return e.prototype.setContainer = function ( e ) {
            const t = this;
            this.$el && ( this.$el.off( [ "click", "mousedown" ] ), this.$el = null ), e && ( this.$el = Object( Y.a )( e ), this.$el.on( "mousedown", ( e => {
              return t.onMouseDown( e )
            } ) ) )
          }, e.prototype.showContextMenu = function ( e ) {
            const t = this;
            e.getActions().done( ( n => {
              n.length && t.contextViewService.showContextView( {
                getAnchor() {
                  return e.getAnchor()
                },
                canRelayout: !1,
                render( i ) {
                  t.menuContainerElement = i;
                  const o = e.getMenuClassName ? e.getMenuClassName() : "";
                  o && ( i.className += " " + o );
                  const r = [],
                    s = e.actionRunner || new $.b;
                  s.onDidBeforeRun( t.onActionRun, t, r ), s.onDidRun( t.onDidActionRun, t, r );
                  const a = new ie( i, n, {
                    actionItemProvider: e.getActionItem,
                    context: e.getActionsContext ? e.getActionsContext() : null,
                    actionRunner: s,
                    getKeyBinding: e.getKeyBinding
                  } );
                  return a.onDidCancel( ( () => {
                    return t.contextViewService.hideContextView( !0 )
                  } ), null, r ), a.onDidBlur( ( () => {
                    return t.contextViewService.hideContextView( !0 )
                  } ), null, r ), a.focus( !!e.autoSelectFirstItem ), Object( y.c )( r.concat( [ a ] ) );
                },
                onHide( n ) {
                  e.onHide && e.onHide( n ), t.menuContainerElement = null
                }
              } )
            } ) )
          }, e.prototype.onActionRun = function ( e ) {
            this.telemetryService && this.telemetryService.publicLog( "workbenchActionExecuted", {
              id: e.action.id,
              from: "contextMenu"
            } ), this.contextViewService.hideContextView( !1 )
          }, e.prototype.onDidActionRun = function ( e ) {
            e.error && this.notificationService && this.notificationService.error( e.error )
          }, e.prototype.onMouseDown = function ( e ) {
            if ( this.menuContainerElement ) {
              for ( let t = new X.b( e ).target; t; ) {
                if ( t === this.menuContainerElement ) return;
                t = t.parentElement
              }
              this.contextViewService.hideContextView()
            }
          }, e.prototype.dispose = function () {
            this.setContainer( null )
          }, e;
        } )(),
        ae = ( () => {
          function e( e, t, n, i ) {
            this._onDidContextMenu = new r.a, this.contextMenuHandler = new se( e, i, t, n )
          }
          return e.prototype.dispose = function () {
            this.contextMenuHandler.dispose()
          }, e.prototype.showContextMenu = function ( e ) {
            this.contextMenuHandler.showContextMenu( e ), this._onDidContextMenu.fire()
          }, e
        } )(),
        ue = n( "vKxM" ),
        le = n( "XXUj" ),
        ce = n( "09fa" ),
        de = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        he = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        pe = ( () => {
          function e( e, t, n ) {
            this.logService = n, this.contextView = new ue.b( e )
          }
          return e.prototype.dispose = function () {
            this.contextView.dispose()
          }, e.prototype.setContainer = function ( e ) {
            this.logService.trace( "ContextViewService#setContainer" ), this.contextView.setContainer( e )
          }, e.prototype.showContextView = function ( e ) {
            this.logService.trace( "ContextViewService#showContextView" ), this.contextView.show( e )
          }, e.prototype.layout = function () {
            this.contextView.layout()
          }, e.prototype.hideContextView = function ( e ) {
            this.logService.trace( "ContextViewService#hideContextView" ), this.contextView.hide( e )
          }, e = de( [ he( 1, le.a ), he( 2, ce.a ) ], e )
        } )(),
        fe = n( "/cxE" ),
        ge = n( "746U" ),
        me = n( "FWmy" ),
        _e = Object.prototype.hasOwnProperty;

      function ve( e, t ) {
        const n = n => {
          if ( _e.call( e, n ) && !1 === t( {
              key: n,
              value: e[ n ]
            }, ( () => {
              delete e[ n ]
            } ) ) ) return {
            value: void 0
          }
        };
        for ( const i in e ) {
          const o = n( i );
          if ( "object" === typeof o ) return o.value
        }
      }
      let ye;
      let be;

      const Ce = ( () => {
        function e( e ) {
          this._hashFn = e, this._nodes = Object.create( null )
        }
        return e.prototype.roots = function () {
          const e = [];
          return ve( this._nodes, ( t => {
            Object( ge.d )( t.value.outgoing ) && e.push( t.value )
          } ) ), e;
        }, e.prototype.insertEdge = function ( e, t ) {
          const n = this.lookupOrInsertNode( e ),
            i = this.lookupOrInsertNode( t );
          n.outgoing[ this._hashFn( t ) ] = i, i.incoming[ this._hashFn( e ) ] = n
        }, e.prototype.removeNode = function ( e ) {
          const t = this._hashFn( e );
          delete this._nodes[ t ], ve( this._nodes, ( e => {
            delete e.value.outgoing[ t ], delete e.value.incoming[ t ]
          } ) )
        }, e.prototype.lookupOrInsertNode = function ( e ) {
          const t = this._hashFn( e );
          let n = this._nodes[ t ];
          return n || ( n = ( e => {
            return {
              data: e,
              incoming: Object.create( null ),
              outgoing: Object.create( null )
            }
          } )( e ), this._nodes[ t ] = n ), n;
        }, Object.defineProperty( e.prototype, "length", {
          get() {
            return Object.keys( this._nodes ).length
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.toString = function () {
          const e = [];
          return ve( this._nodes, ( t => {
            e.push( t.key + ", (incoming)[" + Object.keys( t.value.incoming ).join( ", " ) + "], (outgoing)[" + Object.keys( t.value.outgoing ).join( "," ) + "]" )
          } ) ), e.join( "\n" );
        }, e;
      } )();

      const we = function ( e ) {
        for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
        this.ctor = e, this.staticArguments = t
      };
      const Se = n( "8HsV" );
      const Oe = ( () => {
        function e( e, t ) {
          void 0 === e && ( e = new Se.a ), void 0 === t && ( t = !1 ), this._services = e, this._strict = t, this._services.set( C.a, this )
        }
        return e.prototype.createChild = function ( t ) {
          const n = this;
          return this._services.forEach( ( ( e, i ) => {
            t.has( e ) || ( i instanceof we && ( i = n._createAndCacheServiceInstance( e, i ) ), t.set( e, i ) )
          } ) ), new e( t, this._strict );
        }, e.prototype.invokeFunction = function ( e ) {
          for ( var t, n = this, i = [], o = 1; o < arguments.length; o++ ) i[ o - 1 ] = arguments[ o ];
          try {
            return t = {
              get( e, t ) {
                const i = n._getOrCreateServiceInstance( e );
                if ( !i && t !== C.d ) throw new Error( "[invokeFunction] unknown service '" + e + "'" );
                return i
              }
            }, e.apply( void 0, [ t ].concat( i ) );
          } finally {
            t.get = () => {
              throw Object( fe.c )( "service accessor is only valid during the invocation of its target method" )
            }
          }
        }, e.prototype.createInstance = function ( e ) {
          for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
          return e instanceof we ? this._createInstance( e, t ) : this._createInstance( new we( e ), t )
        }, e.prototype._createInstance = function ( e, t ) {
          for ( var n = e.staticArguments.concat( t ), i = C.b.getServiceDependencies( e.ctor ).sort( ( ( e, t ) => {
              return e.index - t.index
            } ) ), o = [], r = 0, s = i; r < s.length; r++ ) {
            const a = s[ r ],
              u = this._getOrCreateServiceInstance( a.id );
            if ( !u && this._strict && !a.optional ) throw new Error( "[createInstance] " + e.ctor.name + " depends on UNKNOWN service " + a.id + "." );
            o.push( u )
          }
          const l = i.length > 0 ? i[ 0 ].index : n.length;
          if ( n.length !== l ) {
            console.warn( "[createInstance] First service dependency of " + e.ctor.name + " at position " + ( l + 1 ) + " conflicts with " + n.length + " static arguments" );
            const c = l - n.length;
            n = c > 0 ? n.concat( new Array( c ) ) : n.slice( 0, l )
          }
          const d = [ e.ctor ];
          return d.push.apply( d, n ), d.push.apply( d, o ), ge.a.apply( null, d )
        }, e.prototype._getOrCreateServiceInstance = function ( e ) {
          const t = this._services.get( e );
          return t instanceof we ? this._createAndCacheServiceInstance( e, t ) : t
        }, e.prototype._createAndCacheServiceInstance = function ( e, t ) {
          me.a( this._services.get( e ) instanceof we );
          const n = new Ce( ( e => {
            return e.id.toString()
          } ) );

          function i() {
            const e = new Error( "[createInstance] cyclic dependency between services" );
            throw ( e.message = n.toString(), e )
          }
          for ( let o = 0, r = [ {
              id: e,
              desc: t
            } ]; r.length; ) {
            const s = r.pop();
            n.lookupOrInsertNode( s ), o++ > 100 && i();
            for ( let a = 0, u = C.b.getServiceDependencies( s.desc.ctor ); a < u.length; a++ ) {
              const l = u[ a ],
                c = this._services.get( l.id );
              if ( c || console.warn( "[createInstance] " + e + " depends on " + l.id + " which is NOT registered." ), c instanceof we ) {
                const d = {
                  id: l.id,
                  desc: c
                };
                n.insertEdge( s, d ), r.push( d )
              }
            }
          }
          for ( ;; ) {
            const h = n.roots();
            if ( 0 === h.length ) {
              0 !== n.length && i();
              break
            }
            for ( let p = 0, f = h; p < f.length; p++ ) {
              const g = f[ p ],
                m = this._createInstance( g.data.desc, [] );
              this._services.set( g.data.id, m ), n.removeNode( g.data )
            }
          }
          return this._services.get( e )
        }, e;
      } )();
      const Le = n( "6OMU" );
      const xe = n( "tYmi" );
      const Ne = n( "tADe" );
      ( be = ye || ( ye = {} ) ).get = ( e, t, n ) => {
        if ( e[ t ] ) return e[ t ][ n ]
      }, be.set = ( e, t, n, i ) => {
        e[ t ] || ( e[ t ] = Object.create( null ) ), e[ t ][ n ] = i
      }, be.remove = ( e, t, n ) => {
        return !( !e[ t ] || !e[ t ][ n ] ) && ( delete e[ t ][ n ], Object( ge.d )( e[ t ] ) && delete e[ t ], !0 )
      };
      const Ee = ( () => {
        function e( e ) {
          this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = Object.create( null ), this._service = e, this._subscription = e.onMarkerChanged( this._update, this )
        }
        return e.prototype.dispose = function () {
          this._subscription.dispose(), this._data = void 0
        }, e.prototype._update = function ( e ) {
          for ( let t = 0, n = e; t < n.length; t++ ) {
            const i = n[ t ],
              o = i.toString(),
              r = this._data[ o ];
            r && this._substract( r );
            const s = this._resourceStats( i );
            this._add( s ), this._data[ o ] = s
          }
        }, e.prototype._resourceStats = function ( e ) {
          const t = {
            errors: 0,
            warnings: 0,
            infos: 0,
            unknowns: 0
          };
          if ( e.scheme === xe.a.inMemory || e.scheme === xe.a.walkThrough || e.scheme === xe.a.walkThroughSnippet ) return t;
          for ( let n = 0, i = this._service.read( {
              resource: e
            } ); n < i.length; n++ ) {
            const o = i[ n ].severity;
            o === Ne.b.Error ? t.errors += 1 : o === Ne.b.Warning ? t.warnings += 1 : o === Ne.b.Info ? t.infos += 1 : t.unknowns += 1
          }
          return t
        }, e.prototype._substract = function ( e ) {
          this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns
        }, e.prototype._add = function ( e ) {
          this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns
        }, e;
      } )();

      const ke = ( () => {
        function e() {
          this._onMarkerChanged = new r.a, this._onMarkerChangedEvent = Object( r.h )( this._onMarkerChanged.event, e._debouncer, 0 ), this._byResource = Object.create( null ), this._byOwner = Object.create( null ), this._stats = new Ee( this )
        }
        return e.prototype.dispose = function () {
          this._stats.dispose()
        }, Object.defineProperty( e.prototype, "onMarkerChanged", {
          get() {
            return this._onMarkerChangedEvent
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.remove = function ( e, t ) {
          if ( !Object( Le.k )( t ) )
            for ( let n = 0, i = t; n < i.length; n++ ) {
              const o = i[ n ];
              this.changeOne( e, o, void 0 )
            }
        }, e.prototype.changeOne = function ( t, n, i ) {
          if ( Object( Le.k )( i ) ) {
            const o = ye.remove( this._byResource, n.toString(), t ),
              r = ye.remove( this._byOwner, t, n.toString() );
            if ( o !== r ) throw new Error( "invalid marker service state" );
            o && r && this._onMarkerChanged.fire( [ n ] )
          } else {
            for ( var s = [], a = 0, u = i; a < u.length; a++ ) {
              const l = u[ a ],
                c = e._toMarker( t, n, l );
              c && s.push( c )
            }
            ye.set( this._byResource, n.toString(), t, s ), ye.set( this._byOwner, t, n.toString(), s ), this._onMarkerChanged.fire( [ n ] )
          }
        }, e._toMarker = ( e, t, n ) => {
          let i = n.code;
          const o = n.severity;
          const r = n.message;
          const s = n.source;
          let a = n.startLineNumber;
          let u = n.startColumn;
          let l = n.endLineNumber;
          let c = n.endColumn;
          const d = n.relatedInformation;
          const h = n.tags;
          if ( r ) return {
            resource: t,
            owner: e,
            code: i = i || null,
            severity: o,
            message: r,
            source: s,
            startLineNumber: a = a > 0 ? a : 1,
            startColumn: u = u > 0 ? u : 1,
            endLineNumber: l = l >= a ? l : a,
            endColumn: c = c > 0 ? c : u,
            relatedInformation: d,
            tags: h
          }
        }, e.prototype.read = function ( t ) {
          void 0 === t && ( t = Object.create( null ) );
          const n = t.owner;
          const i = t.resource;
          const o = t.severities;
          let r = t.take;
          if ( ( !r || r < 0 ) && ( r = -1 ), n && i ) {
            if ( y = ye.get( this._byResource, i.toString(), n ) ) {
              for ( var s = [], a = 0, u = y; a < u.length; a++ ) {
                const l = u[ a ];
                if ( e._accept( l, o ) ) {
                  var c = s.push( l );
                  if ( r > 0 && c === r ) break
                }
              }
              return s
            }
            return []
          }
          if ( n || i ) {
            const d = n ? this._byOwner[ n ] : this._byResource[ i.toString() ];
            if ( !d ) return [];
            s = [];
            for ( const h in d )
              for ( let p = 0, f = d[ h ]; p < f.length; p++ ) {
                y = f[ p ];
                if ( e._accept( y, o ) ) {
                  c = s.push( y );
                  if ( r > 0 && c === r ) return s
                }
              }
            return s
          }
          var s = [];
          for ( const g in this._byResource )
            for ( const m in this._byResource[ g ] )
              for ( let _ = 0, v = this._byResource[ g ][ m ]; _ < v.length; _++ ) {
                var y = v[ _ ];
                if ( e._accept( y, o ) ) {
                  var c = s.push( y );
                  if ( r > 0 && c === r ) return s
                }
              }
          return s
        }, e._accept = ( e, t ) => {
          return void 0 === t || ( t & e.severity ) === e.severity
        }, e._debouncer = ( t, n ) => {
          t || ( e._dedupeMap = Object.create( null ), t = [] );
          for ( let i = 0, o = n; i < o.length; i++ ) {
            const r = o[ i ];
            void 0 === e._dedupeMap[ r.toString() ] && ( e._dedupeMap[ r.toString() ] = !0, t.push( r ) )
          }
          return t
        }, e;
      } )();

      const Ie = n( "tTk5" );
      const De = n( "A+jI" );
      const Me = n( "EWX2" );
      const Te = n( "MNsG" );
      const Re = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const Pe = "$initialize";
      let Ae = !1;

      function Fe( e ) {
        Te.f && ( Ae || ( Ae = !0, console.warn( "Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/Microsoft/monaco-editor#faq" ) ), console.warn( e.message ) )
      }
      const We = ( () => {
          function e( e ) {
            this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = Object.create( null )
          }
          return e.prototype.setWorkerId = function ( e ) {
            this._workerId = e
          }, e.prototype.sendMessage = function ( e, t ) {
            const n = String( ++this._lastSentReq ),
              i = {
                c: null,
                e: null
              },
              o = new c.b( ( ( e, t ) => {
                i.c = e, i.e = t
              } ), ( () => {} ) );
            return this._pendingReplies[ n ] = i, this._send( {
              vsWorker: this._workerId,
              req: n,
              method: e,
              args: t
            } ), o
          }, e.prototype.handleMessage = function ( e ) {
            let t;
            try {
              t = JSON.parse( e )
            } catch ( n ) {}
            t && t.vsWorker && ( -1 !== this._workerId && t.vsWorker !== this._workerId || this._handleMessage( t ) )
          }, e.prototype._handleMessage = function ( e ) {
            const t = this;
            if ( e.seq ) {
              const n = e;
              if ( !this._pendingReplies[ n.seq ] ) return void console.warn( "Got reply to unknown seq" );
              const i = this._pendingReplies[ n.seq ];
              if ( delete this._pendingReplies[ n.seq ], n.err ) {
                let o = n.err;
                return n.err.$isError && ( ( o = new Error ).name = n.err.name, o.message = n.err.message, o.stack = n.err.stack ), void i.e( o )
              }
              i.c( n.res )
            } else {
              const r = e,
                s = r.req;
              this._handler.handleMessage( r.method, r.args ).then( ( e => {
                t._send( {
                  vsWorker: t._workerId,
                  seq: s,
                  res: e,
                  err: void 0
                } )
              } ), ( e => {
                e.detail instanceof Error && ( e.detail = Object( fe.g )( e.detail ) ), t._send( {
                  vsWorker: t._workerId,
                  seq: s,
                  res: void 0,
                  err: Object( fe.g )( e )
                } )
              } ) )
            }
          }, e.prototype._send = function ( e ) {
            const t = JSON.stringify( e );
            this._handler.sendMessage( t )
          }, e;
        } )(),
        je = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            let o = null;
            let r = null;
            i._worker = i._register( t.create( "vs/base/common/worker/simpleWorker", ( e => {
              i._protocol.handleMessage( e )
            } ), ( e => {
              r( e )
            } ) ) ), i._protocol = new We( {
              sendMessage( e ) {
                i._worker.postMessage( e )
              },
              handleMessage( e, t ) {
                return c.b.as( null )
              }
            } ), i._protocol.setWorkerId( i._worker.getId() );
            let s = null;
            "undefined" !== typeof self.require && "function" === typeof self.require.getConfig ? s = self.require.getConfig() : "undefined" !== typeof self.requirejs && ( s = self.requirejs.s.contexts._.config ), i._lazyProxy = new c.b( ( ( e, t ) => {
              o = e, r = t
            } ), ( () => {} ) ), i._onModuleLoaded = i._protocol.sendMessage( Pe, [ i._worker.getId(), n, s ] ), i._onModuleLoaded.then( ( e => {
              for ( var t = {}, n = 0; n < e.length; n++ ) t[ e[ n ] ] = u( e[ n ], a );
              o( t )
            } ), ( e => {
              r( e ), i._onError( "Worker failed to load " + n, e )
            } ) );
            var a = ( e, t ) => {
                return i._request( e, t )
              },
              u = ( e, t ) => {
                return function () {
                  const n = Array.prototype.slice.call( arguments, 0 );
                  return t( e, n )
                };
              };
            return i
          }
          return Re( t, e ), t.prototype.getProxyObject = function () {
            return new ee.d( this._lazyProxy )
          }, t.prototype._request = function ( e, t ) {
            const n = this;
            return new c.b( ( ( i, o ) => {
              n._onModuleLoaded.then( ( () => {
                n._protocol.sendMessage( e, t ).then( i, o )
              } ), o )
            } ), ( () => {} ) );
          }, t.prototype._onError = ( e, t ) => {
            console.error( e ), console.info( t )
          }, t;
        } )( y.a );
      !( () => {
        function e( e, t ) {
          const n = this;
          this._requestHandler = t, this._protocol = new We( {
            sendMessage( t ) {
              e( t )
            },
            handleMessage( e, t ) {
              return n._handleMessage( e, t )
            }
          } )
        }
        e.prototype.onmessage = function ( e ) {
          this._protocol.handleMessage( e )
        }, e.prototype._handleMessage = function ( e, t ) {
          if ( e === Pe ) return this.initialize( t[ 0 ], t[ 1 ], t[ 2 ] );
          if ( !this._requestHandler || "function" !== typeof this._requestHandler[ e ] ) return c.b.wrapError( new Error( "Missing requestHandler or method: " + e ) );
          try {
            return c.b.as( this._requestHandler[ e ].apply( this._requestHandler, t ) )
          } catch ( n ) {
            return c.b.wrapError( n )
          }
        }, e.prototype.initialize = function ( e, t, n ) {
          let i;
          let o;
          const r = this;
          if ( this._protocol.setWorkerId( e ), this._requestHandler ) {
            const s = [];
            for ( const a in this._requestHandler ) "function" === typeof this._requestHandler[ a ] && s.push( a );
            return c.b.as( s )
          }
          n && ( "undefined" !== typeof n.baseUrl && delete n.baseUrl, "undefined" !== typeof n.paths && "undefined" !== typeof n.paths.vs && delete n.paths.vs, n.catchError = !0, self.require.config( n ) );
          const u = new c.b( ( ( e, t ) => {
            i = e, o = t
          } ) );
          return self.require( [ t ], ( function () {
            for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
            const n = e[ 0 ];
            r._requestHandler = n.create();
            const o = [];
            for ( const s in r._requestHandler ) "function" === typeof r._requestHandler[ s ] && o.push( s );
            i( o )
          } ), o ), u;
        }
      } )();
      const Ve = ( () => {
          function e( e, t, n, i, o ) {
            this.id = t, this.worker = ( ( e, t ) => {
              if ( Te.b.MonacoEnvironment ) {
                if ( "function" === typeof Te.b.MonacoEnvironment.getWorker ) return Te.b.MonacoEnvironment.getWorker( e, t );
                if ( "function" === typeof Te.b.MonacoEnvironment.getWorkerUrl ) return new Worker( Te.b.MonacoEnvironment.getWorkerUrl( e, t ) )
              }
              throw new Error( "You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker" )
            } )( "workerMain.js", n ), this.postMessage( e ), this.worker.onmessage = e => {
              i( e.data )
            }, "function" === typeof this.worker.addEventListener && this.worker.addEventListener( "error", o )
          }
          return e.prototype.getId = function () {
            return this.id
          }, e.prototype.postMessage = function ( e ) {
            this.worker && this.worker.postMessage( e )
          }, e.prototype.dispose = function () {
            this.worker.terminate(), this.worker = null
          }, e
        } )(),
        Be = ( () => {
          function e( e ) {
            this._label = e, this._webWorkerFailedBeforeError = !1
          }
          return e.prototype.create = function ( t, n, i ) {
            const o = this,
              r = ++e.LAST_WORKER_ID;
            if ( this._webWorkerFailedBeforeError ) throw this._webWorkerFailedBeforeError;
            return new Ve( t, r, this._label || "anonymous" + r, n, ( e => {
              Fe( e ), o._webWorkerFailedBeforeError = e, i( e )
            } ) );
          }, e.LAST_WORKER_ID = 0, e;
        } )(),
        He = n( "twdY" ),
        ze = n( "G2kB" ),
        Ue = n( "Gw4z" ),
        Ke = n( "N0LK" ),
        qe = 5e3,
        Ge = 3;

      function Ye( e, t, n, i ) {
        return new Ue.a( e, t, n ).ComputeDiff( i )
      }
      const Xe = ( () => {
          function e( t ) {
            for ( var n = [], i = [], o = 0, r = t.length; o < r; o++ ) n[ o ] = e._getFirstNonBlankColumn( t[ o ], 1 ), i[ o ] = e._getLastNonBlankColumn( t[ o ], 1 );
            this._lines = t, this._startColumns = n, this._endColumns = i
          }
          return e.prototype.getLength = function () {
            return this._lines.length
          }, e.prototype.getElementAtIndex = function ( e ) {
            return this._lines[ e ].substring( this._startColumns[ e ] - 1, this._endColumns[ e ] - 1 )
          }, e.prototype.getStartLineNumber = e => {
            return e + 1
          }, e.prototype.getEndLineNumber = e => {
            return e + 1
          }, e._getFirstNonBlankColumn = ( e, t ) => {
            const n = Ke.firstNonWhitespaceIndex( e );
            return -1 === n ? t : n + 1
          }, e._getLastNonBlankColumn = ( e, t ) => {
            const n = Ke.lastNonWhitespaceIndex( e );
            return -1 === n ? t : n + 2
          }, e.prototype.getCharSequence = function ( e, t, n ) {
            for ( var i = [], o = [], r = [], s = 0, a = t; a <= n; a++ )
              for ( let u = this._lines[ a ], l = e ? this._startColumns[ a ] : 1, c = e ? this._endColumns[ a ] : u.length + 1, d = l; d < c; d++ ) i[ s ] = u.charCodeAt( d - 1 ), o[ s ] = a + 1, r[ s ] = d, s++;
            return new $e( i, o, r )
          }, e;
        } )(),
        $e = ( () => {
          function e( e, t, n ) {
            this._charCodes = e, this._lineNumbers = t, this._columns = n
          }
          return e.prototype.getLength = function () {
            return this._charCodes.length
          }, e.prototype.getElementAtIndex = function ( e ) {
            return this._charCodes[ e ]
          }, e.prototype.getStartLineNumber = function ( e ) {
            return this._lineNumbers[ e ]
          }, e.prototype.getStartColumn = function ( e ) {
            return this._columns[ e ]
          }, e.prototype.getEndLineNumber = function ( e ) {
            return this._lineNumbers[ e ]
          }, e.prototype.getEndColumn = function ( e ) {
            return this._columns[ e ] + 1
          }, e
        } )(),
        Ze = ( () => {
          function e( e, t, n, i, o, r, s, a ) {
            this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = n, this.originalEndColumn = i, this.modifiedStartLineNumber = o, this.modifiedStartColumn = r, this.modifiedEndLineNumber = s, this.modifiedEndColumn = a
          }
          return e.createFromDiffChange = ( t, n, i ) => {
            let o, r, s, a, u, l, c, d;
            return 0 === t.originalLength ? ( o = 0, r = 0, s = 0, a = 0 ) : ( o = n.getStartLineNumber( t.originalStart ), r = n.getStartColumn( t.originalStart ), s = n.getEndLineNumber( t.originalStart + t.originalLength - 1 ), a = n.getEndColumn( t.originalStart + t.originalLength - 1 ) ), 0 === t.modifiedLength ? ( u = 0, l = 0, c = 0, d = 0 ) : ( u = i.getStartLineNumber( t.modifiedStart ), l = i.getStartColumn( t.modifiedStart ), c = i.getEndLineNumber( t.modifiedStart + t.modifiedLength - 1 ), d = i.getEndColumn( t.modifiedStart + t.modifiedLength - 1 ) ), new e( o, r, s, a, u, l, c, d )
          }, e;
        } )();

      const Qe = ( () => {
        function e( e, t, n, i, o ) {
          this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = n, this.modifiedEndLineNumber = i, this.charChanges = o
        }
        return e.createFromDiffResult = ( t, n, i, o, r, s, a ) => {
          let u, l, c, d, h;
          if ( 0 === n.originalLength ? ( u = i.getStartLineNumber( n.originalStart ) - 1, l = 0 ) : ( u = i.getStartLineNumber( n.originalStart ), l = i.getEndLineNumber( n.originalStart + n.originalLength - 1 ) ), 0 === n.modifiedLength ? ( c = o.getStartLineNumber( n.modifiedStart ) - 1, d = 0 ) : ( c = o.getStartLineNumber( n.modifiedStart ), d = o.getEndLineNumber( n.modifiedStart + n.modifiedLength - 1 ) ), s && 0 !== n.originalLength && 0 !== n.modifiedLength && r() ) {
            const p = i.getCharSequence( t, n.originalStart, n.originalStart + n.originalLength - 1 );
            const f = o.getCharSequence( t, n.modifiedStart, n.modifiedStart + n.modifiedLength - 1 );
            let g = Ye( p, f, r, !0 );
            a && ( g = ( e => {
              if ( e.length <= 1 ) return e;
              for ( var t = [ e[ 0 ] ], n = t[ 0 ], i = 1, o = e.length; i < o; i++ ) {
                const r = e[ i ],
                  s = r.originalStart - ( n.originalStart + n.originalLength ),
                  a = r.modifiedStart - ( n.modifiedStart + n.modifiedLength );
                Math.min( s, a ) < Ge ? ( n.originalLength = r.originalStart + r.originalLength - n.originalStart, n.modifiedLength = r.modifiedStart + r.modifiedLength - n.modifiedStart ) : ( t.push( r ), n = r )
              }
              return t
            } )( g ) ), h = [];
            for ( let m = 0, _ = g.length; m < _; m++ ) h.push( Ze.createFromDiffChange( g[ m ], p, f ) )
          }
          return new e( u, l, c, d, h )
        }, e;
      } )();

      const Je = ( () => {
        function e( e, t, n ) {
          this.shouldComputeCharChanges = n.shouldComputeCharChanges, this.shouldPostProcessCharChanges = n.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = n.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = n.shouldMakePrettyDiff, this.maximumRunTimeMs = qe, this.originalLines = e, this.modifiedLines = t, this.original = new Xe( e ), this.modified = new Xe( t )
        }
        return e.prototype.computeDiff = function () {
          if ( 1 === this.original.getLength() && 0 === this.original.getElementAtIndex( 0 ).length ) return [ {
            originalStartLineNumber: 1,
            originalEndLineNumber: 1,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: this.modified.getLength(),
            charChanges: [ {
              modifiedEndColumn: 0,
              modifiedEndLineNumber: 0,
              modifiedStartColumn: 0,
              modifiedStartLineNumber: 0,
              originalEndColumn: 0,
              originalEndLineNumber: 0,
              originalStartColumn: 0,
              originalStartLineNumber: 0
            } ]
          } ];
          if ( 1 === this.modified.getLength() && 0 === this.modified.getElementAtIndex( 0 ).length ) return [ {
            originalStartLineNumber: 1,
            originalEndLineNumber: this.original.getLength(),
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: 1,
            charChanges: [ {
              modifiedEndColumn: 0,
              modifiedEndLineNumber: 0,
              modifiedStartColumn: 0,
              modifiedStartLineNumber: 0,
              originalEndColumn: 0,
              originalEndLineNumber: 0,
              originalStartColumn: 0,
              originalStartLineNumber: 0
            } ]
          } ];
          this.computationStartTime = ( new Date ).getTime();
          const e = Ye( this.original, this.modified, this._continueProcessingPredicate.bind( this ), this.shouldMakePrettyDiff );
          if ( this.shouldIgnoreTrimWhitespace ) {
            for ( var t = [], n = 0, i = e.length; n < i; n++ ) t.push( Qe.createFromDiffResult( this.shouldIgnoreTrimWhitespace, e[ n ], this.original, this.modified, this._continueProcessingPredicate.bind( this ), this.shouldComputeCharChanges, this.shouldPostProcessCharChanges ) );
            return t
          }
          for ( var o = [], r = 0, s = 0, a = ( n = -1, e.length ); n < a; n++ ) {
            for ( var u = n + 1 < a ? e[ n + 1 ] : null, l = u ? u.originalStart : this.originalLines.length, c = u ? u.modifiedStart : this.modifiedLines.length; r < l && s < c; ) {
              const d = this.originalLines[ r ],
                h = this.modifiedLines[ s ];
              if ( d !== h ) {
                for ( var p = Xe._getFirstNonBlankColumn( d, 1 ), f = Xe._getFirstNonBlankColumn( h, 1 ); p > 1 && f > 1; ) {
                  if ( d.charCodeAt( p - 2 ) !== h.charCodeAt( f - 2 ) ) break;
                  p--, f--
                }( p > 1 || f > 1 ) && this._pushTrimWhitespaceCharChange( o, r + 1, 1, p, s + 1, 1, f );
                for ( var g = Xe._getLastNonBlankColumn( d, 1 ), m = Xe._getLastNonBlankColumn( h, 1 ), _ = d.length + 1, v = h.length + 1; g < _ && m < v; ) {
                  if ( d.charCodeAt( g - 1 ) !== d.charCodeAt( m - 1 ) ) break;
                  g++, m++
                }( g < _ || m < v ) && this._pushTrimWhitespaceCharChange( o, r + 1, g, _, s + 1, m, v )
              }
              r++, s++
            }
            u && ( o.push( Qe.createFromDiffResult( this.shouldIgnoreTrimWhitespace, u, this.original, this.modified, this._continueProcessingPredicate.bind( this ), this.shouldComputeCharChanges, this.shouldPostProcessCharChanges ) ), r += u.originalLength, s += u.modifiedLength )
          }
          return o
        }, e.prototype._pushTrimWhitespaceCharChange = function ( e, t, n, i, o, r, s ) {
          let a;
          this._mergeTrimWhitespaceCharChange( e, t, n, i, o, r, s ) || ( this.shouldComputeCharChanges && ( a = [ new Ze( t, n, t, i, o, r, o, s ) ] ), e.push( new Qe( t, t, o, o, a ) ) )
        }, e.prototype._mergeTrimWhitespaceCharChange = function ( e, t, n, i, o, r, s ) {
          const a = e.length;
          if ( 0 === a ) return !1;
          const u = e[ a - 1 ];
          return 0 !== u.originalEndLineNumber && 0 !== u.modifiedEndLineNumber && ( u.originalEndLineNumber + 1 === t && u.modifiedEndLineNumber + 1 === o && ( u.originalEndLineNumber = t, u.modifiedEndLineNumber = o, this.shouldComputeCharChanges && u.charChanges.push( new Ze( t, n, t, i, o, r, o, s ) ), !0 ) )
        }, e.prototype._continueProcessingPredicate = function () {
          return 0 === this.maximumRunTimeMs || ( new Date ).getTime() - this.computationStartTime < this.maximumRunTimeMs
        }, e;
      } )();
      const et = n( "LeU+" );
      const tt = ( () => {
        function e( e, t, n, i ) {
          this._uri = e, this._lines = t, this._eol = n, this._versionId = i
        }
        return e.prototype.dispose = function () {
          this._lines.length = 0
        }, e.prototype.getText = function () {
          return this._lines.join( this._eol )
        }, e.prototype.onEvents = function ( e ) {
          e.eol && e.eol !== this._eol && ( this._eol = e.eol, this._lineStarts = null );
          for ( let t = e.changes, n = 0, i = t.length; n < i; n++ ) {
            const o = t[ n ];
            this._acceptDeleteRange( o.range ), this._acceptInsertText( new a.a( o.range.startLineNumber, o.range.startColumn ), o.text )
          }
          this._versionId = e.versionId
        }, e.prototype._ensureLineStarts = function () {
          if ( !this._lineStarts ) {
            for ( var e = this._eol.length, t = this._lines.length, n = new Uint32Array( t ), i = 0; i < t; i++ ) n[ i ] = this._lines[ i ].length + e;
            this._lineStarts = new et.a( n )
          }
        }, e.prototype._setLineText = function ( e, t ) {
          this._lines[ e ] = t, this._lineStarts && this._lineStarts.changeValue( e, this._lines[ e ].length + this._eol.length )
        }, e.prototype._acceptDeleteRange = function ( e ) {
          if ( e.startLineNumber !== e.endLineNumber ) this._setLineText( e.startLineNumber - 1, this._lines[ e.startLineNumber - 1 ].substring( 0, e.startColumn - 1 ) + this._lines[ e.endLineNumber - 1 ].substring( e.endColumn - 1 ) ), this._lines.splice( e.startLineNumber, e.endLineNumber - e.startLineNumber ), this._lineStarts && this._lineStarts.removeValues( e.startLineNumber, e.endLineNumber - e.startLineNumber );
          else {
            if ( e.startColumn === e.endColumn ) return;
            this._setLineText( e.startLineNumber - 1, this._lines[ e.startLineNumber - 1 ].substring( 0, e.startColumn - 1 ) + this._lines[ e.startLineNumber - 1 ].substring( e.endColumn - 1 ) )
          }
        }, e.prototype._acceptInsertText = function ( e, t ) {
          if ( 0 !== t.length ) {
            const n = t.split( /\r\n|\r|\n/ );
            if ( 1 !== n.length ) {
              n[ n.length - 1 ] += this._lines[ e.lineNumber - 1 ].substring( e.column - 1 ), this._setLineText( e.lineNumber - 1, this._lines[ e.lineNumber - 1 ].substring( 0, e.column - 1 ) + n[ 0 ] );
              for ( var i = new Uint32Array( n.length - 1 ), o = 1; o < n.length; o++ ) this._lines.splice( e.lineNumber + o - 1, 0, n[ o ] ), i[ o - 1 ] = n[ o ].length + this._eol.length;
              this._lineStarts && this._lineStarts.insertValues( e.lineNumber, i )
            } else this._setLineText( e.lineNumber - 1, this._lines[ e.lineNumber - 1 ].substring( 0, e.column - 1 ) + n[ 0 ] + this._lines[ e.lineNumber - 1 ].substring( e.column - 1 ) )
          }
        }, e;
      } )();
      const nt = n( "MXAL" );
      const it = n( "UHym" );

      const ot = ( () => {
        function e( e ) {
          for ( var t = 0, n = 0, i = 0, o = e.length; i < o; i++ ) {
            const r = e[ i ];
            var s = r[ 0 ];
            ( l = r[ 1 ] ) > t && ( t = l ), s > n && ( n = s ), ( c = r[ 2 ] ) > n && ( n = c )
          }
          t++, n++;
          const a = new it.a( n, t, 0 );
          for ( i = 0, o = e.length; i < o; i++ ) {
            const u = e[ i ];
            var l = ( s = u[ 0 ], u[ 1 ] );
            var c = u[ 2 ];
            a.set( s, l, c )
          }
          this._states = a, this._maxCharCode = t
        }
        return e.prototype.nextState = function ( e, t ) {
          return t < 0 || t >= this._maxCharCode ? 0 : this._states.get( e, t )
        }, e
      } )();

      let rt = null;
      let st = null;
      const at = ( () => {
        function e() {}
        return e._createLink = ( e, t, n, i, o ) => {
          let r = o - 1;
          do {
            const s = t.charCodeAt( r );
            if ( 2 !== e.get( s ) ) break;
            r--
          } while ( r > i );
          if ( i > 0 ) {
            const a = t.charCodeAt( i - 1 ),
              u = t.charCodeAt( r );
            ( 40 === a && 41 === u || 91 === a && 93 === u || 123 === a && 125 === u ) && r--
          }
          return {
            range: {
              startLineNumber: n,
              startColumn: i + 1,
              endLineNumber: n,
              endColumn: r + 2
            },
            url: t.substring( i, r + 1 )
          }
        }, e.computeLinks = t => {
          for ( var n = ( null === rt && ( rt = new ot( [
              [ 1, 104, 2 ],
              [ 1, 72, 2 ],
              [ 1, 102, 6 ],
              [ 1, 70, 6 ],
              [ 2, 116, 3 ],
              [ 2, 84, 3 ],
              [ 3, 116, 4 ],
              [ 3, 84, 4 ],
              [ 4, 112, 5 ],
              [ 4, 80, 5 ],
              [ 5, 115, 9 ],
              [ 5, 83, 9 ],
              [ 5, 58, 10 ],
              [ 6, 105, 7 ],
              [ 6, 73, 7 ],
              [ 7, 108, 8 ],
              [ 7, 76, 8 ],
              [ 8, 101, 9 ],
              [ 8, 69, 9 ],
              [ 9, 58, 10 ],
              [ 10, 47, 11 ],
              [ 11, 47, 12 ]
            ] ) ), rt ), i = ( () => {
              if ( null === st ) {
                st = new nt.a( 0 );
                for ( var e = 0; e < " \t<>'\"\u3001\u3002\uff61\uff64\uff0c\uff0e\uff1a\uff1b\uff1f\uff01\uff20\uff03\uff04\uff05\uff06\uff0a\u2018\u201c\u3008\u300a\u300c\u300e\u3010\u3014\uff08\uff3b\uff5b\uff62\uff63\uff5d\uff3d\uff09\u3015\u3011\u300f\u300d\u300b\u3009\u201d\u2019\uff40\uff5e\u2026".length; e++ ) st.set( " \t<>'\"\u3001\u3002\uff61\uff64\uff0c\uff0e\uff1a\uff1b\uff1f\uff01\uff20\uff03\uff04\uff05\uff06\uff0a\u2018\u201c\u3008\u300a\u300c\u300e\u3010\u3014\uff08\uff3b\uff5b\uff62\uff63\uff5d\uff3d\uff09\u3015\u3011\u300f\u300d\u300b\u3009\u201d\u2019\uff40\uff5e\u2026".charCodeAt( e ), 1 );
                for ( e = 0; e < ".,;".length; e++ ) st.set( ".,;".charCodeAt( e ), 2 )
              }
              return st
            } )(), o = [], r = 1, s = t.getLineCount(); r <= s; r++ ) {
            for ( var a = t.getLineContent( r ), u = a.length, l = 0, c = 0, d = 0, h = 1, p = !1, f = !1, g = !1; l < u; ) {
              let m = !1;
              const _ = a.charCodeAt( l );
              if ( 13 === h ) {
                var v = void 0;
                switch ( _ ) {
                  case 40:
                    p = !0, v = 0;
                    break;
                  case 41:
                    v = p ? 0 : 1;
                    break;
                  case 91:
                    f = !0, v = 0;
                    break;
                  case 93:
                    v = f ? 0 : 1;
                    break;
                  case 123:
                    g = !0, v = 0;
                    break;
                  case 125:
                    v = g ? 0 : 1;
                    break;
                  case 39:
                    v = 34 === d || 96 === d ? 0 : 1;
                    break;
                  case 34:
                    v = 39 === d || 96 === d ? 0 : 1;
                    break;
                  case 96:
                    v = 39 === d || 34 === d ? 0 : 1;
                    break;
                  default:
                    v = i.get( _ )
                }
                1 === v && ( o.push( e._createLink( i, a, r, c, l ) ), m = !0 )
              } else if ( 12 === h ) {
                1 === ( v = i.get( _ ) ) ? m = !0 : h = 13
              } else 0 === ( h = n.nextState( h, _ ) ) && ( m = !0 );
              m && ( h = 1, p = !1, f = !1, g = !1, c = l + 1, d = _ ), l++
            }
            13 === h && o.push( e._createLink( i, a, r, c, u ) )
          }
          return o
        }, e;
      } )();
      const ut = ( () => {
          function e() {
            this._defaultValueSet = [
              [ "true", "false" ],
              [ "True", "False" ],
              [ "Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly" ],
              [ "public", "protected", "private" ]
            ]
          }
          return e.prototype.navigateValueSet = function ( e, t, n, i, o ) {
            let r;
            if ( e && t && ( r = this.doNavigateValueSet( t, o ) ) ) return {
              range: e,
              value: r
            };
            if ( n && i && ( r = this.doNavigateValueSet( i, o ) ) ) return {
              range: n,
              value: r
            };
            return null
          }, e.prototype.doNavigateValueSet = function ( e, t ) {
            const n = this.numberReplace( e, t );
            return null !== n ? n : this.textReplace( e, t )
          }, e.prototype.numberReplace = ( e, t ) => {
            const n = Math.pow( 10, e.length - ( e.lastIndexOf( "." ) + 1 ) );
            let i = Number( e );
            const o = parseFloat( e );
            return isNaN( i ) || isNaN( o ) || i !== o ? null : 0 !== i || t ? ( i = Math.floor( i * n ), i += t ? n : -n, String( i / n ) ) : null
          }, e.prototype.textReplace = function ( e, t ) {
            return this.valueSetsReplace( this._defaultValueSet, e, t )
          }, e.prototype.valueSetsReplace = function ( e, t, n ) {
            for ( var i = null, o = 0, r = e.length; null === i && o < r; o++ ) i = this.valueSetReplace( e[ o ], t, n );
            return i
          }, e.prototype.valueSetReplace = ( e, t, n ) => {
            let i = e.indexOf( t );
            return i >= 0 ? ( ( i += n ? 1 : -1 ) < 0 ? i = e.length - 1 : i %= e.length, e[ i ] ) : null
          }, e.INSTANCE = new e, e;
        } )(),
        lt = n( "0JNc" ),
        ct = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        dt = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return ct( t, e ), Object.defineProperty( t.prototype, "uri", {
            get() {
              return this._uri
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( t.prototype, "version", {
            get() {
              return this._versionId
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( t.prototype, "eol", {
            get() {
              return this._eol
            },
            enumerable: !0,
            configurable: !0
          } ), t.prototype.getValue = function () {
            return this.getText()
          }, t.prototype.getLinesContent = function () {
            return this._lines.slice( 0 )
          }, t.prototype.getLineCount = function () {
            return this._lines.length
          }, t.prototype.getLineContent = function ( e ) {
            return this._lines[ e - 1 ]
          }, t.prototype.getWordAtPosition = function ( e, t ) {
            const n = Object( lt.d )( e.column, Object( lt.c )( t ), this._lines[ e.lineNumber - 1 ], 0 );
            return n ? new u.a( e.lineNumber, n.startColumn, e.lineNumber, n.endColumn ) : null
          }, t.prototype.getWordUntilPosition = function ( e, t ) {
            const n = this.getWordAtPosition( e, t );
            return n ? {
              word: this._lines[ e.lineNumber - 1 ].substring( n.startColumn - 1, e.column - 1 ),
              startColumn: n.startColumn,
              endColumn: e.column
            } : {
              word: "",
              startColumn: e.column,
              endColumn: e.column
            }
          }, t.prototype.createWordIterator = function ( e ) {
            let t;
            const n = this;
            const i = {
              done: !1,
              value: ""
            };
            let o = 0;
            let r = 0;
            let s = [];
            const a = () => {
              if ( r < s.length ) i.done = !1, i.value = t.substring( s[ r ].start, s[ r ].end ), r += 1;
              else {
                if ( !( o >= n._lines.length ) ) return t = n._lines[ o ], s = n._wordenize( t, e ), r = 0, o += 1, a();
                i.done = !0, i.value = void 0
              }
              return i
            };
            return {
              next: a
            }
          }, t.prototype._wordenize = ( e, t ) => {
            let n;
            const i = [];
            for ( t.lastIndex = 0;
              ( n = t.exec( e ) ) && 0 !== n[ 0 ].length; ) i.push( {
              start: n.index,
              end: n.index + n[ 0 ].length
            } );
            return i
          }, t.prototype.getValueInRange = function ( e ) {
            if ( ( e = this._validateRange( e ) ).startLineNumber === e.endLineNumber ) return this._lines[ e.startLineNumber - 1 ].substring( e.startColumn - 1, e.endColumn - 1 );
            const t = this._eol,
              n = e.startLineNumber - 1,
              i = e.endLineNumber - 1,
              o = [];
            o.push( this._lines[ n ].substring( e.startColumn - 1 ) );
            for ( let r = n + 1; r < i; r++ ) o.push( this._lines[ r ] );
            return o.push( this._lines[ i ].substring( 0, e.endColumn - 1 ) ), o.join( t )
          }, t.prototype.offsetAt = function ( e ) {
            return e = this._validatePosition( e ), this._ensureLineStarts(), this._lineStarts.getAccumulatedValue( e.lineNumber - 2 ) + ( e.column - 1 )
          }, t.prototype.positionAt = function ( e ) {
            e = Math.floor( e ), e = Math.max( 0, e ), this._ensureLineStarts();
            const t = this._lineStarts.getIndexOf( e ),
              n = this._lines[ t.index ].length;
            return {
              lineNumber: 1 + t.index,
              column: 1 + Math.min( t.remainder, n )
            }
          }, t.prototype._validateRange = function ( e ) {
            const t = this._validatePosition( {
                lineNumber: e.startLineNumber,
                column: e.startColumn
              } ),
              n = this._validatePosition( {
                lineNumber: e.endLineNumber,
                column: e.endColumn
              } );
            return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || n.lineNumber !== e.endLineNumber || n.column !== e.endColumn ? {
              startLineNumber: t.lineNumber,
              startColumn: t.column,
              endLineNumber: n.lineNumber,
              endColumn: n.column
            } : e
          }, t.prototype._validatePosition = function ( e ) {
            if ( !a.a.isIPosition( e ) ) throw new Error( "bad position" );
            let t = e.lineNumber,
              n = e.column,
              i = !1;
            if ( t < 1 ) t = 1, n = 1, i = !0;
            else if ( t > this._lines.length ) t = this._lines.length, n = this._lines[ t - 1 ].length + 1, i = !0;
            else {
              const o = this._lines[ t - 1 ].length + 1;
              n < 1 ? ( n = 1, i = !0 ) : n > o && ( n = o, i = !0 )
            }
            return i ? {
              lineNumber: t,
              column: n
            } : e
          }, t;
        } )( tt ),
        ht = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._models = Object.create( null ), n
          }
          return ct( t, e ), t.prototype.dispose = function () {
            this._models = Object.create( null )
          }, t.prototype._getModel = function ( e ) {
            return this._models[ e ]
          }, t.prototype._getModels = function () {
            const e = this,
              t = [];
            return Object.keys( this._models ).forEach( ( n => {
              return t.push( e._models[ n ] )
            } ) ), t;
          }, t.prototype.acceptNewModel = function ( e ) {
            this._models[ e.url ] = new dt( p.a.parse( e.url ), e.lines, e.EOL, e.versionId )
          }, t.prototype.acceptModelChanged = function ( e, t ) {
            this._models[ e ] && this._models[ e ].onEvents( t )
          }, t.prototype.acceptRemovedModel = function ( e ) {
            this._models[ e ] && delete this._models[ e ]
          }, t;
        } )(
          ( () => {
            function e( e ) {
              this._foreignModuleFactory = e, this._foreignModule = null
            }
            return e.prototype.computeDiff = function ( e, t, n ) {
              const i = this._getModel( e ),
                o = this._getModel( t );
              if ( !i || !o ) return null;
              const r = i.getLinesContent(),
                s = o.getLinesContent(),
                a = new Je( r, s, {
                  shouldComputeCharChanges: !0,
                  shouldPostProcessCharChanges: !0,
                  shouldIgnoreTrimWhitespace: n,
                  shouldMakePrettyDiff: !0
                } );
              return c.b.as( a.computeDiff() )
            }, e.prototype.computeMoreMinimalEdits = function ( t, n ) {
              const i = this._getModel( t );
              if ( !i ) return c.b.as( n );
              for ( var o, r = [], s = 0, a = n; s < a.length; s++ ) {
                const l = a[ s ];
                const d = l.range;
                let h = l.text;
                const p = l.eol;
                if ( "number" === typeof p && ( o = p ), d ) {
                  const f = i.getValueInRange( d );
                  if ( f !== ( h = h.replace( /\r\n|\n|\r/g, i.eol ) ) )
                    if ( Math.max( h.length, f.length ) > e._diffLimit ) r.push( {
                      range: d,
                      text: h
                    } );
                    else
                      for ( let g = Object( Ue.b )( f, h, !1 ), m = i.offsetAt( u.a.lift( d ).getStartPosition() ), _ = 0, v = g; _ < v.length; _++ ) {
                        const y = v[ _ ],
                          b = i.positionAt( m + y.originalStart ),
                          C = i.positionAt( m + y.originalStart + y.originalLength ),
                          w = {
                            text: h.substr( y.modifiedStart, y.modifiedLength ),
                            range: {
                              startLineNumber: b.lineNumber,
                              startColumn: b.column,
                              endLineNumber: C.lineNumber,
                              endColumn: C.column
                            }
                          };
                        i.getValueInRange( w.range ) !== w.text && r.push( w )
                      }
                }
              }
              return "number" === typeof o && r.push( {
                eol: o,
                text: void 0,
                range: void 0
              } ), c.b.as( r )
            }, e.prototype.computeLinks = function ( e ) {
              const t = this._getModel( e );
              return t ? c.b.as(
                ( e => {
                  return e && "function" === typeof e.getLineCount && "function" === typeof e.getLineContent ? at.computeLinks( e ) : []
                } )( t )
              ) : null;
            }, e.prototype.textualSuggest = function ( t, n, i, o ) {
              const r = this._getModel( t );
              if ( r ) {
                const s = [],
                  a = new RegExp( i, o ),
                  u = r.getWordUntilPosition( n, a ).word,
                  l = Object.create( null );
                l[ u ] = !0;
                for ( let d = r.createWordIterator( a ), h = d.next(); !h.done && s.length <= e._suggestionsLimit; h = d.next() ) {
                  const p = h.value;
                  l[ p ] || ( l[ p ] = !0, isNaN( Number( p ) ) && s.push( {
                    type: "text",
                    label: p,
                    insertText: p,
                    noAutoAccept: !0,
                    overwriteBefore: u.length
                  } ) )
                }
                return c.b.as( {
                  suggestions: s
                } )
              }
            }, e.prototype.navigateValueSet = function ( e, t, n, i, o ) {
              const r = this._getModel( e );
              if ( !r ) return null;
              const s = new RegExp( i, o );
              t.startColumn === t.endColumn && ( t = {
                startLineNumber: t.startLineNumber,
                startColumn: t.startColumn,
                endLineNumber: t.endLineNumber,
                endColumn: t.endColumn + 1
              } );
              const a = r.getValueInRange( t );
              const u = r.getWordAtPosition( {
                lineNumber: t.startLineNumber,
                column: t.startColumn
              }, s );
              let l = null;
              null !== u && ( l = r.getValueInRange( u ) );
              const d = ut.INSTANCE.navigateValueSet( t, a, u, l, n );
              return c.b.as( d )
            }, e.prototype.loadForeignModule = function ( e, t ) {
              const n = this,
                i = {
                  getMirrorModels() {
                    return n._getModels()
                  }
                };
              if ( this._foreignModuleFactory ) {
                this._foreignModule = this._foreignModuleFactory( i, t );
                const o = [];
                for ( const r in this._foreignModule ) "function" === typeof this._foreignModule[ r ] && o.push( r );
                return c.b.as( o )
              }
              return c.b.wrapError( new Error( "Unexpected usage" ) )
            }, e.prototype.fmr = function ( e, t ) {
              if ( !this._foreignModule || "function" !== typeof this._foreignModule[ e ] ) return c.b.wrapError( new Error( "Missing requestHandler or method: " + e ) );
              try {
                return c.b.as( this._foreignModule[ e ].apply( this._foreignModule, t ) )
              } catch ( n ) {
                return c.b.wrapError( n )
              }
            }, e._diffLimit = 1e4, e._suggestionsLimit = 1e4, e;
          } )()
        );
      "function" === typeof importScripts && ( Te.b.monaco = m() );
      const pt = n( "cMvZ" ),
        ft = Object( C.c )( "textResourceConfigurationService" ),
        gt = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        mt = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        _t = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        vt = 6e4,
        yt = 3e5;

      function bt( e, t ) {
        const n = e.getModel( t );
        return !!n && !n.isTooLargeForSyncing()
      }
      const Ct = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            return i._modelService = t, i._workerManager = i._register( new St( i._modelService ) ), i._register( He.p.register( "*", {
              provideLinks( e, t ) {
                return bt( i._modelService, e.uri ) ? Object( ee.o )( t, i._workerManager.withWorker().then( ( t => {
                  return t.computeLinks( e.uri )
                } ) ) ) : c.b.as( [] );
              }
            } ) ), i._register( He.u.register( "*", new wt( i._workerManager, n, i._modelService ) ) ), i;
          }
          return gt( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype.canComputeDiff = function ( e, t ) {
            return bt( this._modelService, e ) && bt( this._modelService, t )
          }, t.prototype.computeDiff = function ( e, t, n ) {
            return this._workerManager.withWorker().then( ( i => {
              return i.computeDiff( e, t, n )
            } ) );
          }, t.prototype.computeMoreMinimalEdits = function ( e, t ) {
            return Array.isArray( t ) && 0 !== t.length && bt( this._modelService, e ) ? this._workerManager.withWorker().then( ( n => {
              return n.computeMoreMinimalEdits( e, t )
            } ) ) : c.b.as( t );
          }, t.prototype.canNavigateValueSet = function ( e ) {
            return bt( this._modelService, e )
          }, t.prototype.navigateValueSet = function ( e, t, n ) {
            return this._workerManager.withWorker().then( ( i => {
              return i.navigateValueSet( e, t, n )
            } ) );
          }, t = mt( [ _t( 0, ze.a ), _t( 1, ft ) ], t );
        } )( y.a ),
        wt = ( () => {
          function e( e, t, n ) {
            this._workerManager = e, this._configurationService = t, this._modelService = n
          }
          return e.prototype.provideCompletionItems = function ( e, t ) {
            if ( this._configurationService.getValue( e.uri, t, "editor" ).wordBasedSuggestions && bt( this._modelService, e.uri ) ) return this._workerManager.withWorker().then( ( n => {
              return n.textualSuggest( e.uri, t )
            } ) );
          }, e;
        } )(),
        St = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._modelService = t, n._editorWorkerClient = null, n._register( new ee.b ).cancelAndSet( ( () => {
              return n._checkStopIdleWorker()
            } ), Math.round( yt / 2 ) ), n._register( n._modelService.onModelRemoved( ( e => {
              return n._checkStopEmptyWorker()
            } ) ) ), n;
          }
          return gt( t, e ), t.prototype.dispose = function () {
            this._editorWorkerClient && ( this._editorWorkerClient.dispose(), this._editorWorkerClient = null ), e.prototype.dispose.call( this )
          }, t.prototype._checkStopEmptyWorker = function () {
            this._editorWorkerClient && ( 0 === this._modelService.getModels().length && ( this._editorWorkerClient.dispose(), this._editorWorkerClient = null ) )
          }, t.prototype._checkStopIdleWorker = function () {
            this._editorWorkerClient && ( ( new Date ).getTime() - this._lastWorkerUsedTime > yt && ( this._editorWorkerClient.dispose(), this._editorWorkerClient = null ) )
          }, t.prototype.withWorker = function () {
            return this._lastWorkerUsedTime = ( new Date ).getTime(), this._editorWorkerClient || ( this._editorWorkerClient = new xt( this._modelService, "editorWorkerService" ) ), c.b.as( this._editorWorkerClient )
          }, t
        } )( y.a ),
        Ot = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            if ( o._syncedModels = Object.create( null ), o._syncedModelsLastUsedTime = Object.create( null ), o._proxy = t, o._modelService = n, !i ) {
              const r = new ee.b;
              r.cancelAndSet( ( () => {
                return o._checkStopModelSync()
              } ), Math.round( vt / 2 ) ), o._register( r )
            }
            return o
          }
          return gt( t, e ), t.prototype.dispose = function () {
            for ( const t in this._syncedModels ) Object( y.d )( this._syncedModels[ t ] );
            this._syncedModels = Object.create( null ), this._syncedModelsLastUsedTime = Object.create( null ), e.prototype.dispose.call( this )
          }, t.prototype.esureSyncedResources = function ( e ) {
            for ( let t = 0; t < e.length; t++ ) {
              const n = e[ t ],
                i = n.toString();
              this._syncedModels[ i ] || this._beginModelSync( n ), this._syncedModels[ i ] && ( this._syncedModelsLastUsedTime[ i ] = ( new Date ).getTime() )
            }
          }, t.prototype._checkStopModelSync = function () {
            const e = ( new Date ).getTime(),
              t = [];
            for ( const n in this._syncedModelsLastUsedTime ) {
              e - this._syncedModelsLastUsedTime[ n ] > vt && t.push( n )
            }
            for ( let i = 0; i < t.length; i++ ) this._stopModelSync( t[ i ] )
          }, t.prototype._beginModelSync = function ( e ) {
            const t = this,
              n = this._modelService.getModel( e );
            if ( n && !n.isTooLargeForSyncing() ) {
              const i = e.toString();
              this._proxy.acceptNewModel( {
                url: n.uri.toString(),
                lines: n.getLinesContent(),
                EOL: n.getEOL(),
                versionId: n.getVersionId()
              } );
              const o = [];
              o.push( n.onDidChangeContent( ( e => {
                t._proxy.acceptModelChanged( i.toString(), e )
              } ) ) ), o.push( n.onWillDispose( ( () => {
                t._stopModelSync( i )
              } ) ) ), o.push( Object( y.f )( ( () => {
                t._proxy.acceptRemovedModel( i )
              } ) ) ), this._syncedModels[ i ] = o
            }
          }, t.prototype._stopModelSync = function ( e ) {
            const t = this._syncedModels[ e ];
            delete this._syncedModels[ e ], delete this._syncedModelsLastUsedTime[ e ], Object( y.d )( t )
          }, t;
        } )( y.a ),
        Lt = ( () => {
          function e( e ) {
            this._instance = e, this._proxyObj = c.b.as( this._instance )
          }
          return e.prototype.dispose = function () {
            this._instance.dispose(), this._instance = null, this._proxyObj = null
          }, e.prototype.getProxyObject = function () {
            return new ee.d( this._proxyObj )
          }, e
        } )(),
        xt = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            return i._modelService = t, i._workerFactory = new Be( n ), i._worker = null, i._modelManager = null, i
          }
          return gt( t, e ), t.prototype._getOrCreateWorker = function () {
            if ( !this._worker ) try {
              this._worker = this._register( new je( this._workerFactory, "vs/editor/common/services/editorSimpleWorker" ) )
            } catch ( e ) {
              Fe( e ), this._worker = new Lt( new ht( null ) )
            }
            return this._worker
          }, t.prototype._getProxy = function () {
            const e = this;
            return new ee.d( this._getOrCreateWorker().getProxyObject().then( null, ( t => {
              return Fe( t ), e._worker = new Lt( new ht( null ) ), e._getOrCreateWorker().getProxyObject()
            } ) ) );
          }, t.prototype._getOrCreateModelManager = function ( e ) {
            return this._modelManager || ( this._modelManager = this._register( new Ot( e, this._modelService, !1 ) ) ), this._modelManager
          }, t.prototype._withSyncedResources = function ( e ) {
            const t = this;
            return this._getProxy().then( ( n => {
              return t._getOrCreateModelManager( n ).esureSyncedResources( e ), n
            } ) );
          }, t.prototype.computeDiff = function ( e, t, n ) {
            return this._withSyncedResources( [ e, t ] ).then( ( i => {
              return i.computeDiff( e.toString(), t.toString(), n )
            } ) );
          }, t.prototype.computeMoreMinimalEdits = function ( e, t ) {
            return this._withSyncedResources( [ e ] ).then( ( n => {
              return n.computeMoreMinimalEdits( e.toString(), t )
            } ) );
          }, t.prototype.computeLinks = function ( e ) {
            return this._withSyncedResources( [ e ] ).then( ( t => {
              return t.computeLinks( e.toString() )
            } ) );
          }, t.prototype.textualSuggest = function ( e, t ) {
            const n = this;
            return this._withSyncedResources( [ e ] ).then( ( i => {
              const o = n._modelService.getModel( e );
              if ( !o ) return null;
              const r = pt.a.getWordDefinition( o.getLanguageIdentifier().id ),
                s = r.source,
                a = ( r.global ? "g" : "" ) + ( r.ignoreCase ? "i" : "" ) + ( r.multiline ? "m" : "" );
              return i.textualSuggest( e.toString(), t, s, a )
            } ) );
          }, t.prototype.navigateValueSet = function ( e, t, n ) {
            const i = this;
            return this._withSyncedResources( [ e ] ).then( ( o => {
              const r = i._modelService.getModel( e );
              if ( !r ) return null;
              const s = pt.a.getWordDefinition( r.getLanguageIdentifier().id ),
                a = s.source,
                u = ( s.global ? "g" : "" ) + ( s.ignoreCase ? "i" : "" ) + ( s.multiline ? "m" : "" );
              return o.navigateValueSet( e.toString(), t, n, a, u )
            } ) );
          }, t;
        } )( y.a ),
        Nt = n( "WBhO" ),
        Et = ( () => {
          function e( e ) {
            this._languageIdentifier = e
          }
          return e.prototype.getId = function () {
            return this._languageIdentifier.language
          }, e.prototype.getLanguageIdentifier = function () {
            return this._languageIdentifier
          }, e
        } )(),
        kt = n( "4J+e" ),
        It = n( "l2gE" ),
        Dt = "text/plain",
        Mt = "application/unknown",
        Tt = [],
        Rt = [],
        Pt = [];

      function At( e, t ) {
        void 0 === t && ( t = !1 );
        const n = ( e => {
          return {
            id: e.id,
            mime: e.mime,
            filename: e.filename,
            extension: e.extension,
            filepattern: e.filepattern,
            firstline: e.firstline,
            userConfigured: e.userConfigured,
            filenameLowercase: e.filename ? e.filename.toLowerCase() : void 0,
            extensionLowercase: e.extension ? e.extension.toLowerCase() : void 0,
            filepatternLowercase: e.filepattern ? e.filepattern.toLowerCase() : void 0,
            filepatternOnPath: !!e.filepattern && e.filepattern.indexOf( kt.i ) >= 0
          }
        } )( e );
        Tt.push( n ), n.userConfigured ? Pt.push( n ) : Rt.push( n ), t && !n.userConfigured && Tt.forEach( ( e => {
          e.mime === n.mime || e.userConfigured || ( n.extension && e.extension === n.extension && console.warn( "Overwriting extension <<" + n.extension + ">> to now point to mime <<" + n.mime + ">>" ), n.filename && e.filename === n.filename && console.warn( "Overwriting filename <<" + n.filename + ">> to now point to mime <<" + n.mime + ">>" ), n.filepattern && e.filepattern === n.filepattern && console.warn( "Overwriting filepattern <<" + n.filepattern + ">> to now point to mime <<" + n.mime + ">>" ), n.firstline && e.firstline === n.firstline && console.warn( "Overwriting firstline <<" + n.firstline + ">> to now point to mime <<" + n.mime + ">>" ) )
        } ) )
      }

      function Ft( e, t ) {
        if ( !e ) return [ Mt ];
        e = e.toLowerCase();
        const n = kt.a( e ),
          i = Wt( e, n, Pt );
        if ( i ) return [ i, Dt ];
        const o = Wt( e, n, Rt );
        if ( o ) return [ o, Dt ];
        if ( t ) {
          const r = ( e => {
            Ke.startsWithUTF8BOM( e ) && ( e = e.substr( 1 ) );
            if ( e.length > 0 )
              for ( let t = 0; t < Tt.length; ++t ) {
                const n = Tt[ t ];
                if ( n.firstline ) {
                  const i = e.match( n.firstline );
                  if ( i && i.length > 0 ) return n.mime
                }
              }
            return null
          } )( t );
          if ( r ) return [ r, Dt ]
        }
        return [ Mt ]
      }

      function Wt( e, t, n ) {
        for ( var i, o, r, s = n.length - 1; s >= 0; s-- ) {
          const a = n[ s ];
          if ( t === a.filenameLowercase ) {
            i = a;
            break
          }
          if ( a.filepattern && ( !o || a.filepattern.length > o.filepattern.length ) ) {
            const u = a.filepatternOnPath ? e : t;
            Object( It.a )( a.filepatternLowercase, u ) && ( o = a )
          }
          a.extension && ( !r || a.extension.length > r.extension.length ) && Ke.endsWith( t, a.extensionLowercase ) && ( r = a )
        }
        return i ? i.mime : o ? o.mime : r ? r.mime : null
      }
      const jt = n( "ic2d" ),
        Vt = new( ( () => {
          function e() {
            this._onDidAddLanguages = new r.a, this.onDidAddLanguages = this._onDidAddLanguages.event, this._languages = []
          }
          return e.prototype.registerLanguage = function ( e ) {
            this._languages.push( e ), this._onDidAddLanguages.fire( [ e ] )
          }, e.prototype.getLanguages = function () {
            return this._languages.slice( 0 )
          }, e
        } )() )();
      jt.a.add( "editor.modesRegistry", Vt );
      const Bt = new He.o( "plaintext", 1 );
      Vt.registerLanguage( {
        id: "plaintext",
        extensions: [ ".txt", ".gitignore" ],
        aliases: [ P.a( "plainText.alias", "Plain Text" ), "text" ],
        mimetypes: [ "text/plain" ]
      } ), pt.a.register( Bt, {
        brackets: [
          [ "(", ")" ],
          [ "[", "]" ],
          [ "{", "}" ]
        ]
      } );
      const Ht = n( "i/Ef" ),
        zt = n( "CRAX" ),
        Ut = Object.prototype.hasOwnProperty,
        Kt = ( () => {
          function e( e, t ) {
            void 0 === e && ( e = !0 ), void 0 === t && ( t = !1 );
            const n = this;
            this._nextLanguageId = 1, this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, this._languageIds = [], this._warnOnOverwrite = t, e && ( this._registerLanguages( Vt.getLanguages() ), Vt.onDidAddLanguages( ( e => {
              return n._registerLanguages( e )
            } ) ) )
          }
          return e.prototype._registerLanguages = function ( e ) {
            const t = this;
            if ( 0 !== e.length ) {
              for ( let n = 0; n < e.length; n++ ) this._registerLanguage( e[ n ] );
              this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys( this._languages ).forEach( ( e => {
                const n = t._languages[ e ];
                n.name && ( t._nameMap[ n.name ] = n.identifier ), n.aliases.forEach( ( e => {
                  t._lowercaseNameMap[ e.toLowerCase() ] = n.identifier
                } ) ), n.mimetypes.forEach( ( e => {
                  t._mimeTypesMap[ e ] = n.identifier
                } ) )
              } ) ), jt.a.as( zt.b.Configuration ).registerOverrideIdentifiers( Vt.getLanguages().map( ( e => {
                return e.id
              } ) ) )
            }
          }, e.prototype._registerLanguage = function ( e ) {
            const t = e.id;
            let n = null;
            if ( Ut.call( this._languages, t ) ) n = this._languages[ t ];
            else {
              const i = this._nextLanguageId++;
              n = {
                identifier: new He.o( t, i ),
                name: null,
                mimetypes: [],
                aliases: [],
                extensions: [],
                filenames: [],
                configurationFiles: []
              }, this._languageIds[ i ] = t, this._languages[ t ] = n
            }
            this._mergeLanguage( n, e )
          }, e.prototype._mergeLanguage = function ( e, t ) {
            let n;
            const i = t.id;
            let o = null;
            if ( Array.isArray( t.mimetypes ) && t.mimetypes.length > 0 && ( ( n = e.mimetypes ).push.apply( n, t.mimetypes ), o = t.mimetypes[ 0 ] ), o || ( o = "text/x-" + i, e.mimetypes.push( o ) ), Array.isArray( t.extensions ) )
              for ( let r = 0, s = t.extensions; r < s.length; r++ ) {
                const a = s[ r ];
                At( {
                  id: i,
                  mime: o,
                  extension: a
                }, this._warnOnOverwrite ), e.extensions.push( a )
              }
            if ( Array.isArray( t.filenames ) )
              for ( let u = 0, l = t.filenames; u < l.length; u++ ) {
                const c = l[ u ];
                At( {
                  id: i,
                  mime: o,
                  filename: c
                }, this._warnOnOverwrite ), e.filenames.push( c )
              }
            if ( Array.isArray( t.filenamePatterns ) )
              for ( let d = 0, h = t.filenamePatterns; d < h.length; d++ ) {
                At( {
                  id: i,
                  mime: o,
                  filepattern: h[ d ]
                }, this._warnOnOverwrite )
              }
            if ( "string" === typeof t.firstLine && t.firstLine.length > 0 ) {
              let p = t.firstLine;
              "^" !== p.charAt( 0 ) && ( p = "^" + p );
              try {
                const f = new RegExp( p );
                Ke.regExpLeadsToEndlessLoop( f ) || At( {
                  id: i,
                  mime: o,
                  firstline: f
                }, this._warnOnOverwrite )
              } catch ( y ) {
                Object( fe.e )( y )
              }
            }
            e.aliases.push( i );
            let g = null;
            if ( "undefined" !== typeof t.aliases && Array.isArray( t.aliases ) && ( g = 0 === t.aliases.length ? [ null ] : t.aliases ), null !== g )
              for ( let m = 0; m < g.length; m++ ) g[ m ] && 0 !== g[ m ].length && e.aliases.push( g[ m ] );
            const _ = null !== g && g.length > 0;
            if ( _ && null === g[ 0 ] );
            else {
              const v = ( _ ? g[ 0 ] : null ) || i;
              !_ && e.name || ( e.name = v )
            }
            t.configuration && e.configurationFiles.push( t.configuration )
          }, e.prototype.isRegisteredMode = function ( e ) {
            return !!Ut.call( this._mimeTypesMap, e ) || Ut.call( this._languages, e )
          }, e.prototype.getModeIdForLanguageNameLowercase = function ( e ) {
            return Ut.call( this._lowercaseNameMap, e ) ? this._lowercaseNameMap[ e ].language : null
          }, e.prototype.extractModeIds = function ( e ) {
            const t = this;
            return e ? e.split( "," ).map( ( e => {
              return e.trim()
            } ) ).map( ( e => {
              return Ut.call( t._mimeTypesMap, e ) ? t._mimeTypesMap[ e ].language : e
            } ) ).filter( ( e => {
              return Ut.call( t._languages, e )
            } ) ) : [];
          }, e.prototype.getLanguageIdentifier = function ( e ) {
            if ( e === Ht.b || 0 === e ) return Ht.a;
            let t;
            if ( "string" === typeof e ) t = e;
            else if ( !( t = this._languageIds[ e ] ) ) return null;
            return Ut.call( this._languages, t ) ? this._languages[ t ].identifier : null
          }, e.prototype.getModeIdsFromFilenameOrFirstLine = function ( e, t ) {
            if ( !e && !t ) return [];
            const n = Ft( e, t );
            return this.extractModeIds( n.join( "," ) )
          }, e;
        } )(),
        qt = ( () => {
          function e( e ) {
            void 0 === e && ( e = !1 ), this._onDidCreateMode = new r.a, this.onDidCreateMode = this._onDidCreateMode.event, this._instantiatedModes = {}, this._registry = new Kt( !0, e )
          }
          return e.prototype._onReady = () => {
            return c.b.as( !0 )
          }, e.prototype.isRegisteredMode = function ( e ) {
            return this._registry.isRegisteredMode( e )
          }, e.prototype.getModeIdForLanguageName = function ( e ) {
            return this._registry.getModeIdForLanguageNameLowercase( e )
          }, e.prototype.getModeIdByFilenameOrFirstLine = function ( e, t ) {
            const n = this._registry.getModeIdsFromFilenameOrFirstLine( e, t );
            return n.length > 0 ? n[ 0 ] : null
          }, e.prototype.getModeId = function ( e ) {
            const t = this._registry.extractModeIds( e );
            return t.length > 0 ? t[ 0 ] : null
          }, e.prototype.getLanguageIdentifier = function ( e ) {
            return this._registry.getLanguageIdentifier( e )
          }, e.prototype.getMode = function ( e ) {
            for ( var t = this._registry.extractModeIds( e ), n = !1, i = 0; i < t.length; i++ ) {
              if ( this._instantiatedModes.hasOwnProperty( t[ i ] ) ) return this._instantiatedModes[ t[ i ] ];
              n = n || "plaintext" === t[ i ]
            }
            if ( n ) {
              let o = null;
              return this.getOrCreateMode( e ).then( ( e => {
                o = e
              } ) ).done( null, fe.e ), o;
            }
            return null
          }, e.prototype.getOrCreateMode = function ( e ) {
            const t = this;
            return this._onReady().then( ( () => {
              const n = t.getModeId( e );
              return t._getOrCreateMode( n || "plaintext" )
            } ) );
          }, e.prototype.getOrCreateModeByFilenameOrFirstLine = function ( e, t ) {
            const n = this;
            return this._onReady().then( ( () => {
              const i = n.getModeIdByFilenameOrFirstLine( e, t );
              return n._getOrCreateMode( i || "plaintext" )
            } ) );
          }, e.prototype._getOrCreateMode = function ( e ) {
            if ( !this._instantiatedModes.hasOwnProperty( e ) ) {
              const t = this.getLanguageIdentifier( e );
              this._instantiatedModes[ e ] = new Et( t ), this._onDidCreateMode.fire( this._instantiatedModes[ e ] )
            }
            return this._instantiatedModes[ e ]
          }, e;
        } )(),
        Gt = n( "eLzo" ),
        Yt = n( "tX9W" ),
        Xt = n( "/UlZ" ),
        $t = n( "kYye" ),
        Zt = n( "M1Kb" ),
        Qt = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        Jt = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        };

      function en( e ) {
        return e.toString()
      }
      const tn = ( () => {
          function e( e, t, n ) {
            this.model = e, this._markerDecorations = [], this._modelEventListeners = [], this._modelEventListeners.push( e.onWillDispose( ( () => {
              return t( e )
            } ) ) ), this._modelEventListeners.push( e.onDidChangeLanguage( ( t => {
              return n( e, t )
            } ) ) )
          }
          return e.prototype.dispose = function () {
            this._markerDecorations = this.model.deltaDecorations( this._markerDecorations, [] ), this._modelEventListeners = Object( y.d )( this._modelEventListeners ), this.model = null
          }, e.prototype.acceptMarkerDecorations = function ( e ) {
            this._markerDecorations = this.model.deltaDecorations( this._markerDecorations, e )
          }, e
        } )(),
        nn = ( () => {
          function e() {}
          return e.setMarkers = function ( e, t ) {
            const n = this,
              i = t.read( {
                resource: e.model.uri,
                take: 500
              } ).map( ( t => {
                return {
                  range: n._createDecorationRange( e.model, t ),
                  options: n._createDecorationOption( t )
                }
              } ) );
            e.acceptMarkerDecorations( i )
          }, e._createDecorationRange = ( e, t ) => {
            let n = u.a.lift( t );
            if ( t.severity === Ne.b.Hint && u.a.spansMultipleLines( n ) && ( n = n.setEndPosition( n.startLineNumber, n.startColumn ) ), ( n = e.validateRange( n ) ).isEmpty() ) {
              const i = e.getWordAtPosition( n.getStartPosition() );
              if ( i ) n = new u.a( n.startLineNumber, i.startColumn, n.endLineNumber, i.endColumn );
              else {
                const o = e.getLineLastNonWhitespaceColumn( n.startLineNumber ) || e.getLineMaxColumn( n.startLineNumber );
                1 === o || ( n = n.endColumn >= o ? new u.a( n.startLineNumber, o - 1, n.endLineNumber, o ) : new u.a( n.startLineNumber, n.startColumn, n.endLineNumber, n.endColumn + 1 ) )
              }
            } else if ( t.endColumn === Number.MAX_VALUE && 1 === t.startColumn && n.startLineNumber === n.endLineNumber ) {
              const r = e.getLineFirstNonWhitespaceColumn( t.startLineNumber );
              r < n.endColumn && ( n = new u.a( n.startLineNumber, r, n.endLineNumber, n.endColumn ), t.startColumn = r )
            }
            return n
          }, e._createDecorationOption = e => {
            let t, n, i, o, r;
            switch ( e.severity ) {
              case Ne.b.Hint:
                t = e.tags && e.tags.indexOf( Ne.c.Unnecessary ) >= 0 ? "squiggly-unnecessary" : "squiggly-hint", o = 0;
                break;
              case Ne.b.Warning:
                t = "squiggly-warning", n = Object( T.f )( $t.z ), i = Object( T.f )( $t.z ), o = 20;
                break;
              case Ne.b.Info:
                t = "squiggly-info", n = Object( T.f )( $t.y ), i = Object( T.f )( $t.y ), o = 10;
                break;
              case Ne.b.Error:
              default:
                t = "squiggly-error", n = Object( T.f )( $t.x ), i = Object( T.f )( $t.x ), o = 30
            }
            e.tags && -1 !== e.tags.indexOf( Ne.c.Unnecessary ) && ( r = "squiggly-inline-unnecessary" );
            let s = null;
            let a = e.message;
            const u = e.source;
            const l = e.relatedInformation;
            if ( "string" === typeof a && ( a = a.trim(), u && ( a = /\n/g.test( a ) ? P.a( "diagAndSourceMultiline", "[{0}]\n{1}", u, a ) : P.a( "diagAndSource", "[{0}] {1}", u, a ) ), s = ( new Gt.a ).appendCodeblock( "_", a ), !Object( Le.k )( l ) ) ) {
              s.appendMarkdown( "\n" );
              for ( let c = 0, d = l; c < d.length; c++ ) {
                const h = d[ c ],
                  p = h.message,
                  f = h.resource,
                  g = h.startLineNumber,
                  m = h.startColumn;
                s.appendMarkdown( "* [" + Object( kt.a )( f.path ) + "(" + g + ", " + m + ")](" + f.toString( !1 ) + "#" + g + "," + m + "): " ), s.appendText( "" + p ), s.appendMarkdown( "\n" )
              }
              s.appendMarkdown( "\n" )
            }
            return {
              stickiness: Zt.h.NeverGrowsWhenTypingAtEdges,
              className: t,
              hoverMessage: s,
              showIfCollapsed: !0,
              overviewRuler: {
                color: n,
                darkColor: i,
                position: Zt.f.Right
              },
              zIndex: o,
              inlineClassName: r
            }
          }, e;
        } )(),
        on = Te.c || Te.d ? Zt.b.LF : Zt.b.CRLF,
        rn = ( () => {
          function e( e, t ) {
            const n = this;
            this._markerService = e, this._configurationService = t, this._models = {}, this._modelCreationOptionsByLanguageAndResource = Object.create( null ), this._onModelAdded = new r.a, this._onModelRemoved = new r.a, this._onModelModeChanged = new r.a, this._markerService && ( this._markerServiceSubscription = this._markerService.onMarkerChanged( this._handleMarkerChange, this ) ), this._configurationServiceSubscription = this._configurationService.onDidChangeConfiguration( ( e => {
              return n._updateModelOptions()
            } ) ), this._updateModelOptions()
          }
          return e._readModelOptions = ( e, t ) => {
            let n = Xt.c.tabSize;
            if ( e.editor && "undefined" !== typeof e.editor.tabSize ) {
              const i = parseInt( e.editor.tabSize, 10 );
              isNaN( i ) || ( n = i ), n < 1 && ( n = 1 )
            }
            let o = Xt.c.insertSpaces;
            e.editor && "undefined" !== typeof e.editor.insertSpaces && ( o = "false" !== e.editor.insertSpaces && Boolean( e.editor.insertSpaces ) );
            let r = on;
            const s = e.files && e.files.eol;
            "\r\n" === s ? r = Zt.b.CRLF : "\n" === s && ( r = Zt.b.LF );
            let a = Xt.c.trimAutoWhitespace;
            e.editor && "undefined" !== typeof e.editor.trimAutoWhitespace && ( a = "false" !== e.editor.trimAutoWhitespace && Boolean( e.editor.trimAutoWhitespace ) );
            let u = Xt.c.detectIndentation;
            e.editor && "undefined" !== typeof e.editor.detectIndentation && ( u = "false" !== e.editor.detectIndentation && Boolean( e.editor.detectIndentation ) );
            let l = Xt.c.largeFileOptimizations;
            return e.editor && "undefined" !== typeof e.editor.largeFileOptimizations && ( l = "false" !== e.editor.largeFileOptimizations && Boolean( e.editor.largeFileOptimizations ) ), {
              isForSimpleWidget: t,
              tabSize: n,
              insertSpaces: o,
              detectIndentation: u,
              defaultEOL: r,
              trimAutoWhitespace: a,
              largeFileOptimizations: l
            }
          }, e.prototype.getCreationOptions = function ( t, n, i ) {
            let o = this._modelCreationOptionsByLanguageAndResource[ t + n ];
            return o || ( o = e._readModelOptions( this._configurationService.getValue( {
              overrideIdentifier: t,
              resource: n
            } ), i ), this._modelCreationOptionsByLanguageAndResource[ t + n ] = o ), o
          }, e.prototype._updateModelOptions = function () {
            const t = this._modelCreationOptionsByLanguageAndResource;
            this._modelCreationOptionsByLanguageAndResource = Object.create( null );
            for ( let n = Object.keys( this._models ), i = 0, o = n.length; i < o; i++ ) {
              const r = n[ i ],
                s = this._models[ r ],
                a = s.model.getLanguageIdentifier().language,
                u = s.model.uri,
                l = t[ a + u ],
                c = this.getCreationOptions( a, u, s.model.isForSimpleWidget );
              e._setModelOptionsForModel( s.model, c, l )
            }
          }, e._setModelOptionsForModel = ( e, t, n ) => {
            n && n.detectIndentation === t.detectIndentation && n.insertSpaces === t.insertSpaces && n.tabSize === t.tabSize && n.trimAutoWhitespace === t.trimAutoWhitespace || ( t.detectIndentation ? ( e.detectIndentation( t.insertSpaces, t.tabSize ), e.updateOptions( {
              trimAutoWhitespace: t.trimAutoWhitespace
            } ) ) : e.updateOptions( {
              insertSpaces: t.insertSpaces,
              tabSize: t.tabSize,
              trimAutoWhitespace: t.trimAutoWhitespace
            } ) )
          }, e.prototype.dispose = function () {
            this._markerServiceSubscription && this._markerServiceSubscription.dispose(), this._configurationServiceSubscription.dispose()
          }, e.prototype._handleMarkerChange = function ( e ) {
            const t = this;
            e.forEach( ( e => {
              const n = en( e ),
                i = t._models[ n ];
              i && nn.setMarkers( i, t._markerService )
            } ) )
          }, e.prototype._cleanUp = function ( e ) {
            const t = this;
            e.uri.scheme !== xe.a.inMemory && e.uri.scheme !== xe.a.internal && e.uri.scheme !== xe.a.vscode || this._markerService && this._markerService.read( {
              resource: e.uri
            } ).map( ( e => {
              return e.owner
            } ) ).forEach( ( n => {
              return t._markerService.remove( n, [ e.uri ] )
            } ) ), delete this._modelCreationOptionsByLanguageAndResource[ e.getLanguageIdentifier().language + e.uri ]
          }, e.prototype._createModelData = function ( e, t, n, i ) {
            const o = this,
              r = this.getCreationOptions( t.language, n, i ),
              s = new Yt.b( e, r, t, n ),
              a = en( s.uri );
            if ( this._models[ a ] ) throw new Error( "ModelService: Cannot add model because it already exists!" );
            const u = new tn( s, ( e => {
              return o._onWillDispose( e )
            } ), ( ( e, t ) => {
              return o._onDidChangeLanguage( e, t )
            } ) );
            return this._models[ a ] = u, u
          }, e.prototype.createModel = function ( e, t, n, i ) {
            let o;
            return void 0 === i && ( i = !1 ), !t || c.b.is( t ) ? ( o = this._createModelData( e, Bt, n, i ), this.setMode( o.model, t ) ) : o = this._createModelData( e, t.getLanguageIdentifier(), n, i ), this._markerService && nn.setMarkers( o, this._markerService ), this._onModelAdded.fire( o.model ), o.model
          }, e.prototype.setMode = ( e, t ) => {
            t && ( c.b.is( t ) ? t.then( ( t => {
              e.isDisposed() || e.setMode( t.getLanguageIdentifier() )
            } ) ) : e.setMode( t.getLanguageIdentifier() ) )
          }, e.prototype.getModels = function () {
            for ( var e = [], t = Object.keys( this._models ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              e.push( this._models[ o ].model )
            }
            return e
          }, e.prototype.getModel = function ( e ) {
            const t = en( e ),
              n = this._models[ t ];
            return n ? n.model : null
          }, Object.defineProperty( e.prototype, "onModelAdded", {
            get() {
              return this._onModelAdded ? this._onModelAdded.event : null
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onModelRemoved", {
            get() {
              return this._onModelRemoved ? this._onModelRemoved.event : null
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onModelModeChanged", {
            get() {
              return this._onModelModeChanged ? this._onModelModeChanged.event : null
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype._onWillDispose = function ( e ) {
            const t = en( e.uri ),
              n = this._models[ t ];
            delete this._models[ t ], n.dispose(), this._cleanUp( e ), this._onModelRemoved.fire( e )
          }, e.prototype._onDidChangeLanguage = function ( t, n ) {
            const i = n.oldLanguage,
              o = t.getLanguageIdentifier().language,
              r = this.getCreationOptions( i, t.uri, t.isForSimpleWidget ),
              s = this.getCreationOptions( o, t.uri, t.isForSimpleWidget );
            e._setModelOptionsForModel( t, s, r ), this._onModelModeChanged.fire( {
              model: t,
              oldModeId: i
            } )
          }, e = Qt( [ Jt( 0, Ne.a ), Jt( 1, W.b ) ], e );
        } )(),
        sn = n( "0VEe" ),
        an = n( "YcIv" ),
        un = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        ln = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        cn = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        dn = "data-keybinding-context",
        hn = ( () => {
          function e( e, t ) {
            this._id = e, this._parent = t, this._value = Object.create( null ), this._value._contextId = e
          }
          return e.prototype.setValue = function ( e, t ) {
            return this._value[ e ] !== t && ( this._value[ e ] = t, !0 )
          }, e.prototype.removeValue = function ( e ) {
            return e in this._value && ( delete this._value[ e ], !0 )
          }, e.prototype.getValue = function ( e ) {
            const t = this._value[ e ];
            return "undefined" === typeof t && this._parent ? this._parent.getValue( e ) : t
          }, e;
        } )(),
        pn = ( e => {
          function t( t, n, i ) {
            const o = e.call( this, t, null ) || this;
            return o._emitter = i, o._configurationService = n, o._subscription = n.onDidChangeConfiguration( o._onConfigurationUpdated, o ), o._initFromConfiguration(), o
          }
          return un( t, e ), t.prototype.dispose = function () {
            this._subscription.dispose()
          }, t.prototype._onConfigurationUpdated = function ( e ) {
            if ( e.source === W.a.DEFAULT ) this._initFromConfiguration();
            else
              for ( let t = 0, n = e.affectedKeys; t < n.length; t++ ) {
                const i = n[ t ],
                  o = "config." + i;
                o in this._value && ( this._value[ o ] = this._configurationService.getValue( i ), this._emitter.fire( o ) )
              }
          }, t.prototype._initFromConfiguration = function () {
            const e = this,
              t = this._configurationService.getValue(),
              n = Object.create( null ),
              i = [],
              o = ( t, r ) => {
                for ( const s in t )
                  if ( Object.prototype.hasOwnProperty.call( t, s ) ) {
                    r.push( s );
                    const a = t[ s ];
                    if ( "boolean" === typeof a ) {
                      const u = r.join( "." ),
                        l = e._value[ u ];
                      e._value[ u ] = a, l !== a ? ( i.push( u ), n[ u ] = !0 ) : n[ u ] = !1
                    } else "object" === typeof a && o( a, r );
                    r.pop()
                  }
              };
            for ( const r in ( o( t, [ "config" ] ), this._value ) ) 0 === r.indexOf( "config." ) && void 0 === n[ r ] && ( delete this._value[ r ], n[ r ] = !0, i.push( r ) );
            this._emitter.fire( i )
          }, t;
        } )( hn ),
        fn = ( () => {
          function e( e, t, n ) {
            this._parent = e, this._key = t, this._defaultValue = n, this.reset()
          }
          return e.prototype.set = function ( e ) {
            this._parent.setContext( this._key, e )
          }, e.prototype.reset = function () {
            "undefined" === typeof this._defaultValue ? this._parent.removeContext( this._key ) : this._parent.setContext( this._key, this._defaultValue )
          }, e.prototype.get = function () {
            return this._parent.getContextKeyValue( this._key )
          }, e
        } )(),
        gn = ( () => {
          function e() {
            this._keys = []
          }
          return e.prototype.collect = function ( e ) {
            this._keys = this._keys.concat( e )
          }, e.prototype.affectsSome = function ( e ) {
            for ( let t = 0, n = this._keys; t < n.length; t++ ) {
              const i = n[ t ];
              if ( e.has( i ) ) return !0
            }
            return !1
          }, e;
        } )(),
        mn = ( () => {
          function e( e ) {
            this._myContextId = e, this._onDidChangeContextKey = new r.a
          }
          return e.prototype.createKey = function ( e, t ) {
            return new fn( this, e, t )
          }, Object.defineProperty( e.prototype, "onDidChangeContext", {
            get() {
              return this._onDidChangeContext || ( this._onDidChangeContext = Object( r.h )( this._onDidChangeContextKey.event, ( ( e, t ) => {
                return e || ( e = new gn ), e.collect( t ), e
              } ), 25 ) ), this._onDidChangeContext;
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.createScoped = function ( e ) {
            return new vn( this, this._onDidChangeContextKey, e )
          }, e.prototype.contextMatchesRules = function ( e ) {
            const t = this.getContextValuesContainer( this._myContextId );
            return an.a.contextMatchesRules( t, e )
          }, e.prototype.getContextKeyValue = function ( e ) {
            return this.getContextValuesContainer( this._myContextId ).getValue( e )
          }, e.prototype.setContext = function ( e, t ) {
            const n = this.getContextValuesContainer( this._myContextId );
            n && n.setValue( e, t ) && this._onDidChangeContextKey.fire( e )
          }, e.prototype.removeContext = function ( e ) {
            this.getContextValuesContainer( this._myContextId ).removeValue( e ) && this._onDidChangeContextKey.fire( e )
          }, e.prototype.getContext = function ( e ) {
            return this.getContextValuesContainer(
              ( e => {
                for ( ; e; ) {
                  if ( e.hasAttribute( dn ) ) return parseInt( e.getAttribute( dn ), 10 );
                  e = e.parentElement
                }
                return 0
              } )( e )
            );
          }, e;
        } )(),
        _n = ( e => {
          function t( t ) {
            const n = e.call( this, 0 ) || this;
            n._toDispose = [], n._lastContextId = 0, n._contexts = Object.create( null );
            const i = new pn( n._myContextId, t, n._onDidChangeContextKey );
            return n._contexts[ String( n._myContextId ) ] = i, n._toDispose.push( i ), n
          }
          return un( t, e ), t.prototype.dispose = function () {
            this._toDispose = Object( y.d )( this._toDispose )
          }, t.prototype.getContextValuesContainer = function ( e ) {
            return this._contexts[ String( e ) ]
          }, t.prototype.createChildContext = function ( e ) {
            void 0 === e && ( e = this._myContextId );
            const t = ++this._lastContextId;
            return this._contexts[ String( t ) ] = new hn( t, this.getContextValuesContainer( e ) ), t
          }, t.prototype.disposeContext = function ( e ) {
            delete this._contexts[ String( e ) ]
          }, t = ln( [ cn( 0, W.b ) ], t );
        } )( mn ),
        vn = ( e => {
          function t( t, n, i ) {
            const o = e.call( this, t.createChildContext() ) || this;
            return o._parent = t, o._onDidChangeContextKey = n, i && ( o._domNode = i, o._domNode.setAttribute( dn, String( o._myContextId ) ) ), o
          }
          return un( t, e ), t.prototype.dispose = function () {
            this._parent.disposeContext( this._myContextId ), this._domNode && ( this._domNode.removeAttribute( dn ), this._domNode = void 0 )
          }, Object.defineProperty( t.prototype, "onDidChangeContext", {
            get() {
              return this._parent.onDidChangeContext
            },
            enumerable: !0,
            configurable: !0
          } ), t.prototype.getContextValuesContainer = function ( e ) {
            return this._parent.getContextValuesContainer( e )
          }, t.prototype.createChildContext = function ( e ) {
            return void 0 === e && ( e = this._myContextId ), this._parent.createChildContext( e )
          }, t.prototype.disposeContext = function ( e ) {
            this._parent.disposeContext( e )
          }, t;
        } )( mn );
      w.a.registerCommand( O.g, ( ( e, t, n ) => {
        e.get( O.e ).createKey( String( t ), n )
      } ) );
      const yn = n( "zrhQ" ),
        bn = function ( e, t, n, i, o ) {
          this.token = e, this.index = t, this.fontStyle = n, this.foreground = i, this.background = o
        };

      function Cn( e, t ) {
        e.sort( ( ( e, t ) => {
          const n = ( ( e, t ) => {
            if ( e < t ) return -1;
            if ( e > t ) return 1;
            return 0
          } )( e.token, t.token );
          return 0 !== n ? n : e.index - t.index
        } ) );
        for ( var n = 0, i = "000000", o = "ffffff"; e.length >= 1 && "" === e[ 0 ].token; ) {
          const r = e.shift(); - 1 !== r.fontStyle && ( n = r.fontStyle ), null !== r.foreground && ( i = r.foreground ), null !== r.background && ( o = r.background )
        }
        for ( var s = new Sn, a = 0, u = t; a < u.length; a++ ) {
          const l = u[ a ];
          s.getId( l )
        }
        for ( var c = s.getId( i ), d = s.getId( o ), h = new xn( n, c, d ), p = new Nn( h ), f = 0, g = e.length; f < g; f++ ) {
          const m = e[ f ];
          p.insert( m.token, m.fontStyle, s.getId( m.foreground ), s.getId( m.background ) )
        }
        return new On( s, p )
      }
      const wn = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
      var Sn = ( () => {
        function e() {
          this._lastColorId = 0, this._id2color = [], this._color2id = new Map
        }
        return e.prototype.getId = function ( e ) {
          if ( null === e ) return 0;
          const t = e.match( wn );
          if ( !t ) throw new Error( "Illegal value for token color: " + e );
          e = t[ 1 ].toUpperCase();
          let n = this._color2id.get( e );
          return n || ( n = ++this._lastColorId, this._color2id.set( e, n ), this._id2color[ n ] = yn.a.fromHex( "#" + e ), n )
        }, e.prototype.getColorMap = function () {
          return this._id2color.slice( 0 )
        }, e;
      } )();

      var On = ( () => {
        function e( e, t ) {
          this._colorMap = e, this._root = t, this._cache = new Map
        }
        return e.createFromRawTokenTheme = function ( e, t ) {
          return this.createFromParsedTokenTheme(
            ( e => {
              if ( !e || !Array.isArray( e ) ) return [];
              for ( var t = [], n = 0, i = 0, o = e.length; i < o; i++ ) {
                const r = e[ i ];
                let s = -1;
                if ( "string" === typeof r.fontStyle ) {
                  s = 0;
                  for ( let a = r.fontStyle.split( " " ), u = 0, l = a.length; u < l; u++ ) {
                    switch ( a[ u ] ) {
                      case "italic":
                        s |= 1;
                        break;
                      case "bold":
                        s |= 2;
                        break;
                      case "underline":
                        s |= 4
                    }
                  }
                }
                let c = null;
                "string" === typeof r.foreground && ( c = r.foreground );
                let d = null;
                "string" === typeof r.background && ( d = r.background ), t[ n++ ] = new bn( r.token || "", i, s, c, d )
              }
              return t
            } )( e ),
            t
          );
        }, e.createFromParsedTokenTheme = ( e, t ) => {
          return Cn( e, t )
        }, e.prototype.getColorMap = function () {
          return this._colorMap.getColorMap()
        }, e.prototype._match = function ( e ) {
          return this._root.match( e )
        }, e.prototype.match = function ( e, t ) {
          let n = this._cache.get( t );
          if ( "undefined" === typeof n ) {
            const i = this._match( t ),
              o = ( e => {
                const t = e.match( Ln );
                if ( !t ) return 0;
                switch ( t[ 1 ] ) {
                  case "comment":
                    return 1;
                  case "string":
                    return 2;
                  case "regex":
                    return 4
                }
                throw new Error( "Unexpected match for standard token type!" )
              } )( t );
            n = ( i.metadata | o << 8 ) >>> 0, this._cache.set( t, n )
          }
          return ( n | e << 0 ) >>> 0
        }, e;
      } )();

      const Ln = /\b(comment|string|regex)\b/;
      var xn = ( () => {
          function e( e, t, n ) {
            this._fontStyle = e, this._foreground = t, this._background = n, this.metadata = ( this._fontStyle << 11 | this._foreground << 14 | this._background << 23 ) >>> 0
          }
          return e.prototype.clone = function () {
            return new e( this._fontStyle, this._foreground, this._background )
          }, e.prototype.acceptOverwrite = function ( e, t, n ) {
            -1 !== e && ( this._fontStyle = e ), 0 !== t && ( this._foreground = t ), 0 !== n && ( this._background = n ), this.metadata = ( this._fontStyle << 11 | this._foreground << 14 | this._background << 23 ) >>> 0
          }, e
        } )(),
        Nn = ( () => {
          function e( e ) {
            this._mainRule = e, this._children = new Map
          }
          return e.prototype.match = function ( e ) {
            if ( "" === e ) return this._mainRule;
            let t;
            let n;
            const i = e.indexOf( "." ); -
            1 === i ? ( t = e, n = "" ) : ( t = e.substring( 0, i ), n = e.substring( i + 1 ) );
            const o = this._children.get( t );
            return "undefined" !== typeof o ? o.match( n ) : this._mainRule
          }, e.prototype.insert = function ( t, n, i, o ) {
            if ( "" !== t ) {
              let r;
              let s;
              const a = t.indexOf( "." ); -
              1 === a ? ( r = t, s = "" ) : ( r = t.substring( 0, a ), s = t.substring( a + 1 ) );
              let u = this._children.get( r );
              "undefined" === typeof u && ( u = new e( this._mainRule.clone() ), this._children.set( r, u ) ), u.insert( s, n, i, o )
            } else this._mainRule.acceptOverwrite( n, i, o )
          }, e;
        } )();
      let En;
      let kn;
      let In;
      const Dn = n( "MD5Z" );
      const Mn = {
        base: "vs",
        inherit: !1,
        rules: [ {
          token: "",
          foreground: "000000",
          background: "fffffe"
        }, {
          token: "invalid",
          foreground: "cd3131"
        }, {
          token: "emphasis",
          fontStyle: "italic"
        }, {
          token: "strong",
          fontStyle: "bold"
        }, {
          token: "variable",
          foreground: "001188"
        }, {
          token: "variable.predefined",
          foreground: "4864AA"
        }, {
          token: "constant",
          foreground: "dd0000"
        }, {
          token: "comment",
          foreground: "008000"
        }, {
          token: "number",
          foreground: "09885A"
        }, {
          token: "number.hex",
          foreground: "3030c0"
        }, {
          token: "regexp",
          foreground: "800000"
        }, {
          token: "annotation",
          foreground: "808080"
        }, {
          token: "type",
          foreground: "008080"
        }, {
          token: "delimiter",
          foreground: "000000"
        }, {
          token: "delimiter.html",
          foreground: "383838"
        }, {
          token: "delimiter.xml",
          foreground: "0000FF"
        }, {
          token: "tag",
          foreground: "800000"
        }, {
          token: "tag.id.pug",
          foreground: "4F76AC"
        }, {
          token: "tag.class.pug",
          foreground: "4F76AC"
        }, {
          token: "meta.scss",
          foreground: "800000"
        }, {
          token: "metatag",
          foreground: "e00000"
        }, {
          token: "metatag.content.html",
          foreground: "FF0000"
        }, {
          token: "metatag.html",
          foreground: "808080"
        }, {
          token: "metatag.xml",
          foreground: "808080"
        }, {
          token: "metatag.php",
          fontStyle: "bold"
        }, {
          token: "key",
          foreground: "863B00"
        }, {
          token: "string.key.json",
          foreground: "A31515"
        }, {
          token: "string.value.json",
          foreground: "0451A5"
        }, {
          token: "attribute.name",
          foreground: "FF0000"
        }, {
          token: "attribute.value",
          foreground: "0451A5"
        }, {
          token: "attribute.value.number",
          foreground: "09885A"
        }, {
          token: "attribute.value.unit",
          foreground: "09885A"
        }, {
          token: "attribute.value.html",
          foreground: "0000FF"
        }, {
          token: "attribute.value.xml",
          foreground: "0000FF"
        }, {
          token: "string",
          foreground: "A31515"
        }, {
          token: "string.html",
          foreground: "0000FF"
        }, {
          token: "string.sql",
          foreground: "FF0000"
        }, {
          token: "string.yaml",
          foreground: "0451A5"
        }, {
          token: "keyword",
          foreground: "0000FF"
        }, {
          token: "keyword.json",
          foreground: "0451A5"
        }, {
          token: "keyword.flow",
          foreground: "AF00DB"
        }, {
          token: "keyword.flow.scss",
          foreground: "0000FF"
        }, {
          token: "operator.scss",
          foreground: "666666"
        }, {
          token: "operator.sql",
          foreground: "778899"
        }, {
          token: "operator.swift",
          foreground: "666666"
        }, {
          token: "predefined.sql",
          foreground: "FF00FF"
        } ],
        colors: ( En = {}, En[ Dn.n ] = "#FFFFFE", En[ Dn.u ] = "#000000", En[ Dn.y ] = "#E5EBF1", En[ $t.l ] = "#D3D3D3", En[ $t.a ] = "#939393", En[ Dn.B ] = "#ADD6FF4D", En )
      };
      const Tn = {
        base: "vs-dark",
        inherit: !1,
        rules: [ {
          token: "",
          foreground: "D4D4D4",
          background: "1E1E1E"
        }, {
          token: "invalid",
          foreground: "f44747"
        }, {
          token: "emphasis",
          fontStyle: "italic"
        }, {
          token: "strong",
          fontStyle: "bold"
        }, {
          token: "variable",
          foreground: "74B0DF"
        }, {
          token: "variable.predefined",
          foreground: "4864AA"
        }, {
          token: "variable.parameter",
          foreground: "9CDCFE"
        }, {
          token: "constant",
          foreground: "569CD6"
        }, {
          token: "comment",
          foreground: "608B4E"
        }, {
          token: "number",
          foreground: "B5CEA8"
        }, {
          token: "number.hex",
          foreground: "5BB498"
        }, {
          token: "regexp",
          foreground: "B46695"
        }, {
          token: "annotation",
          foreground: "cc6666"
        }, {
          token: "type",
          foreground: "3DC9B0"
        }, {
          token: "delimiter",
          foreground: "DCDCDC"
        }, {
          token: "delimiter.html",
          foreground: "808080"
        }, {
          token: "delimiter.xml",
          foreground: "808080"
        }, {
          token: "tag",
          foreground: "569CD6"
        }, {
          token: "tag.id.pug",
          foreground: "4F76AC"
        }, {
          token: "tag.class.pug",
          foreground: "4F76AC"
        }, {
          token: "meta.scss",
          foreground: "A79873"
        }, {
          token: "meta.tag",
          foreground: "CE9178"
        }, {
          token: "metatag",
          foreground: "DD6A6F"
        }, {
          token: "metatag.content.html",
          foreground: "9CDCFE"
        }, {
          token: "metatag.html",
          foreground: "569CD6"
        }, {
          token: "metatag.xml",
          foreground: "569CD6"
        }, {
          token: "metatag.php",
          fontStyle: "bold"
        }, {
          token: "key",
          foreground: "9CDCFE"
        }, {
          token: "string.key.json",
          foreground: "9CDCFE"
        }, {
          token: "string.value.json",
          foreground: "CE9178"
        }, {
          token: "attribute.name",
          foreground: "9CDCFE"
        }, {
          token: "attribute.value",
          foreground: "CE9178"
        }, {
          token: "attribute.value.number.css",
          foreground: "B5CEA8"
        }, {
          token: "attribute.value.unit.css",
          foreground: "B5CEA8"
        }, {
          token: "attribute.value.hex.css",
          foreground: "D4D4D4"
        }, {
          token: "string",
          foreground: "CE9178"
        }, {
          token: "string.sql",
          foreground: "FF0000"
        }, {
          token: "keyword",
          foreground: "569CD6"
        }, {
          token: "keyword.flow",
          foreground: "C586C0"
        }, {
          token: "keyword.json",
          foreground: "CE9178"
        }, {
          token: "keyword.flow.scss",
          foreground: "569CD6"
        }, {
          token: "operator.scss",
          foreground: "909090"
        }, {
          token: "operator.sql",
          foreground: "778899"
        }, {
          token: "operator.swift",
          foreground: "909090"
        }, {
          token: "predefined.sql",
          foreground: "FF00FF"
        } ],
        colors: ( kn = {}, kn[ Dn.n ] = "#1E1E1E", kn[ Dn.u ] = "#D4D4D4", kn[ Dn.y ] = "#3A3D41", kn[ $t.l ] = "#404040", kn[ $t.a ] = "#707070", kn[ Dn.B ] = "#ADD6FF26", kn )
      };
      const Rn = {
        base: "hc-black",
        inherit: !1,
        rules: [ {
          token: "",
          foreground: "FFFFFF",
          background: "000000"
        }, {
          token: "invalid",
          foreground: "f44747"
        }, {
          token: "emphasis",
          fontStyle: "italic"
        }, {
          token: "strong",
          fontStyle: "bold"
        }, {
          token: "variable",
          foreground: "1AEBFF"
        }, {
          token: "variable.parameter",
          foreground: "9CDCFE"
        }, {
          token: "constant",
          foreground: "569CD6"
        }, {
          token: "comment",
          foreground: "608B4E"
        }, {
          token: "number",
          foreground: "FFFFFF"
        }, {
          token: "regexp",
          foreground: "C0C0C0"
        }, {
          token: "annotation",
          foreground: "569CD6"
        }, {
          token: "type",
          foreground: "3DC9B0"
        }, {
          token: "delimiter",
          foreground: "FFFF00"
        }, {
          token: "delimiter.html",
          foreground: "FFFF00"
        }, {
          token: "tag",
          foreground: "569CD6"
        }, {
          token: "tag.id.pug",
          foreground: "4F76AC"
        }, {
          token: "tag.class.pug",
          foreground: "4F76AC"
        }, {
          token: "meta",
          foreground: "D4D4D4"
        }, {
          token: "meta.tag",
          foreground: "CE9178"
        }, {
          token: "metatag",
          foreground: "569CD6"
        }, {
          token: "metatag.content.html",
          foreground: "1AEBFF"
        }, {
          token: "metatag.html",
          foreground: "569CD6"
        }, {
          token: "metatag.xml",
          foreground: "569CD6"
        }, {
          token: "metatag.php",
          fontStyle: "bold"
        }, {
          token: "key",
          foreground: "9CDCFE"
        }, {
          token: "string.key",
          foreground: "9CDCFE"
        }, {
          token: "string.value",
          foreground: "CE9178"
        }, {
          token: "attribute.name",
          foreground: "569CD6"
        }, {
          token: "attribute.value",
          foreground: "3FF23F"
        }, {
          token: "string",
          foreground: "CE9178"
        }, {
          token: "string.sql",
          foreground: "FF0000"
        }, {
          token: "keyword",
          foreground: "569CD6"
        }, {
          token: "keyword.flow",
          foreground: "C586C0"
        }, {
          token: "operator.sql",
          foreground: "778899"
        }, {
          token: "operator.swift",
          foreground: "909090"
        }, {
          token: "predefined.sql",
          foreground: "FF00FF"
        } ],
        colors: ( In = {}, In[ Dn.n ] = "#000000", In[ Dn.u ] = "#FFFFFF", In[ $t.l ] = "#FFFFFF", In[ $t.a ] = "#FFFFFF", In )
      };
      const Pn = "vs";
      const An = "vs-dark";
      const Fn = "hc-black";
      const Wn = jt.a.as( Dn.a.ColorContribution );
      const jn = jt.a.as( T.a.ThemingContribution );
      const Vn = ( () => {
        function e( e, t ) {
          this.themeData = t;
          const n = t.base;
          e.length > 0 ? ( this.id = n + " " + e, this.themeName = e ) : ( this.id = n, this.themeName = n ), this.colors = null, this.defaultColors = Object.create( null ), this._tokenTheme = null
        }
        return Object.defineProperty( e.prototype, "base", {
          get() {
            return this.themeData.base
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.notifyBaseUpdated = function () {
          this.themeData.inherit && ( this.colors = null, this._tokenTheme = null )
        }, e.prototype.getColors = function () {
          if ( !this.colors ) {
            const e = Object.create( null );
            for ( var t in this.themeData.colors ) e[ t ] = yn.a.fromHex( this.themeData.colors[ t ] );
            if ( this.themeData.inherit ) {
              const n = Hn( this.themeData.base );
              for ( var t in n.colors ) e[ t ] || ( e[ t ] = yn.a.fromHex( n.colors[ t ] ) )
            }
            this.colors = e
          }
          return this.colors
        }, e.prototype.getColor = function ( e, t ) {
          const n = this.getColors()[ e ];
          return n || ( !1 !== t ? this.getDefault( e ) : null )
        }, e.prototype.getDefault = function ( e ) {
          let t = this.defaultColors[ e ];
          return t || ( t = Wn.resolveDefaultColor( e, this ), this.defaultColors[ e ] = t, t )
        }, e.prototype.defines = function ( e ) {
          return Object.prototype.hasOwnProperty.call( this.getColors(), e )
        }, Object.defineProperty( e.prototype, "type", {
          get() {
            switch ( this.base ) {
              case Pn:
                return "light";
              case Fn:
                return "hc";
              default:
                return "dark"
            }
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "tokenTheme", {
          get() {
            if ( !this._tokenTheme ) {
              let e = [],
                t = [];
              if ( this.themeData.inherit ) {
                const n = Hn( this.themeData.base );
                e = n.rules, n.encodedTokensColors && ( t = n.encodedTokensColors )
              }
              e = e.concat( this.themeData.rules ), this.themeData.encodedTokensColors && ( t = this.themeData.encodedTokensColors ), this._tokenTheme = On.createFromRawTokenTheme( e, t )
            }
            return this._tokenTheme
          },
          enumerable: !0,
          configurable: !0
        } ), e;
      } )();

      function Bn( e ) {
        return e === Pn || e === An || e === Fn
      }

      function Hn( e ) {
        switch ( e ) {
          case Pn:
            return Mn;
          case An:
            return Tn;
          case Fn:
            return Rn
        }
      }

      function zn( e ) {
        const t = Hn( e );
        return new Vn( e, t )
      }
      let Un;

      const Kn = ( () => {
        function e() {
          this.environment = Object.create( null ), this._onThemeChange = new r.a, this._knownThemes = new Map, this._knownThemes.set( Pn, zn( Pn ) ), this._knownThemes.set( An, zn( An ) ), this._knownThemes.set( Fn, zn( Fn ) ), this._styleElement = Q.o(), this._styleElement.className = "monaco-colors", this.setTheme( Pn )
        }
        return Object.defineProperty( e.prototype, "onThemeChange", {
          get() {
            return this._onThemeChange.event
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.defineTheme = function ( e, t ) {
          if ( !/^[a-z0-9\-]+$/i.test( e ) ) throw new Error( "Illegal theme name!" );
          if ( !Bn( t.base ) && !Bn( e ) ) throw new Error( "Illegal theme base!" );
          this._knownThemes.set( e, new Vn( e, t ) ), Bn( e ) && this._knownThemes.forEach( ( t => {
            t.base === e && t.notifyBaseUpdated()
          } ) ), this._theme && this._theme.themeName === e && this.setTheme( e )
        }, e.prototype.getTheme = function () {
          return this._theme
        }, e.prototype.setTheme = function ( e ) {
          let t;
          const n = this;
          t = this._knownThemes.has( e ) ? this._knownThemes.get( e ) : this._knownThemes.get( Pn ), this._theme = t;
          const i = [],
            o = {},
            r = {
              addRule( e ) {
                o[ e ] || ( i.push( e ), o[ e ] = !0 )
              }
            };
          jn.getThemingParticipants().forEach( ( e => {
            return e( t, r, n.environment )
          } ) );
          const s = t.tokenTheme.getColorMap();
          return r.addRule(
            ( e => {
              for ( var t = [], n = 1, i = e.length; n < i; n++ ) {
                const o = e[ n ];
                t[ n ] = ".mtk" + n + " { color: " + o + "; }"
              }
              return t.push( ".mtki { font-style: italic; }" ), t.push( ".mtkb { font-weight: bold; }" ), t.push( ".mtku { text-decoration: underline; text-underline-position: under; }" ), t.join( "\n" )
            } )( s )
          ), this._styleElement.innerHTML = i.join( "\n" ), He.y.setColorMap( s ), this._onThemeChange.fire( t ), t.id;
        }, e;
      } )();

      const qn = Object( C.c )( "dialogService" );
      const Gn = n( "k9mg" );
      const Yn = n( "x/UI" );
      const Xn = n( "2jrX" );
      const $n = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      !( e => {
        const t = new Se.a,
          n = ( () => {
            function e( e, t ) {
              this._serviceId = e, this._factory = t, this._value = null
            }
            return Object.defineProperty( e.prototype, "id", {
              get() {
                return this._serviceId
              },
              enumerable: !0,
              configurable: !0
            } ), e.prototype.get = function ( e ) {
              if ( !this._value ) {
                if ( e && ( this._value = e[ this._serviceId.toString() ] ), this._value || ( this._value = this._factory( e ) ), !this._value ) throw new Error( "Service " + this._serviceId + " is missing!" );
                t.set( this._serviceId, this._value )
              }
              return this._value
            }, e;
          } )();
        e.LazyStaticService = n;
        const i = [];

        function o( e, t ) {
          const o = new n( e, t );
          return i.push( o ), o
        }
        e.init = e => {
          const t = new Se.a;
          for ( const n in e ) e.hasOwnProperty( n ) && t.set( Object( C.c )( n ), e[ n ] );
          i.forEach( ( n => {
            return t.set( n.id, n.get( e ) )
          } ) );
          const o = new Oe( t, !0 );
          return t.set( C.a, o ), [ t, o ]
        }, e.instantiationService = o( C.a, ( () => {
          return new Oe( t, !0 )
        } ) );
        const r = new N.b;
        e.configurationService = o( W.b, ( () => {
          return r
        } ) ), e.resourceConfigurationService = o( ft, ( () => {
          return new N.i( r )
        } ) ), e.contextService = o( Me.a, ( () => {
          return new N.k
        } ) ), e.uriDisplayService = o( Xn.a, ( () => {
          return new N.j
        } ) ), e.telemetryService = o( le.a, ( () => {
          return new N.n
        } ) ), e.dialogService = o( qn, ( () => {
          return new N.c
        } ) ), e.notificationService = o( F.a, ( () => {
          return new N.g
        } ) ), e.markerService = o( Ne.a, ( () => {
          return new ke
        } ) ), e.modeService = o( Nt.a, ( e => {
          return new qt
        } ) ), e.modelService = o( ze.a, ( t => {
          return new rn( e.markerService.get( t ), e.configurationService.get( t ) )
        } ) ), e.editorWorkerService = o( x.a, ( t => {
          return new Ct( e.modelService.get( t ), e.resourceConfigurationService.get( t ) )
        } ) ), e.standaloneThemeService = o( I.a, ( () => {
          return new Kn
        } ) ), e.codeEditorService = o( L.a, ( t => {
          return new sn.a( e.standaloneThemeService.get( t ) )
        } ) ), e.progressService = o( Ie.a, ( () => {
          return new N.h
        } ) ), e.storageService = o( De.a, ( () => {
          return De.b
        } ) ), e.logService = o( ce.a, ( () => {
          return new ce.b
        } ) )
      } )( Un || ( Un = {} ) );
      const Zn = ( e => {
        function t( t, n ) {
          const i = e.call( this ) || this,
            o = Un.init( n ),
            r = o[ 0 ],
            s = o[ 1 ];
          i._serviceCollection = r, i._instantiationService = s;
          const a = i.get( W.b ),
            u = i.get( F.a ),
            l = i.get( le.a ),
            c = ( e, t ) => {
              let o = null;
              return n && ( o = n[ e.toString() ] ), o || ( o = t() ), i._serviceCollection.set( e, o ), o
            },
            d = c( O.e, ( () => {
              return i._register( new _n( a ) )
            } ) );
          c( Gn.a, ( () => {
            return new Gn.b( d )
          } ) );
          const h = c( w.b, ( () => {
            return new N.l( i._instantiationService )
          } ) );
          c( S.a, ( () => {
            return i._register( new N.m( d, h, l, u, t ) )
          } ) );
          const p = c( b.b, ( () => {
            return i._register( new pe( t, l, new ce.b ) )
          } ) );
          return c( b.a, ( () => {
            return i._register( new ae( t, l, u, p ) )
          } ) ), c( M.a, ( () => {
            return new N.e( h )
          } ) ), c( Yn.a, ( () => {
            return new N.a( Un.modelService.get( ze.a ) )
          } ) ), i;
        }
        return $n( t, e ), t.prototype.get = function ( e ) {
          const t = this._serviceCollection.get( e );
          if ( !t ) throw new Error( "Missing service " + e );
          return t
        }, t.prototype.set = function ( e, t ) {
          this._serviceCollection.set( e, t )
        }, t.prototype.has = function ( e ) {
          return this._serviceCollection.has( e )
        }, t;
      } )( y.a );

      function Qn( e ) {
        let t = JSON.parse( e );
        return t = function e( t, n ) {
          if ( !t || n > 200 ) return t;
          if ( "object" === typeof t ) {
            switch ( t.$mid ) {
              case 1:
                return p.a.revive( t );
              case 2:
                return new RegExp( t.source, t.flags )
            }
            for ( const i in t ) Object.hasOwnProperty.call( t, i ) && ( t[ i ] = e( t[ i ], n + 1 ) )
          }
          return t
        }( t, 0 );
      }
      const Jn = new( ( () => {
          function e() {}
          return e.prototype.publicLog = ( e, t ) => {
            return c.b.wrap( null )
          }, e.prototype.getTelemetryInfo = () => {
            return c.b.wrap( {
              instanceId: "someValue.instanceId",
              sessionId: "someValue.sessionId",
              machineId: "someValue.machineId"
            } )
          }, e;
        } )() )(),
        ei = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        ti = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        ni = ( () => {
          function e( e, t, n ) {
            void 0 === n && ( n = Jn ), this._editorService = e, this._commandService = t, this._telemetryService = n
          }
          return e.prototype.open = function ( e, t ) {
            let n;
            this._telemetryService.publicLog( "openerService", {
              scheme: e.scheme
            } );
            const i = e.scheme;
            const o = e.path;
            const r = e.query;
            const s = e.fragment;
            let a = c.b.wrap( void 0 );
            if ( i === xe.a.http || i === xe.a.https || i === xe.a.mailto ) Q.P( e.toString( !0 ) );
            else if ( "command" === i && w.a.getCommand( o ) ) {
              let u = [];
              try {
                u = Qn( r ), Array.isArray( u ) || ( u = [ u ] )
              } catch ( h ) {}
              a = ( n = this._commandService ).executeCommand.apply( n, [ o ].concat( u ) )
            } else {
              let l = void 0;
              const d = /^L?(\d+)(?:,(\d+))?/.exec( s );
              if ( d && ( l = {
                  startLineNumber: parseInt( d[ 1 ] ),
                  startColumn: d[ 2 ] ? parseInt( d[ 2 ] ) : 1
                }, e = e.with( {
                  fragment: ""
                } ) ), !e.scheme ) return c.b.as( void 0 );
              e.scheme === xe.a.file && ( e = e.with( {
                path: Object( kt.h )( e.path )
              } ) ), a = this._editorService.openCodeEditor( {
                resource: e,
                options: {
                  selection: l
                }
              }, this._editorService.getFocusedCodeEditor(), t && t.openToSide )
            }
            return a
          }, e = ei( [ ti( 0, L.a ), ti( 1, w.b ), ti( 2, Object( C.d )( le.a ) ) ], e );
        } )(),
        ii = n( "W9cx" ),
        oi = n( "baJR" ),
        ri = n( "4bUh" ),
        si = n( "qNAo" ),
        ai = ( () => {
          function e() {}
          return e.colorizeElement = function ( e, t, n, i ) {
            const o = ( i = i || {} ).theme || "vs",
              r = i.mimeType || n.getAttribute( "lang" ) || n.getAttribute( "data-lang" );
            if ( r ) {
              e.setTheme( o );
              const s = n.firstChild.nodeValue;
              n.className += " " + o;
              return this.colorize( t, s, r, i ).then( ( e => {
                n.innerHTML = e
              } ), ( e => {
                return console.error( e )
              } ) );
            }
            console.error( "Mode not detected" )
          }, e._tokenizationSupportChangedPromise = e => {
            let t = null;
            const n = () => {
              t && ( t.dispose(), t = null )
            };
            return new c.b( ( ( i, o ) => {
              t = He.y.onDidChange( ( t => {
                t.changedLanguages.indexOf( e ) >= 0 && ( n(), i( void 0 ) )
              } ) )
            } ), n );
          }, e.colorize = function ( e, t, n, i ) {
            Ke.startsWithUTF8BOM( t ) && ( t = t.substr( 1 ) );
            const o = t.split( /\r\n|\r|\n/ ),
              r = e.getModeId( n );
            "undefined" === typeof ( i = i || {} ).tabSize && ( i.tabSize = 4 ), e.getOrCreateMode( r );
            const s = He.y.get( r );
            return s ? c.b.as( ui( o, i.tabSize, s ) ) : c.b.any( [ this._tokenizationSupportChangedPromise( r ), c.b.timeout( 500 ) ] ).then( ( e => {
              const t = He.y.get( r );
              return t ? ui( o, i.tabSize, t ) : ( ( e, t ) => {
                let n = [];
                const i = new Uint32Array( 2 );
                i[ 0 ] = 0, i[ 1 ] = 16793600;
                for ( let o = 0, r = e.length; o < r; o++ ) {
                  const s = e[ o ];
                  i[ 0 ] = s.length;
                  const a = new ri.a( i, s ),
                    u = si.d.isBasicASCII( s, !0 ),
                    l = si.d.containsRTL( s, u, !0 ),
                    c = Object( oi.d )( new oi.b( !1, s, !1, u, l, 0, a, [], t, 0, -1, "none", !1, !1 ) );
                  ( n = n.concat( c.html ) ).push( "<br/>" )
                }
                return n.join( "" )
              } )( o, i.tabSize );
            } ) );
          }, e.colorizeLine = ( e, t, n, i, o ) => {
            void 0 === o && ( o = 4 );
            const r = si.d.isBasicASCII( e, t ),
              s = si.d.containsRTL( e, r, n );
            return Object( oi.d )( new oi.b( !1, e, !1, r, s, 0, i, [], o, 0, -1, "none", !1, !1 ) ).html
          }, e.colorizeModelLine = function ( e, t, n ) {
            void 0 === n && ( n = 4 );
            const i = e.getLineContent( t );
            e.forceTokenization( t );
            const o = e.getLineTokens( t ).inflate();
            return this.colorizeLine( i, e.mightContainNonBasicASCII(), e.mightContainRTL(), o, n )
          }, e;
        } )();

      function ui( e, t, n ) {
        return ( ( e, t, n ) => {
          for ( var i = [], o = n.getInitialState(), r = 0, s = e.length; r < s; r++ ) {
            const a = e[ r ],
              u = n.tokenize2( a, o, 0 );
            ri.a.convertToEndOffset( u.tokens, a.length );
            const l = new ri.a( u.tokens, a ),
              c = si.d.isBasicASCII( a, !0 ),
              d = si.d.containsRTL( a, c, !0 ),
              h = Object( oi.d )( new oi.b( !1, a, !1, c, d, 0, l.inflate(), [], t, 0, -1, "none", !1, !1 ) );
            ( i = i.concat( h.html ) ).push( "<br/>" ), o = u.endState
          }
          return i.join( "" )
        } )( e, t, n );
      }
      const li = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      let ci;
      let di;
      const hi = ( e => {
        function t( t, n ) {
          const i = e.call( this, t, n.label ) || this;
          return i._foreignModuleId = n.moduleId, i._foreignModuleCreateData = n.createData || null, i._foreignProxy = null, i
        }
        return li( t, e ), t.prototype._getForeignProxy = function () {
          const e = this;
          return this._foreignProxy || ( this._foreignProxy = new ee.d( this._getProxy().then( ( t => {
            return t.loadForeignModule( e._foreignModuleId, e._foreignModuleCreateData ).then( ( n => {
              e._foreignModuleId = null, e._foreignModuleCreateData = null;
              for ( var i = ( e, n ) => {
                  return t.fmr( e, n )
                }, o = ( e, t ) => {
                  return function () {
                    const n = Array.prototype.slice.call( arguments, 0 );
                    return t( e, n )
                  };
                }, r = {}, s = 0; s < n.length; s++ ) r[ n[ s ] ] = o( n[ s ], i );
              return r
            } ) );
          } ) ) ) ), this._foreignProxy;
        }, t.prototype.getProxy = function () {
          return this._getForeignProxy()
        }, t.prototype.withSyncedResources = function ( e ) {
          const t = this;
          return this._withSyncedResources( e ).then( ( e => {
            return t.getProxy()
          } ) );
        }, t;
      } )( xt );
      const pi = n( "0Lb2" );
      const fi = n( "t49l" );
      const gi = n( "+3Gp" );
      const mi = n( "uzpd" );

      function _i( e, t, n ) {
        const i = new Zn( e, t );
        let o = null;
        i.has( fi.a ) || ( o = new N.d, i.set( fi.a, o ) ), i.has( ii.a ) || i.set( ii.a, new ni( i.get( L.a ), i.get( w.b ) ) );
        const r = n( i );
        return o && o.setEditor( r ), r
      }

      function vi( e, t, n ) {
        return _i( e, n, ( n => {
          return new K( e, t, n, n.get( C.a ), n.get( L.a ), n.get( w.b ), n.get( O.e ), n.get( S.a ), n.get( b.b ), n.get( I.a ), n.get( F.a ), n.get( W.b ) )
        } ) );
      }

      function yi( e ) {
        return Un.codeEditorService.get().onCodeEditorAdd( ( t => {
          e( t )
        } ) );
      }

      function bi( e, t, n ) {
        return _i( e, n, ( n => {
          return new q( e, t, n, n.get( C.a ), n.get( O.e ), n.get( S.a ), n.get( b.b ), n.get( x.a ), n.get( L.a ), n.get( I.a ), n.get( F.a ), n.get( W.b ) )
        } ) );
      }

      function Ci( e, t ) {
        return new pi.a( e, t )
      }

      function wi( e, t, n ) {
        return Un.modelService.get().createModel( e, t, n )
      }

      function Si( e, t, n ) {
        if ( e = e || "", !t ) {
          const i = n ? n.path : null;
          const o = e.indexOf( "\n" );
          let r = e;
          return -1 !== o && ( r = e.substring( 0, o ) ), wi( e, Un.modeService.get().getOrCreateModeByFilenameOrFirstLine( i, r ), n )
        }
        return wi( e, Un.modeService.get().getOrCreateMode( t ), n )
      }

      function Oi( e, t ) {
        Un.modelService.get().setMode( e, Un.modeService.get().getOrCreateMode( t ) )
      }

      function Li( e, t, n ) {
        e && Un.markerService.get().changeOne( t, e.uri, n )
      }

      function xi( e ) {
        return Un.markerService.get().read( e )
      }

      function Ni( e ) {
        return Un.modelService.get().getModel( e )
      }

      function Ei() {
        return Un.modelService.get().getModels()
      }

      function ki( e ) {
        return Un.modelService.get().onModelAdded( e )
      }

      function Ii( e ) {
        return Un.modelService.get().onModelRemoved( e )
      }

      function Di( e ) {
        return Un.modelService.get().onModelModeChanged( ( t => {
          e( {
            model: t.model,
            oldLanguage: t.oldModeId
          } )
        } ) );
      }

      function Mi( e ) {
        return ( ( e, t ) => {
          return new hi( e, t )
        } )( Un.modelService.get(), e );
      }

      function Ti( e, t ) {
        return ai.colorizeElement( Un.standaloneThemeService.get(), Un.modeService.get(), e, t )
      }

      function Ri( e, t, n ) {
        return ai.colorize( Un.modeService.get(), e, t, n )
      }

      function Pi( e, t, n ) {
        return void 0 === n && ( n = 4 ), ai.colorizeModelLine( e, t, n )
      }

      function Ai( e, t ) {
        Un.modeService.get().getOrCreateMode( t );
        for ( var n = ( e => {
            const t = He.y.get( e );
            return t || {
              getInitialState() {
                return Ht.c
              },
              tokenize( t, n, i ) {
                return Object( Ht.d )( e, t, n, i )
              },
              tokenize2: void 0
            };
          } )( t ), i = e.split( /\r\n|\r|\n/ ), o = [], r = n.getInitialState(), s = 0, a = i.length; s < a; s++ ) {
          const u = i[ s ],
            l = n.tokenize( u, r, 0 );
          o[ s ] = l.tokens, r = l.endState
        }
        return o
      }

      function Fi( e, t ) {
        Un.standaloneThemeService.get().defineTheme( e, t )
      }

      function Wi( e ) {
        Un.standaloneThemeService.get().setTheme( e )
      }!( e => {
        e[ e.Smooth = 0 ] = "Smooth", e[ e.Immediate = 1 ] = "Immediate"
      } )( ci || ( ci = {} ) ), ( e => {
        e[ e.Off = 0 ] = "Off", e[ e.On = 1 ] = "On", e[ e.Relative = 2 ] = "Relative", e[ e.Interval = 3 ] = "Interval", e[ e.Custom = 4 ] = "Custom"
      } )( di || ( di = {} ) );
      const ji = n( "KDc4" ),
        Vi = n( "qj0h" );

      function Bi( e ) {
        return !( e => {
          return Array.isArray( e )
        } )( e );
      }

      function Hi( e ) {
        return "string" === typeof e
      }

      function zi( e ) {
        return !Hi( e )
      }

      function Ui( e ) {
        return !e
      }

      function Ki( e, t ) {
        return e.ignoreCase && t ? t.toLowerCase() : t
      }

      function qi( e ) {
        return e.replace( /[&<>'"_]/g, "-" )
      }

      function Gi( e, t ) {
        throw new Error( e.languageId + ": " + t )
      }

      function Yi( e, t, n, i, o ) {
        let r = null;
        return t.replace( /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g, ( ( t, s, a, u, l, c, d, h, p ) => {
          return Ui( a ) ? Ui( u ) ? !Ui( l ) && l < i.length ? Ki( e, i[ l ] ) : !Ui( d ) && e && "string" === typeof e[ d ] ? e[ d ] : ( null === r && ( r = o.split( "." ) ).unshift( o ), !Ui( c ) && c < r.length ? Ki( e, r[ c ] ) : "" ) : Ki( e, n ) : "$"
        } ) );
      }

      function Xi( e, t ) {
        for ( ; t && t.length > 0; ) {
          const n = e.tokenizer[ t ];
          if ( n ) return n;
          const i = t.lastIndexOf( "." );
          t = i < 0 ? null : t.substr( 0, i )
        }
        return null
      }

      function $i( e, t, n ) {
        return "boolean" === typeof e ? e : ( n && ( e || void 0 === t ) && n(), void 0 === t ? null : t )
      }

      function Zi( e, t, n ) {
        return "string" === typeof e ? e : ( n && ( e || void 0 === t ) && n(), void 0 === t ? null : t )
      }

      function Qi( e, t ) {
        if ( "string" !== typeof t ) return null;
        for ( let n = 0; t.indexOf( "@" ) >= 0 && n < 5; ) n++, t = t.replace( /@(\w+)/g, ( ( n, i ) => {
          let o = "";
          return "string" === typeof e[ i ] ? o = e[ i ] : e[ i ] && e[ i ] instanceof RegExp ? o = e[ i ].source : void 0 === e[ i ] ? Gi( e, "language definition does not contain attribute '" + i + "', used at: " + t ) : Gi( e, "attribute reference '" + i + "' must be a string, used at: " + t ), Ui( o ) ? "" : "(?:" + o + ")"
        } ) );
        return new RegExp( t, e.ignoreCase ? "i" : "" )
      }

      function Ji( e, t, n, i ) {
        let o = -1,
          r = n,
          s = n.match( /^\$(([sS]?)(\d\d?)|#)(.*)$/ );
        s && ( s[ 3 ] && ( o = parseInt( s[ 3 ] ), s[ 2 ] && ( o += 100 ) ), r = s[ 4 ] );
        let a, u = "~",
          l = r;
        if ( r && 0 !== r.length ? /^\w*$/.test( l ) ? u = "==" : ( s = r.match( /^(@|!@|~|!~|==|!=)(.*)$/ ) ) && ( u = s[ 1 ], l = s[ 2 ] ) : ( u = "!=", l = "" ), "~" !== u && "!~" !== u || !/^(\w|\|)*$/.test( l ) )
          if ( "@" === u || "!@" === u ) {
            const c = e[ l ];
            c || Gi( e, "the @ match target '" + l + "' is not defined, in rule: " + t ), ( ( e, t ) => {
              if ( !t ) return !1;
              if ( !Array.isArray( t ) ) return !1;
              for ( const n in t )
                if ( t.hasOwnProperty( n ) && !e( t[ n ] ) ) return !1;
              return !0
            } )( e => {
              return "string" === typeof e
            }, c ) || Gi( e, "the @ match target '" + l + "' must be an array of strings, in rule: " + t );
            const d = Vi.b( c, e.ignoreCase );
            a = e => {
              return "@" === u ? d( e ) : !d( e )
            }
          } else if ( "~" === u || "!~" === u )
          if ( l.indexOf( "$" ) < 0 ) {
            const h = Qi( e, "^" + l + "$" );
            a = e => {
              return "~" === u ? h.test( e ) : !h.test( e )
            }
          } else a = ( t, n, i, o ) => {
            return Qi( e, "^" + Yi( e, l, n, i, o ) + "$" ).test( t )
          };
        else if ( l.indexOf( "$" ) < 0 ) {
          const p = Ki( e, l );
          a = e => {
            return "==" === u ? e === p : e !== p
          }
        } else {
          const f = Ki( e, l );
          a = ( t, n, i, o, r ) => {
            const s = Yi( e, f, n, i, o );
            return "==" === u ? t === s : t !== s
          }
        } else {
          const g = Vi.b( l.split( "|" ), e.ignoreCase );
          a = e => {
            return "~" === u ? g( e ) : !g( e )
          }
        }
        return -1 === o ? {
          name: n,
          value: i,
          test( e, t, n, i ) {
            return a( e, e, t, n, i )
          }
        } : {
          name: n,
          value: i,
          test( e, t, n, i ) {
            const r = ( ( e, t, n, i ) => {
              if ( i < 0 ) return e;
              if ( i < t.length ) return t[ i ];
              if ( i >= 100 ) {
                i -= 100;
                const o = n.split( "." );
                if ( o.unshift( n ), i < o.length ) return o[ i ]
              }
              return null
            } )( e, t, n, o );
            return a( r || "", e, t, n, i )
          }
        };
      }
      const eo = ( () => {
        function e( e ) {
          this.regex = new RegExp( "" ), this.action = {
            token: ""
          }, this.matchOnlyAtLineStart = !1, this.name = "", this.name = e
        }
        return e.prototype.setRegex = function ( e, t ) {
          let n;
          "string" === typeof t ? n = t : t instanceof RegExp ? n = t.source : Gi( e, "rules must start with a match string or regular expression: " + this.name ), this.matchOnlyAtLineStart = n.length > 0 && "^" === n[ 0 ], this.name = this.name + ": " + n, this.regex = Qi( e, "^(?:" + ( this.matchOnlyAtLineStart ? n.substr( 1 ) : n ) + ")" )
        }, e.prototype.setAction = function ( e, t ) {
          this.action = function e( t, n, i ) {
            if ( i ) {
              if ( "string" === typeof i ) return i;
              if ( i.token || "" === i.token ) {
                if ( "string" !== typeof i.token ) return Gi( t, "a 'token' attribute must be of type string, in rule: " + n ), {
                  token: ""
                };
                const o = {
                  token: i.token
                };
                if ( i.token.indexOf( "$" ) >= 0 && ( o.tokenSubst = !0 ), "string" === typeof i.bracket && ( "@open" === i.bracket ? o.bracket = 1 : "@close" === i.bracket ? o.bracket = -1 : Gi( t, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + n ) ), i.next )
                  if ( "string" !== typeof i.next ) Gi( t, "the next state must be a string value in rule: " + n );
                  else {
                    let r = i.next;
                    /^(@pop|@push|@popall)$/.test( r ) || ( "@" === r[ 0 ] && ( r = r.substr( 1 ) ), r.indexOf( "$" ) < 0 && ( ( ( e, t ) => {
                      for ( ; t && t.length > 0; ) {
                        if ( e.stateNames[ t ] ) return !0;
                        const n = t.lastIndexOf( "." );
                        t = n < 0 ? null : t.substr( 0, n )
                      }
                      return !1
                    } )( t, Yi( t, r, "", [], "" ) ) || Gi( t, "the next state '" + i.next + "' is not defined in rule: " + n ) ) ), o.next = r
                  } return "number" === typeof i.goBack && ( o.goBack = i.goBack ), "string" === typeof i.switchTo && ( o.switchTo = i.switchTo ), "string" === typeof i.log && ( o.log = i.log ), "string" === typeof i.nextEmbedded && ( o.nextEmbedded = i.nextEmbedded, t.usesEmbedded = !0 ), o
              }
              if ( Array.isArray( i ) ) {
                const s = [];
                for ( const a in i ) i.hasOwnProperty( a ) && ( s[ a ] = e( t, n, i[ a ] ) );
                return {
                  group: s
                }
              }
              if ( i.cases ) {
                const u = [];
                for ( const l in i.cases )
                  if ( i.cases.hasOwnProperty( l ) ) {
                    const c = e( t, n, i.cases[ l ] );
                    "@default" === l || "@" === l || "" === l ? u.push( {
                      test: null,
                      value: c,
                      name: l
                    } ) : "@eos" === l ? u.push( {
                      test( e, t, n, i ) {
                        return i
                      },
                      value: c,
                      name: l
                    } ) : u.push( Ji( t, n, l, c ) )
                  } const d = t.defaultToken;
                return {
                  test( e, t, n, i ) {
                    for ( const o in u ) {
                      if ( u.hasOwnProperty( o ) )
                        if ( !u[ o ].test || u[ o ].test( e, t, n, i ) ) return u[ o ].value
                    }
                    return d
                  }
                };
              }
              return Gi( t, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + n ), ""
            }
            return {
              token: ""
            }
          }( e, this.name, t )
        }, e;
      } )();
      const to = ( () => {
          function e( e ) {
            this._maxCacheDepth = e, this._entries = Object.create( null )
          }
          return e.create = function ( e, t ) {
            return this._INSTANCE.create( e, t )
          }, e.prototype.create = function ( e, t ) {
            if ( null !== e && e.depth >= this._maxCacheDepth ) return new no( e, t );
            let n = no.getStackElementId( e );
            n.length > 0 && ( n += "|" ), n += t;
            let i = this._entries[ n ];
            return i || ( i = new no( e, t ), this._entries[ n ] = i, i )
          }, e._INSTANCE = new e( 5 ), e;
        } )(),
        no = ( () => {
          function e( e, t ) {
            this.parent = e, this.state = t, this.depth = ( this.parent ? this.parent.depth : 0 ) + 1
          }
          return e.getStackElementId = e => {
            for ( var t = ""; null !== e; ) t.length > 0 && ( t += "|" ), t += e.state, e = e.parent;
            return t
          }, e._equals = ( e, t ) => {
            for ( ; null !== e && null !== t; ) {
              if ( e === t ) return !0;
              if ( e.state !== t.state ) return !1;
              e = e.parent, t = t.parent
            }
            return null === e && null === t
          }, e.prototype.equals = function ( t ) {
            return e._equals( this, t )
          }, e.prototype.push = function ( e ) {
            return to.create( this, e )
          }, e.prototype.pop = function () {
            return this.parent
          }, e.prototype.popall = function () {
            for ( var e = this; e.parent; ) e = e.parent;
            return e
          }, e.prototype.switchTo = function ( e ) {
            return to.create( this.parent, e )
          }, e;
        } )(),
        io = ( () => {
          function e( e, t ) {
            this.modeId = e, this.state = t
          }
          return e.prototype.equals = function ( e ) {
            return this.modeId === e.modeId && this.state.equals( e.state )
          }, e.prototype.clone = function () {
            return this.state.clone() === this.state ? this : new e( this.modeId, this.state )
          }, e
        } )(),
        oo = ( () => {
          function e( e ) {
            this._maxCacheDepth = e, this._entries = Object.create( null )
          }
          return e.create = function ( e, t ) {
            return this._INSTANCE.create( e, t )
          }, e.prototype.create = function ( e, t ) {
            if ( null !== t ) return new ro( e, t );
            if ( null !== e && e.depth >= this._maxCacheDepth ) return new ro( e, t );
            const n = no.getStackElementId( e );
            let i = this._entries[ n ];
            return i || ( i = new ro( e, null ), this._entries[ n ] = i, i )
          }, e._INSTANCE = new e( 5 ), e;
        } )(),
        ro = ( () => {
          function e( e, t ) {
            this.stack = e, this.embeddedModeData = t
          }
          return e.prototype.clone = function () {
            return ( this.embeddedModeData ? this.embeddedModeData.clone() : null ) === this.embeddedModeData ? this : oo.create( this.stack, this.embeddedModeData )
          }, e.prototype.equals = function ( t ) {
            return t instanceof e && ( !!this.stack.equals( t.stack ) && ( null === this.embeddedModeData && null === t.embeddedModeData || null !== this.embeddedModeData && null !== t.embeddedModeData && this.embeddedModeData.equals( t.embeddedModeData ) ) )
          }, e
        } )(),
        so = Object.hasOwnProperty,
        ao = ( () => {
          function e() {
            this._tokens = [], this._language = null, this._lastTokenType = null, this._lastTokenLanguage = null
          }
          return e.prototype.enterMode = function ( e, t ) {
            this._language = t
          }, e.prototype.emit = function ( e, t ) {
            this._lastTokenType === t && this._lastTokenLanguage === this._language || ( this._lastTokenType = t, this._lastTokenLanguage = this._language, this._tokens.push( new h.a( e, t, this._language ) ) )
          }, e.prototype.nestedModeTokenize = function ( e, t, n ) {
            const i = t.modeId,
              o = t.state,
              r = He.y.get( i );
            if ( !r ) return this.enterMode( n, i ), this.emit( n, "" ), o;
            const s = r.tokenize( e, o, n );
            return this._tokens = this._tokens.concat( s.tokens ), this._lastTokenType = null, this._lastTokenLanguage = null, this._language = null, s.endState
          }, e.prototype.finalize = function ( e ) {
            return new h.b( this._tokens, e )
          }, e;
        } )(),
        uo = ( () => {
          function e( e, t ) {
            this._modeService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0
          }
          return e.prototype.enterMode = function ( e, t ) {
            this._currentLanguageId = this._modeService.getLanguageIdentifier( t ).id
          }, e.prototype.emit = function ( e, t ) {
            const n = this._theme.match( this._currentLanguageId, t );
            this._lastTokenMetadata !== n && ( this._lastTokenMetadata = n, this._tokens.push( e ), this._tokens.push( n ) )
          }, e._merge = ( e, t, n ) => {
            const i = null !== e ? e.length : 0,
              o = t.length,
              r = null !== n ? n.length : 0;
            if ( 0 === i && 0 === o && 0 === r ) return new Uint32Array( 0 );
            if ( 0 === i && 0 === o ) return n;
            if ( 0 === o && 0 === r ) return e;
            const s = new Uint32Array( i + o + r );
            null !== e && s.set( e );
            for ( let a = 0; a < o; a++ ) s[ i + a ] = t[ a ];
            return null !== n && s.set( n, i + o ), s
          }, e.prototype.nestedModeTokenize = function ( t, n, i ) {
            const o = n.modeId,
              r = n.state,
              s = He.y.get( o );
            if ( !s ) return this.enterMode( i, o ), this.emit( i, "" ), r;
            const a = s.tokenize2( t, r, i );
            return this._prependTokens = e._merge( this._prependTokens, this._tokens, a.tokens ), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, a.endState
          }, e.prototype.finalize = function ( t ) {
            return new h.c( e._merge( this._prependTokens, this._tokens, null ), t )
          }, e;
        } )(),
        lo = ( () => {
          function e( e, t, n, i ) {
            const o = this;
            this._modeService = e, this._standaloneThemeService = t, this._modeId = n, this._lexer = i, this._embeddedModes = Object.create( null );
            let r = !1;
            this._tokenizationRegistryListener = He.y.onDidChange( ( e => {
              if ( !r ) {
                for ( var t = !1, n = 0, i = e.changedLanguages.length; n < i; n++ ) {
                  const s = e.changedLanguages[ n ];
                  if ( o._embeddedModes[ s ] ) {
                    t = !0;
                    break
                  }
                }
                t && ( r = !0, He.y.fire( [ o._modeId ] ), r = !1 )
              }
            } ) )
          }
          return e.prototype.dispose = function () {
            this._tokenizationRegistryListener.dispose()
          }, e.prototype.getInitialState = function () {
            const e = to.create( null, this._lexer.start );
            return oo.create( e, null )
          }, e.prototype.tokenize = function ( e, t, n ) {
            const i = new ao,
              o = this._tokenize( e, t, n, i );
            return i.finalize( o )
          }, e.prototype.tokenize2 = function ( e, t, n ) {
            const i = new uo( this._modeService, this._standaloneThemeService.getTheme().tokenTheme ),
              o = this._tokenize( e, t, n, i );
            return i.finalize( o )
          }, e.prototype._tokenize = function ( e, t, n, i ) {
            return t.embeddedModeData ? this._nestedTokenize( e, t, n, i ) : this._myTokenize( e, t, n, i )
          }, e.prototype._findLeavingNestedModeOffset = function ( e, t ) {
            let n = this._lexer.tokenizer[ t.stack.state ];
            n || ( n = Xi( this._lexer, t.stack.state ) ) || Gi( this._lexer, "tokenizer state is not defined: " + t.stack.state );
            let i = -1,
              o = !1;
            for ( const r in n )
              if ( so.call( n, r ) ) {
                const s = n[ r ];
                if ( zi( s.action ) && "@pop" === s.action.nextEmbedded ) {
                  o = !0;
                  let a = s.regex;
                  const u = s.regex.source;
                  "^(?:" === u.substr( 0, 4 ) && ")" === u.substr( u.length - 1, 1 ) && ( a = new RegExp( u.substr( 4, u.length - 5 ), a.ignoreCase ? "i" : "" ) );
                  const l = e.search( a ); - 1 !== l && ( -1 === i || l < i ) && ( i = l )
                }
              } return o || Gi( this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state ), i
          }, e.prototype._nestedTokenize = function ( e, t, n, i ) {
            const o = this._findLeavingNestedModeOffset( e, t );
            if ( -1 === o ) {
              const r = i.nestedModeTokenize( e, t.embeddedModeData, n );
              return oo.create( t.stack, new io( t.embeddedModeData.modeId, r ) )
            }
            const s = e.substring( 0, o );
            s.length > 0 && i.nestedModeTokenize( s, t.embeddedModeData, n );
            const a = e.substring( o );
            return this._myTokenize( a, t, n + o, i )
          }, e.prototype._myTokenize = function ( e, t, n, i ) {
            i.enterMode( n, this._modeId );
            for ( var o, r, s = e.length, a = t.embeddedModeData, u = t.stack, l = 0, c = null, d = null, h = null, p = null; l < s; ) {
              const f = l;
              const g = u.depth;
              const m = c ? c.length : 0;
              const _ = u.state;
              let v = null;
              let y = null;
              let b = null;
              let C = null;
              let w = null;
              if ( c ) v = d, y = h.shift(), b = c.shift(), C = p, 0 === c.length && ( c = null, d = null, h = null, p = null );
              else {
                if ( l >= s ) break;
                let S = this._lexer.tokenizer[ _ ];
                S || ( S = Xi( this._lexer, _ ) ) || Gi( this._lexer, "tokenizer state is not defined: " + _ );
                var O = e.substr( l );
                for ( const L in S )
                  if ( so.call( S, L ) ) {
                    const x = S[ L ];
                    if ( ( 0 === l || !x.matchOnlyAtLineStart ) && ( v = O.match( x.regex ) ) ) {
                      y = v[ 0 ], b = x.action;
                      break
                    }
                  }
              }
              for ( v || ( v = [ "" ], y = "" ), b || ( l < s && ( y = ( v = [ e.charAt( l ) ] )[ 0 ] ), b = this._lexer.defaultToken ), l += y.length; Bi( b ) && zi( b ) && b.test; ) b = b.test( y, v, _, l === s );
              let N = null;
              if ( "string" === typeof b || Array.isArray( b ) ) N = b;
              else if ( b.group ) N = b.group;
              else if ( null !== b.token && void 0 !== b.token ) {
                if ( N = b.tokenSubst ? Yi( this._lexer, b.token, y, v, _ ) : b.token, b.nextEmbedded && ( "@pop" === b.nextEmbedded ? ( a || Gi( this._lexer, "cannot pop embedded mode if not inside one" ), a = null ) : a ? Gi( this._lexer, "cannot enter embedded mode from within an embedded mode" ) : w = Yi( this._lexer, b.nextEmbedded, y, v, _ ) ), b.goBack && ( l = Math.max( 0, l - b.goBack ) ), b.switchTo && "string" === typeof b.switchTo ) "@" === ( E = Yi( this._lexer, b.switchTo, y, v, _ ) )[ 0 ] && ( E = E.substr( 1 ) ), Xi( this._lexer, E ) ? u = u.switchTo( E ) : Gi( this._lexer, "trying to switch to a state '" + E + "' that is undefined in rule: " + C.name );
                else if ( b.transform && "function" === typeof b.transform ) Gi( this._lexer, "action.transform not supported" );
                else if ( b.next )
                  if ( "@push" === b.next ) u.depth >= this._lexer.maxStack ? Gi( this._lexer, "maximum tokenizer stack size reached: [" + u.state + "," + u.parent.state + ",...]" ) : u = u.push( _ );
                  else if ( "@pop" === b.next ) u.depth <= 1 ? Gi( this._lexer, "trying to pop an empty stack in rule: " + C.name ) : u = u.pop();
                else if ( "@popall" === b.next ) u = u.popall();
                else {
                  var E;
                  "@" === ( E = Yi( this._lexer, b.next, y, v, _ ) )[ 0 ] && ( E = E.substr( 1 ) ), Xi( this._lexer, E ) ? u = u.push( E ) : Gi( this._lexer, "trying to set a next state '" + E + "' that is undefined in rule: " + C.name )
                }
                b.log && "string" === typeof b.log && ( o = this._lexer, r = this._lexer.languageId + ": " + Yi( this._lexer, b.log, y, v, _ ), console.log( o.languageId + ": " + r ) )
              }
              if ( null === N && Gi( this._lexer, "lexer rule has no well-defined action in rule: " + C.name ), Array.isArray( N ) ) {
                c && c.length > 0 && Gi( this._lexer, "groups cannot be nested: " + C.name ), v.length !== N.length + 1 && Gi( this._lexer, "matched number of groups does not match the number of actions in rule: " + C.name );
                for ( var k = 0, I = 1; I < v.length; I++ ) k += v[ I ].length;
                k !== y.length && Gi( this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + C.name ), d = v, h = v.slice( 1 ), c = N.slice( 0 ), p = C, l -= y.length
              } else {
                if ( "@rematch" === N && ( l -= y.length, y = "", v = null, N = "" ), 0 === y.length ) {
                  if ( g !== u.depth || _ !== u.state || ( c ? c.length : 0 ) !== m ) continue;
                  Gi( this._lexer, "no progress in tokenizer in rule: " + C.name ), l = s
                }
                let D = null;
                if ( Hi( N ) && 0 === N.indexOf( "@brackets" ) ) {
                  const M = N.substr( "@brackets".length );
                  let T = co( this._lexer, y );
                  T || ( Gi( this._lexer, "@brackets token returned but no bracket defined as: " + y ), T = {
                    token: "",
                    bracketType: 0
                  } ), D = qi( T.token + M )
                } else {
                  D = qi( "" === N ? "" : N + this._lexer.tokenPostfix )
                }
                if ( i.emit( f + n, D ), null !== w ) {
                  const R = this._modeService.getModeIdForLanguageName( w );
                  R && ( w = R );
                  const P = this._getNestedEmbeddedModeData( w );
                  if ( l < s ) {
                    O = e.substr( l );
                    return this._nestedTokenize( O, oo.create( u, P ), n + l, i )
                  }
                  return oo.create( u, P )
                }
              }
            }
            return oo.create( u, a )
          }, e.prototype._getNestedEmbeddedModeData = function ( e ) {
            const t = this._locateMode( e );
            if ( t ) {
              const n = He.y.get( t.getId() );
              if ( n ) return new io( t.getId(), n.getInitialState() )
            }
            const i = t ? t.getId() : Ht.b;
            return new io( i, Ht.c )
          }, e.prototype._locateMode = function ( e ) {
            if ( !e || !this._modeService.isRegisteredMode( e ) ) return null;
            const t = this._modeService.getModeId( e );
            this._modeService.getOrCreateMode( t );
            const n = this._modeService.getMode( t );
            return n ? ( this._embeddedModes[ t ] = !0, n ) : ( this._embeddedModes[ t ] = !0, null )
          }, e;
        } )();

      function co( e, t ) {
        if ( !t ) return null;
        t = Ki( e, t );
        for ( let n = e.brackets, i = 0; i < n.length; i++ ) {
          const o = n[ i ];
          if ( o.open === t ) return {
            token: o.token,
            bracketType: 1
          };
          if ( o.close === t ) return {
            token: o.token,
            bracketType: -1
          }
        }
        return null
      }

      function ho( e ) {
        Vt.registerLanguage( e )
      }

      function po() {
        let e = [];
        return e = e.concat( Vt.getLanguages() )
      }

      function fo( e ) {
        const t = Un.modeService.get().getLanguageIdentifier( e );
        return t && t.id
      }

      function go( e, t ) {
        const n = Un.modeService.get().onDidCreateMode( ( i => {
          i.getId() === e && ( n.dispose(), t() )
        } ) );
        return n
      }

      function mo( e, t ) {
        const n = Un.modeService.get().getLanguageIdentifier( e );
        if ( !n ) throw new Error( "Cannot set configuration for unknown language " + e );
        return pt.a.register( n, t )
      }
      let _o;
      const vo = ( () => {
        function e( e ) {
          this._actual = e
        }
        return e.prototype.getInitialState = function () {
          return this._actual.getInitialState()
        }, e.prototype.tokenize = ( e, t, n ) => {
          throw new Error( "Not supported!" )
        }, e.prototype.tokenize2 = function ( e, t ) {
          const n = this._actual.tokenizeEncoded( e, t );
          return new h.c( n.tokens, n.endState )
        }, e;
      } )();

      const yo = ( () => {
        function e( e, t, n ) {
          this._standaloneThemeService = e, this._languageIdentifier = t, this._actual = n
        }
        return e.prototype.getInitialState = function () {
          return this._actual.getInitialState()
        }, e.prototype._toClassicTokens = ( e, t, n ) => {
          for ( var i = [], o = 0, r = 0, s = e.length; r < s; r++ ) {
            const a = e[ r ];
            let u = a.startIndex;
            0 === r ? u = 0 : u < o && ( u = o ), i[ r ] = new h.a( u + n, a.scopes, t ), o = u
          }
          return i
        }, e.prototype.tokenize = function ( e, t, n ) {
          let i;
          const o = this._actual.tokenize( e, t );
          const r = this._toClassicTokens( o.tokens, this._languageIdentifier.language, n );
          return i = o.endState.equals( t ) ? t : o.endState, new h.b( r, i )
        }, e.prototype._toBinaryTokens = function ( e, t ) {
          for ( var n = this._languageIdentifier.id, i = this._standaloneThemeService.getTheme().tokenTheme, o = [], r = 0, s = 0, a = 0, u = e.length; a < u; a++ ) {
            const l = e[ a ],
              c = i.match( n, l.scopes );
            if ( !( r > 0 && o[ r - 1 ] === c ) ) {
              let d = l.startIndex;
              0 === a ? d = 0 : d < s && ( d = s ), o[ r++ ] = d + t, o[ r++ ] = c, s = d
            }
          }
          const h = new Uint32Array( r );
          for ( a = 0; a < r; a++ ) h[ a ] = o[ a ];
          return h
        }, e.prototype.tokenize2 = function ( e, t, n ) {
          let i;
          const o = this._actual.tokenize( e, t );
          const r = this._toBinaryTokens( o.tokens, n );
          return i = o.endState.equals( t ) ? t : o.endState, new h.c( r, i )
        }, e;
      } )();

      function bo( e, t ) {
        let n;
        const i = Un.modeService.get().getLanguageIdentifier( e );
        if ( !i ) throw new Error( "Cannot set tokens provider for unknown language " + e );
        return n = ( e => {
          return e.tokenizeEncoded
        } )( t ) ? new vo( t ) : new yo( Un.standaloneThemeService.get(), i, t ), He.y.register( e, n );
      }

      function Co( e, t ) {
        const n = ( ( e, t ) => {
            if ( !t || "object" !== typeof t ) throw new Error( "Monarch: expecting a language definition object" );
            const n = {};
            n.languageId = e, n.noThrow = !1, n.maxStack = 100, n.start = Zi( t.start ), n.ignoreCase = $i( t.ignoreCase, !1 ), n.tokenPostfix = Zi( t.tokenPostfix, "." + n.languageId ), n.defaultToken = Zi( t.defaultToken, "source", ( () => {
              Gi( n, "the 'defaultToken' must be a string" )
            } ) ), n.usesEmbedded = !1;
            const i = t;

            function o( e, r, s ) {
              for ( const a in s )
                if ( s.hasOwnProperty( a ) ) {
                  const u = s[ a ];
                  let l = u.include;
                  if ( l ) "string" !== typeof l && Gi( n, "an 'include' attribute must be a string at: " + e ), "@" === l[ 0 ] && ( l = l.substr( 1 ) ), t.tokenizer[ l ] || Gi( n, "include target '" + l + "' is not defined at: " + e ), o( e + "." + l, r, t.tokenizer[ l ] );
                  else {
                    const c = new eo( e );
                    if ( Array.isArray( u ) && u.length >= 1 && u.length <= 3 )
                      if ( c.setRegex( i, u[ 0 ] ), u.length >= 3 )
                        if ( "string" === typeof u[ 1 ] ) c.setAction( i, {
                          token: u[ 1 ],
                          next: u[ 2 ]
                        } );
                        else if ( "object" === typeof u[ 1 ] ) {
                      const d = u[ 1 ];
                      d.next = u[ 2 ], c.setAction( i, d )
                    } else Gi( n, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + e );
                    else c.setAction( i, u[ 1 ] );
                    else u.regex || Gi( n, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + e ), u.name && ( c.name = Zi( u.name ) ), u.matchOnlyAtStart && ( c.matchOnlyAtLineStart = $i( u.matchOnlyAtLineStart ) ), c.setRegex( i, u.regex ), c.setAction( i, u.action );
                    r.push( c )
                  }
                }
            }
            for ( const r in ( i.languageId = e, i.ignoreCase = n.ignoreCase, i.noThrow = n.noThrow, i.usesEmbedded = n.usesEmbedded, i.stateNames = t.tokenizer, i.defaultToken = n.defaultToken, t.tokenizer && "object" === typeof t.tokenizer || Gi( n, "a language definition must define the 'tokenizer' attribute as an object" ), n.tokenizer = [], t.tokenizer ) )
              if ( t.tokenizer.hasOwnProperty( r ) ) {
                n.start || ( n.start = r );
                const s = t.tokenizer[ r ];
                n.tokenizer[ r ] = new Array, o( "tokenizer." + r, n.tokenizer[ r ], s )
              } n.usesEmbedded = i.usesEmbedded, t.brackets ? Array.isArray( t.brackets ) || Gi( n, "the 'brackets' attribute must be defined as an array" ) : t.brackets = [ {
              open: "{",
              close: "}",
              token: "delimiter.curly"
            }, {
              open: "[",
              close: "]",
              token: "delimiter.square"
            }, {
              open: "(",
              close: ")",
              token: "delimiter.parenthesis"
            }, {
              open: "<",
              close: ">",
              token: "delimiter.angle"
            } ];
            const a = [];
            for ( const u in t.brackets )
              if ( t.brackets.hasOwnProperty( u ) ) {
                let l = t.brackets[ u ];
                l && Array.isArray( l ) && 3 === l.length && ( l = {
                  token: l[ 2 ],
                  open: l[ 0 ],
                  close: l[ 1 ]
                } ), l.open === l.close && Gi( n, "open and close brackets in a 'brackets' attribute must be different: " + l.open + "\n hint: use the 'bracket' attribute if matching on equal brackets is required." ), "string" === typeof l.open && "string" === typeof l.token ? a.push( {
                  token: Zi( l.token ) + n.tokenPostfix,
                  open: Ki( n, Zi( l.open ) ),
                  close: Ki( n, Zi( l.close ) )
                } ) : Gi( n, "every element in the 'brackets' array must be a '{open,close,token}' object or array" )
              } return n.brackets = a, n.noThrow = !0, n
          } )( e, t ),
          i = ( ( e, t, n, i ) => {
            return new lo( e, t, n, i )
          } )( Un.modeService.get(), Un.standaloneThemeService.get(), e, n );
        return He.y.register( e, i )
      }

      function wo( e, t ) {
        return He.r.register( e, t )
      }

      function So( e, t ) {
        return He.s.register( e, t )
      }

      function Oo( e, t ) {
        return He.t.register( e, t )
      }

      function Lo( e, t ) {
        return He.m.register( e, {
          provideHover( e, n, i ) {
            const o = e.getWordAtPosition( n );
            return Object( ee.n )( t.provideHover( e, n, i ) ).then( ( e => {
              if ( e ) return !e.range && o && ( e.range = new u.a( n.lineNumber, o.startColumn, n.lineNumber, o.endColumn ) ), e.range || ( e.range = new u.a( n.lineNumber, n.column, n.lineNumber, n.column ) ), e
            } ) );
          }
        } );
      }

      function xo( e, t ) {
        return He.j.register( e, t )
      }

      function No( e, t ) {
        return He.h.register( e, t )
      }

      function Eo( e, t ) {
        return He.e.register( e, t )
      }

      function ko( e, t ) {
        return He.n.register( e, t )
      }

      function Io( e, t ) {
        return He.z.register( e, t )
      }

      function Do( e, t ) {
        return He.c.register( e, t )
      }

      function Mo( e, t ) {
        return He.a.register( e, {
          provideCodeActions( e, n, i, o ) {
            const r = Un.markerService.get().read( {
              resource: e.uri
            } ).filter( ( e => {
              return u.a.areIntersectingOrTouching( e, n )
            } ) );
            return t.provideCodeActions( e, n, {
              markers: r,
              only: i.only
            }, o )
          }
        } );
      }

      function To( e, t ) {
        return He.f.register( e, t )
      }

      function Ro( e, t ) {
        return He.i.register( e, t )
      }

      function Po( e, t ) {
        return He.q.register( e, t )
      }

      function Ao( e, t ) {
        return He.p.register( e, t )
      }

      function Fo( e, t ) {
        const n = new Bo( t );
        return He.u.register( e, {
          triggerCharacters: t.triggerCharacters,
          provideCompletionItems( e, t, i, o ) {
            return n.provideCompletionItems( e, t, i, o )
          },
          resolveCompletionItem( e, t, i, o ) {
            return n.resolveCompletionItem( e, t, i, o )
          }
        } );
      }

      function Wo( e, t ) {
        return He.d.register( e, t )
      }

      function jo( e, t ) {
        return He.l.register( e, t )
      }

      function Vo( e ) {
        switch ( e ) {
          case _o.Method:
            return "method";
          case _o.Function:
            return "function";
          case _o.Constructor:
            return "constructor";
          case _o.Field:
            return "field";
          case _o.Variable:
            return "variable";
          case _o.Class:
            return "class";
          case _o.Interface:
            return "interface";
          case _o.Module:
            return "module";
          case _o.Property:
            return "property";
          case _o.Unit:
            return "unit";
          case _o.Value:
            return "value";
          case _o.Enum:
            return "enum";
          case _o.Keyword:
            return "keyword";
          case _o.Snippet:
            return "snippet";
          case _o.Text:
            return "text";
          case _o.Color:
            return "color";
          case _o.File:
            return "file";
          case _o.Reference:
            return "reference";
          case _o.Folder:
            return "folder"
        }
        return "property"
      }!( e => {
        e[ e.Text = 0 ] = "Text", e[ e.Method = 1 ] = "Method", e[ e.Function = 2 ] = "Function", e[ e.Constructor = 3 ] = "Constructor", e[ e.Field = 4 ] = "Field", e[ e.Variable = 5 ] = "Variable", e[ e.Class = 6 ] = "Class", e[ e.Interface = 7 ] = "Interface", e[ e.Module = 8 ] = "Module", e[ e.Property = 9 ] = "Property", e[ e.Unit = 10 ] = "Unit", e[ e.Value = 11 ] = "Value", e[ e.Enum = 12 ] = "Enum", e[ e.Keyword = 13 ] = "Keyword", e[ e.Snippet = 14 ] = "Snippet", e[ e.Color = 15 ] = "Color", e[ e.File = 16 ] = "File", e[ e.Reference = 17 ] = "Reference", e[ e.Folder = 18 ] = "Folder"
      } )( _o || ( _o = {} ) );
      var Bo = ( () => {
        function e( e ) {
          this._provider = e
        }
        return e.from = ( e, t, n ) => {
          const i = {
              _actual: e,
              label: e.label,
              insertText: e.label,
              type: Vo( e.kind ),
              detail: e.detail,
              documentation: e.documentation,
              command: e.command,
              sortText: e.sortText,
              filterText: e.filterText,
              snippetType: "internal",
              additionalTextEdits: e.additionalTextEdits,
              commitCharacters: e.commitCharacters
            },
            o = e.textEdit ? e.textEdit.range : e.range;
          if ( o ) {
            if ( !( o.startLineNumber === o.endLineNumber ) || o.startLineNumber !== t.lineNumber ) return console.warn( "INVALID range, must be single line and on the same line" ), null;
            i.overwriteBefore = t.column - o.startColumn, i.overwriteAfter = o.endColumn - t.column
          } else i.overwriteBefore = t.column - n.column, i.overwriteAfter = 0;
          return e.textEdit ? i.insertText = e.textEdit.text : "object" === typeof e.insertText && "string" === typeof e.insertText.value ? ( i.insertText = e.insertText.value, i.snippetType = "textmate" ) : "string" === typeof e.insertText && ( i.insertText = e.insertText ), i
        }, e.prototype.provideCompletionItems = function ( t, n, i, o ) {
          const r = this._provider.provideCompletionItems( t, n, o, i );
          return Object( ee.n )( r ).then( ( i => {
            let o;
            const r = {
              suggestions: []
            };
            let s = n;
            const u = t.getWordUntilPosition( n );
            if ( u && ( s = new a.a( s.lineNumber, u.startColumn ) ), Array.isArray( i ) ) o = {
              items: i,
              isIncomplete: !1
            };
            else if ( "object" === typeof i && Array.isArray( i.items ) ) o = i, r.incomplete = o.isIncomplete;
            else {
              if ( !i ) return;
              console.warn( "INVALID result from completion provider. expected CompletionItem-array or CompletionList but got:", i )
            }
            for ( let l = 0; l < o.items.length; l++ ) {
              const c = o.items[ l ],
                d = e.from( c, n, s );
              d && r.suggestions.push( d )
            }
            return r
          } ) );
        }, e.prototype.resolveCompletionItem = function ( t, n, i, o ) {
          if ( "function" !== typeof this._provider.resolveCompletionItem ) return c.b.as( i );
          const r = i._actual;
          return r ? Object( ee.n )( this._provider.resolveCompletionItem( r, o ) ).then( ( i => {
            let o = n;
            const r = t.getWordUntilPosition( n );
            return r && ( o = new a.a( o.lineNumber, r.startColumn ) ), e.from( i, n, o )
          } ) ) : c.b.as( i );
        }, e;
      } )();
      const Ho = ( () => {
        function e( e ) {
          c.a.is( e ) ? this._winjsPromise = e : this._winjsPromise = new c.a( ( ( t, n ) => {
            let i = !0;
            e( ( e => {
              i ? Te.h( ( () => {
                return t( e )
              } ) ) : t( e )
            } ), ( e => {
              i ? Te.h( ( () => {
                return n( e )
              } ) ) : n( e )
            } ) ), i = !1
          } ) )
        }
        return e.all = t => {
          return new e( c.a.join( t ).then( null, ( e => {
            for ( const t in e )
              if ( e.hasOwnProperty( t ) ) return e[ t ]
          } ) ) );
        }, e.race = t => {
          return new e( c.a.any( t ).then( ( e => {
            return e.value
          } ), ( e => {
            return e.value
          } ) ) );
        }, e.resolve = t => {
          return new e( c.a.wrap( t ) )
        }, e.reject = t => {
          return new e( c.a.wrapError( t ) )
        }, e.prototype.then = function ( t, n ) {
          let i = !0;
          const o = new e( this._winjsPromise.then( t && ( e => {
            i ? Te.h( ( () => {
              return t( e )
            } ) ) : t( e )
          } ), n && ( e => {
            i ? Te.h( ( () => {
              return n( e )
            } ) ) : n( e )
          } ) ) );
          return i = !1, o
        }, e.prototype.catch = function ( e ) {
          return this.then( null, e )
        }, e;
      } )();
      n.d( t, "CancellationTokenSource", ( () => {
        return Ko
      } ) ), n.d( t, "Emitter", ( () => {
        return qo
      } ) ), n.d( t, "KeyCode", ( () => {
        return Go
      } ) ), n.d( t, "KeyMod", ( () => {
        return Yo
      } ) ), n.d( t, "Position", ( () => {
        return Xo
      } ) ), n.d( t, "Range", ( () => {
        return $o
      } ) ), n.d( t, "Selection", ( () => {
        return Zo
      } ) ), n.d( t, "SelectionDirection", ( () => {
        return Qo
      } ) ), n.d( t, "MarkerSeverity", ( () => {
        return Jo
      } ) ), n.d( t, "MarkerTag", ( () => {
        return er
      } ) ), n.d( t, "Promise", ( () => {
        return tr
      } ) ), n.d( t, "Uri", ( () => {
        return nr
      } ) ), n.d( t, "Token", ( () => {
        return ir
      } ) ), n.d( t, "editor", ( () => {
        return or
      } ) ), n.d( t, "languages", ( () => {
        return rr
      } ) );
      const zo = self;
      "undefined" === typeof zo.Promise && ( zo.Promise = Ho ), Xt.a.wrappingIndent = Xt.j.None, Xt.a.viewInfo.glyphMargin = !1, Xt.a.autoIndent = !1;
      const Uo = m();
      Uo.editor = {
        create: vi,
        onDidCreateEditor: yi,
        createDiffEditor: bi,
        createDiffNavigator: Ci,
        createModel: Si,
        setModelLanguage: Oi,
        setModelMarkers: Li,
        getModelMarkers: xi,
        getModels: Ei,
        getModel: Ni,
        onDidCreateModel: ki,
        onWillDisposeModel: Ii,
        onDidChangeModelLanguage: Di,
        createWebWorker: Mi,
        colorizeElement: Ti,
        colorize: Ri,
        colorizeModelLine: Pi,
        tokenize: Ai,
        defineTheme: Fi,
        setTheme: Wi,
        ScrollbarVisibility: G.b,
        WrappingIndent: Xt.j,
        OverviewRulerLane: Zt.f,
        EndOfLinePreference: Zt.c,
        DefaultEndOfLine: Zt.b,
        EndOfLineSequence: Zt.d,
        TrackedRangeStickiness: Zt.h,
        CursorChangeReason: mi.a,
        MouseTargetType: v.b,
        TextEditorCursorStyle: Xt.i,
        TextEditorCursorBlinkingStyle: Xt.h,
        ContentWidgetPositionPreference: v.a,
        OverlayWidgetPositionPreference: v.c,
        RenderMinimap: Xt.g,
        ScrollType: ci,
        RenderLineNumbersType: di,
        InternalEditorOptions: Xt.e,
        BareFontInfo: gi.a,
        FontInfo: gi.b,
        TextModelResolvedOptions: Zt.g,
        FindMatch: Zt.e,
        EditorType: _.a
      }, Uo.languages = {
        register: ho,
        getLanguages: po,
        onLanguage: go,
        getEncodedLanguageId: fo,
        setLanguageConfiguration: mo,
        setTokensProvider: bo,
        setMonarchTokensProvider: Co,
        registerReferenceProvider: wo,
        registerRenameProvider: So,
        registerCompletionItemProvider: Fo,
        registerSignatureHelpProvider: Oo,
        registerHoverProvider: Lo,
        registerDocumentSymbolProvider: xo,
        registerDocumentHighlightProvider: No,
        registerDefinitionProvider: Eo,
        registerImplementationProvider: ko,
        registerTypeDefinitionProvider: Io,
        registerCodeLensProvider: Do,
        registerCodeActionProvider: Mo,
        registerDocumentFormattingEditProvider: To,
        registerDocumentRangeFormattingEditProvider: Ro,
        registerOnTypeFormattingEditProvider: Po,
        registerLinkProvider: Ao,
        registerColorProvider: Wo,
        registerFoldingRangeProvider: jo,
        DocumentHighlightKind: He.g,
        CompletionItemKind: _o,
        SymbolKind: He.w,
        IndentAction: ji.a,
        SuggestTriggerKind: He.v,
        FoldingRangeKind: He.k
      };
      var Ko = Uo.CancellationTokenSource,
        qo = Uo.Emitter,
        Go = Uo.KeyCode,
        Yo = Uo.KeyMod,
        Xo = Uo.Position,
        $o = Uo.Range,
        Zo = Uo.Selection,
        Qo = Uo.SelectionDirection,
        Jo = Uo.MarkerSeverity,
        er = Uo.MarkerTag,
        tr = Uo.Promise,
        nr = Uo.Uri,
        ir = Uo.Token,
        or = Uo.editor,
        rr = Uo.languages;
      zo.monaco = Uo, "undefined" !== typeof zo.require && "function" === typeof zo.require.config && zo.require.config( {
        ignoreDuplicateModules: [ "vscode-languageserver-types", "vscode-languageserver-types/main", "vscode-nls", "vscode-nls/vscode-nls", "jsonc-parser", "jsonc-parser/main", "vscode-uri", "vscode-uri/index" ]
      } )
    },
    "9B1q": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "css",
        extensions: [ ".css" ],
        aliases: [ "CSS", "css" ],
        mimetypes: [ "text/css" ],
        loader() {
          return o.Promise.wrap( n.e( 263 ).then( n.bind( null, "v7Iz" ) ) )
        }
      } )
    },
    "9XAT": function ( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "LanguageServiceDefaultsImpl", ( () => {
        return o
      } ) );
      n( "M/lh" );
      const i = monaco.Emitter;
      var o = ( () => {
        function e( e, t ) {
          this._onDidChange = new i, this._languageId = e, this.setDiagnosticsOptions( t )
        }
        return Object.defineProperty( e.prototype, "onDidChange", {
          get() {
            return this._onDidChange.event
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "languageId", {
          get() {
            return this._languageId
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "diagnosticsOptions", {
          get() {
            return this._diagnosticsOptions
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.setDiagnosticsOptions = function ( e ) {
          this._diagnosticsOptions = e || Object.create( null ), this._onDidChange.fire( this )
        }, e;
      } )();
      const r = {
        validate: !0,
        lint: {
          compatibleVendorPrefixes: "ignore",
          vendorPrefix: "warning",
          duplicateProperties: "warning",
          emptyRules: "warning",
          importStatement: "ignore",
          boxModel: "ignore",
          universalSelector: "ignore",
          zeroUnits: "ignore",
          fontFaceProperties: "warning",
          hexColorLength: "error",
          argumentsInColorFunction: "error",
          unknownProperties: "warning",
          ieHack: "ignore",
          unknownVendorSpecificProperties: "ignore",
          propertyIgnoredDueToDisplay: "warning",
          important: "ignore",
          float: "ignore",
          idSelector: "ignore"
        }
      };
      const s = new o( "css", r );
      const a = new o( "scss", r );
      const u = new o( "less", r );

      function l() {
        return monaco.Promise.wrap( n.e( 315 ).then( n.bind( null, "20/g" ) ) )
      }
      monaco.languages.css = {
        cssDefaults: s,
        lessDefaults: u,
        scssDefaults: a
      }, monaco.languages.onLanguage( "less", ( () => {
        l().then( ( e => {
          return e.setupMode( u )
        } ) )
      } ) ), monaco.languages.onLanguage( "scss", ( () => {
        l().then( ( e => {
          return e.setupMode( a )
        } ) )
      } ) ), monaco.languages.onLanguage( "css", ( () => {
        l().then( ( e => {
          return e.setupMode( s )
        } ) )
      } ) )
    },
    "9XeP": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "clipboardService" );
    },
    "9Y+e": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "VMIq" );
      var o = ( () => {
        function e( e, t, n, i, o, r ) {
          this.id = e, this.label = t, this.alias = n, this._precondition = i, this._run = o, this._contextKeyService = r
        }
        return e.prototype.isSupported = function () {
          return this._contextKeyService.contextMatchesRules( this._precondition )
        }, e.prototype.run = function () {
          if ( !this.isSupported() ) return i.b.as( void 0 );
          const e = this._run();
          return e || i.b.as( void 0 )
        }, e;
      } )();
    },
    "A+jI": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return r
      } ) ), n.d( t, "c", ( () => {
        return i
      } ) ), n.d( t, "b", ( () => {
        return s
      } ) );
      var i;
      const o = n( "Cg/j" );
      var r = Object( o.c )( "storageService" );
      !( e => {
        e[ e.GLOBAL = 0 ] = "GLOBAL", e[ e.WORKSPACE = 1 ] = "WORKSPACE"
      } )( i || ( i = {} ) );
      var s = {
        _serviceBrand: void 0,
        store() {},
        remove() {},
        get( e, t, n ) {
          return n
        },
        getInteger( e, t, n ) {
          return n
        },
        getBoolean( e, t, n ) {
          return n
        }
      }
    },
    AKMP( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return u
      } ) ), n.d( t, "a", ( () => {
        return l
      } ) );
      const i = n( "pmY6" ),
        o = n( "EffR" ),
        r = n( "51f4" ),
        s = n( "XSiN" ),
        a = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )();

      function u( e, t ) {
        const n = new s.b( t );
        return n.preventDefault(), {
          leftButton: n.leftButton,
          posx: n.posx,
          posy: n.posy
        }
      }
      var l = ( e => {
        function t() {
          const t = e.call( this ) || this;
          return t.hooks = [], t.mouseMoveEventMerger = null, t.mouseMoveCallback = null, t.onStopCallback = null, t
        }
        return a( t, e ), t.prototype.dispose = function () {
          this.stopMonitoring( !1 ), e.prototype.dispose.call( this )
        }, t.prototype.stopMonitoring = function ( e ) {
          if ( this.isMonitoring() ) {
            this.hooks = Object( i.d )( this.hooks ), this.mouseMoveEventMerger = null, this.mouseMoveCallback = null;
            const t = this.onStopCallback;
            this.onStopCallback = null, e && t()
          }
        }, t.prototype.isMonitoring = function () {
          return this.hooks.length > 0
        }, t.prototype.startMonitoring = function ( e, t, n ) {
          const i = this;
          if ( !this.isMonitoring() ) {
            this.mouseMoveEventMerger = e, this.mouseMoveCallback = t, this.onStopCallback = n;
            for ( var a = r.a.getSameOriginWindowChain(), u = 0; u < a.length; u++ ) this.hooks.push( o.i( a[ u ].window.document, "mousemove", ( e => {
              return i.mouseMoveCallback( e )
            } ), ( ( e, t ) => {
              return i.mouseMoveEventMerger( e, t )
            } ) ) ), this.hooks.push( o.g( a[ u ].window.document, "mouseup", ( e => {
              return i.stopMonitoring( !0 )
            } ) ) );
            if ( r.a.hasDifferentOriginAncestor() ) {
              const l = a[ a.length - 1 ];
              this.hooks.push( o.g( l.window.document, "mouseout", ( e => {
                "html" === new s.b( e ).target.tagName.toLowerCase() && i.stopMonitoring( !0 )
              } ) ) ), this.hooks.push( o.g( l.window.document, "mouseover", ( e => {
                "html" === new s.b( e ).target.tagName.toLowerCase() && i.stopMonitoring( !0 )
              } ) ) ), this.hooks.push( o.g( l.window.document.body, "mouseleave", ( e => {
                i.stopMonitoring( !0 )
              } ) ) )
            }
          }
        }, t;
      } )( i.a )
    },
    AbCa( e, t, n ) {},
    AhDq( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "GotoLineEntry", ( () => {
        return p
      } ) ), n.d( t, "GotoLineAction", ( () => {
        return f
      } ) );
      n( "C9rm" );
      const i = n( "3/fG" );
      const o = n( "Rpxm" );
      const r = n( "ksmt" );
      const s = n( "wQH0" );
      const a = n( "sFUC" );
      const u = n( "rzPn" );
      const l = n( "sswD" );
      const c = n( "cGHE" );
      const d = n( "aokT" );
      const h = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      var p = ( e => {
        function t( t, n, i ) {
          const o = e.call( this ) || this;
          return o.editor = n, o.decorator = i, o._parseResult = o._parseInput( t ), o
        }
        return h( t, e ), t.prototype._parseInput = function ( e ) {
          let t;
          let n;
          const o = e.split( "," ).map( ( e => {
            return parseInt( e, 10 )
          } ) ).filter( ( e => {
            return !isNaN( e )
          } ) );
          t = 0 === o.length ? new c.a( -1, -1 ) : 1 === o.length ? new c.a( o[ 0 ], 1 ) : new c.a( o[ 0 ], o[ 1 ] );
          const r = ( n = Object( a.d )( this.editor ) ? this.editor.getModel() : this.editor.getModel().modified ).validatePosition( t ).equals( t );
          return {
            position: t,
            isValid: r,
            label: r ? t.column && t.column > 1 ? i.a( "gotoLineLabelValidLineAndColumn", "Go to line {0} and character {1}", t.lineNumber, t.column ) : i.a( "gotoLineLabelValidLine", "Go to line {0}", t.lineNumber, t.column ) : t.lineNumber < 1 || t.lineNumber > n.getLineCount() ? i.a( "gotoLineLabelEmptyWithLineLimit", "Type a line number between 1 and {0} to navigate to", n.getLineCount() ) : i.a( "gotoLineLabelEmptyWithLineAndColumnLimit", "Type a character between 1 and {0} to navigate to", n.getLineMaxColumn( t.lineNumber ) )
          }
        }, t.prototype.getLabel = function () {
          return this._parseResult.label
        }, t.prototype.getAriaLabel = function () {
          return i.a( "gotoLineAriaLabel", "Go to line {0}", this._parseResult.label )
        }, t.prototype.run = function ( e, t ) {
          return e === r.a.OPEN ? this.runOpen() : this.runPreview()
        }, t.prototype.runOpen = function () {
          if ( !this._parseResult.isValid ) return !1;
          const e = this.toSelection();
          return this.editor.setSelection( e ), this.editor.revealRangeInCenter( e, 0 ), this.editor.focus(), !0
        }, t.prototype.runPreview = function () {
          if ( !this._parseResult.isValid ) return this.decorator.clearDecorations(), !1;
          const e = this.toSelection();
          return this.editor.revealRangeInCenter( e, 0 ), this.decorator.decorateLine( e, this.editor ), !1
        }, t.prototype.toSelection = function () {
          return new d.a( this._parseResult.position.lineNumber, this._parseResult.position.column, this._parseResult.position.lineNumber, this._parseResult.position.column )
        }, t;
      } )( o.a );

      var f = ( e => {
        function t() {
          return e.call( this, i.a( "gotoLineActionInput", "Type a line number, followed by an optional colon and a character number to navigate to" ), {
            id: "editor.action.gotoLine",
            label: i.a( "GotoLineAction.label", "Go to Line..." ),
            alias: "Go to Line...",
            precondition: null,
            kbOpts: {
              kbExpr: s.a.focus,
              primary: 2085,
              mac: {
                primary: 293
              },
              weight: 100
            }
          } ) || this
        }
        return h( t, e ), t.prototype.run = function ( e, t ) {
          const n = this;
          this._show( this.getController( t ), {
            getModel( e ) {
              return new o.c( [ new p( e, t, n.getController( t ) ) ] )
            },
            getAutoFocus( e ) {
              return {
                autoFocusFirstEntry: e.length > 0
              }
            }
          } )
        }, t;
      } )( u.a );
      Object( l.f )( f )
    },
    ApJL( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "clojure",
        extensions: [ ".clj", ".cljs", ".cljc", ".edn" ],
        aliases: [ "clojure", "Clojure" ],
        loader() {
          return o.Promise.wrap( n.e( 258 ).then( n.bind( null, "AoeA" ) ) )
        }
      } )
    },
    BBpZ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return p
      } ) );
      n( "xNeX" );
      const i = n( "D3Dy" ),
        o = n( "pmY6" ),
        r = n( "MI8n" ),
        s = n( "MNsG" ),
        a = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )();

      function u( e, t ) {
        return !!e[ t ]
      }
      const l = function ( e, t ) {
          this.target = e.target, this.hasTriggerModifier = u( e.event, t.triggerModifier ), this.hasSideBySideModifier = u( e.event, t.triggerSideBySideModifier ), this.isNoneOrSingleMouseDown = i.k || e.event.detail <= 1
        },
        c = function ( e, t ) {
          this.keyCodeIsTriggerKey = e.keyCode === t.triggerKey, this.keyCodeIsSideBySideKey = e.keyCode === t.triggerSideBySideKey, this.hasTriggerModifier = u( e, t.triggerModifier )
        },
        d = ( () => {
          function e( e, t, n, i ) {
            this.triggerKey = e, this.triggerModifier = t, this.triggerSideBySideKey = n, this.triggerSideBySideModifier = i
          }
          return e.prototype.equals = function ( e ) {
            return this.triggerKey === e.triggerKey && this.triggerModifier === e.triggerModifier && this.triggerSideBySideKey === e.triggerSideBySideKey && this.triggerSideBySideModifier === e.triggerSideBySideModifier
          }, e
        } )();

      function h( e ) {
        return "altKey" === e ? s.d ? new d( 57, "metaKey", 6, "altKey" ) : new d( 5, "ctrlKey", 6, "altKey" ) : s.d ? new d( 6, "altKey", 57, "metaKey" ) : new d( 6, "altKey", 5, "ctrlKey" )
      }
      var p = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n._onMouseMoveOrRelevantKeyDown = n._register( new r.a ), n.onMouseMoveOrRelevantKeyDown = n._onMouseMoveOrRelevantKeyDown.event, n._onExecute = n._register( new r.a ), n.onExecute = n._onExecute.event, n._onCancel = n._register( new r.a ), n.onCancel = n._onCancel.event, n._editor = t, n._opts = h( n._editor.getConfiguration().multiCursorModifier ), n.lastMouseMoveEvent = null, n.hasTriggerKeyOnMouseDown = !1, n._register( n._editor.onDidChangeConfiguration( ( e => {
            if ( e.multiCursorModifier ) {
              const t = h( n._editor.getConfiguration().multiCursorModifier );
              if ( n._opts.equals( t ) ) return;
              n._opts = t, n.lastMouseMoveEvent = null, n.hasTriggerKeyOnMouseDown = !1, n._onCancel.fire()
            }
          } ) ) ), n._register( n._editor.onMouseMove( ( e => {
            return n.onEditorMouseMove( new l( e, n._opts ) )
          } ) ) ), n._register( n._editor.onMouseDown( ( e => {
            return n.onEditorMouseDown( new l( e, n._opts ) )
          } ) ) ), n._register( n._editor.onMouseUp( ( e => {
            return n.onEditorMouseUp( new l( e, n._opts ) )
          } ) ) ), n._register( n._editor.onKeyDown( ( e => {
            return n.onEditorKeyDown( new c( e, n._opts ) )
          } ) ) ), n._register( n._editor.onKeyUp( ( e => {
            return n.onEditorKeyUp( new c( e, n._opts ) )
          } ) ) ), n._register( n._editor.onMouseDrag( ( () => {
            return n.resetHandler()
          } ) ) ), n._register( n._editor.onDidChangeCursorSelection( ( e => {
            return n.onDidChangeCursorSelection( e )
          } ) ) ), n._register( n._editor.onDidChangeModel( ( e => {
            return n.resetHandler()
          } ) ) ), n._register( n._editor.onDidChangeModelContent( ( () => {
            return n.resetHandler()
          } ) ) ), n._register( n._editor.onDidScrollChange( ( e => {
            ( e.scrollTopChanged || e.scrollLeftChanged ) && n.resetHandler()
          } ) ) ), n;
        }
        return a( t, e ), t.prototype.onDidChangeCursorSelection = function ( e ) {
          e.selection && e.selection.startColumn !== e.selection.endColumn && this.resetHandler()
        }, t.prototype.onEditorMouseMove = function ( e ) {
          this.lastMouseMoveEvent = e, this._onMouseMoveOrRelevantKeyDown.fire( [ e, null ] )
        }, t.prototype.onEditorMouseDown = function ( e ) {
          this.hasTriggerKeyOnMouseDown = e.hasTriggerModifier
        }, t.prototype.onEditorMouseUp = function ( e ) {
          this.hasTriggerKeyOnMouseDown && this._onExecute.fire( e )
        }, t.prototype.onEditorKeyDown = function ( e ) {
          this.lastMouseMoveEvent && ( e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier ) ? this._onMouseMoveOrRelevantKeyDown.fire( [ this.lastMouseMoveEvent, e ] ) : e.hasTriggerModifier && this._onCancel.fire()
        }, t.prototype.onEditorKeyUp = function ( e ) {
          e.keyCodeIsTriggerKey && this._onCancel.fire()
        }, t.prototype.resetHandler = function () {
          this.lastMouseMoveEvent = null, this.hasTriggerKeyOnMouseDown = !1, this._onCancel.fire()
        }, t
      } )( o.a )
    },
    BEdG( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "xml",
        extensions: [ ".xml", ".dtd", ".ascx", ".csproj", ".config", ".wxi", ".wxl", ".wxs", ".xaml", ".svg", ".svgz", ".opf", ".xsl" ],
        firstLine: "(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",
        aliases: [ "XML", "xml" ],
        mimetypes: [ "text/xml", "application/xml", "application/xaml+xml", "application/xml-dtd" ],
        loader() {
          return o.Promise.wrap( n.e( 313 ).then( n.bind( null, "aH2L" ) ) )
        }
      } )
    },
    BFtn( e, t, n ) {
      "use strict";

      function i( e, t ) {
        for ( var n = e.getCount(), i = e.findTokenIndexAtOffset( t ), r = e.getLanguageId( i ), s = i; s + 1 < n && e.getLanguageId( s + 1 ) === r; ) s++;
        for ( var a = i; a > 0 && e.getLanguageId( a - 1 ) === r; ) a--;
        return new o( e, r, a, s + 1, e.getStartOffset( a ), e.getEndOffset( s ) )
      }
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) );
      var o = ( () => {
        function e( e, t, n, i, o, r ) {
          this._actual = e, this.languageId = t, this._firstTokenIndex = n, this._lastTokenIndex = i, this.firstCharOffset = o, this._lastCharOffset = r
        }
        return e.prototype.getLineContent = function () {
          return this._actual.getLineContent().substring( this.firstCharOffset, this._lastCharOffset )
        }, e.prototype.getTokenCount = function () {
          return this._lastTokenIndex - this._firstTokenIndex
        }, e.prototype.findTokenIndexAtOffset = function ( e ) {
          return this._actual.findTokenIndexAtOffset( e + this.firstCharOffset ) - this._firstTokenIndex
        }, e.prototype.getStandardTokenType = function ( e ) {
          return this._actual.getStandardTokenType( e + this._firstTokenIndex )
        }, e
      } )();

      function r( e ) {
        return 0 !== ( 7 & e )
      }
    },
    BUKB( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "tcl",
        extensions: [ ".tcl" ],
        aliases: [ "tcl", "Tcl", "tcltk", "TclTk", "tcl/tk", "Tcl/Tk" ],
        loader() {
          return o.Promise.wrap( n.e( 310 ).then( n.bind( null, "xT+r" ) ) )
        }
      } )
    },
    BjKj( e, t, n ) {},
    C6rC( e, t, n ) {},
    C9rm( e, t, n ) {},
    CClx( e, t, n ) {},
    CHaL( e, t, n ) {},
    CRAX( e, t, n ) {
      "use strict";
      const i = n( "3/fG" ),
        o = n( "MI8n" ),
        r = n( "ic2d" ),
        s = n( "746U" ),
        a = n( "N0LK" ),
        u = "base.contributions.json";
      const l = new( ( () => {
        function e() {
          this._onDidChangeSchema = new o.a, this.schemasById = {}
        }
        return e.prototype.registerSchema = function ( e, t ) {
          let n;
          this.schemasById[ ( n = e, n.length > 0 && "#" === n.charAt( n.length - 1 ) ? n.substring( 0, n.length - 1 ) : n ) ] = t, this._onDidChangeSchema.fire( e )
        }, e;
      } )() )();
      r.a.add( u, l ), n.d( t, "b", ( () => {
        return d
      } ) ), n.d( t, "a", ( () => {
        return c
      } ) ), n.d( t, "c", ( () => {
        return w
      } ) );
      var c, d = {
        Configuration: "base.contributions.configuration"
      };
      !( e => {
        e[ e.APPLICATION = 1 ] = "APPLICATION", e[ e.WINDOW = 2 ] = "WINDOW", e[ e.RESOURCE = 3 ] = "RESOURCE"
      } )( c || ( c = {} ) );
      const h = {
        properties: {},
        patternProperties: {}
      };
      const p = {
        properties: {},
        patternProperties: {}
      };
      const f = {
        properties: {},
        patternProperties: {}
      };
      const g = {
        properties: {},
        patternProperties: {}
      };
      const m = "vscode://schemas/settings/editor";
      const _ = r.a.as( u );
      const v = ( () => {
        function e() {
          this.overrideIdentifiers = [], this._onDidSchemaChange = new o.a, this._onDidRegisterConfiguration = new o.a, this.configurationContributors = [], this.editorConfigurationSchema = {
            properties: {},
            patternProperties: {},
            additionalProperties: !1,
            errorMessage: "Unknown editor configuration setting"
          }, this.configurationProperties = {}, this.excludedConfigurationProperties = {}, this.computeOverridePropertyPattern(), _.registerSchema( m, this.editorConfigurationSchema )
        }
        return e.prototype.registerConfiguration = function ( e, t ) {
          void 0 === t && ( t = !0 ), this.registerConfigurations( [ e ], [], t )
        }, e.prototype.registerConfigurations = function ( e, t, n ) {
          const i = this;
          void 0 === n && ( n = !0 );
          const o = this.toConfiguration( t );
          o && e.push( o );
          const r = [];
          e.forEach( ( e => {
            r.push.apply( r, i.validateAndRegisterProperties( e, n ) ), i.configurationContributors.push( e ), i.registerJSONConfiguration( e ), i.updateSchemaForOverrideSettingsConfiguration( e )
          } ) ), this._onDidRegisterConfiguration.fire( r )
        }, e.prototype.registerOverrideIdentifiers = function ( e ) {
          let t;
          ( t = this.overrideIdentifiers ).push.apply( t, e ), this.updateOverridePropertyPatternKey()
        }, e.prototype.toConfiguration = e => {
          for ( var t = {
              id: "defaultOverrides",
              title: i.a( "defaultConfigurations.title", "Default Configuration Overrides" ),
              properties: {}
            }, n = 0, o = e; n < o.length; n++ ) {
            const r = o[ n ];
            for ( const s in r.defaults ) {
              const a = r.defaults[ s ];
              w.test( s ) && "object" === typeof a && ( t.properties[ s ] = {
                type: "object",
                default: a,
                description: i.a( "overrideSettings.description", "Configure editor settings to be overridden for {0} language.", s ),
                $ref: m
              } )
            }
          }
          return Object.keys( t.properties ).length ? t : null
        }, e.prototype.validateAndRegisterProperties = function ( e, t, n, i ) {
          void 0 === t && ( t = !0 ), void 0 === n && ( n = c.WINDOW ), void 0 === i && ( i = !1 ), n = s.j( e.scope ) ? n : e.scope, i = e.overridable || i;
          const o = [],
            r = e.properties;
          if ( r )
            for ( const a in r ) {
              let u = void 0;
              if ( t && ( u = L( a ) ) ) console.warn( u ), delete r[ a ];
              else {
                const l = r[ a ],
                  d = l.default;
                s.i( d ) && ( l.default = S( l.type ) ), i && ( l.overridable = !0 ), w.test( a ) ? l.scope = void 0 : l.scope = s.j( l.scope ) ? n : l.scope, !r[ a ].hasOwnProperty( "included" ) || r[ a ].included ? ( this.configurationProperties[ a ] = r[ a ], o.push( a ) ) : ( this.excludedConfigurationProperties[ a ] = r[ a ], delete r[ a ] )
              }
            }
          const h = e.allOf;
          if ( h )
            for ( let p = 0, f = h; p < f.length; p++ ) {
              const g = f[ p ];
              o.push.apply( o, this.validateAndRegisterProperties( g, t, n, i ) )
            }
          return o
        }, e.prototype.getConfigurationProperties = function () {
          return this.configurationProperties
        }, e.prototype.registerJSONConfiguration = function ( e ) {
          ! function e( t ) {
            const n = t.properties;
            if ( n )
              for ( const i in n ) switch ( h.properties[ i ] = n[ i ], n[ i ].scope ) {
                case c.APPLICATION:
                  p.properties[ i ] = n[ i ];
                  break;
                case c.WINDOW:
                  f.properties[ i ] = n[ i ];
                  break;
                case c.RESOURCE:
                  g.properties[ i ] = n[ i ]
              }
            const o = t.allOf;
            o && o.forEach( e )
          }( e ), this._onDidSchemaChange.fire()
        }, e.prototype.updateSchemaForOverrideSettingsConfiguration = function ( e ) {
          e.id !== y && ( this.update( e ), _.registerSchema( m, this.editorConfigurationSchema ) )
        }, e.prototype.updateOverridePropertyPatternKey = function () {
          let e = h.patternProperties[ this.overridePropertyPattern ];
          e || ( e = {
            type: "object",
            description: i.a( "overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language." ),
            errorMessage: "Unknown Identifier. Use language identifiers",
            $ref: m
          } ), delete h.patternProperties[ this.overridePropertyPattern ], delete p.patternProperties[ this.overridePropertyPattern ], delete f.patternProperties[ this.overridePropertyPattern ], delete g.patternProperties[ this.overridePropertyPattern ], this.computeOverridePropertyPattern(), h.patternProperties[ this.overridePropertyPattern ] = e, p.patternProperties[ this.overridePropertyPattern ] = e, f.patternProperties[ this.overridePropertyPattern ] = e, g.patternProperties[ this.overridePropertyPattern ] = e, this._onDidSchemaChange.fire()
        }, e.prototype.update = function ( e ) {
          const t = this,
            n = e.properties;
          if ( n )
            for ( const i in n ) n[ i ].overridable && ( this.editorConfigurationSchema.properties[ i ] = this.getConfigurationProperties()[ i ] );
          const o = e.allOf;
          o && o.forEach( ( e => {
            return t.update( e )
          } ) )
        }, e.prototype.computeOverridePropertyPattern = function () {
          this.overridePropertyPattern = this.overrideIdentifiers.length ? C.replace( "${0}", this.overrideIdentifiers.map( ( e => {
            return a.createRegExp( e, !1 ).source
          } ) ).join( "|" ) ) : b
        }, e;
      } )();
      const y = "override";
      const b = "\\[.*\\]$";
      const C = "\\[(${0})\\]$";
      var w = new RegExp( b );

      function S( e ) {
        switch ( Array.isArray( e ) ? e[ 0 ] : e ) {
          case "boolean":
            return !1;
          case "integer":
          case "number":
            return 0;
          case "string":
            return "";
          case "array":
            return [];
          case "object":
            return {};
          default:
            return null
        }
      }
      const O = new v;

      function L( e ) {
        return w.test( e ) ? i.a( "config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", e ) : void 0 !== O.getConfigurationProperties()[ e ] ? i.a( "config.property.duplicate", "Cannot register '{0}'. This property is already registered.", e ) : null
      }
      r.a.add( d.Configuration, O )
    },
    CdFp( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "abap",
        extensions: [ ".abap" ],
        aliases: [ "abap", "ABAP" ],
        loader() {
          return o.Promise.wrap( n.e( 252 ).then( n.bind( null, "6Xso" ) ) )
        }
      } )
    },
    "Cg/j": function ( e, t, n ) {
      "use strict";
      let i;
      n.d( t, "b", ( () => {
        return i
      } ) ), n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "c", ( () => {
        return s
      } ) ), n.d( t, "d", ( () => {
        return a
      } ) ), ( e => {
        e.serviceIds = new Map, e.DI_TARGET = "$di$target", e.DI_DEPENDENCIES = "$di$dependencies", e.getServiceDependencies = t => {
          return t[ e.DI_DEPENDENCIES ] || []
        }
      } )( i || ( i = {} ) );
      var o = s( "instantiationService" );

      function r( e, t, n, o ) {
        t[ i.DI_TARGET ] === t ? t[ i.DI_DEPENDENCIES ].push( {
          id: e,
          index: n,
          optional: o
        } ) : ( t[ i.DI_DEPENDENCIES ] = [ {
          id: e,
          index: n,
          optional: o
        } ], t[ i.DI_TARGET ] = t )
      }

      function s( e ) {
        if ( i.serviceIds.has( e ) ) return i.serviceIds.get( e );
        const t = function ( e, n, i ) {
          if ( 3 !== arguments.length ) throw new Error( "@IServiceName-decorator can only be used to decorate a parameter" );
          r( t, e, i, !1 )
        };
        return t.toString = () => {
          return e
        }, i.serviceIds.set( e, t ), t;
      }

      function a( e ) {
        return function ( t, n, i ) {
          if ( 3 !== arguments.length ) throw new Error( "@optional-decorator can only be used to decorate a parameter" );
          r( e, t, i, !0 )
        }
      }
    },
    CjOT( e, t, n ) {},
    Comh( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) );
      const i = n( "aokT" );
      const o = n( "cGHE" );
      const r = n( "M1Kb" );
      const s = n( "N0LK" );
      var a = ( () => {
        function e( e, t, n, i, o ) {
          this.value = e, this.selectionStart = t, this.selectionEnd = n, this.selectionStartPosition = i, this.selectionEndPosition = o
        }
        return e.prototype.toString = function () {
          return "[ <" + this.value + ">, selectionStart: " + this.selectionStart + ", selectionEnd: " + this.selectionEnd + "]"
        }, e.readFromTextArea = t => {
          return new e( t.getValue(), t.getSelectionStart(), t.getSelectionEnd(), null, null )
        }, e.prototype.collapseSelection = function () {
          return new e( this.value, this.value.length, this.value.length, null, null )
        }, e.prototype.writeToTextArea = function ( e, t, n ) {
          t.setValue( e, this.value ), n && t.setSelectionRange( e, this.selectionStart, this.selectionEnd )
        }, e.prototype.deduceEditorPosition = function ( e ) {
          if ( e <= this.selectionStart ) {
            var t = this.value.substring( e, this.selectionStart );
            return this._finishDeduceEditorPosition( this.selectionStartPosition, t, -1 )
          }
          if ( e >= this.selectionEnd ) {
            t = this.value.substring( this.selectionEnd, e );
            return this._finishDeduceEditorPosition( this.selectionEndPosition, t, 1 )
          }
          const n = this.value.substring( this.selectionStart, e );
          if ( -1 === n.indexOf( String.fromCharCode( 8230 ) ) ) return this._finishDeduceEditorPosition( this.selectionStartPosition, n, 1 );
          const i = this.value.substring( e, this.selectionEnd );
          return this._finishDeduceEditorPosition( this.selectionEndPosition, i, -1 )
        }, e.prototype._finishDeduceEditorPosition = ( e, t, n ) => {
          for ( var i = 0, o = -1; - 1 !== ( o = t.indexOf( "\n", o + 1 ) ); ) i++;
          return [ e, n * t.length, i ]
        }, e.selectedText = t => {
          return new e( t, 0, t.length, null, null )
        }, e.deduceInput = ( e, t, n, i ) => {
          if ( !e ) return {
            text: "",
            replaceCharCnt: 0
          };
          let o = e.value,
            r = e.selectionStart,
            a = e.selectionEnd,
            u = t.value,
            l = t.selectionStart,
            c = t.selectionEnd;
          i && o.length > 0 && r === a && l === c && !s.startsWith( u, o ) && s.endsWith( u, o ) && ( r = 0, a = 0 );
          const d = o.substring( a ),
            h = u.substring( c ),
            p = s.commonSuffixLength( d, h );
          u = u.substring( 0, u.length - p );
          const f = ( o = o.substring( 0, o.length - p ) ).substring( 0, r ),
            g = u.substring( 0, l ),
            m = s.commonPrefixLength( f, g );
          if ( u = u.substring( m ), o = o.substring( m ), l -= m, r -= m, c -= m, a -= m, n && l === c && o.length > 0 ) {
            let _ = null;
            if ( l === u.length ? s.startsWith( u, o ) && ( _ = u.substring( o.length ) ) : s.endsWith( u, o ) && ( _ = u.substring( 0, u.length - o.length ) ), null !== _ && _.length > 0 && ( /\uFE0F/.test( _ ) || s.containsEmoji( _ ) ) ) return {
              text: _,
              replaceCharCnt: 0
            }
          }
          return l === c ? o === u && 0 === r && a === o.length && l === u.length && -1 === u.indexOf( "\n" ) && s.containsFullWidthCharacter( u ) ? {
            text: "",
            replaceCharCnt: 0
          } : {
            text: u,
            replaceCharCnt: f.length - m
          } : {
            text: u,
            replaceCharCnt: a - r
          }
        }, e.EMPTY = new e( "", 0, 0, null, null ), e;
      } )();

      var u = ( () => {
        function e() {}
        return e._getPageOfLine = t => {
          return Math.floor( ( t - 1 ) / e._LINES_PER_PAGE )
        }, e._getRangeForPage = t => {
          const n = t * e._LINES_PER_PAGE,
            o = n + 1,
            r = n + e._LINES_PER_PAGE;
          return new i.a( o, 1, r + 1, 1 )
        }, e.fromEditorSelection = ( t, n, s, u ) => {
          const l = e._getPageOfLine( s.startLineNumber );
          const c = e._getRangeForPage( l );
          const d = e._getPageOfLine( s.endLineNumber );
          const h = e._getRangeForPage( d );
          const p = c.intersectRanges( new i.a( 1, 1, s.startLineNumber, s.startColumn ) );
          let f = n.getValueInRange( p, r.c.LF );
          const g = n.getLineCount();
          const m = n.getLineMaxColumn( g );
          const _ = h.intersectRanges( new i.a( s.endLineNumber, s.endColumn, g, m ) );
          let v = n.getValueInRange( _, r.c.LF );
          let y = null;
          if ( l === d || l + 1 === d ) y = n.getValueInRange( s, r.c.LF );
          else {
            const b = c.intersectRanges( s ),
              C = h.intersectRanges( s );
            y = n.getValueInRange( b, r.c.LF ) + String.fromCharCode( 8230 ) + n.getValueInRange( C, r.c.LF )
          }
          if ( u ) {
            f.length > 500 && ( f = f.substring( f.length - 500, f.length ) ), v.length > 500 && ( v = v.substring( 0, 500 ) ), y.length > 1e3 && ( y = y.substring( 0, 500 ) + String.fromCharCode( 8230 ) + y.substring( y.length - 500, y.length ) )
          }
          return new a( f + y + v, f.length, f.length + y.length, new o.a( s.startLineNumber, s.startColumn ), new o.a( s.endLineNumber, s.endColumn ) )
        }, e._LINES_PER_PAGE = 10, e;
      } )();
    },
    CuPc( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "apl",
        extensions: [ ".apl" ],
        aliases: [ "apl", "APL" ],
        loader() {
          return o.Promise.wrap( n.e( 254 ).then( n.bind( null, "VfaY" ) ) )
        }
      } )
    },
    CxEt( e, t, n ) {
      "use strict";
      n.r( t );
      let i;
      const o = n( "sswD" );
      const r = n( "pmY6" );
      const s = n( "N0LK" );
      const a = n( "VMIq" );
      const u = n( "x/UI" );
      const l = n( "wQH0" );
      const c = n( "NR8r" );
      const d = n( "3/fG" );
      const h = n( "nnTU" );
      const p = n( "T8No" );
      const f = n( "Uzvx" );
      const g = n( "bexQ" );
      const m = n( "tADe" );
      const _ = n( "tTk5" );
      const v = n( "X+cX" );
      const y = n( "MI8n" );
      const b = n( "aokT" );
      const C = n( "twdY" );
      const w = n( "6OMU" );
      const S = n( "JQT/" );
      const O = n( "/cxE" );
      const L = n( "bY76" );
      const x = n( "G2kB" );
      const N = ( () => {
        function e( e ) {
          this.value = e
        }
        return e.prototype.contains = function ( t ) {
          return this.value === t || Object( s.startsWith )( t, this.value + e.sep )
        }, e.sep = ".", e.Empty = new e( "" ), e.Refactor = new e( "refactor" ), e.Source = new e( "source" ), e.SourceOrganizeImports = new e( "source.organizeImports" ), e
      } )();

      function E( e, t, n, i ) {
        void 0 === i && ( i = S.a.None );
        const o = {
            only: n && n.filter && n.filter.kind ? n.filter.kind.value : void 0,
            trigger: n && "manual" === n.type ? C.b.Manual : C.b.Automatic
          },
          r = C.a.all( e ).map( ( i => {
            return Object( v.h )( ( n => {
              return i.provideCodeActions( e, t, o, n )
            } ) ).then( ( e => {
              return Array.isArray( e ) ? e.filter( ( e => {
                return ( ( e, t ) => {
                  if ( !t ) return !1;
                  if ( e && e.kind && ( !t.kind || !e.kind.contains( t.kind ) ) ) return !1;
                  if ( t.kind && N.Source.contains( t.kind ) && ( !e || !e.includeSourceActions ) ) return !1;
                  return !0
                } )( n && n.filter, e );
              } ) ) : [];
            } ), ( e => {
              if ( Object( O.d )( e ) ) throw e;
              return Object( O.f )( e ), []
            } ) );
          } ) );
        return Promise.all( r ).then( w.i ).then( ( e => {
          return Object( w.l )( e, k )
        } ) );
      }

      function k( e, t ) {
        const n = !Object( w.k )( e.diagnostics ),
          i = !Object( w.k )( t.diagnostics );
        return n ? i ? e.diagnostics[ 0 ].message.localeCompare( t.diagnostics[ 0 ].message ) : -1 : i ? 1 : 0
      }!( e => {
        e[ e.IfSingle = 1 ] = "IfSingle", e[ e.First = 2 ] = "First", e[ e.Never = 3 ] = "Never"
      } )( i || ( i = {} ) ), Object( o.j )( "_executeCodeActionProvider", ( ( e, t ) => {
        const n = t.resource,
          i = t.range;
        if ( !( n instanceof L.a ) || !b.a.isIRange( i ) ) throw Object( O.b )();
        const o = e.get( x.a ).getModel( n );
        if ( !o ) throw Object( O.b )();
        return E( o, o.validateRange( i ), {
          type: "manual",
          filter: {
            includeSourceActions: !0
          }
        } )
      } ) );
      const I = new p.f( "supportedCodeAction", "" ),
        D = ( () => {
          function e( e, t, n, i, o ) {
            void 0 === i && ( i = 250 );
            const r = this;
            this._editor = e, this._markerService = t, this._signalChange = n, this._progressService = o, this._disposables = [], this._disposables.push( Object( y.h )( this._markerService.onMarkerChanged, ( ( e, t ) => {
              return e ? e.concat( t ) : t
            } ), i / 2 )( ( e => {
              return r._onMarkerChanges( e )
            } ) ), Object( y.h )( this._editor.onDidChangeCursorPosition, ( ( e, t ) => {
              return t
            } ), i )( ( e => {
              return r._onCursorChange()
            } ) ) )
          }
          return e.prototype.dispose = function () {
            this._disposables = Object( r.d )( this._disposables )
          }, e.prototype.trigger = function ( e ) {
            const t = this._getRangeOfSelectionUnlessWhitespaceEnclosed( e );
            return this._createEventAndSignalChange( e, t )
          }, e.prototype._onMarkerChanges = function ( e ) {
            for ( let t = this._editor.getModel().uri, n = 0, i = e; n < i.length; n++ ) {
              if ( i[ n ].toString() === t.toString() ) return void this.trigger( {
                type: "auto"
              } )
            }
          }, e.prototype._onCursorChange = function () {
            this.trigger( {
              type: "auto"
            } )
          }, e.prototype._getRangeOfMarker = function ( e ) {
            for ( let t = this._editor.getModel(), n = 0, i = this._markerService.read( {
                resource: t.uri
              } ); n < i.length; n++ ) {
              const o = i[ n ];
              if ( b.a.intersectRanges( o, e ) ) return b.a.lift( o )
            }
          }, e.prototype._getRangeOfSelectionUnlessWhitespaceEnclosed = function ( e ) {
            const t = this._editor.getModel(),
              n = this._editor.getSelection();
            if ( n.isEmpty() && ( !e.filter || !e.filter.includeSourceActions ) ) {
              const i = n.getPosition(),
                o = i.lineNumber,
                r = i.column,
                s = t.getLineContent( o );
              if ( 0 === s.length ) return;
              if ( 1 === r ) {
                if ( /\s/.test( s[ 0 ] ) ) return
              } else if ( r === t.getLineMaxColumn( o ) ) {
                if ( /\s/.test( s[ s.length - 1 ] ) ) return
              } else if ( /\s/.test( s[ r - 2 ] ) && /\s/.test( s[ r - 1 ] ) ) return
            }
            return n
          }, e.prototype._createEventAndSignalChange = function ( e, t ) {
            if ( t ) {
              const n = this._editor.getModel(),
                i = this._getRangeOfMarker( t ),
                o = i ? i.getStartPosition() : t.getStartPosition(),
                r = Object( v.i )( ( i => {
                  return E( n, t, e, i )
                } ) );
              return this._progressService && "manual" === e.type && this._progressService.showWhile( a.b.wrap( r ), 250 ), this._signalChange( {
                trigger: e,
                rangeOrSelection: t,
                position: o,
                actions: r
              } ), r
            }
            return this._signalChange( {
              trigger: e,
              rangeOrSelection: void 0,
              position: void 0,
              actions: void 0
            } ), a.b.as( void 0 )
          }, e;
        } )(),
        M = ( () => {
          function e( e, t, n, i ) {
            const o = this;
            this._progressService = i, this._onDidChangeFixes = new y.a, this._disposables = [], this._editor = e, this._markerService = t, this._supportedCodeActions = I.bindTo( n ), this._disposables.push( this._editor.onDidChangeModel( ( () => {
              return o._update()
            } ) ) ), this._disposables.push( this._editor.onDidChangeModelLanguage( ( () => {
              return o._update()
            } ) ) ), this._disposables.push( C.a.onDidChange( this._update, this ) ), this._update()
          }
          return e.prototype.dispose = function () {
            this._disposables = Object( r.d )( this._disposables ), Object( r.d )( this._codeActionOracle )
          }, Object.defineProperty( e.prototype, "onDidChangeFixes", {
            get() {
              return this._onDidChangeFixes.event
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype._update = function () {
            const e = this;
            if ( this._codeActionOracle && ( this._codeActionOracle.dispose(), this._codeActionOracle = void 0, this._onDidChangeFixes.fire( void 0 ) ), this._editor.getModel() && C.a.has( this._editor.getModel() ) && !this._editor.getConfiguration().readOnly ) {
              for ( var t = [], n = 0, i = C.a.all( this._editor.getModel() ); n < i.length; n++ ) {
                const o = i[ n ];
                Array.isArray( o.providedCodeActionKinds ) && t.push.apply( t, o.providedCodeActionKinds )
              }
              this._supportedCodeActions.set( t.join( " " ) ), this._codeActionOracle = new D( this._editor, this._markerService, ( t => {
                return e._onDidChangeFixes.fire( t )
              } ), void 0, this._progressService ), this._codeActionOracle.trigger( {
                type: "auto"
              } )
            } else this._supportedCodeActions.reset()
          }, e.prototype.trigger = function ( e ) {
            return this._codeActionOracle ? this._codeActionOracle.trigger( e ) : a.b.as( void 0 )
          }, e;
        } )(),
        T = n( "EffR" ),
        R = n( "8HAY" ),
        P = n( "cGHE" ),
        A = ( () => {
          function e( e, t, n ) {
            this._editor = e, this._contextMenuService = t, this._onApplyCodeAction = n, this._onDidExecuteCodeAction = new y.a, this.onDidExecuteCodeAction = this._onDidExecuteCodeAction.event
          }
          return e.prototype.show = function ( e, t ) {
            const n = this,
              i = e.then( ( e => {
                return e.map( ( e => {
                  return new R.a( e.command ? e.command.id : e.title, e.title, void 0, !0, ( () => {
                    return Object( v.g )( n._onApplyCodeAction( e ), ( () => {
                      return n._onDidExecuteCodeAction.fire( void 0 )
                    } ) );
                  } ) );
                } ) );
              } ) ).then( ( e => {
                return n._editor.getDomNode() ? e : a.b.wrapError( Object( O.a )() )
              } ) );
            this._contextMenuService.showContextMenu( {
              getAnchor() {
                return P.a.isIPosition( t ) && ( t = n._toCoords( t ) ), t
              },
              getActions() {
                return a.b.wrap( i )
              },
              onHide() {
                n._visible = !1, n._editor.focus()
              },
              autoSelectFirstItem: !0
            } )
          }, Object.defineProperty( e.prototype, "isVisible", {
            get() {
              return this._visible
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype._toCoords = function ( e ) {
            this._editor.revealPosition( e, 1 ), this._editor.render();
            const t = this._editor.getScrolledVisiblePosition( this._editor.getPosition() ),
              n = Object( T.u )( this._editor.getDomNode() );
            return {
              x: n.left + t.left,
              y: n.top + t.top + t.height
            }
          }, e;
        } )(),
        F = n( "AKMP" ),
        W = ( n( "MNXI" ), n( "sFUC" ) ),
        j = n( "tX9W" ),
        V = ( () => {
          function e( e ) {
            const t = this;
            this._disposables = [], this._onClick = new y.a, this.onClick = this._onClick.event, this._futureFixes = new S.b, this._domNode = document.createElement( "div" ), this._domNode.className = "lightbulb-glyph", this._editor = e, this._editor.addContentWidget( this ), this._disposables.push( this._editor.onDidChangeModel( ( e => {
              return t._futureFixes.cancel()
            } ) ) ), this._disposables.push( this._editor.onDidChangeModelLanguage( ( e => {
              return t._futureFixes.cancel()
            } ) ) ), this._disposables.push( this._editor.onDidChangeModelContent( ( e => {
              t._model && t.model.position.lineNumber >= t._editor.getModel().getLineCount() && t._futureFixes.cancel()
            } ) ) ), this._disposables.push( T.j( this._domNode, "click", ( e => {
              t._editor.focus();
              const n = T.u( t._domNode );
              const i = n.top;
              const o = n.height;
              const r = t._editor.getConfiguration().lineHeight;
              let s = Math.floor( r / 3 );
              t._position && t._position.position.lineNumber < t._model.position.lineNumber && ( s += r ), t._onClick.fire( {
                x: e.posx,
                y: i + o + s
              } )
            } ) ) ), this._disposables.push( T.g( this._domNode, "mouseenter", ( e => {
              if ( 1 === ( 1 & e.buttons ) ) {
                t.hide();
                const n = new F.a;
                n.startMonitoring( F.b, ( () => {} ), ( () => {
                  n.dispose()
                } ) )
              }
            } ) ) ), this._disposables.push( this._editor.onDidChangeConfiguration( ( e => {
              e.contribInfo && !t._editor.getConfiguration().contribInfo.lightbulbEnabled && t.hide()
            } ) ) )
          }
          return e.prototype.dispose = function () {
            Object( r.d )( this._disposables ), this._editor.removeContentWidget( this )
          }, e.prototype.getId = () => {
            return "LightBulbWidget"
          }, e.prototype.getDomNode = function () {
            return this._domNode
          }, e.prototype.getPosition = function () {
            return this._position
          }, Object.defineProperty( e.prototype, "model", {
            get() {
              return this._model
            },
            set( e ) {
              const t = this;
              !this._position || e.position && this._position.position.lineNumber === e.position.lineNumber ? this._futureFixes && this._futureFixes.cancel() : this.hide(), this._futureFixes = new S.b;
              const n = this._futureFixes.token;
              this._model = e;
              const i = this._model.rangeOrSelection;
              this._model.actions.then( ( e => {
                !n.isCancellationRequested && e && e.length > 0 ? i.isEmpty() && e.every( ( e => {
                  return e.kind && N.Refactor.contains( e.kind )
                } ) ) ? t.hide() : t._show() : t.hide()
              } ) ).catch( ( e => {
                t.hide()
              } ) )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "title", {
            get() {
              return this._domNode.title
            },
            set( e ) {
              this._domNode.title = e
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype._show = function () {
            const t = this._editor.getConfiguration();
            if ( t.contribInfo.lightbulbEnabled ) {
              const n = this._model.position.lineNumber,
                i = this._editor.getModel();
              if ( i ) {
                const o = i.getOptions().tabSize;
                const r = i.getLineContent( n );
                const s = j.b.computeIndentLevel( r, o );
                let a = n;
                t.fontInfo.spaceWidth * s > 22 || ( n > 1 ? a -= 1 : a += 1 ), this._position = {
                  position: {
                    lineNumber: a,
                    column: 1
                  },
                  preference: e._posPref
                }, this._editor.layoutContentWidget( this )
              }
            }
          }, e.prototype.hide = function () {
            this._position = null, this._model = null, this._futureFixes.cancel(), this._editor.layoutContentWidget( this )
          }, e._posPref = [ W.a.EXACT ], e;
        } )(),
        B = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        H = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        z = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        U = ( e, t, n, i ) => {
          return new( n || ( n = Promise ) )( ( ( o, r ) => {
            function s( e ) {
              try {
                u( i.next( e ) )
              } catch ( t ) {
                r( t )
              }
            }

            function a( e ) {
              try {
                u( i.throw( e ) )
              } catch ( t ) {
                r( t )
              }
            }

            function u( e ) {
              e.done ? o( e.value ) : new n( ( t => {
                t( e.value )
              } ) ).then( s, a )
            }
            u( ( i = i.apply( e, t || [] ) ).next() )
          } ) );
        },
        K = ( e, t ) => {
          let n, i, o, r, s = {
            label: 0,
            sent() {
              if ( 1 & o[ 0 ] ) throw o[ 1 ];
              return o[ 1 ]
            },
            trys: [],
            ops: []
          };
          return r = {
            next: a( 0 ),
            throw: a( 1 ),
            return: a( 2 )
          }, "function" === typeof Symbol && ( r[ Symbol.iterator ] = function () {
            return this
          } ), r;

          function a( r ) {
            return a => {
              return ( r => {
                if ( n ) throw new TypeError( "Generator is already executing." );
                for ( ; s; ) try {
                  if ( n = 1, i && ( o = 2 & r[ 0 ] ? i.return : r[ 0 ] ? i.throw || ( ( o = i.return ) && o.call( i ), 0 ) : i.next ) && !( o = o.call( i, r[ 1 ] ) ).done ) return o;
                  switch ( i = 0, o && ( r = [ 2 & r[ 0 ], o.value ] ), r[ 0 ] ) {
                    case 0:
                    case 1:
                      o = r;
                      break;
                    case 4:
                      return s.label++, {
                        value: r[ 1 ],
                        done: !1
                      };
                    case 5:
                      s.label++, i = r[ 1 ], r = [ 0 ];
                      continue;
                    case 7:
                      r = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if ( !( o = ( o = s.trys ).length > 0 && o[ o.length - 1 ] ) && ( 6 === r[ 0 ] || 2 === r[ 0 ] ) ) {
                        s = 0;
                        continue
                      }
                      if ( 3 === r[ 0 ] && ( !o || r[ 1 ] > o[ 0 ] && r[ 1 ] < o[ 3 ] ) ) {
                        s.label = r[ 1 ];
                        break
                      }
                      if ( 6 === r[ 0 ] && s.label < o[ 1 ] ) {
                        s.label = o[ 1 ], o = r;
                        break
                      }
                      if ( o && s.label < o[ 2 ] ) {
                        s.label = o[ 2 ], s.ops.push( r );
                        break
                      }
                      o[ 2 ] && s.ops.pop(), s.trys.pop();
                      continue
                  }
                  r = t.call( e, s )
                } catch ( a ) {
                  r = [ 6, a ], i = 0
                } finally {
                  n = o = 0
                }
                if ( 5 & r[ 0 ] ) throw r[ 1 ];
                return {
                  value: r[ 0 ] ? r[ 1 ] : void 0,
                  done: !0
                }
              } )( [ r, a ] );
            };
          }
        };

      function q( e ) {
        return p.d.regex( I.keys()[ 0 ], new RegExp( "(\\s|^)" + Object( s.escapeRegExpCharacters )( e.value ) + "\\b" ) )
      }
      const G = ( () => {
        function e( e, t, n, i, o, r, s, a ) {
          const u = this;
          this._commandService = r, this._keybindingService = s, this._bulkEditService = a, this._disposables = [], this._editor = e, this._model = new M( this._editor, t, n, i ), this._codeActionContextMenu = new A( e, o, ( e => {
            return u._onApplyCodeAction( e )
          } ) ), this._lightBulbWidget = new V( e ), this._updateLightBulbTitle(), this._disposables.push( this._codeActionContextMenu.onDidExecuteCodeAction( ( e => {
            return u._model.trigger( {
              type: "auto",
              filter: {}
            } )
          } ) ), this._lightBulbWidget.onClick( this._handleLightBulbSelect, this ), this._model.onDidChangeFixes( ( e => {
            return u._onCodeActionsEvent( e )
          } ) ), this._keybindingService.onDidUpdateKeybindings( this._updateLightBulbTitle, this ) )
        }
        return e.get = t => {
          return t.getContribution( e.ID )
        }, e.prototype.dispose = function () {
          this._model.dispose(), Object( r.d )( this._disposables )
        }, e.prototype._onCodeActionsEvent = function ( e ) {
          const t = this;
          this._activeRequest && ( this._activeRequest.cancel(), this._activeRequest = void 0 ), e && e.actions && ( this._activeRequest = e.actions ), e && e.actions && e.trigger.filter && e.trigger.filter.kind ? e.actions.then( ( n => {
            e.trigger.autoApply === i.First || e.trigger.autoApply === i.IfSingle && 1 === n.length ? t._onApplyCodeAction( n[ 0 ] ) : t._codeActionContextMenu.show( e.actions, e.position )
          } ) ).catch( O.e ) : e && "manual" === e.trigger.type ? this._codeActionContextMenu.show( e.actions, e.position ) : e && e.actions ? this._codeActionContextMenu.isVisible ? this._codeActionContextMenu.show( e.actions, e.position ) : this._lightBulbWidget.model = e : this._lightBulbWidget.hide()
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype._handleLightBulbSelect = function ( e ) {
          this._lightBulbWidget.model.actions && this._codeActionContextMenu.show( this._lightBulbWidget.model.actions, e )
        }, e.prototype.triggerFromEditorSelection = function ( e, t ) {
          return this._model.trigger( {
            type: "manual",
            filter: e,
            autoApply: t
          } )
        }, e.prototype._updateLightBulbTitle = function () {
          let e;
          const t = this._keybindingService.lookupKeybinding( X.Id );
          e = t ? d.a( "quickFixWithKb", "Show Fixes ({0})", t.getLabel() ) : d.a( "quickFix", "Show Fixes" ), this._lightBulbWidget.title = e
        }, e.prototype._onApplyCodeAction = function ( e ) {
          return a.b.wrap( function ( e, t, n, i ) {
            return U( this, void 0, void 0, ( function () {
              return K( this, ( function ( o ) {
                switch ( o.label ) {
                  case 0:
                    return e.edit ? [ 4, t.apply( e.edit, {
                      editor: i
                    } ) ] : [ 3, 2 ];
                  case 1:
                    o.sent(), o.label = 2;
                  case 2:
                    return e.command ? [ 4, n.executeCommand.apply( n, [ e.command.id ].concat( e.command.arguments ) ) ] : [ 3, 4 ];
                  case 3:
                    o.sent(), o.label = 4;
                  case 4:
                    return [ 2 ]
                }
              } ) )
            } ) )
          }( e, this._bulkEditService, this._commandService, this._editor ) )
        }, e.ID = "editor.contrib.quickFixController", e = H( [ z( 1, m.a ), z( 2, p.e ), z( 3, _.a ), z( 4, f.a ), z( 5, h.b ), z( 6, g.a ), z( 7, u.a ) ], e );
      } )();

      function Y( e, t, n, i ) {
        const o = G.get( e );
        if ( o ) {
          const r = e.getPosition();
          o.triggerFromEditorSelection( n, i ).then( ( n => {
            n && n.length || c.a.get( e ).showMessage( t, r )
          } ) )
        }
      }
      var X = ( e => {
        function t() {
          return e.call( this, {
            id: t.Id,
            label: d.a( "quickfix.trigger.label", "Quick Fix..." ),
            alias: "Quick Fix",
            precondition: p.d.and( l.a.writable, l.a.hasCodeActionsProvider ),
            kbOpts: {
              kbExpr: l.a.editorTextFocus,
              primary: 2132,
              weight: 100
            }
          } ) || this
        }
        return B( t, e ), t.prototype.run = ( e, t ) => {
          return Y( t, d.a( "editor.action.quickFix.noneMessage", "No code actions available" ) )
        }, t.Id = "editor.action.quickFix", t;
      } )( o.b );
      const $ = ( () => {
        function e( e, t ) {
          this.kind = e, this.apply = t
        }
        return e.fromUser = t => {
          return t && "object" === typeof t ? new e( e.getKindFromUser( t ), e.getApplyFromUser( t ) ) : new e( N.Empty, i.IfSingle )
        }, e.getApplyFromUser = e => {
          switch ( "string" === typeof e.apply ? e.apply.toLowerCase() : "" ) {
            case "first":
              return i.First;
            case "never":
              return i.Never;
            case "ifsingle":
            default:
              return i.IfSingle
          }
        }, e.getKindFromUser = e => {
          return "string" === typeof e.kind ? new N( e.kind ) : N.Empty
        }, e;
      } )();
      const Z = ( e => {
        function t() {
          return e.call( this, {
            id: t.Id,
            precondition: p.d.and( l.a.writable, l.a.hasCodeActionsProvider )
          } ) || this
        }
        return B( t, e ), t.prototype.runEditorCommand = ( e, t, n ) => {
          const i = $.fromUser( n );
          return Y( t, d.a( "editor.action.quickFix.noneMessage", "No code actions available" ), {
            kind: i.kind,
            includeSourceActions: !0
          }, i.apply )
        }, t.Id = "editor.action.codeAction", t;
      } )( o.c );
      const Q = ( e => {
        function t() {
          return e.call( this, {
            id: t.Id,
            label: d.a( "refactor.label", "Refactor..." ),
            alias: "Refactor",
            precondition: p.d.and( l.a.writable, l.a.hasCodeActionsProvider ),
            kbOpts: {
              kbExpr: l.a.editorTextFocus,
              primary: 3120,
              mac: {
                primary: 1328
              },
              weight: 100
            },
            menuOpts: {
              group: "1_modification",
              order: 2,
              when: p.d.and( l.a.writable, q( N.Refactor ) )
            }
          } ) || this
        }
        return B( t, e ), t.prototype.run = ( e, t ) => {
          return Y( t, d.a( "editor.action.refactor.noneMessage", "No refactorings available" ), {
            kind: N.Refactor
          }, i.Never )
        }, t.Id = "editor.action.refactor", t;
      } )( o.b );
      const J = ( e => {
        function t() {
          return e.call( this, {
            id: t.Id,
            label: d.a( "source.label", "Source Action..." ),
            alias: "Source Action",
            precondition: p.d.and( l.a.writable, l.a.hasCodeActionsProvider ),
            menuOpts: {
              group: "1_modification",
              order: 2.1,
              when: p.d.and( l.a.writable, q( N.Source ) )
            }
          } ) || this
        }
        return B( t, e ), t.prototype.run = ( e, t ) => {
          return Y( t, d.a( "editor.action.source.noneMessage", "No source actions available" ), {
            kind: N.Source,
            includeSourceActions: !0
          }, i.Never )
        }, t.Id = "editor.action.sourceAction", t;
      } )( o.b );
      const ee = ( e => {
        function t() {
          return e.call( this, {
            id: t.Id,
            label: d.a( "organizeImports.label", "Organize Imports" ),
            alias: "Organize Imports",
            precondition: p.d.and( l.a.writable, q( N.SourceOrganizeImports ) ),
            kbOpts: {
              kbExpr: l.a.editorTextFocus,
              primary: 1581,
              weight: 100
            }
          } ) || this
        }
        return B( t, e ), t.prototype.run = ( e, t ) => {
          return Y( t, d.a( "editor.action.organize.noneMessage", "No organize imports action available" ), {
            kind: N.SourceOrganizeImports,
            includeSourceActions: !0
          }, i.IfSingle )
        }, t.Id = "editor.action.organizeImports", t;
      } )( o.b );
      Object( o.h )( G ), Object( o.f )( X ), Object( o.f )( Q ), Object( o.f )( J ), Object( o.f )( ee ), Object( o.g )( new Z )
    },
    D3Dy( e, t, n ) {
      "use strict";
      n.d( t, "d", ( () => {
        return r
      } ) ), n.d( t, "c", ( () => {
        return s
      } ) ), n.d( t, "p", ( () => {
        return a
      } ) ), n.d( t, "b", ( () => {
        return u
      } ) ), n.d( t, "a", ( () => {
        return l
      } ) ), n.d( t, "o", ( () => {
        return c
      } ) ), n.d( t, "k", ( () => {
        return h
      } ) ), n.d( t, "g", ( () => {
        return p
      } ) ), n.d( t, "h", ( () => {
        return f
      } ) ), n.d( t, "j", ( () => {
        return g
      } ) ), n.d( t, "n", ( () => {
        return m
      } ) ), n.d( t, "f", ( () => {
        return _
      } ) ), n.d( t, "m", ( () => {
        return v
      } ) ), n.d( t, "l", ( () => {
        return y
      } ) ), n.d( t, "i", ( () => {
        return b
      } ) ), n.d( t, "e", ( () => {
        return C
      } ) );
      const i = n( "MI8n" ),
        o = ( () => {
          function e() {
            this._zoomLevel = 0, this._lastZoomLevelChangeTime = 0, this._onDidChangeZoomLevel = new i.a, this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event, this._accessibilitySupport = 0, this._onDidChangeAccessibilitySupport = new i.a, this.onDidChangeAccessibilitySupport = this._onDidChangeAccessibilitySupport.event
          }
          return e.prototype.getZoomLevel = function () {
            return this._zoomLevel
          }, e.prototype.getTimeSinceLastZoomLevelChanged = function () {
            return Date.now() - this._lastZoomLevelChangeTime
          }, e.prototype.getPixelRatio = () => {
            const e = document.createElement( "canvas" ).getContext( "2d" );
            return ( window.devicePixelRatio || 1 ) / ( e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1 )
          }, e.prototype.getAccessibilitySupport = function () {
            return this._accessibilitySupport
          }, e.INSTANCE = new e, e;
        } )();

      function r() {
        return o.INSTANCE.getZoomLevel()
      }

      function s() {
        return o.INSTANCE.getTimeSinceLastZoomLevelChanged()
      }

      function a( e ) {
        return o.INSTANCE.onDidChangeZoomLevel( e )
      }

      function u() {
        return o.INSTANCE.getPixelRatio()
      }

      function l() {
        return o.INSTANCE.getAccessibilitySupport()
      }

      function c( e ) {
        return o.INSTANCE.onDidChangeAccessibilitySupport( e )
      }
      const d = navigator.userAgent;
      var h = d.indexOf( "Trident" ) >= 0;
      var p = d.indexOf( "Edge/" ) >= 0;
      var f = h || p;
      var g = d.indexOf( "Firefox" ) >= 0;
      var m = d.indexOf( "AppleWebKit" ) >= 0;
      var _ = d.indexOf( "Chrome" ) >= 0;
      var v = -1 === d.indexOf( "Chrome" ) && d.indexOf( "Safari" ) >= 0;
      var y = d.indexOf( "iPad" ) >= 0;
      var b = p && d.indexOf( "WebView/" ) >= 0;

      function C() {
        if ( h ) return !1;
        if ( p ) {
          const e = d.indexOf( "Edge/" ),
            t = parseInt( d.substring( e + 5, d.indexOf( ".", e ) ), 10 );
          if ( !t || t >= 12 && t <= 16 ) return !1
        }
        return !0
      }
    },
    DTDp( e, t, n ) {},
    DtFZ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "crystal",
        extensions: [ ".cr" ],
        aliases: [ "Crystal", "crystal" ],
        loader() {
          return o.Promise.wrap( n.e( 260 ).then( n.bind( null, "xD+k" ) ) )
        }
      } )
    },
    Dvnd( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "kotlin",
        extensions: [ ".kt" ],
        aliases: [ "Kotlin", "kotlin" ],
        mimetypes: [ "text/x-kotlin-source", "text/x-kotlin" ],
        loader() {
          return o.Promise.wrap( n.e( 274 ).then( n.bind( null, "y0OK" ) ) )
        }
      } )
    },
    "E+ie": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "csp",
        extensions: [],
        aliases: [ "CSP", "csp" ],
        loader() {
          return o.Promise.wrap( n.e( 262 ).then( n.bind( null, "p+q7" ) ) )
        }
      } )
    },
    E4kL( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "yaml",
        extensions: [ ".yaml", ".yml" ],
        aliases: [ "YAML", "yaml", "YML", "yml" ],
        mimetypes: [ "application/x-yaml" ],
        loader() {
          return o.Promise.wrap( n.e( 314 ).then( n.bind( null, "EaLm" ) ) )
        }
      } )
    },
    EIAu( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return s
      } ) ), n.d( t, "a", ( () => {
        return g
      } ) );
      const i = n( "N0LK" );
      const o = n( "aokT" );
      const r = function ( e, t, n, i, o ) {
        this.languageIdentifier = e, this.open = t, this.close = n, this.forwardRegex = i, this.reversedRegex = o
      };
      var s = function ( e, t ) {
        const n = this;
        this.brackets = t.map( ( t => {
          return new r( e, t[ 0 ], t[ 1 ], u( {
            open: t[ 0 ],
            close: t[ 1 ]
          } ), l( {
            open: t[ 0 ],
            close: t[ 1 ]
          } ) )
        } ) ), this.forwardRegex = c( this.brackets ), this.reversedRegex = d( this.brackets ), this.textIsBracket = {}, this.textIsOpenBracket = {};
        let i = 0;
        this.brackets.forEach( ( e => {
          n.textIsBracket[ e.open.toLowerCase() ] = e, n.textIsBracket[ e.close.toLowerCase() ] = e, n.textIsOpenBracket[ e.open.toLowerCase() ] = !0, n.textIsOpenBracket[ e.close.toLowerCase() ] = !1, i = Math.max( i, e.open.length ), i = Math.max( i, e.close.length )
        } ) ), this.maxBracketLength = i
      };

      function a( e, t ) {
        const n = {};
        return i => {
          const o = e( i );
          return n.hasOwnProperty( o ) || ( n[ o ] = t( i ) ), n[ o ]
        };
      }
      var u = a( ( e => {
          return e.open + ";" + e.close
        } ), ( e => {
          return p( [ e.open, e.close ] )
        } ) ),
        l = a( ( e => {
          return e.open + ";" + e.close
        } ), ( e => {
          return p( [ f( e.open ), f( e.close ) ] )
        } ) ),
        c = a( ( e => {
          return e.map( ( e => {
            return e.open + ";" + e.close
          } ) ).join( ";" );
        } ), ( e => {
          const t = [];
          return e.forEach( ( e => {
            t.push( e.open ), t.push( e.close )
          } ) ), p( t );
        } ) ),
        d = a( ( e => {
          return e.map( ( e => {
            return e.open + ";" + e.close
          } ) ).join( ";" );
        } ), ( e => {
          const t = [];
          return e.forEach( ( e => {
            t.push( f( e.open ) ), t.push( f( e.close ) )
          } ) ), p( t );
        } ) );

      function h( e ) {
        const t = /^[\w]+$/.test( e );
        return e = i.escapeRegExpCharacters( e ), t ? "\\b" + e + "\\b" : e
      }

      function p( e ) {
        const t = "(" + e.map( h ).join( ")|(" ) + ")";
        return i.createRegExp( t, !0 )
      }
      var f = ( () => {
          let e = null,
            t = null;
          return n => {
            return e !== n && ( t = ( e => {
              for ( var t = "", n = e.length - 1; n >= 0; n-- ) t += e.charAt( n );
              return t
            } )( e = n ) ), t;
          };
        } )(),
        g = ( () => {
          function e() {}
          return e._findPrevBracketInText = ( e, t, n, i ) => {
            const r = n.match( e );
            if ( !r ) return null;
            const s = n.length - r.index,
              a = r[ 0 ].length,
              u = i + s;
            return new o.a( t, u - a + 1, t, u + 1 )
          }, e.findPrevBracketInToken = function ( e, t, n, i, o ) {
            const r = f( n ).substring( n.length - o, n.length - i );
            return this._findPrevBracketInText( e, t, r, i )
          }, e.findNextBracketInText = ( e, t, n, i ) => {
            const r = n.match( e );
            if ( !r ) return null;
            const s = r.index,
              a = r[ 0 ].length;
            if ( 0 === a ) return null;
            const u = i + s;
            return new o.a( t, u + 1, t, u + 1 + a )
          }, e.findNextBracketInToken = function ( e, t, n, i, o ) {
            const r = n.substring( i, o );
            return this.findNextBracketInText( e, t, r, i )
          }, e;
        } )()
    },
    EOst( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "typescript",
        extensions: [ ".ts", ".tsx" ],
        aliases: [ "TypeScript", "ts", "typescript" ],
        mimetypes: [ "text/typescript" ],
        loader() {
          return o.Promise.wrap( n.e( 31 ).then( n.bind( null, "87dK" ) ) )
        }
      } )
    },
    "EPS+": function ( e, t, n ) {},
    EWX2( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return l
      } ) ), n.d( t, "b", ( () => {
        return c
      } ) );
      let i;
      let o;
      const r = n( "bY76" );
      const s = n( "4J+e" );
      const a = n( "Cg/j" );
      const u = n( "QDVR" );
      var l = Object( a.c )( "contextService" );
      !( e => {
        e.isIWorkspace = e => {
          return e && "object" === typeof e && "string" === typeof e.id && "string" === typeof e.name && Array.isArray( e.folders )
        }
      } )( i || ( i = {} ) ), ( e => {
        e.isIWorkspaceFolder = e => {
          return e && "object" === typeof e && r.a.isUri( e.uri ) && "string" === typeof e.name && "function" === typeof e.toResource
        }
      } )( o || ( o = {} ) );
      !( () => {
        function e( e, t, n, i, o ) {
          void 0 === t && ( t = "" ), void 0 === n && ( n = [] ), void 0 === i && ( i = null ), this._id = e, this._name = t, this._configuration = i, this._ctime = o, this._foldersMap = u.c.forPaths(), this.folders = n
        }
        Object.defineProperty( e.prototype, "folders", {
          get() {
            return this._folders
          },
          set( e ) {
            this._folders = e, this.updateFoldersMap()
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "id", {
          get() {
            return this._id
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "name", {
          get() {
            return this._name
          },
          set( e ) {
            this._name = e
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "configuration", {
          get() {
            return this._configuration
          },
          set( e ) {
            this._configuration = e
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.getFolder = function ( e ) {
          return e ? this._foldersMap.findSubstr( e.toString() ) : null
        }, e.prototype.updateFoldersMap = function () {
          this._foldersMap = u.c.forPaths();
          for ( let e = 0, t = this.folders; e < t.length; e++ ) {
            const n = t[ e ];
            this._foldersMap.set( n.uri.toString(), n )
          }
        }, e.prototype.toJSON = function () {
          return {
            id: this.id,
            folders: this.folders,
            name: this.name,
            configuration: this.configuration
          }
        }
      } )();
      var c = ( () => {
        function e( e, t ) {
          this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name
        }
        return e.prototype.toResource = function ( e ) {
          return this.uri.with( {
            path: s.f( this.uri.path, e )
          } )
        }, e.prototype.toJSON = function () {
          return {
            uri: this.uri,
            name: this.name,
            index: this.index
          }
        }, e
      } )()
    },
    EffR( e, t, n ) {
      "use strict";
      n.d( t, "l", ( () => {
        return p
      } ) ), n.d( t, "D", ( () => {
        return f
      } ) ), n.d( t, "z", ( () => {
        return v
      } ) ), n.d( t, "f", ( () => {
        return y
      } ) ), n.d( t, "G", ( () => {
        return b
      } ) ), n.d( t, "N", ( () => {
        return C
      } ) ), n.d( t, "g", ( () => {
        return S
      } ) ), n.d( t, "j", ( () => {
        return O
      } ) ), n.d( t, "h", ( () => {
        return L
      } ) ), n.d( t, "J", ( () => {
        return x
      } ) ), n.d( t, "L", ( () => {
        return N
      } ) ), n.d( t, "i", ( () => {
        return T
      } ) ), n.d( t, "r", ( () => {
        return R
      } ) ), n.d( t, "q", ( () => {
        return F
      } ) ), n.d( t, "b", ( () => {
        return j
      } ) ), n.d( t, "w", ( () => {
        return V
      } ) ), n.d( t, "u", ( () => {
        return B
      } ) ), n.d( t, "e", ( () => {
        return H
      } ) ), n.d( t, "y", ( () => {
        return z
      } ) ), n.d( t, "t", ( () => {
        return U
      } ) ), n.d( t, "s", ( () => {
        return K
      } ) ), n.d( t, "x", ( () => {
        return q
      } ) ), n.d( t, "B", ( () => {
        return G
      } ) ), n.d( t, "p", ( () => {
        return Y
      } ) ), n.d( t, "o", ( () => {
        return X
      } ) ), n.d( t, "n", ( () => {
        return Q
      } ) ), n.d( t, "F", ( () => {
        return J
      } ) ), n.d( t, "C", ( () => {
        return ee
      } ) ), n.d( t, "d", ( () => {
        return te
      } ) ), n.d( t, "c", ( () => {
        return ne
      } ) ), n.d( t, "K", ( () => {
        return ie
      } ) ), n.d( t, "I", ( () => {
        return oe
      } ) ), n.d( t, "O", ( () => {
        return se
      } ) ), n.d( t, "k", ( () => {
        return ae
      } ) ), n.d( t, "E", ( () => {
        return ue
      } ) ), n.d( t, "a", ( () => {
        return ce
      } ) ), n.d( t, "M", ( () => {
        return de
      } ) ), n.d( t, "A", ( () => {
        return he
      } ) ), n.d( t, "H", ( () => {
        return pe
      } ) ), n.d( t, "v", ( () => {
        return fe
      } ) ), n.d( t, "m", ( () => {
        return ge
      } ) ), n.d( t, "P", ( () => {
        return me
      } ) );
      const i = n( "MNsG" ),
        o = n( "X+cX" ),
        r = n( "/cxE" ),
        s = n( "pmY6" ),
        a = n( "D3Dy" ),
        u = n( "uDWl" ),
        l = n( "XSiN" ),
        c = n( "MI8n" ),
        d = n( "4y0V" ),
        h = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )();

      function p( e ) {
        for ( ; e.firstChild; ) e.removeChild( e.firstChild )
      }

      function f( e ) {
        for ( ; e; ) {
          if ( e === document.body ) return !0;
          e = e.parentNode
        }
        return !1
      }
      const g = new( ( () => {
        function e() {}
        return e.prototype._findClassName = function ( e, t ) {
          const n = e.className;
          if ( n ) {
            t = t.trim();
            const i = n.length,
              o = t.length;
            if ( 0 !== o )
              if ( i < o ) this._lastStart = -1;
              else {
                if ( n === t ) return this._lastStart = 0, void( this._lastEnd = i );
                for ( let r, s = -1;
                  ( s = n.indexOf( t, s + 1 ) ) >= 0; ) {
                  if ( r = s + o, ( 0 === s || 32 === n.charCodeAt( s - 1 ) ) && 32 === n.charCodeAt( r ) ) return this._lastStart = s, void( this._lastEnd = r + 1 );
                  if ( s > 0 && 32 === n.charCodeAt( s - 1 ) && r === i ) return this._lastStart = s - 1, void( this._lastEnd = r );
                  if ( 0 === s && r === i ) return this._lastStart = 0, void( this._lastEnd = r )
                }
                this._lastStart = -1
              }
            else this._lastStart = -1
          } else this._lastStart = -1
        }, e.prototype.hasClass = function ( e, t ) {
          return this._findClassName( e, t ), -1 !== this._lastStart
        }, e.prototype.addClasses = function ( e ) {
          for ( var t = this, n = [], i = 1; i < arguments.length; i++ ) n[ i - 1 ] = arguments[ i ];
          n.forEach( ( n => {
            return n.split( " " ).forEach( ( n => {
              return t.addClass( e, n )
            } ) );
          } ) )
        }, e.prototype.addClass = function ( e, t ) {
          e.className ? ( this._findClassName( e, t ), -1 === this._lastStart && ( e.className = e.className + " " + t ) ) : e.className = t
        }, e.prototype.removeClass = function ( e, t ) {
          this._findClassName( e, t ), -1 !== this._lastStart && ( e.className = e.className.substring( 0, this._lastStart ) + e.className.substring( this._lastEnd ) )
        }, e.prototype.removeClasses = function ( e ) {
          for ( var t = this, n = [], i = 1; i < arguments.length; i++ ) n[ i - 1 ] = arguments[ i ];
          n.forEach( ( n => {
            return n.split( " " ).forEach( ( n => {
              return t.removeClass( e, n )
            } ) );
          } ) )
        }, e.prototype.toggleClass = function ( e, t, n ) {
          this._findClassName( e, t ), -1 === this._lastStart || void 0 !== n && n || this.removeClass( e, t ), -1 !== this._lastStart || void 0 !== n && !n || this.addClass( e, t )
        }, e;
      } )() )();
      const m = new( ( () => {
        function e() {}
        return e.prototype.hasClass = ( e, t ) => {
          return t && e.classList && e.classList.contains( t )
        }, e.prototype.addClasses = function ( e ) {
          for ( var t = this, n = [], i = 1; i < arguments.length; i++ ) n[ i - 1 ] = arguments[ i ];
          n.forEach( ( n => {
            return n.split( " " ).forEach( ( n => {
              return t.addClass( e, n )
            } ) );
          } ) )
        }, e.prototype.addClass = ( e, t ) => {
          t && e.classList && e.classList.add( t )
        }, e.prototype.removeClass = ( e, t ) => {
          t && e.classList && e.classList.remove( t )
        }, e.prototype.removeClasses = function ( e ) {
          for ( var t = this, n = [], i = 1; i < arguments.length; i++ ) n[ i - 1 ] = arguments[ i ];
          n.forEach( ( n => {
            return n.split( " " ).forEach( ( n => {
              return t.removeClass( e, n )
            } ) );
          } ) )
        }, e.prototype.toggleClass = ( e, t, n ) => {
          e.classList && e.classList.toggle( t, n )
        }, e;
      } )() )();
      const _ = a.k ? g : m;
      var v = _.hasClass.bind( _ );
      var y = _.addClass.bind( _ );
      var b = _.removeClass.bind( _ );
      var C = _.toggleClass.bind( _ );
      const w = ( () => {
        function e( e, t, n, i ) {
          this._node = e, this._type = t, this._handler = n, this._useCapture = i || !1, this._node.addEventListener( this._type, this._handler, this._useCapture )
        }
        return e.prototype.dispose = function () {
          this._handler && ( this._node.removeEventListener( this._type, this._handler, this._useCapture ), this._node = null, this._handler = null )
        }, e
      } )();

      function S( e, t, n, i ) {
        return new w( e, t, n, i )
      }
      var O = ( e, t, n, i ) => {
        let o = n;
        return "click" === t || "mousedown" === t ? o = ( e => {
          return t => {
            return e( new l.b( t ) )
          };
        } )( n ) : "keydown" !== t && "keypress" !== t && "keyup" !== t || ( o = ( e => {
          return t => {
            return e( new u.a( t ) )
          };
        } )( n ) ), S( e, t, o, i );
      };

      function L( e, t ) {
        return S( e, "mouseout", ( n => {
          for ( var i = n.relatedTarget || n.toElement; i && i !== e; ) i = i.parentNode;
          i !== e && t( n )
        } ) );
      }
      var x;
      var N;
      let E = null;
      const k = ( () => {
        function e( e, t ) {
          this._runner = e, this.priority = t, this._canceled = !1
        }
        return e.prototype.dispose = function () {
          this._canceled = !0
        }, e.prototype.execute = function () {
          if ( !this._canceled ) try {
            this._runner()
          } catch ( e ) {
            Object( r.e )( e )
          }
        }, e.sort = ( e, t ) => {
          return t.priority - e.priority
        }, e;
      } )();
      !( () => {
        let e = [];
        let t = null;
        let n = !1;
        let i = !1;
        const o = () => {
          for ( n = !1, t = e, e = [], i = !0; t.length > 0; ) {
            t.sort( k.sort ), t.shift().execute()
          }
          i = !1
        };
        N = ( t, i ) => {
          void 0 === i && ( i = 0 );
          const r = new k( t, i );
          return e.push( r ), n || ( n = !0, ( e => {
            if ( !E ) {
              E = self.requestAnimationFrame || self.msRequestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || ( e => {
                return setTimeout( ( () => {
                  return e( ( new Date ).getTime() )
                } ), 0 );
              } )
            }
            E.call( self, e )
          } )( o ) ), r;
        }, x = ( e, n ) => {
          if ( i ) {
            const o = new k( e, n );
            return t.push( o ), o
          }
          return N( e, n )
        }
      } )();
      const I = 16,
        D = ( e, t ) => {
          return t
        },
        M = ( e => {
          function t( t, n, i, r, s ) {
            void 0 === r && ( r = D ), void 0 === s && ( s = I );
            const a = e.call( this ) || this;
            let u = null;
            let l = 0;
            const c = a._register( new o.f );
            const d = () => {
              l = ( new Date ).getTime(), i( u ), u = null
            };
            return a._register( S( t, n, ( e => {
              u = r( u, e );
              const t = ( new Date ).getTime() - l;
              t >= s ? ( c.cancel(), d() ) : c.setIfNotSet( d, s - t )
            } ) ) ), a;
          }
          return h( t, e ), t
        } )( s.a );

      function T( e, t, n, i, o ) {
        return new M( e, t, n, i, o )
      }

      function R( e ) {
        return document.defaultView.getComputedStyle( e, null )
      }
      const P = ( e, t ) => {
        return parseFloat( t ) || 0
      };

      function A( e, t, n ) {
        const i = R( e );
        let o = "0";
        return i && ( o = i.getPropertyValue ? i.getPropertyValue( t ) : i.getAttribute( n ) ), P( e, o )
      }

      function F( e ) {
        if ( e !== document.body ) return new j( e.clientWidth, e.clientHeight );
        if ( window.innerWidth && window.innerHeight ) return new j( window.innerWidth, window.innerHeight );
        if ( document.body && document.body.clientWidth && document.body.clientWidth ) return new j( document.body.clientWidth, document.body.clientHeight );
        if ( document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight ) return new j( document.documentElement.clientWidth, document.documentElement.clientHeight );
        throw new Error( "Unable to figure out browser width and height" )
      }
      const W = {
        getBorderLeftWidth( e ) {
          return A( e, "border-left-width", "borderLeftWidth" )
        },
        getBorderRightWidth( e ) {
          return A( e, "border-right-width", "borderRightWidth" )
        },
        getBorderTopWidth( e ) {
          return A( e, "border-top-width", "borderTopWidth" )
        },
        getBorderBottomWidth( e ) {
          return A( e, "border-bottom-width", "borderBottomWidth" )
        },
        getPaddingLeft( e ) {
          return A( e, "padding-left", "paddingLeft" )
        },
        getPaddingRight( e ) {
          return A( e, "padding-right", "paddingRight" )
        },
        getPaddingTop( e ) {
          return A( e, "padding-top", "paddingTop" )
        },
        getPaddingBottom( e ) {
          return A( e, "padding-bottom", "paddingBottom" )
        },
        getMarginLeft( e ) {
          return A( e, "margin-left", "marginLeft" )
        },
        getMarginTop( e ) {
          return A( e, "margin-top", "marginTop" )
        },
        getMarginRight( e ) {
          return A( e, "margin-right", "marginRight" )
        },
        getMarginBottom( e ) {
          return A( e, "margin-bottom", "marginBottom" )
        },
        __commaSentinel: !1
      };
      var j = function ( e, t ) {
        this.width = e, this.height = t
      };

      function V( e ) {
        for ( var t = e.offsetParent, n = e.offsetTop, i = e.offsetLeft; null !== ( e = e.parentNode ) && e !== document.body && e !== document.documentElement; ) {
          n -= e.scrollTop;
          const o = R( e );
          o && ( i -= "rtl" !== o.direction ? e.scrollLeft : -e.scrollLeft ), e === t && ( i += W.getBorderLeftWidth( e ), n += W.getBorderTopWidth( e ), n += e.offsetTop, i += e.offsetLeft, t = e.offsetParent )
        }
        return {
          left: i,
          top: n
        }
      }

      function B( e ) {
        const t = e.getBoundingClientRect();
        return {
          left: t.left + H.scrollX,
          top: t.top + H.scrollY,
          width: t.width,
          height: t.height
        }
      }
      var H = new( ( () => {
        function e() {}
        return Object.defineProperty( e.prototype, "scrollX", {
          get() {
            return "number" === typeof window.scrollX ? window.scrollX : document.body.scrollLeft + document.documentElement.scrollLeft
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "scrollY", {
          get() {
            return "number" === typeof window.scrollY ? window.scrollY : document.body.scrollTop + document.documentElement.scrollTop
          },
          enumerable: !0,
          configurable: !0
        } ), e;
      } )() )();

      function z( e ) {
        const t = W.getMarginLeft( e ) + W.getMarginRight( e );
        return e.offsetWidth + t
      }

      function U( e ) {
        const t = W.getBorderLeftWidth( e ) + W.getBorderRightWidth( e ),
          n = W.getPaddingLeft( e ) + W.getPaddingRight( e );
        return e.offsetWidth - t - n
      }

      function K( e ) {
        const t = W.getBorderTopWidth( e ) + W.getBorderBottomWidth( e ),
          n = W.getPaddingTop( e ) + W.getPaddingBottom( e );
        return e.offsetHeight - t - n
      }

      function q( e ) {
        const t = W.getMarginTop( e ) + W.getMarginBottom( e );
        return e.offsetHeight + t
      }

      function G( e, t ) {
        for ( ; e; ) {
          if ( e === t ) return !0;
          e = e.parentNode
        }
        return !1
      }

      function Y( e, t, n ) {
        for ( ; e; ) {
          if ( v( e, t ) ) return e;
          if ( n )
            if ( "string" === typeof n ) {
              if ( v( e, n ) ) return null
            } else if ( e === n ) return null;
          e = e.parentNode
        }
        return null
      }

      function X( e ) {
        void 0 === e && ( e = document.getElementsByTagName( "head" )[ 0 ] );
        const t = document.createElement( "style" );
        return t.type = "text/css", t.media = "screen", e.appendChild( t ), t
      }
      let $ = null;

      function Z() {
        return $ || ( $ = X() ), $
      }

      function Q( e, t, n ) {
        void 0 === n && ( n = Z() ), n && t && n.sheet.insertRule( e + "{" + t + "}", 0 )
      }

      function J( e, t ) {
        if ( void 0 === t && ( t = Z() ), t ) {
          for ( var n = ( e => {
              return e && e.sheet && e.sheet.rules ? e.sheet.rules : e && e.sheet && e.sheet.cssRules ? e.sheet.cssRules : []
            } )( t ), i = [], o = 0; o < n.length; o++ ) {
            -1 !== n[ o ].selectorText.indexOf( e ) && i.push( o )
          }
          for ( o = i.length - 1; o >= 0; o-- ) t.sheet.deleteRule( i[ o ] )
        }
      }

      function ee( e ) {
        return "object" === typeof HTMLElement ? e instanceof HTMLElement : e && "object" === typeof e && 1 === e.nodeType && "string" === typeof e.nodeName
      }
      var te = {
          CLICK: "click",
          AUXCLICK: "auxclick",
          DBLCLICK: "dblclick",
          MOUSE_UP: "mouseup",
          MOUSE_DOWN: "mousedown",
          MOUSE_OVER: "mouseover",
          MOUSE_MOVE: "mousemove",
          MOUSE_OUT: "mouseout",
          MOUSE_ENTER: "mouseenter",
          MOUSE_LEAVE: "mouseleave",
          CONTEXT_MENU: "contextmenu",
          WHEEL: "wheel",
          KEY_DOWN: "keydown",
          KEY_PRESS: "keypress",
          KEY_UP: "keyup",
          LOAD: "load",
          UNLOAD: "unload",
          ABORT: "abort",
          ERROR: "error",
          RESIZE: "resize",
          SCROLL: "scroll",
          SELECT: "select",
          CHANGE: "change",
          SUBMIT: "submit",
          RESET: "reset",
          FOCUS: "focus",
          FOCUS_IN: "focusin",
          FOCUS_OUT: "focusout",
          BLUR: "blur",
          INPUT: "input",
          STORAGE: "storage",
          DRAG_START: "dragstart",
          DRAG: "drag",
          DRAG_ENTER: "dragenter",
          DRAG_LEAVE: "dragleave",
          DRAG_OVER: "dragover",
          DROP: "drop",
          DRAG_END: "dragend",
          ANIMATION_START: a.n ? "webkitAnimationStart" : "animationstart",
          ANIMATION_END: a.n ? "webkitAnimationEnd" : "animationend",
          ANIMATION_ITERATION: a.n ? "webkitAnimationIteration" : "animationiteration"
        },
        ne = {
          stop( e, t ) {
            e.preventDefault ? e.preventDefault() : e.returnValue = !1, t && ( e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0 )
          }
        };

      function ie( e ) {
        for ( var t = [], n = 0; e && e.nodeType === e.ELEMENT_NODE; n++ ) t[ n ] = e.scrollTop, e = e.parentNode;
        return t
      }

      function oe( e, t ) {
        for ( let n = 0; e && e.nodeType === e.ELEMENT_NODE; n++ ) e.scrollTop !== t[ n ] && ( e.scrollTop = t[ n ] ), e = e.parentNode
      }
      const re = ( () => {
        function e( e ) {
          const t = this;
          this._onDidFocus = new c.a, this.onDidFocus = this._onDidFocus.event, this._onDidBlur = new c.a, this.onDidBlur = this._onDidBlur.event, this.disposables = [];
          let n = !1,
            i = !1;
          Object( d.a )( e, te.FOCUS, !0 )( ( () => {
            i = !1, n || ( n = !0, t._onDidFocus.fire() )
          } ), null, this.disposables ), Object( d.a )( e, te.BLUR, !0 )( ( () => {
            n && ( i = !0, window.setTimeout( ( () => {
              i && ( i = !1, n = !1, t._onDidBlur.fire() )
            } ), 0 ) )
          } ), null, this.disposables )
        }
        return e.prototype.dispose = function () {
          this.disposables = Object( s.d )( this.disposables ), this._onDidFocus.dispose(), this._onDidBlur.dispose()
        }, e
      } )();

      function se( e ) {
        return new re( e )
      }

      function ae( e ) {
        for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
        return t.forEach( ( t => {
          return e.appendChild( t )
        } ) ), t[ t.length - 1 ];
      }

      function ue( e, t ) {
        return e.insertBefore( t, e.firstChild ), t
      }
      const le = /([\w\-]+)?(#([\w\-]+))?((.([\w\-]+))*)/;

      function ce( e, t ) {
        for ( var n = [], i = 2; i < arguments.length; i++ ) n[ i - 2 ] = arguments[ i ];
        const o = le.exec( e );
        if ( !o ) throw new Error( "Bad use of emmet" );
        const r = document.createElement( o[ 1 ] || "div" );
        return o[ 3 ] && ( r.id = o[ 3 ] ), o[ 4 ] && ( r.className = o[ 4 ].replace( /\./g, " " ).trim() ), Object.keys( t || {} ).forEach( ( e => {
          if ( /^on\w+$/.test( e ) ) r[ e ] = t[ e ];
          else if ( "selected" === e ) {
            t[ e ] && r.setAttribute( e, "true" )
          } else r.setAttribute( e, t[ e ] )
        } ) ), n.filter( ( e => {
          return !!e
        } ) ).forEach( ( e => {
          e instanceof Node ? r.appendChild( e ) : r.appendChild( document.createTextNode( e ) )
        } ) ), r;
      }

      function de() {
        for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
        for ( let n = 0, i = e; n < i.length; n++ ) {
          const o = i[ n ];
          o.style.display = "", o.removeAttribute( "aria-hidden" )
        }
      }

      function he() {
        for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
        for ( let n = 0, i = e; n < i.length; n++ ) {
          const o = i[ n ];
          o.style.display = "none", o.setAttribute( "aria-hidden", "true" )
        }
      }

      function pe( e ) {
        if ( e && e.hasAttribute( "tabIndex" ) ) {
          if ( document.activeElement === e ) {
            const t = ( ( e, t ) => {
              for ( ; e; ) {
                if ( e instanceof HTMLElement && e.hasAttribute( t ) ) return e;
                e = e.parentNode
              }
              return null
            } )( e.parentElement, "tabIndex" );
            t && t.focus()
          }
          e.removeAttribute( "tabindex" )
        }
      }

      function fe( e ) {
        return Array.prototype.slice.call( document.getElementsByTagName( e ), 0 )
      }

      function ge( e ) {
        const t = window.devicePixelRatio * e;
        return Math.max( 1, Math.floor( t ) ) / window.devicePixelRatio
      }

      function me( e ) {
        if ( i.e || a.i ) window.open( e );
        else {
          const t = window.open();
          t && ( t.opener = null, t.location.href = e )
        }
      }
    },
    EzsQ( e, t, n ) {},
    FWmy( e, t, n ) {
      "use strict";

      function i( e, t ) {
        if ( !e || null === e ) throw new Error( t ? "Assertion failed (" + t + ")" : "Assertion Failed" )
      }
      n.d( t, "a", ( () => {
        return i
      } ) )
    },
    FvUK( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "less",
        extensions: [ ".less" ],
        aliases: [ "Less", "less" ],
        mimetypes: [ "text/x-less", "text/less" ],
        loader() {
          return o.Promise.wrap( n.e( 275 ).then( n.bind( null, "OfHX" ) ) )
        }
      } )
    },
    G2kB( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "modelService" );

      function r( e ) {
        return !e.isTooLargeForSyncing() && !e.isForSimpleWidget
      }
    },
    G300( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return u
      } ) );
      const i = n( "pmY6" );
      const o = n( "XSiN" );
      const r = n( "uDWl" );
      const s = n( "EffR" );
      const a = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var u = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return a( t, e ), t.prototype.onclick = function ( e, t ) {
          this._register( s.g( e, s.d.CLICK, ( e => {
            return t( new o.b( e ) )
          } ) ) )
        }, t.prototype.onmousedown = function ( e, t ) {
          this._register( s.g( e, s.d.MOUSE_DOWN, ( e => {
            return t( new o.b( e ) )
          } ) ) )
        }, t.prototype.onmouseover = function ( e, t ) {
          this._register( s.g( e, s.d.MOUSE_OVER, ( e => {
            return t( new o.b( e ) )
          } ) ) )
        }, t.prototype.onnonbubblingmouseout = function ( e, t ) {
          this._register( s.h( e, ( e => {
            return t( new o.b( e ) )
          } ) ) )
        }, t.prototype.onkeydown = function ( e, t ) {
          this._register( s.g( e, s.d.KEY_DOWN, ( e => {
            return t( new r.a( e ) )
          } ) ) )
        }, t.prototype.onkeyup = function ( e, t ) {
          this._register( s.g( e, s.d.KEY_UP, ( e => {
            return t( new r.a( e ) )
          } ) ) )
        }, t.prototype.oninput = function ( e, t ) {
          this._register( s.g( e, s.d.INPUT, t ) )
        }, t.prototype.onblur = function ( e, t ) {
          this._register( s.g( e, s.d.BLUR, t ) )
        }, t.prototype.onfocus = function ( e, t ) {
          this._register( s.g( e, s.d.FOCUS, t ) )
        }, t.prototype.onchange = function ( e, t ) {
          this._register( s.g( e, s.d.CHANGE, t ) )
        }, t;
      } )( i.a );
    },
    G9H2( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "scala",
        extensions: [ ".scala", ".sbt" ],
        aliases: [ "SCALA", "Scala", "scala" ],
        loader() {
          return o.Promise.wrap( n.e( 301 ).then( n.bind( null, "VZ+T" ) ) )
        }
      } )
    },
    GJhM( e, t, n ) {
      "use strict";
      n( "eq1K" );
      const i = n( "EffR" ),
        o = n( "MNsG" ),
        r = n( "XSiN" ),
        s = n( "AKMP" ),
        a = n( "G300" ),
        u = n( "ZlPH" ),
        l = n( "X+cX" ),
        c = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        d = 11,
        h = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._onActivate = t.onActivate, n.bgDomNode = document.createElement( "div" ), n.bgDomNode.className = "arrow-background", n.bgDomNode.style.position = "absolute", n.bgDomNode.style.width = t.bgWidth + "px", n.bgDomNode.style.height = t.bgHeight + "px", "undefined" !== typeof t.top && ( n.bgDomNode.style.top = "0px" ), "undefined" !== typeof t.left && ( n.bgDomNode.style.left = "0px" ), "undefined" !== typeof t.bottom && ( n.bgDomNode.style.bottom = "0px" ), "undefined" !== typeof t.right && ( n.bgDomNode.style.right = "0px" ), n.domNode = document.createElement( "div" ), n.domNode.className = t.className, n.domNode.style.position = "absolute", n.domNode.style.width = d + "px", n.domNode.style.height = d + "px", "undefined" !== typeof t.top && ( n.domNode.style.top = t.top + "px" ), "undefined" !== typeof t.left && ( n.domNode.style.left = t.left + "px" ), "undefined" !== typeof t.bottom && ( n.domNode.style.bottom = t.bottom + "px" ), "undefined" !== typeof t.right && ( n.domNode.style.right = t.right + "px" ), n._mouseMoveMonitor = n._register( new s.a ), n.onmousedown( n.bgDomNode, ( e => {
              return n._arrowMouseDown( e )
            } ) ), n.onmousedown( n.domNode, ( e => {
              return n._arrowMouseDown( e )
            } ) ), n._mousedownRepeatTimer = n._register( new l.b ), n._mousedownScheduleRepeatTimer = n._register( new l.f ), n;
          }
          return c( t, e ), t.prototype._arrowMouseDown = function ( e ) {
            const t = this;
            this._onActivate(), this._mousedownRepeatTimer.cancel(), this._mousedownScheduleRepeatTimer.cancelAndSet( ( () => {
              t._mousedownRepeatTimer.cancelAndSet( ( () => {
                return t._onActivate()
              } ), 1e3 / 24 )
            } ), 200 ), this._mouseMoveMonitor.startMonitoring( s.b, ( e => {} ), ( () => {
              t._mousedownRepeatTimer.cancel(), t._mousedownScheduleRepeatTimer.cancel()
            } ) ), e.preventDefault()
          }, t;
        } )( a.a ),
        p = n( "pmY6" ),
        f = n( "QuOb" ),
        g = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        m = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            return o._visibility = t, o._visibleClassName = n, o._invisibleClassName = i, o._domNode = null, o._isVisible = !1, o._isNeeded = !1, o._shouldBeVisible = !1, o._revealTimer = o._register( new l.f ), o
          }
          return g( t, e ), t.prototype.applyVisibilitySetting = function ( e ) {
            return this._visibility !== f.b.Hidden && ( this._visibility === f.b.Visible || e )
          }, t.prototype.setShouldBeVisible = function ( e ) {
            const t = this.applyVisibilitySetting( e );
            this._shouldBeVisible !== t && ( this._shouldBeVisible = t, this.ensureVisibility() )
          }, t.prototype.setIsNeeded = function ( e ) {
            this._isNeeded !== e && ( this._isNeeded = e, this.ensureVisibility() )
          }, t.prototype.setDomNode = function ( e ) {
            this._domNode = e, this._domNode.setClassName( this._invisibleClassName ), this.setShouldBeVisible( !1 )
          }, t.prototype.ensureVisibility = function () {
            this._isNeeded ? this._shouldBeVisible ? this._reveal() : this._hide( !0 ) : this._hide( !1 )
          }, t.prototype._reveal = function () {
            const e = this;
            this._isVisible || ( this._isVisible = !0, this._revealTimer.setIfNotSet( ( () => {
              e._domNode.setClassName( e._visibleClassName )
            } ), 0 ) )
          }, t.prototype._hide = function ( e ) {
            this._revealTimer.cancel(), this._isVisible && ( this._isVisible = !1, this._domNode.setClassName( this._invisibleClassName + ( e ? " fade" : "" ) ) )
          }, t;
        } )( p.a ),
        _ = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        v = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._lazyRender = t.lazyRender, n._host = t.host, n._scrollable = t.scrollable, n._scrollbarState = t.scrollbarState, n._visibilityController = n._register( new m( t.visibility, "visible scrollbar " + t.extraScrollbarClassName, "invisible scrollbar " + t.extraScrollbarClassName ) ), n._mouseMoveMonitor = n._register( new s.a ), n._shouldRender = !0, n.domNode = Object( u.b )( document.createElement( "div" ) ), n.domNode.setAttribute( "role", "presentation" ), n.domNode.setAttribute( "aria-hidden", "true" ), n._visibilityController.setDomNode( n.domNode ), n.domNode.setPosition( "absolute" ), n.onmousedown( n.domNode.domNode, ( e => {
              return n._domNodeMouseDown( e )
            } ) ), n;
          }
          return _( t, e ), t.prototype._createArrow = function ( e ) {
            const t = this._register( new h( e ) );
            this.domNode.domNode.appendChild( t.bgDomNode ), this.domNode.domNode.appendChild( t.domNode )
          }, t.prototype._createSlider = function ( e, t, n, i ) {
            const o = this;
            this.slider = Object( u.b )( document.createElement( "div" ) ), this.slider.setClassName( "slider" ), this.slider.setPosition( "absolute" ), this.slider.setTop( e ), this.slider.setLeft( t ), this.slider.setWidth( n ), this.slider.setHeight( i ), this.slider.setLayerHinting( !0 ), this.domNode.domNode.appendChild( this.slider.domNode ), this.onmousedown( this.slider.domNode, ( e => {
              e.leftButton && ( e.preventDefault(), o._sliderMouseDown( e, ( () => {} ) ) )
            } ) )
          }, t.prototype._onElementSize = function ( e ) {
            return this._scrollbarState.setVisibleSize( e ) && ( this._visibilityController.setIsNeeded( this._scrollbarState.isNeeded() ), this._shouldRender = !0, this._lazyRender || this.render() ), this._shouldRender
          }, t.prototype._onElementScrollSize = function ( e ) {
            return this._scrollbarState.setScrollSize( e ) && ( this._visibilityController.setIsNeeded( this._scrollbarState.isNeeded() ), this._shouldRender = !0, this._lazyRender || this.render() ), this._shouldRender
          }, t.prototype._onElementScrollPosition = function ( e ) {
            return this._scrollbarState.setScrollPosition( e ) && ( this._visibilityController.setIsNeeded( this._scrollbarState.isNeeded() ), this._shouldRender = !0, this._lazyRender || this.render() ), this._shouldRender
          }, t.prototype.beginReveal = function () {
            this._visibilityController.setShouldBeVisible( !0 )
          }, t.prototype.beginHide = function () {
            this._visibilityController.setShouldBeVisible( !1 )
          }, t.prototype.render = function () {
            this._shouldRender && ( this._shouldRender = !1, this._renderDomNode( this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize() ), this._updateSlider( this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition() ) )
          }, t.prototype._domNodeMouseDown = function ( e ) {
            e.target === this.domNode.domNode && this._onMouseDown( e )
          }, t.prototype.delegateMouseDown = function ( e ) {
            const t = this.domNode.domNode.getClientRects()[ 0 ].top,
              n = t + this._scrollbarState.getSliderPosition(),
              i = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(),
              o = this._sliderMousePosition( e );
            n <= o && o <= i ? e.leftButton && ( e.preventDefault(), this._sliderMouseDown( e, ( () => {} ) ) ) : this._onMouseDown( e )
          }, t.prototype._onMouseDown = function ( e ) {
            let t, n;
            if ( e.target === this.domNode.domNode && "number" === typeof e.browserEvent.offsetX && "number" === typeof e.browserEvent.offsetY ) t = e.browserEvent.offsetX, n = e.browserEvent.offsetY;
            else {
              const o = i.u( this.domNode.domNode );
              t = e.posx - o.left, n = e.posy - o.top
            }
            this._setDesiredScrollPositionNow( this._scrollbarState.getDesiredScrollPositionFromOffset( this._mouseDownRelativePosition( t, n ) ) ), e.leftButton && ( e.preventDefault(), this._sliderMouseDown( e, ( () => {} ) ) )
          }, t.prototype._sliderMouseDown = function ( e, t ) {
            const n = this,
              i = this._sliderMousePosition( e ),
              r = this._sliderOrthogonalMousePosition( e ),
              a = this._scrollbarState.clone();
            this.slider.toggleClassName( "active", !0 ), this._mouseMoveMonitor.startMonitoring( s.b, ( e => {
              const t = n._sliderOrthogonalMousePosition( e ),
                s = Math.abs( t - r );
              if ( o.g && s > 140 ) n._setDesiredScrollPositionNow( a.getScrollPosition() );
              else {
                const u = n._sliderMousePosition( e ) - i;
                n._setDesiredScrollPositionNow( a.getDesiredScrollPositionFromDelta( u ) )
              }
            } ), ( () => {
              n.slider.toggleClassName( "active", !1 ), n._host.onDragEnd(), t()
            } ) ), this._host.onDragStart()
          }, t.prototype._setDesiredScrollPositionNow = function ( e ) {
            const t = {};
            this.writeScrollPosition( t, e ), this._scrollable.setScrollPositionNow( t )
          }, t;
        } )( a.a ),
        y = ( () => {
          function e( e, t, n ) {
            this._scrollbarSize = Math.round( t ), this._oppositeScrollbarSize = Math.round( n ), this._arrowSize = Math.round( e ), this._visibleSize = 0, this._scrollSize = 0, this._scrollPosition = 0, this._computedAvailableSize = 0, this._computedIsNeeded = !1, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues()
          }
          return e.prototype.clone = function () {
            const t = new e( this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize );
            return t.setVisibleSize( this._visibleSize ), t.setScrollSize( this._scrollSize ), t.setScrollPosition( this._scrollPosition ), t
          }, e.prototype.setVisibleSize = function ( e ) {
            const t = Math.round( e );
            return this._visibleSize !== t && ( this._visibleSize = t, this._refreshComputedValues(), !0 )
          }, e.prototype.setScrollSize = function ( e ) {
            const t = Math.round( e );
            return this._scrollSize !== t && ( this._scrollSize = t, this._refreshComputedValues(), !0 )
          }, e.prototype.setScrollPosition = function ( e ) {
            const t = Math.round( e );
            return this._scrollPosition !== t && ( this._scrollPosition = t, this._refreshComputedValues(), !0 )
          }, e._computeValues = ( e, t, n, i, o ) => {
            const r = Math.max( 0, n - e ),
              s = Math.max( 0, r - 2 * t ),
              a = i > 0 && i > n;
            if ( !a ) return {
              computedAvailableSize: Math.round( r ),
              computedIsNeeded: a,
              computedSliderSize: Math.round( s ),
              computedSliderRatio: 0,
              computedSliderPosition: 0
            };
            const u = Math.round( Math.max( 20, Math.floor( n * s / i ) ) ),
              l = ( s - u ) / ( i - n ),
              c = o * l;
            return {
              computedAvailableSize: Math.round( r ),
              computedIsNeeded: a,
              computedSliderSize: Math.round( u ),
              computedSliderRatio: l,
              computedSliderPosition: Math.round( c )
            }
          }, e.prototype._refreshComputedValues = function () {
            const t = e._computeValues( this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition );
            this._computedAvailableSize = t.computedAvailableSize, this._computedIsNeeded = t.computedIsNeeded, this._computedSliderSize = t.computedSliderSize, this._computedSliderRatio = t.computedSliderRatio, this._computedSliderPosition = t.computedSliderPosition
          }, e.prototype.getArrowSize = function () {
            return this._arrowSize
          }, e.prototype.getScrollPosition = function () {
            return this._scrollPosition
          }, e.prototype.getRectangleLargeSize = function () {
            return this._computedAvailableSize
          }, e.prototype.getRectangleSmallSize = function () {
            return this._scrollbarSize
          }, e.prototype.isNeeded = function () {
            return this._computedIsNeeded
          }, e.prototype.getSliderSize = function () {
            return this._computedSliderSize
          }, e.prototype.getSliderPosition = function () {
            return this._computedSliderPosition
          }, e.prototype.getDesiredScrollPositionFromOffset = function ( e ) {
            if ( !this._computedIsNeeded ) return 0;
            const t = e - this._arrowSize - this._computedSliderSize / 2;
            return Math.round( t / this._computedSliderRatio )
          }, e.prototype.getDesiredScrollPositionFromDelta = function ( e ) {
            if ( !this._computedIsNeeded ) return 0;
            const t = this._computedSliderPosition + e;
            return Math.round( t / this._computedSliderRatio )
          }, e;
        } )(),
        b = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        C = ( e => {
          function t( t, n, i ) {
            const o = e.call( this, {
              lazyRender: n.lazyRender,
              host: i,
              scrollbarState: new y( n.horizontalHasArrows ? n.arrowSize : 0, n.horizontal === f.b.Hidden ? 0 : n.horizontalScrollbarSize, n.vertical === f.b.Hidden ? 0 : n.verticalScrollbarSize ),
              visibility: n.horizontal,
              extraScrollbarClassName: "horizontal",
              scrollable: t
            } ) || this;
            if ( n.horizontalHasArrows ) {
              const s = ( n.arrowSize - d ) / 2,
                a = ( n.horizontalScrollbarSize - d ) / 2;
              o._createArrow( {
                className: "left-arrow",
                top: a,
                left: s,
                bottom: void 0,
                right: void 0,
                bgWidth: n.arrowSize,
                bgHeight: n.horizontalScrollbarSize,
                onActivate() {
                  return o._host.onMouseWheel( new r.c( null, 1, 0 ) )
                }
              } ), o._createArrow( {
                className: "right-arrow",
                top: a,
                left: void 0,
                bottom: void 0,
                right: s,
                bgWidth: n.arrowSize,
                bgHeight: n.horizontalScrollbarSize,
                onActivate() {
                  return o._host.onMouseWheel( new r.c( null, -1, 0 ) )
                }
              } )
            }
            return o._createSlider( Math.floor( ( n.horizontalScrollbarSize - n.horizontalSliderSize ) / 2 ), 0, null, n.horizontalSliderSize ), o
          }
          return b( t, e ), t.prototype._updateSlider = function ( e, t ) {
            this.slider.setWidth( e ), this.slider.setLeft( t )
          }, t.prototype._renderDomNode = function ( e, t ) {
            this.domNode.setWidth( e ), this.domNode.setHeight( t ), this.domNode.setLeft( 0 ), this.domNode.setBottom( 0 )
          }, t.prototype.onDidScroll = function ( e ) {
            return this._shouldRender = this._onElementScrollSize( e.scrollWidth ) || this._shouldRender, this._shouldRender = this._onElementScrollPosition( e.scrollLeft ) || this._shouldRender, this._shouldRender = this._onElementSize( e.width ) || this._shouldRender, this._shouldRender
          }, t.prototype._mouseDownRelativePosition = ( e, t ) => {
            return e
          }, t.prototype._sliderMousePosition = e => {
            return e.posx
          }, t.prototype._sliderOrthogonalMousePosition = e => {
            return e.posy
          }, t.prototype.writeScrollPosition = ( e, t ) => {
            e.scrollLeft = t
          }, t;
        } )( v ),
        w = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        S = ( e => {
          function t( t, n, i ) {
            const o = e.call( this, {
              lazyRender: n.lazyRender,
              host: i,
              scrollbarState: new y( n.verticalHasArrows ? n.arrowSize : 0, n.vertical === f.b.Hidden ? 0 : n.verticalScrollbarSize, 0 ),
              visibility: n.vertical,
              extraScrollbarClassName: "vertical",
              scrollable: t
            } ) || this;
            if ( n.verticalHasArrows ) {
              const s = ( n.arrowSize - d ) / 2,
                a = ( n.verticalScrollbarSize - d ) / 2;
              o._createArrow( {
                className: "up-arrow",
                top: s,
                left: a,
                bottom: void 0,
                right: void 0,
                bgWidth: n.verticalScrollbarSize,
                bgHeight: n.arrowSize,
                onActivate() {
                  return o._host.onMouseWheel( new r.c( null, 0, 1 ) )
                }
              } ), o._createArrow( {
                className: "down-arrow",
                top: void 0,
                left: a,
                bottom: s,
                right: void 0,
                bgWidth: n.verticalScrollbarSize,
                bgHeight: n.arrowSize,
                onActivate() {
                  return o._host.onMouseWheel( new r.c( null, 0, -1 ) )
                }
              } )
            }
            return o._createSlider( 0, Math.floor( ( n.verticalScrollbarSize - n.verticalSliderSize ) / 2 ), n.verticalSliderSize, null ), o
          }
          return w( t, e ), t.prototype._updateSlider = function ( e, t ) {
            this.slider.setHeight( e ), this.slider.setTop( t )
          }, t.prototype._renderDomNode = function ( e, t ) {
            this.domNode.setWidth( t ), this.domNode.setHeight( e ), this.domNode.setRight( 0 ), this.domNode.setTop( 0 )
          }, t.prototype.onDidScroll = function ( e ) {
            return this._shouldRender = this._onElementScrollSize( e.scrollHeight ) || this._shouldRender, this._shouldRender = this._onElementScrollPosition( e.scrollTop ) || this._shouldRender, this._shouldRender = this._onElementSize( e.height ) || this._shouldRender, this._shouldRender
          }, t.prototype._mouseDownRelativePosition = ( e, t ) => {
            return t
          }, t.prototype._sliderMousePosition = e => {
            return e.posy
          }, t.prototype._sliderOrthogonalMousePosition = e => {
            return e.posx
          }, t.prototype.writeScrollPosition = ( e, t ) => {
            e.scrollTop = t
          }, t;
        } )( v ),
        O = n( "MI8n" );
      n.d( t, "b", ( () => {
        return k
      } ) ), n.d( t, "c", ( () => {
        return I
      } ) ), n.d( t, "a", ( () => {
        return D
      } ) );
      const L = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const x = function ( e, t, n ) {
        this.timestamp = e, this.deltaX = t, this.deltaY = n, this.score = 0
      };
      const N = ( () => {
        function e() {
          this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1
        }
        return e.prototype.isPhysicalMouseWheel = function () {
          if ( -1 === this._front && -1 === this._rear ) return !1;
          for ( var e = 1, t = 0, n = 1, i = this._rear;; ) {
            const o = i === this._front ? e : Math.pow( 2, -n );
            if ( e -= o, t += this._memory[ i ].score * o, i === this._front ) break;
            i = ( this._capacity + i - 1 ) % this._capacity, n++
          }
          return t <= .5
        }, e.prototype.accept = function ( e, t, n ) {
          const i = new x( e, t, n );
          i.score = this._computeScore( i ), -1 === this._front && -1 === this._rear ? ( this._memory[ 0 ] = i, this._front = 0, this._rear = 0 ) : ( this._rear = ( this._rear + 1 ) % this._capacity, this._rear === this._front && ( this._front = ( this._front + 1 ) % this._capacity ), this._memory[ this._rear ] = i )
        }, e.prototype._computeScore = function ( e ) {
          if ( Math.abs( e.deltaX ) > 0 && Math.abs( e.deltaY ) > 0 ) return 1;
          let t = .5; - 1 === this._front && -1 === this._rear || this._memory[ this._rear ];
          return ( Math.abs( e.deltaX - Math.round( e.deltaX ) ) > 0 || Math.abs( e.deltaY - Math.round( e.deltaY ) ) > 0 ) && ( t += .25 ), Math.min( Math.max( t, 0 ), 1 )
        }, e.INSTANCE = new e, e;
      } )();

      const E = ( e => {
        function t( t, n, i ) {
          const o = e.call( this ) || this;
          o._onScroll = o._register( new O.a ), o.onScroll = o._onScroll.event, t.style.overflow = "hidden", o._options = M( n ), o._scrollable = i, o._register( o._scrollable.onScroll( ( e => {
            o._onDidScroll( e ), o._onScroll.fire( e )
          } ) ) );
          const r = {
            onMouseWheel( e ) {
              return o._onMouseWheel( e )
            },
            onDragStart() {
              return o._onDragStart()
            },
            onDragEnd() {
              return o._onDragEnd()
            }
          };
          return o._verticalScrollbar = o._register( new S( o._scrollable, o._options, r ) ), o._horizontalScrollbar = o._register( new C( o._scrollable, o._options, r ) ), o._domNode = document.createElement( "div" ), o._domNode.className = "monaco-scrollable-element " + o._options.className, o._domNode.setAttribute( "role", "presentation" ), o._domNode.style.position = "relative", o._domNode.style.overflow = "hidden", o._domNode.appendChild( t ), o._domNode.appendChild( o._horizontalScrollbar.domNode.domNode ), o._domNode.appendChild( o._verticalScrollbar.domNode.domNode ), o._options.useShadows && ( o._leftShadowDomNode = Object( u.b )( document.createElement( "div" ) ), o._leftShadowDomNode.setClassName( "shadow" ), o._domNode.appendChild( o._leftShadowDomNode.domNode ), o._topShadowDomNode = Object( u.b )( document.createElement( "div" ) ), o._topShadowDomNode.setClassName( "shadow" ), o._domNode.appendChild( o._topShadowDomNode.domNode ), o._topLeftShadowDomNode = Object( u.b )( document.createElement( "div" ) ), o._topLeftShadowDomNode.setClassName( "shadow top-left-corner" ), o._domNode.appendChild( o._topLeftShadowDomNode.domNode ) ), o._listenOnDomNode = o._options.listenOnDomNode || o._domNode, o._mouseWheelToDispose = [], o._setListeningToMouseWheel( o._options.handleMouseWheel ), o.onmouseover( o._listenOnDomNode, ( e => {
            return o._onMouseOver( e )
          } ) ), o.onnonbubblingmouseout( o._listenOnDomNode, ( e => {
            return o._onMouseOut( e )
          } ) ), o._hideTimeout = o._register( new l.f ), o._isDragging = !1, o._mouseIsOver = !1, o._shouldRender = !0, o._revealOnScroll = !0, o;
        }
        return L( t, e ), t.prototype.dispose = function () {
          this._mouseWheelToDispose = Object( p.d )( this._mouseWheelToDispose ), e.prototype.dispose.call( this )
        }, t.prototype.getDomNode = function () {
          return this._domNode
        }, t.prototype.getOverviewRulerLayoutInfo = function () {
          return {
            parent: this._domNode,
            insertBefore: this._verticalScrollbar.domNode.domNode
          }
        }, t.prototype.delegateVerticalScrollbarMouseDown = function ( e ) {
          this._verticalScrollbar.delegateMouseDown( e )
        }, t.prototype.getScrollDimensions = function () {
          return this._scrollable.getScrollDimensions()
        }, t.prototype.setScrollDimensions = function ( e ) {
          this._scrollable.setScrollDimensions( e )
        }, t.prototype.updateClassName = function ( e ) {
          this._options.className = e, o.d && ( this._options.className += " mac" ), this._domNode.className = "monaco-scrollable-element " + this._options.className
        }, t.prototype.updateOptions = function ( e ) {
          const t = M( e );
          this._options.handleMouseWheel = t.handleMouseWheel, this._options.mouseWheelScrollSensitivity = t.mouseWheelScrollSensitivity, this._setListeningToMouseWheel( this._options.handleMouseWheel ), this._options.lazyRender || this._render()
        }, t.prototype._setListeningToMouseWheel = function ( e ) {
          const t = this;
          if ( this._mouseWheelToDispose.length > 0 !== e && ( this._mouseWheelToDispose = Object( p.d )( this._mouseWheelToDispose ), e ) ) {
            const n = e => {
              const n = new r.c( e );
              t._onMouseWheel( n )
            };
            this._mouseWheelToDispose.push( i.g( this._listenOnDomNode, "mousewheel", n ) ), this._mouseWheelToDispose.push( i.g( this._listenOnDomNode, "DOMMouseScroll", n ) )
          }
        }, t.prototype._onMouseWheel = function ( e ) {
          let t;
          const n = N.INSTANCE;
          if ( n.accept( Date.now(), e.deltaX, e.deltaY ), e.deltaY || e.deltaX ) {
            let i = e.deltaY * this._options.mouseWheelScrollSensitivity,
              r = e.deltaX * this._options.mouseWheelScrollSensitivity;
            this._options.flipAxes && ( i = ( t = [ r, i ] )[ 0 ], r = t[ 1 ] );
            const s = !o.d && e.browserEvent && e.browserEvent.shiftKey;
            !this._options.scrollYToX && !s || r || ( r = i, i = 0 );
            const a = this._scrollable.getFutureScrollPosition();
            let u = {};
            if ( i ) {
              const l = a.scrollTop - 50 * i;
              this._verticalScrollbar.writeScrollPosition( u, l )
            }
            if ( r ) {
              const c = a.scrollLeft - 50 * r;
              this._horizontalScrollbar.writeScrollPosition( u, c )
            }
            if ( u = this._scrollable.validateScrollPosition( u ), a.scrollLeft !== u.scrollLeft || a.scrollTop !== u.scrollTop ) this._options.mouseWheelSmoothScroll && n.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth( u ) : this._scrollable.setScrollPositionNow( u ), this._shouldRender = !0
          }( this._options.alwaysConsumeMouseWheel || this._shouldRender ) && ( e.preventDefault(), e.stopPropagation() )
        }, t.prototype._onDidScroll = function ( e ) {
          this._shouldRender = this._horizontalScrollbar.onDidScroll( e ) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll( e ) || this._shouldRender, this._options.useShadows && ( this._shouldRender = !0 ), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render()
        }, t.prototype.renderNow = function () {
          if ( !this._options.lazyRender ) throw new Error( "Please use `lazyRender` together with `renderNow`!" );
          this._render()
        }, t.prototype._render = function () {
          if ( this._shouldRender && ( this._shouldRender = !1, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows ) ) {
            const e = this._scrollable.getCurrentScrollPosition(),
              t = e.scrollTop > 0,
              n = e.scrollLeft > 0;
            this._leftShadowDomNode.setClassName( "shadow" + ( n ? " left" : "" ) ), this._topShadowDomNode.setClassName( "shadow" + ( t ? " top" : "" ) ), this._topLeftShadowDomNode.setClassName( "shadow top-left-corner" + ( t ? " top" : "" ) + ( n ? " left" : "" ) )
          }
        }, t.prototype._onDragStart = function () {
          this._isDragging = !0, this._reveal()
        }, t.prototype._onDragEnd = function () {
          this._isDragging = !1, this._hide()
        }, t.prototype._onMouseOut = function ( e ) {
          this._mouseIsOver = !1, this._hide()
        }, t.prototype._onMouseOver = function ( e ) {
          this._mouseIsOver = !0, this._reveal()
        }, t.prototype._reveal = function () {
          this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide()
        }, t.prototype._hide = function () {
          this._mouseIsOver || this._isDragging || ( this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide() )
        }, t.prototype._scheduleHide = function () {
          const e = this;
          this._mouseIsOver || this._isDragging || this._hideTimeout.cancelAndSet( ( () => {
            return e._hide()
          } ), 500 )
        }, t;
      } )( a.a );

      var k = ( e => {
        function t( t, n ) {
          let o = this;
          ( n = n || {} ).mouseWheelSmoothScroll = !1;
          const r = new f.a( 0, ( e => {
            return i.L( e )
          } ) );
          return ( o = e.call( this, t, n, r ) || this )._register( r ), o
        }
        return L( t, e ), t.prototype.setScrollPosition = function ( e ) {
          this._scrollable.setScrollPositionNow( e )
        }, t.prototype.getScrollPosition = function () {
          return this._scrollable.getCurrentScrollPosition()
        }, t
      } )( E );
      var I = ( e => {
        function t( t, n, i ) {
          return e.call( this, t, n, i ) || this
        }
        return L( t, e ), t
      } )( E );
      var D = ( e => {
        function t( t, n ) {
          const i = e.call( this, t, n ) || this;
          return i._element = t, i.onScroll( ( e => {
            e.scrollTopChanged && ( i._element.scrollTop = e.scrollTop ), e.scrollLeftChanged && ( i._element.scrollLeft = e.scrollLeft )
          } ) ), i.scanDomNode(), i;
        }
        return L( t, e ), t.prototype.scanDomNode = function () {
          this.setScrollDimensions( {
            width: this._element.clientWidth,
            scrollWidth: this._element.scrollWidth,
            height: this._element.clientHeight,
            scrollHeight: this._element.scrollHeight
          } ), this.setScrollPosition( {
            scrollLeft: this._element.scrollLeft,
            scrollTop: this._element.scrollTop
          } )
        }, t
      } )( k );

      function M( e ) {
        const t = {
          lazyRender: "undefined" !== typeof e.lazyRender && e.lazyRender,
          className: "undefined" !== typeof e.className ? e.className : "",
          useShadows: "undefined" === typeof e.useShadows || e.useShadows,
          handleMouseWheel: "undefined" === typeof e.handleMouseWheel || e.handleMouseWheel,
          flipAxes: "undefined" !== typeof e.flipAxes && e.flipAxes,
          alwaysConsumeMouseWheel: "undefined" !== typeof e.alwaysConsumeMouseWheel && e.alwaysConsumeMouseWheel,
          scrollYToX: "undefined" !== typeof e.scrollYToX && e.scrollYToX,
          mouseWheelScrollSensitivity: "undefined" !== typeof e.mouseWheelScrollSensitivity ? e.mouseWheelScrollSensitivity : 1,
          mouseWheelSmoothScroll: "undefined" === typeof e.mouseWheelSmoothScroll || e.mouseWheelSmoothScroll,
          arrowSize: "undefined" !== typeof e.arrowSize ? e.arrowSize : 11,
          listenOnDomNode: "undefined" !== typeof e.listenOnDomNode ? e.listenOnDomNode : null,
          horizontal: "undefined" !== typeof e.horizontal ? e.horizontal : f.b.Auto,
          horizontalScrollbarSize: "undefined" !== typeof e.horizontalScrollbarSize ? e.horizontalScrollbarSize : 10,
          horizontalSliderSize: "undefined" !== typeof e.horizontalSliderSize ? e.horizontalSliderSize : 0,
          horizontalHasArrows: "undefined" !== typeof e.horizontalHasArrows && e.horizontalHasArrows,
          vertical: "undefined" !== typeof e.vertical ? e.vertical : f.b.Auto,
          verticalScrollbarSize: "undefined" !== typeof e.verticalScrollbarSize ? e.verticalScrollbarSize : 10,
          verticalHasArrows: "undefined" !== typeof e.verticalHasArrows && e.verticalHasArrows,
          verticalSliderSize: "undefined" !== typeof e.verticalSliderSize ? e.verticalSliderSize : 0
        };
        return t.horizontalSliderSize = "undefined" !== typeof e.horizontalSliderSize ? e.horizontalSliderSize : t.horizontalScrollbarSize, t.verticalSliderSize = "undefined" !== typeof e.verticalSliderSize ? e.verticalSliderSize : t.verticalScrollbarSize, o.d && ( t.className += " mac" ), t
      }
    },
    "GR/f": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "/cxE" ),
        o = n( "LCkn" ),
        r = n( "Ll0s" ),
        s = n( "aokT" ),
        a = n( "N0LK" ),
        u = n( "zN7H" ),
        l = n( "cMvZ" ),
        c = n( "KDc4" ),
        d = n( "gCVg" ),
        h = ( () => {
          function e( e, t, n ) {
            this._range = e, this._charBeforeSelection = t, this._charAfterSelection = n
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            t.addTrackedEditOperation( new s.a( this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn ), this._charBeforeSelection ), t.addTrackedEditOperation( new s.a( this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn ), this._charAfterSelection )
          }, e.prototype.computeCursorState = function ( e, t ) {
            const n = t.getInverseEditOperations(),
              i = n[ 0 ].range,
              o = n[ 1 ].range;
            return new d.a( i.endLineNumber, i.endColumn, o.endLineNumber, o.endColumn - this._charAfterSelection.length )
          }, e;
        } )(),
        p = n( "5v8Y" );
      n.d( t, "TypeOperations", ( () => {
        return f
      } ) );
      var f = ( () => {
        function e() {}
        return e.indent = ( e, t, n ) => {
          for ( var i = [], o = 0, r = n.length; o < r; o++ ) i[ o ] = new u.a( n[ o ], {
            isUnshift: !1,
            tabSize: e.tabSize,
            oneIndent: e.oneIndent,
            useTabStops: e.useTabStops
          } );
          return i
        }, e.outdent = ( e, t, n ) => {
          for ( var i = [], o = 0, r = n.length; o < r; o++ ) i[ o ] = new u.a( n[ o ], {
            isUnshift: !0,
            tabSize: e.tabSize,
            oneIndent: e.oneIndent,
            useTabStops: e.useTabStops
          } );
          return i
        }, e.shiftIndent = ( e, t, n ) => {
          n = n || 1;
          for ( var i = u.a.shiftIndentCount( t, t.length + n, e.tabSize ), o = "", r = 0; r < i; r++ ) o += "\t";
          return o
        }, e.unshiftIndent = ( e, t, n ) => {
          n = n || 1;
          for ( var i = u.a.unshiftIndentCount( t, t.length + n, e.tabSize ), o = "", r = 0; r < i; r++ ) o += "\t";
          return o
        }, e._distributedPaste = ( e, t, n, i ) => {
          for ( var s = [], a = 0, u = n.length; a < u; a++ ) s[ a ] = new o.a( n[ a ], i[ a ] );
          return new r.e( 0, s, {
            shouldPushStackElementBefore: !0,
            shouldPushStackElementAfter: !0
          } )
        }, e._simplePaste = ( e, t, n, i, a ) => {
          for ( var u = [], l = 0, c = n.length; l < c; l++ ) {
            const d = n[ l ],
              h = d.getPosition();
            if ( a && i.indexOf( "\n" ) !== i.length - 1 && ( a = !1 ), a && d.startLineNumber !== d.endLineNumber && ( a = !1 ), a && d.startColumn === t.getLineMinColumn( d.startLineNumber ) && d.endColumn === t.getLineMaxColumn( d.startLineNumber ) && ( a = !1 ), a ) {
              const p = new s.a( h.lineNumber, 1, h.lineNumber, 1 );
              u[ l ] = new o.a( p, i )
            } else u[ l ] = new o.a( d, i )
          }
          return new r.e( 0, u, {
            shouldPushStackElementBefore: !0,
            shouldPushStackElementAfter: !0
          } )
        }, e._distributePasteToCursors = ( e, t, n, i ) => {
          if ( n ) return null;
          if ( 1 === e.length ) return null;
          if ( i && i.length === e.length ) return i;
          10 === t.charCodeAt( t.length - 1 ) && ( t = t.substr( 0, t.length - 1 ) );
          const o = t.split( /\r\n|\r|\n/ );
          return o.length === e.length ? o : null
        }, e.paste = function ( e, t, n, i, o, r ) {
          const a = this._distributePasteToCursors( n, i, o, r );
          return a ? ( n = n.sort( s.a.compareRangesUsingStarts ), this._distributedPaste( e, t, n, a ) ) : this._simplePaste( e, t, n, i, o )
        }, e._goodIndentForLine = ( t, n, i ) => {
          let o;
          let r;
          const u = t.autoIndent ? l.a.getInheritIndentForLine( n, i, !1 ) : null;
          if ( u ) o = u.action, r = u.indentation;
          else if ( i > 1 ) {
            let d = i - 1;
            for ( d = i - 1; d >= 1; d-- ) {
              const h = n.getLineContent( d );
              if ( a.lastNonWhitespaceIndex( h ) >= 0 ) break
            }
            if ( d < 1 ) return null;
            const p = n.getLineMaxColumn( d ),
              f = l.a.getEnterAction( n, new s.a( d, p, d, p ) );
            f && ( r = f.indentation, ( o = f.enterAction ) && ( r += o.appendText ) )
          }
          return o && ( o === c.a.Indent && ( r = e.shiftIndent( t, r ) ), o === c.a.Outdent && ( r = e.unshiftIndent( t, r ) ), r = t.normalizeIndentation( r ) ), r || null
        }, e._replaceJumpToNextIndent = ( e, t, n, i ) => {
          let s = "";
          const a = n.getStartPosition();
          if ( e.insertSpaces )
            for ( let u = r.a.visibleColumnFromColumn2( e, t, a ), l = e.tabSize, c = l - u % l, d = 0; d < c; d++ ) s += " ";
          else s = "\t";
          return new o.a( n, s, i )
        }, e.tab = function ( e, t, n ) {
          for ( var i = [], r = 0, l = n.length; r < l; r++ ) {
            const c = n[ r ];
            if ( c.isEmpty() ) {
              const d = t.getLineContent( c.startLineNumber );
              if ( /^\s*$/.test( d ) && t.isCheapToTokenize( c.startLineNumber ) ) {
                let h = this._goodIndentForLine( e, t, c.startLineNumber );
                h = h || "\t";
                const p = e.normalizeIndentation( h );
                if ( !a.startsWith( d, p ) ) {
                  i[ r ] = new o.a( new s.a( c.startLineNumber, 1, c.startLineNumber, d.length + 1 ), p, !0 );
                  continue
                }
              }
              i[ r ] = this._replaceJumpToNextIndent( e, t, c, !0 )
            } else {
              if ( c.startLineNumber === c.endLineNumber ) {
                const f = t.getLineMaxColumn( c.startLineNumber );
                if ( 1 !== c.startColumn || c.endColumn !== f ) {
                  i[ r ] = this._replaceJumpToNextIndent( e, t, c, !1 );
                  continue
                }
              }
              i[ r ] = new u.a( c, {
                isUnshift: !1,
                tabSize: e.tabSize,
                oneIndent: e.oneIndent,
                useTabStops: e.useTabStops
              } )
            }
          }
          return i
        }, e.replacePreviousChar = ( e, t, n, i, a, u ) => {
          for ( var l = [], c = 0, d = i.length; c < d; c++ ) {
            const h = i[ c ];
            if ( h.isEmpty() ) {
              const p = h.getPosition(),
                f = Math.max( 1, p.column - u ),
                g = new s.a( p.lineNumber, f, p.lineNumber, p.column );
              l[ c ] = new o.a( g, a )
            } else l[ c ] = null
          }
          return new r.e( 1, l, {
            shouldPushStackElementBefore: 1 !== e,
            shouldPushStackElementAfter: !1
          } )
        }, e._typeCommand = ( e, t, n ) => {
          return n ? new o.d( e, t, !0 ) : new o.a( e, t, !0 )
        }, e._enter = ( t, n, i, u ) => {
          if ( !n.isCheapToTokenize( u.getStartPosition().lineNumber ) ) {
            const d = n.getLineContent( u.startLineNumber ),
              h = a.getLeadingWhitespace( d ).substring( 0, u.startColumn - 1 );
            return e._typeCommand( u, "\n" + t.normalizeIndentation( h ), i )
          }
          const p = l.a.getEnterAction( n, u );
          if ( p ) {
            const f = p.enterAction,
              g = p.indentation;
            if ( f.indentAction === c.a.None ) return e._typeCommand( u, "\n" + t.normalizeIndentation( g + f.appendText ), i );
            if ( f.indentAction === c.a.Indent ) return e._typeCommand( u, "\n" + t.normalizeIndentation( g + f.appendText ), i );
            if ( f.indentAction === c.a.IndentOutdent ) {
              const m = t.normalizeIndentation( g ),
                _ = t.normalizeIndentation( g + f.appendText ),
                v = "\n" + _ + "\n" + m;
              return i ? new o.d( u, v, !0 ) : new o.c( u, v, -1, _.length - m.length, !0 )
            }
            if ( f.indentAction === c.a.Outdent ) {
              const y = e.unshiftIndent( t, g );
              return e._typeCommand( u, "\n" + t.normalizeIndentation( y + f.appendText ), i )
            }
          }
          if ( !t.autoIndent ) {
            const b = n.getLineContent( u.startLineNumber ),
              C = a.getLeadingWhitespace( b ).substring( 0, u.startColumn - 1 );
            return e._typeCommand( u, "\n" + t.normalizeIndentation( C ), i )
          }
          const w = l.a.getIndentForEnter( n, u, {
              unshiftIndent( n ) {
                return e.unshiftIndent( t, n )
              },
              shiftIndent( n ) {
                return e.shiftIndent( t, n )
              },
              normalizeIndentation( e ) {
                return t.normalizeIndentation( e )
              }
            }, t.autoIndent ),
            S = n.getLineContent( u.startLineNumber ),
            O = a.getLeadingWhitespace( S ).substring( 0, u.startColumn - 1 );
          if ( w ) {
            let L = r.a.visibleColumnFromColumn2( t, n, u.getEndPosition() );
            const x = u.endColumn;
            let N = "\n";
            O !== t.normalizeIndentation( w.beforeEnter ) && ( N = t.normalizeIndentation( w.beforeEnter ) + S.substring( O.length, u.startColumn - 1 ) + "\n", u = new s.a( u.startLineNumber, 1, u.endLineNumber, u.endColumn ) );
            const E = n.getLineContent( u.endLineNumber ),
              k = a.firstNonWhitespaceIndex( E );
            if ( u = k >= 0 ? u.setEndPosition( u.endLineNumber, Math.max( u.endColumn, k + 1 ) ) : u.setEndPosition( u.endLineNumber, n.getLineMaxColumn( u.endLineNumber ) ), i ) return new o.d( u, N + t.normalizeIndentation( w.afterEnter ), !0 );
            let I = 0;
            return x <= k + 1 && ( t.insertSpaces || ( L = Math.ceil( L / t.tabSize ) ), I = Math.min( L + 1 - t.normalizeIndentation( w.afterEnter ).length - 1, 0 ) ), new o.c( u, N + t.normalizeIndentation( w.afterEnter ), 0, I, !0 )
          }
          return e._typeCommand( u, "\n" + t.normalizeIndentation( O ), i )
        }, e._isAutoIndentType = ( e, t, n ) => {
          if ( !e.autoIndent ) return !1;
          for ( let i = 0, o = n.length; i < o; i++ )
            if ( !t.isCheapToTokenize( n[ i ].getEndPosition().lineNumber ) ) return !1;
          return !0
        }, e._runAutoIndentType = ( t, n, i, o ) => {
          const r = l.a.getIndentationAtPosition( n, i.startLineNumber, i.startColumn ),
            a = l.a.getIndentActionForType( n, i, o, {
              shiftIndent( n ) {
                return e.shiftIndent( t, n )
              },
              unshiftIndent( n ) {
                return e.unshiftIndent( t, n )
              }
            } );
          if ( null === a ) return null;
          if ( a !== t.normalizeIndentation( r ) ) {
            const u = n.getLineFirstNonWhitespaceColumn( i.startLineNumber );
            return 0 === u ? e._typeCommand( new s.a( i.startLineNumber, 0, i.endLineNumber, i.endColumn ), t.normalizeIndentation( a ) + o, !1 ) : e._typeCommand( new s.a( i.startLineNumber, 0, i.endLineNumber, i.endColumn ), t.normalizeIndentation( a ) + n.getLineContent( i.startLineNumber ).substring( u - 1, i.startColumn - 1 ) + o, !1 )
          }
          return null
        }, e._isAutoClosingCloseCharType = function ( e, t, n, i ) {
          if ( !e.autoClosingBrackets || !e.autoClosingPairsClose.hasOwnProperty( i ) ) return !1;
          for ( let o = i === e.autoClosingPairsClose[ i ], r = 0, s = n.length; r < s; r++ ) {
            const a = n[ r ];
            if ( !a.isEmpty() ) return !1;
            const u = a.getPosition(),
              l = t.getLineContent( u.lineNumber );
            if ( l.charAt( u.column - 1 ) !== i ) return !1;
            if ( o ) {
              const c = l.substr( 0, u.column - 1 );
              if ( this._countNeedlesInHaystack( c, i ) % 2 === 0 ) return !1
            }
          }
          return !0
        }, e._countNeedlesInHaystack = ( e, t ) => {
          for ( var n = 0, i = -1; - 1 !== ( i = e.indexOf( t, i + 1 ) ); ) n++;
          return n
        }, e._runAutoClosingCloseCharType = ( e, t, n, i, a ) => {
          for ( var u = [], l = 0, c = i.length; l < c; l++ ) {
            const d = i[ l ].getPosition(),
              h = new s.a( d.lineNumber, d.column, d.lineNumber, d.column + 1 );
            u[ l ] = new o.a( h, a )
          }
          return new r.e( 1, u, {
            shouldPushStackElementBefore: 1 !== e,
            shouldPushStackElementAfter: !1
          } )
        }, e._isBeforeClosingBrace = ( e, t, n ) => {
          const i = e.autoClosingPairsOpen[ t ] === t;
          let o = !1;
          for ( const r in e.autoClosingPairsClose ) {
            const s = e.autoClosingPairsOpen[ r ] === r;
            if ( ( i || !s ) && n === r ) {
              o = !0;
              break
            }
          }
          return o
        }, e._isAutoClosingOpenCharType = ( t, n, o, r ) => {
          if ( !t.autoClosingBrackets || !t.autoClosingPairsOpen.hasOwnProperty( r ) ) return !1;
          for ( let s = 0, a = o.length; s < a; s++ ) {
            const u = o[ s ];
            if ( !u.isEmpty() ) return !1;
            const c = u.getPosition(),
              d = n.getLineContent( c.lineNumber );
            if ( ( "'" === r || '"' === r ) && c.column > 1 ) {
              const h = Object( p.a )( t.wordSeparators ),
                f = d.charCodeAt( c.column - 2 );
              if ( 0 === h.get( f ) ) return !1
            }
            const g = d.charAt( c.column - 1 );
            if ( g )
              if ( !e._isBeforeClosingBrace( t, r, g ) && !/\s/.test( g ) ) return !1;
            if ( !n.isCheapToTokenize( c.lineNumber ) ) return !1;
            n.forceTokenization( c.lineNumber );
            const m = n.getLineTokens( c.lineNumber );
            let _ = !1;
            try {
              _ = l.a.shouldAutoClosePair( r, m, c.column )
            } catch ( v ) {
              Object( i.e )( v )
            }
            if ( !_ ) return !1
          }
          return !0
        }, e._runAutoClosingOpenCharType = ( e, t, n, i, s ) => {
          for ( var a = [], u = 0, l = i.length; u < l; u++ ) {
            const c = i[ u ],
              d = t.autoClosingPairsOpen[ s ];
            a[ u ] = new o.c( c, s + d, 0, -d.length )
          }
          return new r.e( 1, a, {
            shouldPushStackElementBefore: !0,
            shouldPushStackElementAfter: !1
          } )
        }, e._isSurroundSelectionType = ( e, t, n, i ) => {
          if ( !e.autoClosingBrackets || !e.surroundingPairs.hasOwnProperty( i ) ) return !1;
          for ( let o = "'" === i || '"' === i, r = 0, s = n.length; r < s; r++ ) {
            const a = n[ r ];
            if ( a.isEmpty() ) return !1;
            for ( var u = !0, l = a.startLineNumber; l <= a.endLineNumber; l++ ) {
              const c = t.getLineContent( l ),
                d = l === a.startLineNumber ? a.startColumn - 1 : 0,
                h = l === a.endLineNumber ? a.endColumn - 1 : c.length,
                p = c.substring( d, h );
              if ( /[^ \t]/.test( p ) ) {
                u = !1;
                break
              }
            }
            if ( u ) return !1;
            if ( o && a.startLineNumber === a.endLineNumber && a.startColumn + 1 === a.endColumn ) {
              const f = t.getValueInRange( a );
              if ( "'" === f || '"' === f ) return !1
            }
          }
          return !0
        }, e._runSurroundSelectionType = ( e, t, n, i, o ) => {
          for ( var s = [], a = 0, u = i.length; a < u; a++ ) {
            const l = i[ a ],
              c = t.surroundingPairs[ o ];
            s[ a ] = new h( l, o, c )
          }
          return new r.e( 0, s, {
            shouldPushStackElementBefore: !0,
            shouldPushStackElementAfter: !0
          } )
        }, e._isTypeInterceptorElectricChar = ( e, t, n ) => {
          return !( 1 !== n.length || !t.isCheapToTokenize( n[ 0 ].getEndPosition().lineNumber ) )
        }, e._typeInterceptorElectricChar = ( e, t, n, u, c ) => {
          if ( !t.electricChars.hasOwnProperty( c ) || !u.isEmpty() ) return null;
          const d = u.getPosition();
          n.forceTokenization( d.lineNumber );
          let h;
          const p = n.getLineTokens( d.lineNumber );
          try {
            h = l.a.onElectricCharacter( c, p, d.column )
          } catch ( O ) {
            Object( i.e )( O )
          }
          if ( !h ) return null;
          if ( h.appendText ) {
            var f = new o.c( u, c + h.appendText, 0, -h.appendText.length );
            return new r.e( 1, [ f ], {
              shouldPushStackElementBefore: !1,
              shouldPushStackElementAfter: !0
            } )
          }
          if ( h.matchOpenBracket ) {
            const g = ( p.getLineContent() + c ).lastIndexOf( h.matchOpenBracket ) + 1,
              m = n.findMatchingBracketUp( h.matchOpenBracket, {
                lineNumber: d.lineNumber,
                column: g
              } );
            if ( m ) {
              if ( m.startLineNumber === d.lineNumber ) return null;
              const _ = n.getLineContent( m.startLineNumber ),
                v = a.getLeadingWhitespace( _ ),
                y = t.normalizeIndentation( v ),
                b = n.getLineContent( d.lineNumber ),
                C = n.getLineFirstNonWhitespaceColumn( d.lineNumber ) || d.column,
                w = y + b.substring( C - 1, d.column - 1 ) + c,
                S = new s.a( d.lineNumber, 1, d.lineNumber, d.column );
              f = new o.a( S, w );
              return new r.e( 1, [ f ], {
                shouldPushStackElementBefore: !1,
                shouldPushStackElementAfter: !0
              } )
            }
          }
          return null
        }, e.compositionEndWithInterceptors = function ( t, n, s, a ) {
          if ( !n.autoClosingBrackets ) return null;
          for ( var u = [], c = 0; c < a.length; c++ )
            if ( a[ c ].isEmpty() ) {
              const d = a[ c ].getPosition(),
                h = s.getLineContent( d.lineNumber ),
                f = h.charAt( d.column - 2 );
              if ( n.autoClosingPairsClose.hasOwnProperty( f ) && f === n.autoClosingPairsClose[ f ] ) {
                const g = h.substr( 0, d.column - 2 );
                if ( this._countNeedlesInHaystack( g, f ) % 2 === 1 ) continue
              }
              if ( n.autoClosingPairsOpen.hasOwnProperty( f ) ) {
                if ( ( "'" === f || '"' === f ) && d.column > 2 ) {
                  const m = Object( p.a )( n.wordSeparators ),
                    _ = h.charCodeAt( d.column - 3 );
                  if ( 0 === m.get( _ ) ) continue
                }
                const v = h.charAt( d.column - 1 );
                if ( v )
                  if ( !e._isBeforeClosingBrace( n, f, v ) && !/\s/.test( v ) ) continue;
                if ( !s.isCheapToTokenize( d.lineNumber ) ) continue;
                s.forceTokenization( d.lineNumber );
                const y = s.getLineTokens( d.lineNumber );
                let b = !1;
                try {
                  b = l.a.shouldAutoClosePair( f, y, d.column - 1 )
                } catch ( w ) {
                  Object( i.e )( w )
                }
                if ( b ) {
                  const C = n.autoClosingPairsOpen[ f ];
                  u[ c ] = new o.c( a[ c ], C, 0, -C.length )
                }
              }
            } return new r.e( 1, u, {
            shouldPushStackElementBefore: !0,
            shouldPushStackElementAfter: !1
          } )
        }, e.typeWithInterceptors = function ( t, n, i, s, a ) {
          if ( "\n" === a ) {
            for ( var u = [], l = 0, c = s.length; l < c; l++ ) u[ l ] = e._enter( n, i, !1, s[ l ] );
            return new r.e( 1, u, {
              shouldPushStackElementBefore: !0,
              shouldPushStackElementAfter: !1
            } )
          }
          if ( this._isAutoIndentType( n, i, s ) ) {
            const d = [];
            let h = !1;
            for ( l = 0, c = s.length; l < c; l++ )
              if ( d[ l ] = this._runAutoIndentType( n, i, s[ l ], a ), !d[ l ] ) {
                h = !0;
                break
              } if ( !h ) return new r.e( 1, d, {
              shouldPushStackElementBefore: !0,
              shouldPushStackElementAfter: !1
            } )
          }
          if ( this._isAutoClosingCloseCharType( n, i, s, a ) ) return this._runAutoClosingCloseCharType( t, n, i, s, a );
          if ( this._isAutoClosingOpenCharType( n, i, s, a ) ) return this._runAutoClosingOpenCharType( t, n, i, s, a );
          if ( this._isSurroundSelectionType( n, i, s, a ) ) return this._runSurroundSelectionType( t, n, i, s, a );
          if ( this._isTypeInterceptorElectricChar( n, i, s ) ) {
            const p = this._typeInterceptorElectricChar( t, n, i, s[ 0 ], a );
            if ( p ) return p
          }
          const f = [];
          for ( l = 0, c = s.length; l < c; l++ ) f[ l ] = new o.a( s[ l ], a );
          let g = 1 !== t;
          return " " === a && ( g = !0 ), new r.e( 1, f, {
            shouldPushStackElementBefore: g,
            shouldPushStackElementAfter: !1
          } )
        }, e.typeWithoutInterceptors = ( e, t, n, i, s ) => {
          for ( var a = [], u = 0, l = i.length; u < l; u++ ) a[ u ] = new o.a( i[ u ], s );
          return new r.e( 1, a, {
            shouldPushStackElementBefore: 1 !== e,
            shouldPushStackElementAfter: !1
          } )
        }, e.lineInsertBefore = function ( e, t, n ) {
          for ( var i = [], r = 0, a = n.length; r < a; r++ ) {
            let u = n[ r ].positionLineNumber;
            if ( 1 === u ) i[ r ] = new o.d( new s.a( 1, 1, 1, 1 ), "\n" );
            else {
              u--;
              const l = t.getLineMaxColumn( u );
              i[ r ] = this._enter( e, t, !1, new s.a( u, l, u, l ) )
            }
          }
          return i
        }, e.lineInsertAfter = function ( e, t, n ) {
          for ( var i = [], o = 0, r = n.length; o < r; o++ ) {
            const a = n[ o ].positionLineNumber,
              u = t.getLineMaxColumn( a );
            i[ o ] = this._enter( e, t, !1, new s.a( a, u, a, u ) )
          }
          return i
        }, e.lineBreakInsert = function ( e, t, n ) {
          for ( var i = [], o = 0, r = n.length; o < r; o++ ) i[ o ] = this._enter( e, t, !0, n[ o ] );
          return i
        }, e;
      } )()
    },
    GZrW( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "sol",
        extensions: [ ".sol" ],
        aliases: [ "sol", "solidity", "Solidity" ],
        loader() {
          return o.Promise.wrap( n.e( 305 ).then( n.bind( null, "Csoz" ) ) )
        }
      } )
    },
    Gb1F( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "sb",
        extensions: [ ".sb" ],
        aliases: [ "Small Basic", "sb" ],
        loader() {
          return o.Promise.wrap( n.e( 300 ).then( n.bind( null, "ynbn" ) ) )
        }
      } )
    },
    GvMn( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "VMIq" ),
        r = n( "aokT" ),
        s = n( "gCVg" ),
        a = n( "wQH0" ),
        u = n( "sswD" ),
        l = n( "pAvP" ),
        c = ( () => {
          function e( e, t, n ) {
            this._editRange = e, this._originalSelection = t, this._text = n
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            t.addTrackedEditOperation( this._editRange, this._text )
          }, e.prototype.computeCursorState = function ( e, t ) {
            const n = t.getInverseEditOperations()[ 0 ].range;
            return this._originalSelection.isEmpty() ? new s.a( n.endLineNumber, Math.min( this._originalSelection.positionColumn, n.endColumn ), n.endLineNumber, Math.min( this._originalSelection.positionColumn, n.endColumn ) ) : new s.a( n.endLineNumber, n.endColumn - this._text.length, n.endLineNumber, n.endColumn )
          }, e;
        } )(),
        d = n( "vATl" ),
        h = n( "t9D7" ),
        p = n( "kYye" ),
        f = n( "tX9W" ),
        g = n( "X+cX" ),
        m = n( "/cxE" ),
        _ = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        v = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        y = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        b = ( () => {
          function e( e, t ) {
            this.decorationIds = [], this.editor = e, this.editorWorkerService = t
          }
          return e.get = t => {
            return t.getContribution( e.ID )
          }, e.prototype.dispose = () => {}, e.prototype.getId = () => {
            return e.ID
          }, e.prototype.run = function ( t, n ) {
            const i = this;
            this.currentRequest && this.currentRequest.cancel();
            let o = this.editor.getSelection();
            const a = this.editor.getModel().uri;
            if ( o.startLineNumber !== o.endLineNumber ) return null;
            const u = new d.a( this.editor, 5 );
            return this.editorWorkerService.canNavigateValueSet( a ) ? ( this.currentRequest = Object( g.i )( ( e => {
              return i.editorWorkerService.navigateValueSet( a, o, n )
            } ) ), this.currentRequest.then( ( n => {
              if ( n && n.range && n.value && u.validate( i.editor ) ) {
                const a = r.a.lift( n.range );
                let l = n.range;
                const d = n.value.length - ( o.endColumn - o.startColumn );
                l = {
                  startLineNumber: l.startLineNumber,
                  startColumn: l.startColumn,
                  endLineNumber: l.endLineNumber,
                  endColumn: l.startColumn + n.value.length
                }, d > 1 && ( o = new s.a( o.startLineNumber, o.startColumn, o.endLineNumber, o.endColumn + d - 1 ) );
                const h = new c( a, o, n.value );
                i.editor.pushUndoStop(), i.editor.executeCommand( t, h ), i.editor.pushUndoStop(), i.decorationIds = i.editor.deltaDecorations( i.decorationIds, [ {
                  range: l,
                  options: e.DECORATION
                } ] ), i.decorationRemover && i.decorationRemover.cancel(), i.decorationRemover = Object( g.m )( 350 ), i.decorationRemover.then( ( () => {
                  return i.decorationIds = i.editor.deltaDecorations( i.decorationIds, [] )
                } ) ).catch( m.e )
              }
            } ) ).catch( m.e ) ) : void 0;
          }, e.ID = "editor.contrib.inPlaceReplaceController", e.DECORATION = f.a.register( {
            className: "valueSetReplacement"
          } ), e = v( [ y( 1, l.a ) ], e );
        } )(),
        C = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.inPlaceReplace.up",
              label: i.a( "InPlaceReplaceAction.previous.label", "Replace with Previous Value" ),
              alias: "Replace with Previous Value",
              precondition: a.a.writable,
              kbOpts: {
                kbExpr: a.a.editorTextFocus,
                primary: 3154,
                weight: 100
              }
            } ) || this
          }
          return _( t, e ), t.prototype.run = function ( e, t ) {
            const n = b.get( t );
            if ( n ) return o.b.wrap( n.run( this.id, !0 ) )
          }, t;
        } )( u.b ),
        w = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.inPlaceReplace.down",
              label: i.a( "InPlaceReplaceAction.next.label", "Replace with Next Value" ),
              alias: "Replace with Next Value",
              precondition: a.a.writable,
              kbOpts: {
                kbExpr: a.a.editorTextFocus,
                primary: 3156,
                weight: 100
              }
            } ) || this
          }
          return _( t, e ), t.prototype.run = function ( e, t ) {
            const n = b.get( t );
            if ( n ) return o.b.wrap( n.run( this.id, !1 ) )
          }, t;
        } )( u.b );
      Object( u.h )( b ), Object( u.f )( C ), Object( u.f )( w ), Object( h.e )( ( ( e, t ) => {
        const n = e.getColor( p.d );
        n && t.addRule( ".monaco-editor.vs .valueSetReplacement { outline: solid 2px " + n + "; }" )
      } ) )
    },
    Gw4z( e, t, n ) {
      "use strict";
      const i = ( () => {
        function e( e, t, n, i ) {
          this.originalStart = e, this.originalLength = t, this.modifiedStart = n, this.modifiedLength = i
        }
        return e.prototype.getOriginalEnd = function () {
          return this.originalStart + this.originalLength
        }, e.prototype.getModifiedEnd = function () {
          return this.modifiedStart + this.modifiedLength
        }, e
      } )();

      function o( e ) {
        return {
          getLength() {
            return e.length
          },
          getElementAtIndex( t ) {
            return e.charCodeAt( t )
          }
        };
      }

      function r( e, t, n ) {
        return new l( o( e ), o( t ) ).ComputeDiff( n )
      }
      n.d( t, "b", ( () => {
        return r
      } ) ), n.d( t, "a", ( () => {
        return l
      } ) );
      const s = ( () => {
        function e() {}
        return e.Assert = ( e, t ) => {
          if ( !e ) throw new Error( t )
        }, e;
      } )();
      const a = ( () => {
        function e() {}
        return e.Copy = ( e, t, n, i, o ) => {
          for ( let r = 0; r < o; r++ ) n[ i + r ] = e[ t + r ]
        }, e;
      } )();
      const u = ( () => {
        function e() {
          this.m_changes = [], this.m_originalStart = Number.MAX_VALUE, this.m_modifiedStart = Number.MAX_VALUE, this.m_originalCount = 0, this.m_modifiedCount = 0
        }
        return e.prototype.MarkNextChange = function () {
          ( this.m_originalCount > 0 || this.m_modifiedCount > 0 ) && this.m_changes.push( new i( this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount ) ), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = Number.MAX_VALUE, this.m_modifiedStart = Number.MAX_VALUE
        }, e.prototype.AddOriginalElement = function ( e, t ) {
          this.m_originalStart = Math.min( this.m_originalStart, e ), this.m_modifiedStart = Math.min( this.m_modifiedStart, t ), this.m_originalCount++
        }, e.prototype.AddModifiedElement = function ( e, t ) {
          this.m_originalStart = Math.min( this.m_originalStart, e ), this.m_modifiedStart = Math.min( this.m_modifiedStart, t ), this.m_modifiedCount++
        }, e.prototype.getChanges = function () {
          return ( this.m_originalCount > 0 || this.m_modifiedCount > 0 ) && this.MarkNextChange(), this.m_changes
        }, e.prototype.getReverseChanges = function () {
          return ( this.m_originalCount > 0 || this.m_modifiedCount > 0 ) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes
        }, e
      } )();

      var l = ( () => {
        function e( e, t, n ) {
          void 0 === n && ( n = null ), this.OriginalSequence = e, this.ModifiedSequence = t, this.ContinueProcessingPredicate = n, this.m_forwardHistory = [], this.m_reverseHistory = []
        }
        return e.prototype.ElementsAreEqual = function ( e, t ) {
          return this.OriginalSequence.getElementAtIndex( e ) === this.ModifiedSequence.getElementAtIndex( t )
        }, e.prototype.OriginalElementsAreEqual = function ( e, t ) {
          return this.OriginalSequence.getElementAtIndex( e ) === this.OriginalSequence.getElementAtIndex( t )
        }, e.prototype.ModifiedElementsAreEqual = function ( e, t ) {
          return this.ModifiedSequence.getElementAtIndex( e ) === this.ModifiedSequence.getElementAtIndex( t )
        }, e.prototype.ComputeDiff = function ( e ) {
          return this._ComputeDiff( 0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1, e )
        }, e.prototype._ComputeDiff = function ( e, t, n, i, o ) {
          const r = this.ComputeDiffRecursive( e, t, n, i, [ !1 ] );
          return o ? this.ShiftChanges( r ) : r
        }, e.prototype.ComputeDiffRecursive = function ( e, t, n, o, r ) {
          for ( r[ 0 ] = !1; e <= t && n <= o && this.ElementsAreEqual( e, n ); ) e++, n++;
          for ( ; t >= e && o >= n && this.ElementsAreEqual( t, o ); ) t--, o--;
          if ( e > t || n > o ) {
            let a = void 0;
            return n <= o ? ( s.Assert( e === t + 1, "originalStart should only be one more than originalEnd" ), a = [ new i( e, 0, n, o - n + 1 ) ] ) : e <= t ? ( s.Assert( n === o + 1, "modifiedStart should only be one more than modifiedEnd" ), a = [ new i( e, t - e + 1, n, 0 ) ] ) : ( s.Assert( e === t + 1, "originalStart should only be one more than originalEnd" ), s.Assert( n === o + 1, "modifiedStart should only be one more than modifiedEnd" ), a = [] ), a
          }
          const u = [ 0 ],
            l = [ 0 ],
            c = this.ComputeRecursionPoint( e, t, n, o, u, l, r ),
            d = u[ 0 ],
            h = l[ 0 ];
          if ( null !== c ) return c;
          if ( !r[ 0 ] ) {
            const p = this.ComputeDiffRecursive( e, d, n, h, r );
            let f = [];
            return f = r[ 0 ] ? [ new i( d + 1, t - ( d + 1 ) + 1, h + 1, o - ( h + 1 ) + 1 ) ] : this.ComputeDiffRecursive( d + 1, t, h + 1, o, r ), this.ConcatenateChanges( p, f )
          }
          return [ new i( e, t - e + 1, n, o - n + 1 ) ]
        }, e.prototype.WALKTRACE = function ( e, t, n, o, r, s, a, l, c, d, h, p, f, g, m, _, v, y ) {
          let b, C, w = null,
            S = new u,
            O = t,
            L = n,
            x = f[ 0 ] - _[ 0 ] - o,
            N = Number.MIN_VALUE,
            E = this.m_forwardHistory.length - 1;
          do {
            ( C = x + e ) === O || C < L && c[ C - 1 ] < c[ C + 1 ] ? ( g = ( h = c[ C + 1 ] ) - x - o, h < N && S.MarkNextChange(), N = h, S.AddModifiedElement( h + 1, g ), x = C + 1 - e ) : ( g = ( h = c[ C - 1 ] + 1 ) - x - o, h < N && S.MarkNextChange(), N = h - 1, S.AddOriginalElement( h, g + 1 ), x = C - 1 - e ), E >= 0 && ( e = ( c = this.m_forwardHistory[ E ] )[ 0 ], O = 1, L = c.length - 1 )
          } while ( --E >= -1 );
          if ( b = S.getReverseChanges(), y[ 0 ] ) {
            let k = f[ 0 ] + 1,
              I = _[ 0 ] + 1;
            if ( null !== b && b.length > 0 ) {
              const D = b[ b.length - 1 ];
              k = Math.max( k, D.getOriginalEnd() ), I = Math.max( I, D.getModifiedEnd() )
            }
            w = [ new i( k, p - k + 1, I, m - I + 1 ) ]
          } else {
            S = new u, O = s, L = a, x = f[ 0 ] - _[ 0 ] - l, N = Number.MAX_VALUE, E = v ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
            do {
              ( C = x + r ) === O || C < L && d[ C - 1 ] >= d[ C + 1 ] ? ( g = ( h = d[ C + 1 ] - 1 ) - x - l, h > N && S.MarkNextChange(), N = h + 1, S.AddOriginalElement( h + 1, g + 1 ), x = C + 1 - r ) : ( g = ( h = d[ C - 1 ] ) - x - l, h > N && S.MarkNextChange(), N = h, S.AddModifiedElement( h + 1, g + 1 ), x = C - 1 - r ), E >= 0 && ( r = ( d = this.m_reverseHistory[ E ] )[ 0 ], O = 1, L = d.length - 1 )
            } while ( --E >= -1 );
            w = S.getChanges()
          }
          return this.ConcatenateChanges( b, w )
        }, e.prototype.ComputeRecursionPoint = function ( e, t, n, o, r, s, u ) {
          let l, c, d, h = 0,
            p = 0,
            f = 0,
            g = 0;
          e--, n--, r[ 0 ] = 0, s[ 0 ] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
          let m;
          let _;
          const v = t - e + ( o - n );
          const y = v + 1;
          const b = new Array( y );
          const C = new Array( y );
          const w = o - n;
          const S = t - e;
          const O = e - n;
          const L = t - o;
          const x = ( S - w ) % 2 === 0;
          for ( b[ w ] = e, C[ S ] = t, u[ 0 ] = !1, d = 1; d <= v / 2 + 1; d++ ) {
            let N = 0,
              E = 0;
            for ( h = this.ClipDiagonalBound( w - d, d, w, y ), p = this.ClipDiagonalBound( w + d, d, w, y ), m = h; m <= p; m += 2 ) {
              for ( c = ( l = m === h || m < p && b[ m - 1 ] < b[ m + 1 ] ? b[ m + 1 ] : b[ m - 1 ] + 1 ) - ( m - w ) - O, _ = l; l < t && c < o && this.ElementsAreEqual( l + 1, c + 1 ); ) l++, c++;
              if ( b[ m ] = l, l + c > N + E && ( N = l, E = c ), !x && Math.abs( m - S ) <= d - 1 && l >= C[ m ] ) return r[ 0 ] = l, s[ 0 ] = c, _ <= C[ m ] && d <= 1448 ? this.WALKTRACE( w, h, p, O, S, f, g, L, b, C, l, t, r, c, o, s, x, u ) : null
            }
            const k = ( N - e + ( E - n ) - d ) / 2;
            if ( null !== this.ContinueProcessingPredicate && !this.ContinueProcessingPredicate( N, this.OriginalSequence, k ) ) return u[ 0 ] = !0, r[ 0 ] = N, s[ 0 ] = E, k > 0 && d <= 1448 ? this.WALKTRACE( w, h, p, O, S, f, g, L, b, C, l, t, r, c, o, s, x, u ) : ( e++, n++, [ new i( e, t - e + 1, n, o - n + 1 ) ] );
            for ( f = this.ClipDiagonalBound( S - d, d, S, y ), g = this.ClipDiagonalBound( S + d, d, S, y ), m = f; m <= g; m += 2 ) {
              for ( c = ( l = m === f || m < g && C[ m - 1 ] >= C[ m + 1 ] ? C[ m + 1 ] - 1 : C[ m - 1 ] ) - ( m - S ) - L, _ = l; l > e && c > n && this.ElementsAreEqual( l, c ); ) l--, c--;
              if ( C[ m ] = l, x && Math.abs( m - w ) <= d && l <= b[ m ] ) return r[ 0 ] = l, s[ 0 ] = c, _ >= b[ m ] && d <= 1448 ? this.WALKTRACE( w, h, p, O, S, f, g, L, b, C, l, t, r, c, o, s, x, u ) : null
            }
            if ( d <= 1447 ) {
              let I = new Array( p - h + 2 );
              I[ 0 ] = w - h + 1, a.Copy( b, h, I, 1, p - h + 1 ), this.m_forwardHistory.push( I ), ( I = new Array( g - f + 2 ) )[ 0 ] = S - f + 1, a.Copy( C, f, I, 1, g - f + 1 ), this.m_reverseHistory.push( I )
            }
          }
          return this.WALKTRACE( w, h, p, O, S, f, g, L, b, C, l, t, r, c, o, s, x, u )
        }, e.prototype.ShiftChanges = function ( e ) {
          let t;
          do {
            t = !1;
            for ( var n = 0; n < e.length; n++ )
              for ( var i = e[ n ], o = n < e.length - 1 ? e[ n + 1 ].originalStart : this.OriginalSequence.getLength(), r = n < e.length - 1 ? e[ n + 1 ].modifiedStart : this.ModifiedSequence.getLength(), s = i.originalLength > 0, a = i.modifiedLength > 0; i.originalStart + i.originalLength < o && i.modifiedStart + i.modifiedLength < r && ( !s || this.OriginalElementsAreEqual( i.originalStart, i.originalStart + i.originalLength ) ) && ( !a || this.ModifiedElementsAreEqual( i.modifiedStart, i.modifiedStart + i.modifiedLength ) ); ) i.originalStart++, i.modifiedStart++;
            const u = new Array,
              l = [ null ];
            for ( n = 0; n < e.length; n++ ) n < e.length - 1 && this.ChangesOverlap( e[ n ], e[ n + 1 ], l ) ? ( t = !0, u.push( l[ 0 ] ), n++ ) : u.push( e[ n ] );
            e = u
          } while ( t );
          for ( n = e.length - 1; n >= 0; n-- ) {
            i = e[ n ], o = 0, r = 0;
            if ( n > 0 ) {
              const c = e[ n - 1 ];
              c.originalLength > 0 && ( o = c.originalStart + c.originalLength ), c.modifiedLength > 0 && ( r = c.modifiedStart + c.modifiedLength )
            }
            s = i.originalLength > 0, a = i.modifiedLength > 0;
            for ( var d = 0, h = this._boundaryScore( i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength ), p = 1;; p++ ) {
              const f = i.originalStart - p,
                g = i.modifiedStart - p;
              if ( f < o || g < r ) break;
              if ( s && !this.OriginalElementsAreEqual( f, f + i.originalLength ) ) break;
              if ( a && !this.ModifiedElementsAreEqual( g, g + i.modifiedLength ) ) break;
              const m = this._boundaryScore( f, i.originalLength, g, i.modifiedLength );
              m > h && ( h = m, d = p )
            }
            i.originalStart -= d, i.modifiedStart -= d
          }
          return e
        }, e.prototype._OriginalIsBoundary = function ( e ) {
          if ( e <= 0 || e >= this.OriginalSequence.getLength() - 1 ) return !0;
          const t = this.OriginalSequence.getElementAtIndex( e );
          return "string" === typeof t && /^\s*$/.test( t )
        }, e.prototype._OriginalRegionIsBoundary = function ( e, t ) {
          if ( this._OriginalIsBoundary( e ) || this._OriginalIsBoundary( e - 1 ) ) return !0;
          if ( t > 0 ) {
            const n = e + t;
            if ( this._OriginalIsBoundary( n - 1 ) || this._OriginalIsBoundary( n ) ) return !0
          }
          return !1
        }, e.prototype._ModifiedIsBoundary = function ( e ) {
          if ( e <= 0 || e >= this.ModifiedSequence.getLength() - 1 ) return !0;
          const t = this.ModifiedSequence.getElementAtIndex( e );
          return "string" === typeof t && /^\s*$/.test( t )
        }, e.prototype._ModifiedRegionIsBoundary = function ( e, t ) {
          if ( this._ModifiedIsBoundary( e ) || this._ModifiedIsBoundary( e - 1 ) ) return !0;
          if ( t > 0 ) {
            const n = e + t;
            if ( this._ModifiedIsBoundary( n - 1 ) || this._ModifiedIsBoundary( n ) ) return !0
          }
          return !1
        }, e.prototype._boundaryScore = function ( e, t, n, i ) {
          return ( this._OriginalRegionIsBoundary( e, t ) ? 1 : 0 ) + ( this._ModifiedRegionIsBoundary( n, i ) ? 1 : 0 )
        }, e.prototype.ConcatenateChanges = function ( e, t ) {
          const n = [];
          let i = null;
          return 0 === e.length || 0 === t.length ? t.length > 0 ? t : e : this.ChangesOverlap( e[ e.length - 1 ], t[ 0 ], n ) ? ( i = new Array( e.length + t.length - 1 ), a.Copy( e, 0, i, 0, e.length - 1 ), i[ e.length - 1 ] = n[ 0 ], a.Copy( t, 1, i, e.length, t.length - 1 ), i ) : ( i = new Array( e.length + t.length ), a.Copy( e, 0, i, 0, e.length ), a.Copy( t, 0, i, e.length, t.length ), i )
        }, e.prototype.ChangesOverlap = ( e, t, n ) => {
          if ( s.Assert( e.originalStart <= t.originalStart, "Left change is not less than or equal to right change" ), s.Assert( e.modifiedStart <= t.modifiedStart, "Left change is not less than or equal to right change" ), e.originalStart + e.originalLength >= t.originalStart || e.modifiedStart + e.modifiedLength >= t.modifiedStart ) {
            const o = e.originalStart;
            let r = e.originalLength;
            const a = e.modifiedStart;
            let u = e.modifiedLength;
            return e.originalStart + e.originalLength >= t.originalStart && ( r = t.originalStart + t.originalLength - e.originalStart ), e.modifiedStart + e.modifiedLength >= t.modifiedStart && ( u = t.modifiedStart + t.modifiedLength - e.modifiedStart ), n[ 0 ] = new i( o, r, a, u ), !0
          }
          return n[ 0 ] = null, !1
        }, e.prototype.ClipDiagonalBound = ( e, t, n, i ) => {
          if ( e >= 0 && e < i ) return e;
          const o = t % 2 === 0;
          return e < 0 ? o === ( n % 2 === 0 ) ? 0 : 1 : o === ( ( i - n - 1 ) % 2 === 0 ) ? i - 1 : i - 2
        }, e;
      } )();
    },
    H6Gb( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "php",
        extensions: [ ".php", ".php4", ".php5", ".phtml", ".ctp" ],
        aliases: [ "PHP", "php" ],
        mimetypes: [ "application/x-php" ],
        loader() {
          return o.Promise.wrap( n.e( 286 ).then( n.bind( null, "lXEz" ) ) )
        }
      } )
    },
    HdwC( e, t, n ) {
      "use strict";
      const i = n( "MI8n" ),
        o = n( "pmY6" ),
        r = n( "MNsG" ),
        s = n( "D3Dy" ),
        a = n( "iDAx" ),
        u = n( "+3Gp" ),
        l = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        c = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            return i.referenceDomElement = t, i.changeCallback = n, i.measureReferenceDomElementToken = -1, i.width = -1, i.height = -1, i.measureReferenceDomElement( !1 ), i
          }
          return l( t, e ), t.prototype.dispose = function () {
            this.stopObserving(), e.prototype.dispose.call( this )
          }, t.prototype.getWidth = function () {
            return this.width
          }, t.prototype.getHeight = function () {
            return this.height
          }, t.prototype.startObserving = function () {
            const e = this; - 1 === this.measureReferenceDomElementToken && ( this.measureReferenceDomElementToken = setInterval( ( () => {
              return e.measureReferenceDomElement( !0 )
            } ), 100 ) )
          }, t.prototype.stopObserving = function () {
            -1 !== this.measureReferenceDomElementToken && ( clearInterval( this.measureReferenceDomElementToken ), this.measureReferenceDomElementToken = -1 )
          }, t.prototype.observe = function ( e ) {
            this.measureReferenceDomElement( !0, e )
          }, t.prototype.measureReferenceDomElement = function ( e, t ) {
            let n = 0,
              i = 0;
            t ? ( n = t.width, i = t.height ) : this.referenceDomElement && ( n = this.referenceDomElement.clientWidth, i = this.referenceDomElement.clientHeight ), n = Math.max( 5, n ), i = Math.max( 5, i ), this.width === n && this.height === i || ( this.width = n, this.height = i, e && this.changeCallback() )
          }, t;
        } )( o.a ),
        d = ( () => {
          function e( e, t ) {
            this.chr = e, this.type = t, this.width = 0
          }
          return e.prototype.fulfill = function ( e ) {
            this.width = e
          }, e
        } )(),
        h = ( () => {
          function e( e, t ) {
            this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null
          }
          return e.prototype.read = function () {
            this._createDomElements(), document.body.appendChild( this._container ), this._readFromDomElements(), document.body.removeChild( this._container ), this._container = null, this._testElements = null
          }, e.prototype._createDomElements = function () {
            const t = document.createElement( "div" );
            t.style.position = "absolute", t.style.top = "-50000px", t.style.width = "50000px";
            const n = document.createElement( "div" );
            n.style.fontFamily = this._bareFontInfo.fontFamily, n.style.fontWeight = this._bareFontInfo.fontWeight, n.style.fontSize = this._bareFontInfo.fontSize + "px", n.style.lineHeight = this._bareFontInfo.lineHeight + "px", n.style.letterSpacing = this._bareFontInfo.letterSpacing + "px", t.appendChild( n );
            const i = document.createElement( "div" );
            i.style.fontFamily = this._bareFontInfo.fontFamily, i.style.fontWeight = "bold", i.style.fontSize = this._bareFontInfo.fontSize + "px", i.style.lineHeight = this._bareFontInfo.lineHeight + "px", i.style.letterSpacing = this._bareFontInfo.letterSpacing + "px", t.appendChild( i );
            const o = document.createElement( "div" );
            o.style.fontFamily = this._bareFontInfo.fontFamily, o.style.fontWeight = this._bareFontInfo.fontWeight, o.style.fontSize = this._bareFontInfo.fontSize + "px", o.style.lineHeight = this._bareFontInfo.lineHeight + "px", o.style.letterSpacing = this._bareFontInfo.letterSpacing + "px", o.style.fontStyle = "italic", t.appendChild( o );
            for ( var r = [], s = 0, a = this._requests.length; s < a; s++ ) {
              const u = this._requests[ s ];
              let l = void 0;
              0 === u.type && ( l = n ), 2 === u.type && ( l = i ), 1 === u.type && ( l = o ), l.appendChild( document.createElement( "br" ) );
              const c = document.createElement( "span" );
              e._render( c, u ), l.appendChild( c ), r[ s ] = c
            }
            this._container = t, this._testElements = r
          }, e._render = ( e, t ) => {
            if ( " " === t.chr ) {
              for ( var n = "&nbsp;", i = 0; i < 8; i++ ) n += n;
              e.innerHTML = n
            } else {
              let o = t.chr;
              for ( i = 0; i < 8; i++ ) o += o;
              e.textContent = o
            }
          }, e.prototype._readFromDomElements = function () {
            for ( let e = 0, t = this._requests.length; e < t; e++ ) {
              const n = this._requests[ e ],
                i = this._testElements[ e ];
              n.fulfill( i.offsetWidth / 256 )
            }
          }, e;
        } )();
      n.d( t, "a", ( () => {
        return m
      } ) );
      const p = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const f = ( () => {
        function e() {
          this._keys = Object.create( null ), this._values = Object.create( null )
        }
        return e.prototype.has = function ( e ) {
          const t = e.getId();
          return !!this._values[ t ]
        }, e.prototype.get = function ( e ) {
          const t = e.getId();
          return this._values[ t ]
        }, e.prototype.put = function ( e, t ) {
          const n = e.getId();
          this._keys[ n ] = e, this._values[ n ] = t
        }, e.prototype.remove = function ( e ) {
          const t = e.getId();
          delete this._keys[ t ], delete this._values[ t ]
        }, e.prototype.getValues = function () {
          const e = this;
          return Object.keys( this._keys ).map( ( t => {
            return e._values[ t ]
          } ) );
        }, e;
      } )();
      const g = ( e => {
        function t() {
          const t = e.call( this ) || this;
          return t._onDidChange = t._register( new i.a ), t.onDidChange = t._onDidChange.event, t._cache = new f, t._evictUntrustedReadingsTimeout = -1, t
        }
        return p( t, e ), t.prototype.dispose = function () {
          -1 !== this._evictUntrustedReadingsTimeout && ( clearTimeout( this._evictUntrustedReadingsTimeout ), this._evictUntrustedReadingsTimeout = -1 ), e.prototype.dispose.call( this )
        }, t.prototype._writeToCache = function ( e, t ) {
          const n = this;
          this._cache.put( e, t ), t.isTrusted || -1 !== this._evictUntrustedReadingsTimeout || ( this._evictUntrustedReadingsTimeout = setTimeout( ( () => {
            n._evictUntrustedReadingsTimeout = -1, n._evictUntrustedReadings()
          } ), 5e3 ) )
        }, t.prototype._evictUntrustedReadings = function () {
          for ( var e = this._cache.getValues(), t = !1, n = 0, i = e.length; n < i; n++ ) {
            const o = e[ n ];
            o.isTrusted || ( t = !0, this._cache.remove( o ) )
          }
          t && this._onDidChange.fire()
        }, t.prototype.readConfiguration = function ( e ) {
          if ( !this._cache.has( e ) ) {
            let n = t._actualReadConfiguration( e );
            ( n.typicalHalfwidthCharacterWidth <= 2 || n.typicalFullwidthCharacterWidth <= 2 || n.spaceWidth <= 2 || n.maxDigitWidth <= 2 ) && ( n = new u.b( {
              zoomLevel: s.d(),
              fontFamily: n.fontFamily,
              fontWeight: n.fontWeight,
              fontSize: n.fontSize,
              lineHeight: n.lineHeight,
              letterSpacing: n.letterSpacing,
              isMonospace: n.isMonospace,
              typicalHalfwidthCharacterWidth: Math.max( n.typicalHalfwidthCharacterWidth, 5 ),
              typicalFullwidthCharacterWidth: Math.max( n.typicalFullwidthCharacterWidth, 5 ),
              spaceWidth: Math.max( n.spaceWidth, 5 ),
              maxDigitWidth: Math.max( n.maxDigitWidth, 5 )
            }, !1 ) ), this._writeToCache( e, n )
          }
          return this._cache.get( e )
        }, t.createRequest = ( e, t, n, i ) => {
          const o = new d( e, t );
          return n.push( o ), i && i.push( o ), o
        }, t._actualReadConfiguration = function ( e ) {
          const t = [],
            n = [],
            i = this.createRequest( "n", 0, t, n ),
            o = this.createRequest( "\uff4d", 0, t, null ),
            r = this.createRequest( " ", 0, t, n ),
            a = this.createRequest( "0", 0, t, n ),
            l = this.createRequest( "1", 0, t, n ),
            c = this.createRequest( "2", 0, t, n ),
            d = this.createRequest( "3", 0, t, n ),
            p = this.createRequest( "4", 0, t, n ),
            f = this.createRequest( "5", 0, t, n ),
            g = this.createRequest( "6", 0, t, n ),
            m = this.createRequest( "7", 0, t, n ),
            _ = this.createRequest( "8", 0, t, n ),
            v = this.createRequest( "9", 0, t, n );
          this.createRequest( "\u2192", 0, t, n ), this.createRequest( "\xb7", 0, t, n ), this.createRequest( "|", 0, t, n ), this.createRequest( "/", 0, t, n ), this.createRequest( "-", 0, t, n ), this.createRequest( "_", 0, t, n ), this.createRequest( "i", 0, t, n ), this.createRequest( "l", 0, t, n ), this.createRequest( "m", 0, t, n ), this.createRequest( "|", 1, t, n ), this.createRequest( "_", 1, t, n ), this.createRequest( "i", 1, t, n ), this.createRequest( "l", 1, t, n ), this.createRequest( "m", 1, t, n ), this.createRequest( "n", 1, t, n ), this.createRequest( "|", 2, t, n ), this.createRequest( "_", 2, t, n ), this.createRequest( "i", 2, t, n ), this.createRequest( "l", 2, t, n ), this.createRequest( "m", 2, t, n ), this.createRequest( "n", 2, t, n ), ( ( e, t ) => {
            new h( e, t ).read()
          } )( e, t );
          for ( var y = Math.max( a.width, l.width, c.width, d.width, p.width, f.width, g.width, m.width, _.width, v.width ), b = !0, C = n[ 0 ].width, w = 1, S = n.length; w < S; w++ ) {
            const O = C - n[ w ].width;
            if ( O < -.001 || O > .001 ) {
              b = !1;
              break
            }
          }
          const L = s.c() > 2e3;
          return new u.b( {
            zoomLevel: s.d(),
            fontFamily: e.fontFamily,
            fontWeight: e.fontWeight,
            fontSize: e.fontSize,
            lineHeight: e.lineHeight,
            letterSpacing: e.letterSpacing,
            isMonospace: b,
            typicalHalfwidthCharacterWidth: i.width,
            typicalFullwidthCharacterWidth: o.width,
            spaceWidth: r.width,
            maxDigitWidth: y
          }, L )
        }, t.INSTANCE = new t, t;
      } )( o.a );
      var m = ( e => {
        function t( t, n ) {
          void 0 === n && ( n = null );
          const i = e.call( this, t ) || this;
          return i._elementSizeObserver = i._register( new c( n, ( () => {
            return i._onReferenceDomElementSizeChanged()
          } ) ) ), i._register( g.INSTANCE.onDidChange( ( () => {
            return i._onCSSBasedConfigurationChanged()
          } ) ) ), i._validatedOptions.automaticLayout && i._elementSizeObserver.startObserving(), i._register( s.p( ( e => {
            return i._recomputeOptions()
          } ) ) ), i._register( s.o( ( () => {
            return i._recomputeOptions()
          } ) ) ), i._recomputeOptions(), i;
        }
        return p( t, e ), t._massageFontFamily = e => {
          return /[,"']/.test( e ) ? e : /[+ ]/.test( e ) ? '"' + e + '"' : e
        }, t.applyFontInfoSlow = ( e, n ) => {
          e.style.fontFamily = t._massageFontFamily( n.fontFamily ), e.style.fontWeight = n.fontWeight, e.style.fontSize = n.fontSize + "px", e.style.lineHeight = n.lineHeight + "px", e.style.letterSpacing = n.letterSpacing + "px"
        }, t.applyFontInfo = ( e, n ) => {
          e.setFontFamily( t._massageFontFamily( n.fontFamily ) ), e.setFontWeight( n.fontWeight ), e.setFontSize( n.fontSize ), e.setLineHeight( n.lineHeight ), e.setLetterSpacing( n.letterSpacing )
        }, t.prototype._onReferenceDomElementSizeChanged = function () {
          this._recomputeOptions()
        }, t.prototype._onCSSBasedConfigurationChanged = function () {
          this._recomputeOptions()
        }, t.prototype.observeReferenceElement = function ( e ) {
          this._elementSizeObserver.observe( e )
        }, t.prototype.dispose = function () {
          e.prototype.dispose.call( this )
        }, t.prototype._getExtraEditorClassName = () => {
          let e = "";
          return s.k ? e += "ie " : s.j ? e += "ff " : s.g ? e += "edge " : s.m && ( e += "safari " ), r.d && ( e += "mac " ), e
        }, t.prototype._getEnvConfiguration = function () {
          return {
            extraEditorClassName: this._getExtraEditorClassName(),
            outerWidth: this._elementSizeObserver.getWidth(),
            outerHeight: this._elementSizeObserver.getHeight(),
            emptySelectionClipboard: s.n || s.j,
            pixelRatio: s.b(),
            zoomLevel: s.d(),
            accessibilitySupport: s.a()
          }
        }, t.prototype.readConfiguration = e => {
          return g.INSTANCE.readConfiguration( e )
        }, t;
      } )( a.a );
    },
    HyZH( e, t, n ) {},
    "I/Lx": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "fsharp",
        extensions: [ ".fs", ".fsi", ".fsx", ".fsscript" ],
        aliases: [ "F#", "FSharp", "fsharp" ],
        loader() {
          return o.Promise.wrap( n.e( 265 ).then( n.bind( null, "yswY" ) ) )
        }
      } )
    },
    "J+ZK": function ( e, t, n ) {},
    "JQT/": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "b", ( () => {
        return a
      } ) );
      var i;
      const o = n( "MI8n" );
      const r = Object.freeze( ( ( e, t ) => {
        const n = setTimeout( e.bind( t ), 0 );
        return {
          dispose() {
            clearTimeout( n )
          }
        };
      } ) );
      !( e => {
        e.None = Object.freeze( {
          isCancellationRequested: !1,
          onCancellationRequested: o.b.None
        } ), e.Cancelled = Object.freeze( {
          isCancellationRequested: !0,
          onCancellationRequested: r
        } )
      } )( i || ( i = {} ) );
      const s = ( () => {
        function e() {
          this._isCancelled = !1
        }
        return e.prototype.cancel = function () {
          this._isCancelled || ( this._isCancelled = !0, this._emitter && ( this._emitter.fire( void 0 ), this.dispose() ) )
        }, Object.defineProperty( e.prototype, "isCancellationRequested", {
          get() {
            return this._isCancelled
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "onCancellationRequested", {
          get() {
            return this._isCancelled ? r : ( this._emitter || ( this._emitter = new o.a ), this._emitter.event )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.dispose = function () {
          this._emitter && ( this._emitter.dispose(), this._emitter = void 0 )
        }, e;
      } )();
      var a = ( () => {
        function e() {}
        return Object.defineProperty( e.prototype, "token", {
          get() {
            return this._token || ( this._token = new s ), this._token
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.cancel = function () {
          this._token ? this._token instanceof s && this._token.cancel() : this._token = i.Cancelled
        }, e.prototype.dispose = function () {
          this._token ? this._token instanceof s && this._token.dispose() : this._token = i.None
        }, e;
      } )();
    },
    JYp7( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return r
      } ) ), n.d( t, "b", ( () => {
        return s
      } ) ), n.d( t, "c", ( () => {
        return a
      } ) );
      let i;
      const o = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      !( e => {
        const t = {
          next() {
            return {
              done: !0,
              value: void 0
            }
          }
        };

        function n( e, t ) {
          for ( let n = e.next(); !n.done; n = e.next() ) t( n.value )
        }
        e.empty = () => {
          return t
        }, e.iterate = ( e, t, n ) => {
          return void 0 === t && ( t = 0 ), void 0 === n && ( n = e.length ), {
            next() {
              return t >= n ? {
                done: !0,
                value: void 0
              } : {
                done: !1,
                value: e[ t++ ]
              }
            }
          };
        }, e.map = ( e, t ) => {
          return {
            next() {
              const n = e.next(),
                i = n.done,
                o = n.value;
              return {
                done: i,
                value: i ? void 0 : t( o )
              }
            }
          };
        }, e.filter = ( e, t ) => {
          return {
            next() {
              for ( ;; ) {
                const n = e.next(),
                  i = n.done,
                  o = n.value;
                if ( i ) return {
                  done: i,
                  value: void 0
                };
                if ( t( o ) ) return {
                  done: i,
                  value: o
                }
              }
            }
          };
        }, e.forEach = n, e.collect = e => {
          const t = [];
          return n( e, ( e => {
            return t.push( e )
          } ) ), t;
        }
      } )( i || ( i = {} ) );
      var r = ( () => {
          function e( e, t, n, i ) {
            void 0 === t && ( t = 0 ), void 0 === n && ( n = e.length ), void 0 === i && ( i = t - 1 ), this.items = e, this.start = t, this.end = n, this.index = i
          }
          return e.prototype.next = function () {
            return this.index = Math.min( this.index + 1, this.end ), this.current()
          }, e.prototype.current = function () {
            return this.index === this.start - 1 || this.index === this.end ? null : this.items[ this.index ]
          }, e
        } )(),
        s = ( e => {
          function t( t, n, i, o ) {
            return void 0 === n && ( n = 0 ), void 0 === i && ( i = t.length ), void 0 === o && ( o = n - 1 ), e.call( this, t, n, i, o ) || this
          }
          return o( t, e ), t.prototype.current = function () {
            return e.prototype.current.call( this )
          }, t.prototype.previous = function () {
            return this.index = Math.max( this.index - 1, this.start - 1 ), this.current()
          }, t.prototype.first = function () {
            return this.index = this.start, this.current()
          }, t.prototype.last = function () {
            return this.index = this.end - 1, this.current()
          }, t.prototype.parent = () => {
            return null
          }, t;
        } )( r ),
        a = ( () => {
          function e( e, t ) {
            this.iterator = e, this.fn = t
          }
          return e.prototype.next = function () {
            return this.fn( this.iterator.next() )
          }, e
        } )()
    },
    JlLP( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "powerquery",
        extensions: [ ".pq", ".pqm" ],
        aliases: [ "PQ", "M", "Power Query", "Power Query M" ],
        loader() {
          return o.Promise.wrap( n.e( 288 ).then( n.bind( null, "W1QP" ) ) )
        }
      } )
    },
    KDc4( e, t, n ) {
      "use strict";
      let i;
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "b", ( () => {
        return o
      } ) ), ( e => {
        e[ e.None = 0 ] = "None", e[ e.Indent = 1 ] = "Indent", e[ e.IndentOutdent = 2 ] = "IndentOutdent", e[ e.Outdent = 3 ] = "Outdent"
      } )( i || ( i = {} ) );
      var o = ( () => {
        function e( e ) {
          if ( this.open = e.open, this.close = e.close, this._standardTokenMask = 0, Array.isArray( e.notIn ) )
            for ( let t = 0, n = e.notIn.length; t < n; t++ ) {
              switch ( e.notIn[ t ] ) {
                case "string":
                  this._standardTokenMask |= 2;
                  break;
                case "comment":
                  this._standardTokenMask |= 1;
                  break;
                case "regex":
                  this._standardTokenMask |= 4
              }
            }
        }
        return e.prototype.isOK = function ( e ) {
          return 0 === ( this._standardTokenMask & e )
        }, e
      } )()
    },
    KTWA( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "wQH0" ),
        r = n( "sswD" ),
        s = n( "aokT" ),
        a = ( () => {
          function e( e, t ) {
            this._selection = e, this._isMovingLeft = t
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            const n = this._selection;
            if ( this._selectionId = t.trackSelection( n ), n.startLineNumber === n.endLineNumber && ( !this._isMovingLeft || 0 !== n.startColumn ) && ( this._isMovingLeft || n.endColumn !== e.getLineMaxColumn( n.startLineNumber ) ) ) {
              let i;
              let o;
              let r;
              const a = n.selectionStartLineNumber;
              const u = e.getLineContent( a );
              this._isMovingLeft ? ( i = u.substring( 0, n.startColumn - 2 ), o = u.substring( n.startColumn - 1, n.endColumn - 1 ), r = u.substring( n.startColumn - 2, n.startColumn - 1 ) + u.substring( n.endColumn - 1 ) ) : ( i = u.substring( 0, n.startColumn - 1 ) + u.substring( n.endColumn - 1, n.endColumn ), o = u.substring( n.startColumn - 1, n.endColumn - 1 ), r = u.substring( n.endColumn ) );
              const l = i + o + r;
              t.addEditOperation( new s.a( a, 1, a, e.getLineMaxColumn( a ) ), null ), t.addEditOperation( new s.a( a, 1, a, 1 ), l ), this._cutStartIndex = n.startColumn + ( this._isMovingLeft ? -1 : 1 ), this._cutEndIndex = this._cutStartIndex + n.endColumn - n.startColumn, this._moved = !0
            }
          }, e.prototype.computeCursorState = function ( e, t ) {
            let n = t.getTrackedSelection( this._selectionId );
            return this._moved && ( n = ( n = n.setStartPosition( n.startLineNumber, this._cutStartIndex ) ).setEndPosition( n.startLineNumber, this._cutEndIndex ) ), n
          }, e;
        } )(),
        u = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        l = ( e => {
          function t( t, n ) {
            const i = e.call( this, n ) || this;
            return i.left = t, i
          }
          return u( t, e ), t.prototype.run = function ( e, t ) {
            for ( var n = [], i = t.getSelections(), o = 0; o < i.length; o++ ) n.push( new a( i[ o ], this.left ) );
            t.pushUndoStop(), t.executeCommands( this.id, n ), t.pushUndoStop()
          }, t
        } )( r.b ),
        c = ( e => {
          function t() {
            return e.call( this, !0, {
              id: "editor.action.moveCarretLeftAction",
              label: i.a( "caret.moveLeft", "Move Caret Left" ),
              alias: "Move Caret Left",
              precondition: o.a.writable
            } ) || this
          }
          return u( t, e ), t
        } )( l ),
        d = ( e => {
          function t() {
            return e.call( this, !1, {
              id: "editor.action.moveCarretRightAction",
              label: i.a( "caret.moveRight", "Move Caret Right" ),
              alias: "Move Caret Right",
              precondition: o.a.writable
            } ) || this
          }
          return u( t, e ), t
        } )( l );
      Object( r.f )( c ), Object( r.f )( d )
    },
    KgQ1( e, t, n ) {},
    Krc3( e, t, n ) {},
    LCkn( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "d", ( () => {
        return r
      } ) ), n.d( t, "c", ( () => {
        return s
      } ) ), n.d( t, "b", ( () => {
        return a
      } ) );
      const i = n( "gCVg" );
      var o = ( () => {
        function e( e, t, n ) {
          void 0 === n && ( n = !1 ), this._range = e, this._text = t, this.insertsAutoWhitespace = n
        }
        return e.prototype.getEditOperations = function ( e, t ) {
          t.addTrackedEditOperation( this._range, this._text )
        }, e.prototype.computeCursorState = ( e, t ) => {
          const n = t.getInverseEditOperations()[ 0 ].range;
          return new i.a( n.endLineNumber, n.endColumn, n.endLineNumber, n.endColumn )
        }, e;
      } )();
      var r = ( () => {
        function e( e, t, n ) {
          void 0 === n && ( n = !1 ), this._range = e, this._text = t, this.insertsAutoWhitespace = n
        }
        return e.prototype.getEditOperations = function ( e, t ) {
          t.addTrackedEditOperation( this._range, this._text )
        }, e.prototype.computeCursorState = ( e, t ) => {
          const n = t.getInverseEditOperations()[ 0 ].range;
          return new i.a( n.startLineNumber, n.startColumn, n.startLineNumber, n.startColumn )
        }, e;
      } )();
      var s = ( () => {
        function e( e, t, n, i, o ) {
          void 0 === o && ( o = !1 ), this._range = e, this._text = t, this._columnDeltaOffset = i, this._lineNumberDeltaOffset = n, this.insertsAutoWhitespace = o
        }
        return e.prototype.getEditOperations = function ( e, t ) {
          t.addTrackedEditOperation( this._range, this._text )
        }, e.prototype.computeCursorState = function ( e, t ) {
          const n = t.getInverseEditOperations()[ 0 ].range;
          return new i.a( n.endLineNumber + this._lineNumberDeltaOffset, n.endColumn + this._columnDeltaOffset, n.endLineNumber + this._lineNumberDeltaOffset, n.endColumn + this._columnDeltaOffset )
        }, e;
      } )();
      var a = ( () => {
        function e( e, t, n ) {
          this._range = e, this._text = t, this._initialSelection = n
        }
        return e.prototype.getEditOperations = function ( e, t ) {
          t.addEditOperation( this._range, this._text ), this._selectionId = t.trackSelection( this._initialSelection )
        }, e.prototype.computeCursorState = function ( e, t ) {
          return t.getTrackedSelection( this._selectionId )
        }, e
      } )();
    },
    LNDK( e, t, n ) {
      "use strict";
      n( "M/lh" ), n( "CdFp" ), n( "23p7" ), n( "CuPc" ), n( "OOlL" ), n( "li8W" ), n( "kdPm" ), n( "ApJL" ), n( "jrbv" ), n( "gqHg" ), n( "DtFZ" ), n( "p3Ex" ), n( "E+ie" ), n( "9B1q" ), n( "SvYn" ), n( "I/Lx" ), n( "e39c" ), n( "0oIH" ), n( "+a1H" ), n( "hFdI" ), n( "zQEy" ), n( "k7mE" ), n( "cldp" ), n( "2qqv" ), n( "Dvnd" ), n( "FvUK" ), n( "ZvGG" ), n( "QFiB" ), n( "ZkA/" ), n( "/cAr" ), n( "xYNL" ), n( "jVwG" ), n( "6lNC" ), n( "q8qy" ), n( "sStQ" ), n( "oKJv" ), n( "H6Gb" ), n( "y3CF" ), n( "JlLP" ), n( "j2o1" ), n( "woZy" ), n( "iLY9" ), n( "628j" ), n( "Msxo" ), n( "ajgA" ), n( "QiAa" ), n( "pI2L" ), n( "yKqg" ), n( "ij/i" ), n( "XQgg" ), n( "Gb1F" ), n( "G9H2" ), n( "xmOD" ), n( "c9ML" ), n( "Mzro" ), n( "GZrW" ), n( "1lwE" ), n( "w9QG" ), n( "ufhN" ), n( "LRks" ), n( "BUKB" ), n( "n18v" ), n( "EOst" ), n( "nrBJ" ), n( "BEdG" ), n( "E4kL" )
    },
    LRks( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "swift",
        aliases: [ "Swift", "swift" ],
        extensions: [ ".swift" ],
        mimetypes: [ "text/swift" ],
        loader() {
          return o.Promise.wrap( n.e( 309 ).then( n.bind( null, "05+/" ) ) )
        }
      } )
    },
    LUcL( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "DeleteWordPartLeft", ( () => {
        return c
      } ) ), n.d( t, "DeleteWordPartRight", ( () => {
        return d
      } ) ), n.d( t, "WordPartLeftCommand", ( () => {
        return h
      } ) ), n.d( t, "CursorWordPartLeft", ( () => {
        return p
      } ) ), n.d( t, "CursorWordPartLeftSelect", ( () => {
        return f
      } ) ), n.d( t, "WordPartRightCommand", ( () => {
        return g
      } ) ), n.d( t, "CursorWordPartRight", ( () => {
        return m
      } ) ), n.d( t, "CursorWordPartRightSelect", ( () => {
        return _
      } ) );
      const i = n( "wQH0" );
      const o = n( "sswD" );
      const r = n( "aokT" );
      const s = n( "1I1M" );
      const a = n( "s7Km" );
      const u = n( "nnTU" );
      const l = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var c = ( e => {
        function t() {
          return e.call( this, {
            whitespaceHeuristics: !0,
            wordNavigationType: 0,
            id: "deleteWordPartLeft",
            precondition: i.a.writable,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 0,
              mac: {
                primary: 769
              },
              weight: 100
            }
          } ) || this
        }
        return l( t, e ), t.prototype._delete = ( e, t, n, i, o ) => {
          const a = s.b.deleteWordPartLeft( e, t, n, i, o );
          return a || new r.a( 1, 1, 1, 1 )
        }, t;
      } )( a.DeleteWordCommand );
      var d = ( e => {
        function t() {
          return e.call( this, {
            whitespaceHeuristics: !0,
            wordNavigationType: 1,
            id: "deleteWordPartRight",
            precondition: i.a.writable,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 0,
              mac: {
                primary: 788
              },
              weight: 100
            }
          } ) || this
        }
        return l( t, e ), t.prototype._delete = ( e, t, n, i, o ) => {
          const a = s.b.deleteWordPartRight( e, t, n, i, o );
          if ( a ) return a;
          const u = t.getLineCount(),
            l = t.getLineMaxColumn( u );
          return new r.a( u, l, u, l )
        }, t;
      } )( a.DeleteWordCommand );
      var h = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return l( t, e ), t.prototype._move = ( e, t, n, i ) => {
          return s.b.moveWordPartLeft( e, t, n, i )
        }, t;
      } )( a.MoveWordCommand );
      var p = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !1,
            wordNavigationType: 0,
            id: "cursorWordPartLeft",
            precondition: null,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 0,
              mac: {
                primary: 783
              },
              weight: 100
            }
          } ) || this
        }
        return l( t, e ), t
      } )( h );
      u.a.registerCommandAlias( "cursorWordPartStartLeft", "cursorWordPartLeft" );
      var f = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !0,
            wordNavigationType: 0,
            id: "cursorWordPartLeftSelect",
            precondition: null,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 0,
              mac: {
                primary: 1807
              },
              weight: 100
            }
          } ) || this
        }
        return l( t, e ), t
      } )( h );
      u.a.registerCommandAlias( "cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect" );
      var g = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return l( t, e ), t.prototype._move = ( e, t, n, i ) => {
            return s.b.moveWordPartRight( e, t, n, i )
          }, t;
        } )( a.MoveWordCommand ),
        m = ( e => {
          function t() {
            return e.call( this, {
              inSelectionMode: !1,
              wordNavigationType: 1,
              id: "cursorWordPartRight",
              precondition: null,
              kbOpts: {
                kbExpr: i.a.textInputFocus,
                primary: 0,
                mac: {
                  primary: 785
                },
                weight: 100
              }
            } ) || this
          }
          return l( t, e ), t
        } )( g ),
        _ = ( e => {
          function t() {
            return e.call( this, {
              inSelectionMode: !0,
              wordNavigationType: 1,
              id: "cursorWordPartRightSelect",
              precondition: null,
              kbOpts: {
                kbExpr: i.a.textInputFocus,
                primary: 0,
                mac: {
                  primary: 1809
                },
                weight: 100
              }
            } ) || this
          }
          return l( t, e ), t
        } )( g );
      Object( o.g )( new c ), Object( o.g )( new d ), Object( o.g )( new p ), Object( o.g )( new f ), Object( o.g )( new m ), Object( o.g )( new _ )
    },
    "LeU+": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return r
      } ) ), n.d( t, "b", ( () => {
        return s
      } ) );
      const i = n( "UHym" );
      const o = function ( e, t ) {
        this.index = e, this.remainder = t
      };
      var r = ( () => {
        function e( e ) {
          this.values = e, this.prefixSum = new Uint32Array( e.length ), this.prefixSumValidIndex = new Int32Array( 1 ), this.prefixSumValidIndex[ 0 ] = -1
        }
        return e.prototype.getCount = function () {
          return this.values.length
        }, e.prototype.insertValues = function ( e, t ) {
          e = Object( i.b )( e );
          const n = this.values,
            o = this.prefixSum,
            r = t.length;
          return 0 !== r && ( this.values = new Uint32Array( n.length + r ), this.values.set( n.subarray( 0, e ), 0 ), this.values.set( n.subarray( e ), e + r ), this.values.set( t, e ), e - 1 < this.prefixSumValidIndex[ 0 ] && ( this.prefixSumValidIndex[ 0 ] = e - 1 ), this.prefixSum = new Uint32Array( this.values.length ), this.prefixSumValidIndex[ 0 ] >= 0 && this.prefixSum.set( o.subarray( 0, this.prefixSumValidIndex[ 0 ] + 1 ) ), !0 )
        }, e.prototype.changeValue = function ( e, t ) {
          return e = Object( i.b )( e ), t = Object( i.b )( t ), this.values[ e ] !== t && ( this.values[ e ] = t, e - 1 < this.prefixSumValidIndex[ 0 ] && ( this.prefixSumValidIndex[ 0 ] = e - 1 ), !0 )
        }, e.prototype.removeValues = function ( e, t ) {
          e = Object( i.b )( e ), t = Object( i.b )( t );
          const n = this.values,
            o = this.prefixSum;
          if ( e >= n.length ) return !1;
          const r = n.length - e;
          return t >= r && ( t = r ), 0 !== t && ( this.values = new Uint32Array( n.length - t ), this.values.set( n.subarray( 0, e ), 0 ), this.values.set( n.subarray( e + t ), e ), this.prefixSum = new Uint32Array( this.values.length ), e - 1 < this.prefixSumValidIndex[ 0 ] && ( this.prefixSumValidIndex[ 0 ] = e - 1 ), this.prefixSumValidIndex[ 0 ] >= 0 && this.prefixSum.set( o.subarray( 0, this.prefixSumValidIndex[ 0 ] + 1 ) ), !0 )
        }, e.prototype.getTotalValue = function () {
          return 0 === this.values.length ? 0 : this._getAccumulatedValue( this.values.length - 1 )
        }, e.prototype.getAccumulatedValue = function ( e ) {
          return e < 0 ? 0 : ( e = Object( i.b )( e ), this._getAccumulatedValue( e ) )
        }, e.prototype._getAccumulatedValue = function ( e ) {
          if ( e <= this.prefixSumValidIndex[ 0 ] ) return this.prefixSum[ e ];
          let t = this.prefixSumValidIndex[ 0 ] + 1;
          0 === t && ( this.prefixSum[ 0 ] = this.values[ 0 ], t++ ), e >= this.values.length && ( e = this.values.length - 1 );
          for ( let n = t; n <= e; n++ ) this.prefixSum[ n ] = this.prefixSum[ n - 1 ] + this.values[ n ];
          return this.prefixSumValidIndex[ 0 ] = Math.max( this.prefixSumValidIndex[ 0 ], e ), this.prefixSum[ e ]
        }, e.prototype.getIndexOf = function ( e ) {
          e = Math.floor( e ), this.getTotalValue();
          for ( var t, n, i, r = 0, s = this.values.length - 1; r <= s; )
            if ( t = r + ( s - r ) / 2 | 0, e < ( i = ( n = this.prefixSum[ t ] ) - this.values[ t ] ) ) s = t - 1;
            else {
              if ( !( e >= n ) ) break;
              r = t + 1
            } return new o( t, e - i )
        }, e;
      } )();
      var s = ( () => {
        function e( e ) {
          this._cacheAccumulatedValueStart = 0, this._cache = null, this._actual = new r( e ), this._bustCache()
        }
        return e.prototype._bustCache = function () {
          this._cacheAccumulatedValueStart = 0, this._cache = null
        }, e.prototype.insertValues = function ( e, t ) {
          this._actual.insertValues( e, t ) && this._bustCache()
        }, e.prototype.changeValue = function ( e, t ) {
          this._actual.changeValue( e, t ) && this._bustCache()
        }, e.prototype.removeValues = function ( e, t ) {
          this._actual.removeValues( e, t ) && this._bustCache()
        }, e.prototype.getTotalValue = function () {
          return this._actual.getTotalValue()
        }, e.prototype.getAccumulatedValue = function ( e ) {
          return this._actual.getAccumulatedValue( e )
        }, e.prototype.getIndexOf = function ( e ) {
          if ( e = Math.floor( e ), null !== this._cache ) {
            const t = e - this._cacheAccumulatedValueStart;
            if ( t >= 0 && t < this._cache.length ) return this._cache[ t ]
          }
          return this._actual.getIndexOf( e )
        }, e.prototype.warmUpCache = function ( e, t ) {
          for ( var n = [], i = e; i <= t; i++ ) n[ i - e ] = this.getIndexOf( i );
          this._cache = n, this._cacheAccumulatedValueStart = e
        }, e;
      } )();
    },
    Ll0s( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return c
      } ) ), n.d( t, "f", ( () => {
        return d
      } ) ), n.d( t, "c", ( () => {
        return h
      } ) ), n.d( t, "d", ( () => {
        return p
      } ) ), n.d( t, "e", ( () => {
        return f
      } ) ), n.d( t, "a", ( () => {
        return g
      } ) );
      const i = n( "cGHE" );
      const o = n( "N0LK" );
      const r = n( "tX9W" );
      const s = n( "gCVg" );
      const a = n( "aokT" );
      const u = n( "cMvZ" );
      const l = n( "/cxE" );
      var c = ( () => {
        function e( t, n, i, o ) {
          this._languageIdentifier = t;
          const r = o.editor;
          this.readOnly = r.readOnly, this.tabSize = i.tabSize, this.insertSpaces = i.insertSpaces, this.oneIndent = n, this.pageSize = Math.max( 1, Math.floor( r.layoutInfo.height / r.fontInfo.lineHeight ) - 2 ), this.lineHeight = r.lineHeight, this.useTabStops = r.useTabStops, this.wordSeparators = r.wordSeparators, this.emptySelectionClipboard = r.emptySelectionClipboard, this.multiCursorMergeOverlapping = r.multiCursorMergeOverlapping, this.autoClosingBrackets = r.autoClosingBrackets, this.autoIndent = r.autoIndent, this.autoClosingPairsOpen = {}, this.autoClosingPairsClose = {}, this.surroundingPairs = {}, this._electricChars = null;
          const s = e._getAutoClosingPairs( t );
          if ( s )
            for ( var a = 0; a < s.length; a++ ) this.autoClosingPairsOpen[ s[ a ].open ] = s[ a ].close, this.autoClosingPairsClose[ s[ a ].close ] = s[ a ].open;
          const u = e._getSurroundingPairs( t );
          if ( u )
            for ( a = 0; a < u.length; a++ ) this.surroundingPairs[ u[ a ].open ] = u[ a ].close
        }
        return e.shouldRecreate = e => {
          return e.layoutInfo || e.wordSeparators || e.emptySelectionClipboard || e.multiCursorMergeOverlapping || e.autoClosingBrackets || e.useTabStops || e.lineHeight || e.readOnly
        }, Object.defineProperty( e.prototype, "electricChars", {
          get() {
            if ( !this._electricChars ) {
              this._electricChars = {};
              const t = e._getElectricCharacters( this._languageIdentifier );
              if ( t )
                for ( let n = 0; n < t.length; n++ ) this._electricChars[ t[ n ] ] = !0
            }
            return this._electricChars
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.normalizeIndentation = function ( e ) {
          return r.b.normalizeIndentation( e, this.tabSize, this.insertSpaces )
        }, e._getElectricCharacters = e => {
          try {
            return u.a.getElectricCharacters( e.id )
          } catch ( t ) {
            return Object( l.e )( t ), null
          }
        }, e._getAutoClosingPairs = e => {
          try {
            return u.a.getAutoClosingPairs( e.id )
          } catch ( t ) {
            return Object( l.e )( t ), null
          }
        }, e._getSurroundingPairs = e => {
          try {
            return u.a.getSurroundingPairs( e.id )
          } catch ( t ) {
            return Object( l.e )( t ), null
          }
        }, e;
      } )();
      var d = ( () => {
        function e( t, n, i, o ) {
          this.selectionStart = t, this.selectionStartLeftoverVisibleColumns = n, this.position = i, this.leftoverVisibleColumns = o, this.selection = e._computeSelection( this.selectionStart, this.position )
        }
        return e.prototype.equals = function ( e ) {
          return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.position.equals( e.position ) && this.selectionStart.equalsRange( e.selectionStart )
        }, e.prototype.hasSelection = function () {
          return !this.selection.isEmpty() || !this.selectionStart.isEmpty()
        }, e.prototype.move = function ( t, n, o, r ) {
          return t ? new e( this.selectionStart, this.selectionStartLeftoverVisibleColumns, new i.a( n, o ), r ) : new e( new a.a( n, o, n, o ), r, new i.a( n, o ), r )
        }, e._computeSelection = ( e, t ) => {
          let n, i, o, r;
          return e.isEmpty() ? ( n = e.startLineNumber, i = e.startColumn, o = t.lineNumber, r = t.column ) : t.isBeforeOrEqual( e.getStartPosition() ) ? ( n = e.endLineNumber, i = e.endColumn, o = t.lineNumber, r = t.column ) : ( n = e.startLineNumber, i = e.startColumn, o = t.lineNumber, r = t.column ), new s.a( n, i, o, r )
        }, e;
      } )();
      var h = ( () => {
        function e( e, t, n ) {
          this.model = t, this.viewModel = n, this.config = new c( this.model.getLanguageIdentifier(), this.model.getOneIndent(), this.model.getOptions(), e )
        }
        return e.prototype.validateViewPosition = function ( e, t ) {
          return this.viewModel.coordinatesConverter.validateViewPosition( e, t )
        }, e.prototype.validateViewRange = function ( e, t ) {
          return this.viewModel.coordinatesConverter.validateViewRange( e, t )
        }, e.prototype.convertViewRangeToModelRange = function ( e ) {
          return this.viewModel.coordinatesConverter.convertViewRangeToModelRange( e )
        }, e.prototype.convertViewPositionToModelPosition = function ( e, t ) {
          return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition( new i.a( e, t ) )
        }, e.prototype.convertModelPositionToViewPosition = function ( e ) {
          return this.viewModel.coordinatesConverter.convertModelPositionToViewPosition( e )
        }, e.prototype.convertModelRangeToViewRange = function ( e ) {
          return this.viewModel.coordinatesConverter.convertModelRangeToViewRange( e )
        }, e.prototype.getCurrentScrollTop = function () {
          return this.viewModel.viewLayout.getCurrentScrollTop()
        }, e.prototype.getCompletelyVisibleViewRange = function () {
          return this.viewModel.getCompletelyVisibleViewRange()
        }, e.prototype.getCompletelyVisibleModelRange = function () {
          const e = this.viewModel.getCompletelyVisibleViewRange();
          return this.viewModel.coordinatesConverter.convertViewRangeToModelRange( e )
        }, e.prototype.getCompletelyVisibleViewRangeAtScrollTop = function ( e ) {
          return this.viewModel.getCompletelyVisibleViewRangeAtScrollTop( e )
        }, e.prototype.getVerticalOffsetForViewLine = function ( e ) {
          return this.viewModel.viewLayout.getVerticalOffsetForLineNumber( e )
        }, e;
      } )();
      var p = ( () => {
        function e( e, t ) {
          this.modelState = e, this.viewState = t
        }
        return e.fromModelState = t => {
          return new e( t, null )
        }, e.fromViewState = t => {
          return new e( null, t )
        }, e.fromModelSelection = t => {
          const n = t.selectionStartLineNumber,
            o = t.selectionStartColumn,
            r = t.positionLineNumber,
            s = t.positionColumn,
            u = new d( new a.a( n, o, n, o ), 0, new i.a( r, s ), 0 );
          return e.fromModelState( u )
        }, e.fromModelSelections = function ( e ) {
          for ( var t = [], n = 0, i = e.length; n < i; n++ ) t[ n ] = this.fromModelSelection( e[ n ] );
          return t
        }, e.prototype.equals = function ( e ) {
          return this.viewState.equals( e.viewState ) && this.modelState.equals( e.modelState )
        }, e;
      } )();
      var f = function ( e, t, n ) {
        this.type = e, this.commands = t, this.shouldPushStackElementBefore = n.shouldPushStackElementBefore, this.shouldPushStackElementAfter = n.shouldPushStackElementAfter
      };

      var g = ( () => {
        function e() {}
        return e.isLowSurrogate = ( e, t, n ) => {
          const i = e.getLineContent( t );
          return !( n < 0 || n >= i.length ) && o.isLowSurrogate( i.charCodeAt( n ) )
        }, e.isHighSurrogate = ( e, t, n ) => {
          const i = e.getLineContent( t );
          return !( n < 0 || n >= i.length ) && o.isHighSurrogate( i.charCodeAt( n ) )
        }, e.isInsideSurrogatePair = function ( e, t, n ) {
          return this.isHighSurrogate( e, t, n - 2 )
        }, e.visibleColumnFromColumn = function ( e, t, n ) {
          let i = e.length;
          i > t - 1 && ( i = t - 1 );
          for ( var r = 0, s = 0; s < i; s++ ) {
            const a = e.charCodeAt( s );
            9 === a ? r = this.nextTabStop( r, n ) : o.isFullWidthCharacter( a ) ? r += 2 : r += 1
          }
          return r
        }, e.visibleColumnFromColumn2 = function ( e, t, n ) {
          return this.visibleColumnFromColumn( t.getLineContent( n.lineNumber ), n.column, e.tabSize )
        }, e.columnFromVisibleColumn = function ( e, t, n ) {
          if ( t <= 0 ) return 1;
          for ( var i = e.length, r = 0, s = 0; s < i; s++ ) {
            const a = e.charCodeAt( s );
            let u = void 0;
            if ( ( u = 9 === a ? this.nextTabStop( r, n ) : o.isFullWidthCharacter( a ) ? r + 2 : r + 1 ) >= t ) return u - t < t - r ? s + 2 : s + 1;
            r = u
          }
          return i + 1
        }, e.columnFromVisibleColumn2 = function ( e, t, n, i ) {
          const o = this.columnFromVisibleColumn( t.getLineContent( n ), i, e.tabSize ),
            r = t.getLineMinColumn( n );
          if ( o < r ) return r;
          const s = t.getLineMaxColumn( n );
          return o > s ? s : o
        }, e.nextTabStop = ( e, t ) => {
          return e + t - e % t
        }, e.prevTabStop = ( e, t ) => {
          return e - 1 - ( e - 1 ) % t
        }, e;
      } )();
    },
    "M/lh": function ( e, t, n ) {
      let i;
      self.MonacoEnvironment = ( i = {
        editorWorkerService: "monaco/0.14.20/editor.worker.js",
        css: "monaco/0.14.20/css.worker.js",
        html: "monaco/0.14.20/html.worker.js",
        json: "monaco/0.14.20/json.worker.js",
        typescript: "monaco/0.14.20/typescript.worker.js",
        javascript: "monaco/0.14.20/typescript.worker.js",
        less: "monaco/0.14.20/css.worker.js",
        scss: "monaco/0.14.20/css.worker.js",
        handlebars: "monaco/0.14.20/html.worker.js",
        razor: "monaco/0.14.20/html.worker.js"
      }, {
        getWorkerUrl( e, t ) {
          const n = "string" === typeof window.__webpack_public_path__ ? window.__webpack_public_path__ : "/public";
          return ( n ? n.replace( /\/$/, "" ) + "/" : "" ) + i[ t ]
        }
      } ), n( "SBYE" ), n( "bk7F" ), n( "KTWA" ), n( "w29/" ), n( "CxEt" ), n( "d6R0" ), n( "kqbb" ), n( "n01l" ), n( "fD5p" ), n( "1YUG" ), n( "5RaG" ), n( "/RFl" ), n( "oQaD" ), n( "dgXF" ), n( "bfR1" ), n( "cIJc" ), n( "n3JV" ), n( "gh2A" ), n( "lY/7" ), n( "AhDq" ), n( "rugR" ), n( "GvMn" ), n( "gJAb" ), n( "oiKk" ), n( "dH+W" ), n( "2ESN" ), n( "8XyJ" ), n( "WwIK" ), n( "v+CO" ), n( "WQDh" ), n( "TC2m" ), n( "4sI4" ), n( "Q631" ), n( "10Fh" ), n( "tXSY" ), n( "ep4t" ), n( "vVA1" ), n( "k7pc" ), n( "ba9Q" ), n( "XtJs" ), n( "s7Km" ), n( "LUcL" ), e.exports = n( "8z58" ), n( "CdFp" ), n( "23p7" ), n( "CuPc" ), n( "OOlL" ), n( "li8W" ), n( "kdPm" ), n( "ApJL" ), n( "jrbv" ), n( "gqHg" ), n( "DtFZ" ), n( "p3Ex" ), n( "E+ie" ), n( "9B1q" ), n( "9XAT" ), n( "SvYn" ), n( "I/Lx" ), n( "e39c" ), n( "0oIH" ), n( "+a1H" ), n( "hFdI" ), n( "c2dO" ), n( "zQEy" ), n( "k7mE" ), n( "cldp" ), n( "p5tG" ), n( "2qqv" ), n( "Dvnd" ), n( "FvUK" ), n( "ZvGG" ), n( "QFiB" ), n( "ZkA/" ), n( "/cAr" ), n( "xYNL" ), n( "jVwG" ), n( "6lNC" ), n( "q8qy" ), n( "sStQ" ), n( "oKJv" ), n( "H6Gb" ), n( "y3CF" ), n( "JlLP" ), n( "j2o1" ), n( "woZy" ), n( "iLY9" ), n( "628j" ), n( "Msxo" ), n( "ajgA" ), n( "QiAa" ), n( "pI2L" ), n( "yKqg" ), n( "ij/i" ), n( "XQgg" ), n( "Gb1F" ), n( "G9H2" ), n( "xmOD" ), n( "c9ML" ), n( "Mzro" ), n( "GZrW" ), n( "1lwE" ), n( "w9QG" ), n( "ufhN" ), n( "LRks" ), n( "BUKB" ), n( "n18v" ), n( "EOst" ), n( "z3hU" ), n( "nrBJ" ), n( "BEdG" ), n( "E4kL" )
    },
    M1Kb( e, t, n ) {
      "use strict";
      let i, o, r, s;
      n.d( t, "f", ( () => {
        return i
      } ) ), n.d( t, "c", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) ), n.d( t, "d", ( () => {
        return s
      } ) ), n.d( t, "g", ( () => {
        return u
      } ) ), n.d( t, "e", ( () => {
        return l
      } ) ), n.d( t, "h", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return c
      } ) ), ( e => {
        e[ e.Left = 1 ] = "Left", e[ e.Center = 2 ] = "Center", e[ e.Right = 4 ] = "Right", e[ e.Full = 7 ] = "Full"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.TextDefined = 0 ] = "TextDefined", e[ e.LF = 1 ] = "LF", e[ e.CRLF = 2 ] = "CRLF"
      } )( o || ( o = {} ) ), ( e => {
        e[ e.LF = 1 ] = "LF", e[ e.CRLF = 2 ] = "CRLF"
      } )( r || ( r = {} ) ), ( e => {
        e[ e.LF = 0 ] = "LF", e[ e.CRLF = 1 ] = "CRLF"
      } )( s || ( s = {} ) );
      var a, u = ( () => {
          function e( e ) {
            this.tabSize = 0 | e.tabSize, this.insertSpaces = Boolean( e.insertSpaces ), this.defaultEOL = 0 | e.defaultEOL, this.trimAutoWhitespace = Boolean( e.trimAutoWhitespace )
          }
          return e.prototype.equals = function ( e ) {
            return this.tabSize === e.tabSize && this.insertSpaces === e.insertSpaces && this.defaultEOL === e.defaultEOL && this.trimAutoWhitespace === e.trimAutoWhitespace
          }, e.prototype.createChangeEvent = function ( e ) {
            return {
              tabSize: this.tabSize !== e.tabSize,
              insertSpaces: this.insertSpaces !== e.insertSpaces,
              trimAutoWhitespace: this.trimAutoWhitespace !== e.trimAutoWhitespace
            }
          }, e
        } )(),
        l = function ( e, t ) {
          this.range = e, this.matches = t
        };
      !( e => {
        e[ e.AlwaysGrowsWhenTypingAtEdges = 0 ] = "AlwaysGrowsWhenTypingAtEdges", e[ e.NeverGrowsWhenTypingAtEdges = 1 ] = "NeverGrowsWhenTypingAtEdges", e[ e.GrowsOnlyWhenTypingBefore = 2 ] = "GrowsOnlyWhenTypingBefore", e[ e.GrowsOnlyWhenTypingAfter = 3 ] = "GrowsOnlyWhenTypingAfter"
      } )( a || ( a = {} ) );
      var c = function ( e, t, n ) {
        this.reverseEdits = e, this.changes = t, this.trimAutoWhitespaceLineNumbers = n
      }
    },
    M1kC( e, t, n ) {},
    MD5Z( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return s
      } ) ), n.d( t, "kb", ( () => {
        return u
      } ) ), n.d( t, "I", ( () => {
        return l
      } ) ), n.d( t, "G", ( () => {
        return c
      } ) ), n.d( t, "H", ( () => {
        return d
      } ) ), n.d( t, "e", ( () => {
        return h
      } ) ), n.d( t, "b", ( () => {
        return p
      } ) ), n.d( t, "qb", ( () => {
        return f
      } ) ), n.d( t, "pb", ( () => {
        return g
      } ) ), n.d( t, "rb", ( () => {
        return m
      } ) ), n.d( t, "K", ( () => {
        return _
      } ) ), n.d( t, "M", ( () => {
        return v
      } ) ), n.d( t, "L", ( () => {
        return y
      } ) ), n.d( t, "J", ( () => {
        return b
      } ) ), n.d( t, "P", ( () => {
        return C
      } ) ), n.d( t, "Q", ( () => {
        return w
      } ) ), n.d( t, "R", ( () => {
        return S
      } ) ), n.d( t, "S", ( () => {
        return O
      } ) ), n.d( t, "N", ( () => {
        return L
      } ) ), n.d( t, "O", ( () => {
        return x
      } ) ), n.d( t, "W", ( () => {
        return N
      } ) ), n.d( t, "X", ( () => {
        return E
      } ) ), n.d( t, "T", ( () => {
        return k
      } ) ), n.d( t, "U", ( () => {
        return I
      } ) ), n.d( t, "cb", ( () => {
        return D
      } ) ), n.d( t, "db", ( () => {
        return M
      } ) ), n.d( t, "bb", ( () => {
        return T
      } ) ), n.d( t, "Z", ( () => {
        return R
      } ) ), n.d( t, "ab", ( () => {
        return P
      } ) ), n.d( t, "V", ( () => {
        return A
      } ) ), n.d( t, "Y", ( () => {
        return F
      } ) ), n.d( t, "ib", ( () => {
        return W
      } ) ), n.d( t, "hb", ( () => {
        return j
      } ) ), n.d( t, "c", ( () => {
        return V
      } ) ), n.d( t, "d", ( () => {
        return B
      } ) ), n.d( t, "lb", ( () => {
        return H
      } ) ), n.d( t, "nb", ( () => {
        return z
      } ) ), n.d( t, "ob", ( () => {
        return U
      } ) ), n.d( t, "mb", ( () => {
        return K
      } ) ), n.d( t, "jb", ( () => {
        return q
      } ) ), n.d( t, "n", ( () => {
        return G
      } ) ), n.d( t, "u", ( () => {
        return Y
      } ) ), n.d( t, "D", ( () => {
        return X
      } ) ), n.d( t, "E", ( () => {
        return $
      } ) ), n.d( t, "F", ( () => {
        return Z
      } ) ), n.d( t, "z", ( () => {
        return Q
      } ) ), n.d( t, "A", ( () => {
        return J
      } ) ), n.d( t, "y", ( () => {
        return ee
      } ) ), n.d( t, "B", ( () => {
        return te
      } ) ), n.d( t, "C", ( () => {
        return ne
      } ) ), n.d( t, "o", ( () => {
        return ie
      } ) ), n.d( t, "q", ( () => {
        return oe
      } ) ), n.d( t, "s", ( () => {
        return re
      } ) ), n.d( t, "p", ( () => {
        return se
      } ) ), n.d( t, "r", ( () => {
        return ae
      } ) ), n.d( t, "t", ( () => {
        return ue
      } ) ), n.d( t, "x", ( () => {
        return le
      } ) ), n.d( t, "v", ( () => {
        return ce
      } ) ), n.d( t, "w", ( () => {
        return de
      } ) ), n.d( t, "m", ( () => {
        return he
      } ) ), n.d( t, "f", ( () => {
        return pe
      } ) ), n.d( t, "g", ( () => {
        return fe
      } ) ), n.d( t, "i", ( () => {
        return ge
      } ) ), n.d( t, "k", ( () => {
        return me
      } ) ), n.d( t, "j", ( () => {
        return _e
      } ) ), n.d( t, "l", ( () => {
        return ve
      } ) ), n.d( t, "h", ( () => {
        return ye
      } ) ), n.d( t, "fb", ( () => {
        return Ce
      } ) ), n.d( t, "gb", ( () => {
        return we
      } ) ), n.d( t, "eb", ( () => {
        return Oe
      } ) );
      const i = n( "ic2d" );
      const o = n( "zrhQ" );
      const r = n( "3/fG" );
      var s = {
        ColorContribution: "base.contributions.colors"
      };
      const a = new( ( () => {
        function e() {
          this.colorSchema = {
            type: "object",
            description: r.a( "schema.colors", "Colors used in the workbench." ),
            properties: {},
            additionalProperties: !1
          }, this.colorReferenceSchema = {
            type: "string",
            enum: [],
            enumDescriptions: []
          }, this.colorsById = {}
        }
        return e.prototype.registerColor = function ( e, t, n, i, o ) {
          void 0 === i && ( i = !1 );
          const r = {
            id: e,
            description: n,
            defaults: t,
            needsTransparency: i,
            deprecationMessage: o
          };
          this.colorsById[ e ] = r;
          const s = {
            type: "string",
            description: n,
            format: "color-hex",
            default: "#ff0000"
          };
          return o && ( s.deprecationMessage = o ), this.colorSchema.properties[ e ] = s, this.colorReferenceSchema.enum.push( e ), this.colorReferenceSchema.enumDescriptions.push( n ), e
        }, e.prototype.resolveDefaultColor = function ( e, t ) {
          const n = this.colorsById[ e ];
          return n && n.defaults ? xe( n.defaults[ t.type ], t ) : null
        }, e.prototype.toString = function () {
          const e = this;
          return Object.keys( this.colorsById ).sort( ( ( e, t ) => {
            const n = -1 === e.indexOf( "." ) ? 0 : 1,
              i = -1 === t.indexOf( "." ) ? 0 : 1;
            return n !== i ? n - i : e.localeCompare( t )
          } ) ).map( ( t => {
            return "- `" + t + "`: " + e.colorsById[ t ].description
          } ) ).join( "\n" );
        }, e;
      } )() )();

      function u( e, t, n, i, o ) {
        return a.registerColor( e, t, n, i, o )
      }
      i.a.add( s.ColorContribution, a );
      var l = u( "foreground", {
        dark: "#CCCCCC",
        light: "#616161",
        hc: "#FFFFFF"
      }, r.a( "foreground", "Overall foreground color. This color is only used if not overridden by a component." ) );
      var c = u( "errorForeground", {
        dark: "#F48771",
        light: "#A1260D",
        hc: "#F48771"
      }, r.a( "errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component." ) );
      var d = u( "focusBorder", {
        dark: o.a.fromHex( "#0E639C" ).transparent( .6 ),
        light: o.a.fromHex( "#007ACC" ).transparent( .4 ),
        hc: "#F38518"
      }, r.a( "focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component." ) );
      var h = u( "contrastBorder", {
        light: null,
        dark: null,
        hc: "#6FC3DF"
      }, r.a( "contrastBorder", "An extra border around elements to separate them from others for greater contrast." ) );
      var p = u( "contrastActiveBorder", {
        light: null,
        dark: null,
        hc: d
      }, r.a( "activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast." ) );
      var f = u( "textLink.foreground", {
        light: "#006AB1",
        dark: "#3794FF",
        hc: "#3794FF"
      }, r.a( "textLinkForeground", "Foreground color for links in text." ) );
      var g = u( "textCodeBlock.background", {
        light: "#dcdcdc66",
        dark: "#0a0a0a66",
        hc: o.a.black
      }, r.a( "textCodeBlockBackground", "Background color for code blocks in text." ) );
      var m = u( "widget.shadow", {
        dark: "#000000",
        light: "#A8A8A8",
        hc: null
      }, r.a( "widgetShadow", "Shadow color of widgets such as find/replace inside the editor." ) );
      var _ = u( "input.background", {
        dark: "#3C3C3C",
        light: o.a.white,
        hc: o.a.black
      }, r.a( "inputBoxBackground", "Input box background." ) );
      var v = u( "input.foreground", {
        dark: l,
        light: l,
        hc: l
      }, r.a( "inputBoxForeground", "Input box foreground." ) );
      var y = u( "input.border", {
        dark: null,
        light: null,
        hc: h
      }, r.a( "inputBoxBorder", "Input box border." ) );
      var b = u( "inputOption.activeBorder", {
        dark: "#007ACC",
        light: "#007ACC",
        hc: p
      }, r.a( "inputBoxActiveOptionBorder", "Border color of activated options in input fields." ) );
      var C = u( "inputValidation.infoBackground", {
        dark: "#063B49",
        light: "#D6ECF2",
        hc: o.a.black
      }, r.a( "inputValidationInfoBackground", "Input validation background color for information severity." ) );
      var w = u( "inputValidation.infoBorder", {
        dark: "#007acc",
        light: "#007acc",
        hc: h
      }, r.a( "inputValidationInfoBorder", "Input validation border color for information severity." ) );
      var S = u( "inputValidation.warningBackground", {
        dark: "#352A05",
        light: "#F6F5D2",
        hc: o.a.black
      }, r.a( "inputValidationWarningBackground", "Input validation background color for warning severity." ) );
      var O = u( "inputValidation.warningBorder", {
        dark: "#B89500",
        light: "#B89500",
        hc: h
      }, r.a( "inputValidationWarningBorder", "Input validation border color for warning severity." ) );
      var L = u( "inputValidation.errorBackground", {
        dark: "#5A1D1D",
        light: "#F2DEDE",
        hc: o.a.black
      }, r.a( "inputValidationErrorBackground", "Input validation background color for error severity." ) );
      var x = u( "inputValidation.errorBorder", {
        dark: "#BE1100",
        light: "#BE1100",
        hc: h
      }, r.a( "inputValidationErrorBorder", "Input validation border color for error severity." ) );
      var N = u( "list.focusBackground", {
        dark: "#062F4A",
        light: "#DFF0FF",
        hc: null
      }, r.a( "listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not." ) );
      var E = u( "list.focusForeground", {
        dark: null,
        light: null,
        hc: null
      }, r.a( "listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not." ) );
      var k = u( "list.activeSelectionBackground", {
        dark: "#094771",
        light: "#2477CE",
        hc: null
      }, r.a( "listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not." ) );
      var I = u( "list.activeSelectionForeground", {
        dark: o.a.white,
        light: o.a.white,
        hc: null
      }, r.a( "listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not." ) );
      var D = u( "list.inactiveSelectionBackground", {
        dark: "#37373D",
        light: "#dddfea",
        hc: null
      }, r.a( "listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not." ) );
      var M = u( "list.inactiveSelectionForeground", {
        dark: null,
        light: null,
        hc: null
      }, r.a( "listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not." ) );
      var T = u( "list.inactiveFocusBackground", {
        dark: "#313135",
        light: "#d8dae6",
        hc: null
      }, r.a( "listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not." ) );
      var R = u( "list.hoverBackground", {
        dark: "#2A2D2E",
        light: "#F0F0F0",
        hc: null
      }, r.a( "listHoverBackground", "List/Tree background when hovering over items using the mouse." ) );
      var P = u( "list.hoverForeground", {
        dark: null,
        light: null,
        hc: null
      }, r.a( "listHoverForeground", "List/Tree foreground when hovering over items using the mouse." ) );
      var A = u( "list.dropBackground", {
        dark: N,
        light: N,
        hc: null
      }, r.a( "listDropBackground", "List/Tree drag and drop background when moving items around using the mouse." ) );
      var F = u( "list.highlightForeground", {
        dark: "#0097fb",
        light: "#007acc",
        hc: d
      }, r.a( "highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree." ) );
      var W = u( "pickerGroup.foreground", {
        dark: "#3794FF",
        light: "#006AB1",
        hc: o.a.white
      }, r.a( "pickerGroupForeground", "Quick picker color for grouping labels." ) );
      var j = u( "pickerGroup.border", {
        dark: "#3F3F46",
        light: "#CCCEDB",
        hc: o.a.white
      }, r.a( "pickerGroupBorder", "Quick picker color for grouping borders." ) );
      var V = u( "badge.background", {
        dark: "#4D4D4D",
        light: "#C4C4C4",
        hc: o.a.black
      }, r.a( "badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count." ) );
      var B = u( "badge.foreground", {
        dark: o.a.white,
        light: "#333",
        hc: o.a.white
      }, r.a( "badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count." ) );
      var H = u( "scrollbar.shadow", {
        dark: "#000000",
        light: "#DDDDDD",
        hc: null
      }, r.a( "scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled." ) );
      var z = u( "scrollbarSlider.background", {
        dark: o.a.fromHex( "#797979" ).transparent( .4 ),
        light: o.a.fromHex( "#646464" ).transparent( .4 ),
        hc: Se( h, .6 )
      }, r.a( "scrollbarSliderBackground", "Scrollbar slider background color." ) );
      var U = u( "scrollbarSlider.hoverBackground", {
        dark: o.a.fromHex( "#646464" ).transparent( .7 ),
        light: o.a.fromHex( "#646464" ).transparent( .7 ),
        hc: Se( h, .8 )
      }, r.a( "scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering." ) );
      var K = u( "scrollbarSlider.activeBackground", {
        dark: o.a.fromHex( "#BFBFBF" ).transparent( .4 ),
        light: o.a.fromHex( "#000000" ).transparent( .6 ),
        hc: h
      }, r.a( "scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on." ) );
      var q = u( "progressBar.background", {
        dark: o.a.fromHex( "#0E70C0" ),
        light: o.a.fromHex( "#0E70C0" ),
        hc: h
      }, r.a( "progressBarBackground", "Background color of the progress bar that can show for long running operations." ) );
      var G = u( "editor.background", {
        light: "#fffffe",
        dark: "#1E1E1E",
        hc: o.a.black
      }, r.a( "editorBackground", "Editor background color." ) );
      var Y = u( "editor.foreground", {
        light: "#333333",
        dark: "#BBBBBB",
        hc: o.a.white
      }, r.a( "editorForeground", "Editor default foreground color." ) );
      var X = u( "editorWidget.background", {
        dark: "#2D2D30",
        light: "#EFEFF2",
        hc: "#0C141F"
      }, r.a( "editorWidgetBackground", "Background color of editor widgets, such as find/replace." ) );
      var $ = u( "editorWidget.border", {
        dark: "#454545",
        light: "#C8C8C8",
        hc: h
      }, r.a( "editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget." ) );
      var Z = u( "editorWidget.resizeBorder", {
        light: null,
        dark: null,
        hc: null
      }, r.a( "editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget." ) );
      var Q = u( "editor.selectionBackground", {
        light: "#ADD6FF",
        dark: "#264F78",
        hc: "#f3f518"
      }, r.a( "editorSelectionBackground", "Color of the editor selection." ) );
      var J = u( "editor.selectionForeground", {
        light: null,
        dark: null,
        hc: "#000000"
      }, r.a( "editorSelectionForeground", "Color of the selected text for high contrast." ) );
      var ee = u( "editor.inactiveSelectionBackground", {
        light: Se( Q, .5 ),
        dark: Se( Q, .5 ),
        hc: Se( Q, .5 )
      }, r.a( "editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque to not hide underlying decorations." ), !0 );
      var te = u( "editor.selectionHighlightBackground", {
        light: Le( Q, G, .3, .6 ),
        dark: Le( Q, G, .3, .6 ),
        hc: null
      }, r.a( "editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque to not hide underlying decorations." ), !0 );
      var ne = u( "editor.selectionHighlightBorder", {
        light: null,
        dark: null,
        hc: p
      }, r.a( "editorSelectionHighlightBorder", "Border color for regions with the same content as the selection." ) );
      var ie = u( "editor.findMatchBackground", {
        light: "#A8AC94",
        dark: "#515C6A",
        hc: null
      }, r.a( "editorFindMatch", "Color of the current search match." ) );
      var oe = u( "editor.findMatchHighlightBackground", {
        light: "#EA5C0055",
        dark: "#EA5C0055",
        hc: null
      }, r.a( "findMatchHighlight", "Color of the other search matches. The color must not be opaque to not hide underlying decorations." ), !0 );
      var re = u( "editor.findRangeHighlightBackground", {
        dark: "#3a3d4166",
        light: "#b4b4b44d",
        hc: null
      }, r.a( "findRangeHighlight", "Color of the range limiting the search. The color must not be opaque to not hide underlying decorations." ), !0 );
      var se = u( "editor.findMatchBorder", {
        light: null,
        dark: null,
        hc: p
      }, r.a( "editorFindMatchBorder", "Border color of the current search match." ) );
      var ae = u( "editor.findMatchHighlightBorder", {
        light: null,
        dark: null,
        hc: p
      }, r.a( "findMatchHighlightBorder", "Border color of the other search matches." ) );
      var ue = u( "editor.findRangeHighlightBorder", {
        dark: null,
        light: null,
        hc: Se( p, .4 )
      }, r.a( "findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque to not hide underlying decorations." ), !0 );
      var le = u( "editor.hoverHighlightBackground", {
        light: "#ADD6FF26",
        dark: "#264f7840",
        hc: "#ADD6FF26"
      }, r.a( "hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque to not hide underlying decorations." ), !0 );
      var ce = u( "editorHoverWidget.background", {
        light: X,
        dark: X,
        hc: X
      }, r.a( "hoverBackground", "Background color of the editor hover." ) );
      var de = u( "editorHoverWidget.border", {
        light: $,
        dark: $,
        hc: $
      }, r.a( "hoverBorder", "Border color of the editor hover." ) );
      var he = u( "editorLink.activeForeground", {
        dark: "#4E94CE",
        light: o.a.blue,
        hc: o.a.cyan
      }, r.a( "activeLinkForeground", "Color of active links." ) );
      var pe = new o.a( new o.c( 155, 185, 85, .2 ) );
      var fe = new o.a( new o.c( 255, 0, 0, .2 ) );
      var ge = u( "diffEditor.insertedTextBackground", {
        dark: pe,
        light: pe,
        hc: null
      }, r.a( "diffEditorInserted", "Background color for text that got inserted. The color must not be opaque to not hide underlying decorations." ), !0 );
      var me = u( "diffEditor.removedTextBackground", {
        dark: fe,
        light: fe,
        hc: null
      }, r.a( "diffEditorRemoved", "Background color for text that got removed. The color must not be opaque to not hide underlying decorations." ), !0 );
      var _e = u( "diffEditor.insertedTextBorder", {
        dark: null,
        light: null,
        hc: "#33ff2eff"
      }, r.a( "diffEditorInsertedOutline", "Outline color for the text that got inserted." ) );
      var ve = u( "diffEditor.removedTextBorder", {
        dark: null,
        light: null,
        hc: "#FF008F"
      }, r.a( "diffEditorRemovedOutline", "Outline color for text that got removed." ) );
      var ye = u( "diffEditor.border", {
        dark: null,
        light: null,
        hc: h
      }, r.a( "diffEditorBorder", "Border color between the two text editors." ) );
      const be = new o.a( new o.c( 246, 185, 77, .7 ) );
      var Ce = u( "editorOverviewRuler.findMatchForeground", {
        dark: be,
        light: be,
        hc: be
      }, r.a( "overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque to not hide underlying decorations." ), !0 );
      var we = u( "editorOverviewRuler.selectionHighlightForeground", {
        dark: "#A0A0A0CC",
        light: "#A0A0A0CC",
        hc: "#A0A0A0CC"
      }, r.a( "overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque to not hide underlying decorations." ), !0 );

      function Se( e, t ) {
        return n => {
          const i = xe( e, n );
          return i ? i.transparent( t ) : null
        };
      }

      function Oe() {
        for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
        return t => {
          for ( let n = 0, i = e; n < i.length; n++ ) {
            const o = xe( i[ n ], t );
            if ( o ) return o
          }
          return null
        };
      }

      function Le( e, t, n, i ) {
        return r => {
          const s = xe( e, r );
          if ( s ) {
            const a = xe( t, r );
            return a ? s.isDarkerThan( a ) ? o.a.getLighterColor( s, a, n ).transparent( i ) : o.a.getDarkerColor( s, a, n ).transparent( i ) : s.transparent( n * i )
          }
          return null
        };
      }

      function xe( e, t ) {
        return null === e ? null : "string" === typeof e ? "#" === e[ 0 ] ? o.a.fromHex( e ) : t.getColor( e ) : e instanceof o.a ? e : "function" === typeof e ? e( t ) : null
      }
    },
    MI8n( e, t, n ) {
      "use strict";
      const i = n( "/cxE" );
      let o;
      const r = n( "pmY6" );
      const s = n( "24hK" );
      n.d( t, "b", ( () => {
        return o
      } ) ), n.d( t, "a", ( () => {
        return a
      } ) ), n.d( t, "d", ( () => {
        return u
      } ) ), n.d( t, "k", ( () => {
        return l
      } ) ), n.d( t, "f", ( () => {
        return c
      } ) ), n.d( t, "h", ( () => {
        return d
      } ) ), n.d( t, "c", ( () => {
        return h
      } ) ), n.d( t, "j", ( () => {
        return p
      } ) ), n.d( t, "i", ( () => {
        return f
      } ) ), n.d( t, "g", ( () => {
        return m
      } ) ), n.d( t, "e", ( () => {
        return _
      } ) ), ( e => {
        const t = {
          dispose() {}
        };
        e.None = () => {
          return t
        }
      } )( o || ( o = {} ) );
      var a = ( () => {
          function e( e ) {
            this._options = e
          }
          return Object.defineProperty( e.prototype, "event", {
            get() {
              const t = this;
              return this._event || ( this._event = ( n, i, o ) => {
                t._listeners || ( t._listeners = new s.a );
                const r = t._listeners.isEmpty();
                r && t._options && t._options.onFirstListenerAdd && t._options.onFirstListenerAdd( t );
                let a;
                const u = t._listeners.push( i ? [ n, i ] : n );
                return r && t._options && t._options.onFirstListenerDidAdd && t._options.onFirstListenerDidAdd( t ), t._options && t._options.onListenerDidAdd && t._options.onListenerDidAdd( t, n, i ), a = {
                  dispose() {
                    a.dispose = e._noop, t._disposed || ( u(), t._options && t._options.onLastListenerRemove && t._listeners.isEmpty() && t._options.onLastListenerRemove( t ) )
                  }
                }, Array.isArray( o ) && o.push( a ), a;
              } ), this._event;
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.fire = function ( e ) {
            if ( this._listeners ) {
              this._deliveryQueue || ( this._deliveryQueue = [] );
              for ( var t = this._listeners.iterator(), n = t.next(); !n.done; n = t.next() ) this._deliveryQueue.push( [ n.value, e ] );
              for ( ; this._deliveryQueue.length > 0; ) {
                const o = this._deliveryQueue.shift(),
                  r = o[ 0 ],
                  s = o[ 1 ];
                try {
                  "function" === typeof r ? r.call( void 0, s ) : r[ 0 ].call( r[ 1 ], s )
                } catch ( n ) {
                  Object( i.e )( n )
                }
              }
            }
          }, e.prototype.dispose = function () {
            this._listeners && ( this._listeners = void 0 ), this._deliveryQueue && ( this._deliveryQueue.length = 0 ), this._disposed = !0
          }, e._noop = () => {}, e;
        } )(),
        u = ( () => {
          function e() {
            const e = this;
            this.hasListeners = !1, this.events = [], this.emitter = new a( {
              onFirstListenerAdd() {
                return e.onFirstListenerAdd()
              },
              onLastListenerRemove() {
                return e.onLastListenerRemove()
              }
            } )
          }
          return Object.defineProperty( e.prototype, "event", {
            get() {
              return this.emitter.event
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.add = function ( e ) {
            const t = this,
              n = {
                event: e,
                listener: null
              };
            this.events.push( n ), this.hasListeners && this.hook( n );
            return Object( r.f )( function ( e ) {
              let t;
              const n = this;
              let i = !1;
              return function () {
                return i ? t : ( i = !0, t = e.apply( n, arguments ) )
              }
            }( ( () => {
              t.hasListeners && t.unhook( n );
              const e = t.events.indexOf( n );
              t.events.splice( e, 1 )
            } ) ) );
          }, e.prototype.onFirstListenerAdd = function () {
            const e = this;
            this.hasListeners = !0, this.events.forEach( ( t => {
              return e.hook( t )
            } ) )
          }, e.prototype.onLastListenerRemove = function () {
            const e = this;
            this.hasListeners = !1, this.events.forEach( ( t => {
              return e.unhook( t )
            } ) )
          }, e.prototype.hook = function ( e ) {
            const t = this;
            e.listener = e.event( ( e => {
              return t.emitter.fire( e )
            } ) )
          }, e.prototype.unhook = e => {
            e.listener.dispose(), e.listener = null
          }, e.prototype.dispose = function () {
            this.emitter.dispose()
          }, e;
        } )();

      function l( e ) {
        return ( t, n, i ) => {
          void 0 === n && ( n = null );
          const o = e( ( e => {
            return o.dispose(), t.call( n, e )
          } ), null, i );
          return o
        };
      }

      function c() {
        for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
        return ( t, n, i ) => {
          return void 0 === n && ( n = null ), Object( r.c )( e.map( ( e => {
            return e( ( e => {
              return t.call( n, e )
            } ), null, i );
          } ) ) );
        };
      }

      function d( e, t, n, i ) {
        let o;
        void 0 === n && ( n = 100 ), void 0 === i && ( i = !1 );
        let r = void 0;
        let s = void 0;
        let u = 0;
        const l = new a( {
          onFirstListenerAdd() {
            o = e( ( e => {
              u++, r = t( r, e ), i && !s && l.fire( r ), clearTimeout( s ), s = setTimeout( ( () => {
                const e = r;
                r = void 0, s = void 0, ( !i || u > 1 ) && l.fire( e ), u = 0
              } ), n )
            } ) )
          },
          onLastListenerRemove() {
            o.dispose()
          }
        } );
        return l.event
      }
      var h = ( () => {
        function e() {
          this.buffers = []
        }
        return e.prototype.wrapEvent = function ( e ) {
          const t = this;
          return ( n, i, o ) => {
            return e( ( e => {
              const o = t.buffers[ t.buffers.length - 1 ];
              o ? o.push( ( () => {
                return n.call( i, e )
              } ) ) : n.call( i, e )
            } ), void 0, o );
          };
        }, e.prototype.bufferEvents = function ( e ) {
          const t = [];
          this.buffers.push( t ), e(), this.buffers.pop(), t.forEach( ( e => {
            return e()
          } ) )
        }, e;
      } )();

      function p( e, t ) {
        return ( n, i, o ) => {
          return void 0 === i && ( i = null ), e( ( e => {
            return n.call( i, t( e ) )
          } ), null, o );
        };
      }

      function f( e, t ) {
        return ( n, i, o ) => {
          return void 0 === i && ( i = null ), e( ( e => {
            return t( e ) && n.call( i, e )
          } ), null, o );
        };
      }
      const g = ( () => {
        function e( e ) {
          this._event = e
        }
        return Object.defineProperty( e.prototype, "event", {
          get() {
            return this._event
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.map = function ( t ) {
          return new e( p( this._event, t ) )
        }, e.prototype.filter = function ( t ) {
          return new e( f( this._event, t ) )
        }, e.prototype.on = function ( e, t, n ) {
          return this._event( e, t, n )
        }, e;
      } )();

      function m( e ) {
        return new g( e )
      }
      var _ = ( () => {
        function e() {
          this.emitter = new a, this.event = this.emitter.event, this.disposable = r.a.None
        }
        return Object.defineProperty( e.prototype, "input", {
          set( e ) {
            this.disposable.dispose(), this.disposable = e( this.emitter.fire, this.emitter )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.dispose = function () {
          this.disposable.dispose(), this.emitter.dispose()
        }, e;
      } )()
    },
    MNXI( e, t, n ) {},
    MNsG( e, t, n ) {
      "use strict";
      ( ( ( e, i ) => {
        n.d( t, "g", ( () => {
          return f
        } ) ), n.d( t, "d", ( () => {
          return g
        } ) ), n.d( t, "c", ( () => {
          return m
        } ) ), n.d( t, "e", ( () => {
          return _
        } ) ), n.d( t, "f", ( () => {
          return v
        } ) ), n.d( t, "b", ( () => {
          return y
        } ) ), n.d( t, "h", ( () => {
          return C
        } ) ), n.d( t, "a", ( () => {
          return w
        } ) );
        let o, r = !1,
          s = !1,
          a = !1,
          u = !1,
          l = !1;
        if ( "object" === typeof e && "function" === typeof e.nextTick && "string" === typeof e.platform ) {
          r = "win32" === e.platform, s = "darwin" === e.platform, a = "linux" === e.platform, "en", "en";
          const c = e.env.VSCODE_NLS_CONFIG;
          if ( c ) try {
            const d = JSON.parse( c ),
              h = d.availableLanguages[ "*" ];
            d.locale, h || "en", d._translationsConfigFile
          } catch ( S ) {}
          u = !0
        } else if ( "object" === typeof navigator ) {
          const p = navigator.userAgent;
          r = p.indexOf( "Windows" ) >= 0, s = p.indexOf( "Macintosh" ) >= 0, a = p.indexOf( "Linux" ) >= 0, l = !0, navigator.language
        }!( e => {
          e[ e.Web = 0 ] = "Web", e[ e.Mac = 1 ] = "Mac", e[ e.Linux = 2 ] = "Linux", e[ e.Windows = 3 ] = "Windows"
        } )( o || ( o = {} ) );
        o.Web;
        u && ( s ? o.Mac : r ? o.Windows : a && o.Linux );
        var f = r;
        var g = s;
        var m = a;
        var _ = u;
        var v = l;
        var y = "object" === typeof self ? self : "object" === typeof i ? i : {};
        let b = null;

        function C( t ) {
          return null === b && ( b = y.setImmediate ? y.setImmediate.bind( y ) : "undefined" !== typeof e && "function" === typeof e.nextTick ? e.nextTick.bind( e ) : y.setTimeout.bind( y ) ), b( t )
        }
        var w = s ? 2 : r ? 1 : 3
      } ) ).call( this, n( "8oxB" ), n( "yLpj" ) )
    },
    MXAL( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) );
      const i = n( "UHym" );
      var o = ( () => {
        function e( t ) {
          const n = Object( i.d )( t );
          this._defaultValue = n, this._asciiMap = e._createAsciiMap( n ), this._map = new Map
        }
        return e._createAsciiMap = e => {
          for ( var t = new Uint8Array( 256 ), n = 0; n < 256; n++ ) t[ n ] = e;
          return t
        }, e.prototype.set = function ( e, t ) {
          const n = Object( i.d )( t );
          e >= 0 && e < 256 ? this._asciiMap[ e ] = n : this._map.set( e, n )
        }, e.prototype.get = function ( e ) {
          return e >= 0 && e < 256 ? this._asciiMap[ e ] : this._map.get( e ) || this._defaultValue
        }, e;
      } )();
      var r = ( () => {
        function e() {
          this._actual = new o( 0 )
        }
        return e.prototype.add = function ( e ) {
          this._actual.set( e, 1 )
        }, e.prototype.has = function ( e ) {
          return 1 === this._actual.get( e )
        }, e
      } )();
    },
    Msxo( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "r",
        extensions: [ ".r", ".rhistory", ".rprofile", ".rt" ],
        aliases: [ "R", "r" ],
        loader() {
          return o.Promise.wrap( n.e( 293 ).then( n.bind( null, "Qx4d" ) ) )
        }
      } )
    },
    MvK1( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) );
      const i = ( () => {
        function e( e, t, n ) {
          this.from = 0 | e, this.to = 0 | t, this.colorId = 0 | n
        }
        return e.compare = ( e, t ) => {
          return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId
        }, e;
      } )();
      var o = ( () => {
        function e( e, t, n ) {
          this.startLineNumber = e, this.endLineNumber = t, this.color = n, this._colorZone = null
        }
        return e.compare = ( e, t ) => {
          return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.endLineNumber - t.endLineNumber : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1
        }, e.prototype.setColorZone = function ( e ) {
          this._colorZone = e
        }, e.prototype.getColorZones = function () {
          return this._colorZone
        }, e;
      } )();

      var r = ( () => {
        function e( e ) {
          this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = !1, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = Object.create( null ), this._id2Color = []
        }
        return e.prototype.getId2Color = function () {
          return this._id2Color
        }, e.prototype.setZones = function ( e ) {
          this._zones = e, this._zones.sort( o.compare )
        }, e.prototype.setLineHeight = function ( e ) {
          return this._lineHeight !== e && ( this._lineHeight = e, this._colorZonesInvalid = !0, !0 )
        }, e.prototype.setPixelRatio = function ( e ) {
          this._pixelRatio = e, this._colorZonesInvalid = !0
        }, e.prototype.getDOMWidth = function () {
          return this._domWidth
        }, e.prototype.getCanvasWidth = function () {
          return this._domWidth * this._pixelRatio
        }, e.prototype.setDOMWidth = function ( e ) {
          return this._domWidth !== e && ( this._domWidth = e, this._colorZonesInvalid = !0, !0 )
        }, e.prototype.getDOMHeight = function () {
          return this._domHeight
        }, e.prototype.getCanvasHeight = function () {
          return this._domHeight * this._pixelRatio
        }, e.prototype.setDOMHeight = function ( e ) {
          return this._domHeight !== e && ( this._domHeight = e, this._colorZonesInvalid = !0, !0 )
        }, e.prototype.getOuterHeight = function () {
          return this._outerHeight
        }, e.prototype.setOuterHeight = function ( e ) {
          return this._outerHeight !== e && ( this._outerHeight = e, this._colorZonesInvalid = !0, !0 )
        }, e.prototype.resolveColorZones = function () {
          for ( var e = this._colorZonesInvalid, t = Math.floor( this._lineHeight ), n = Math.floor( this.getCanvasHeight() ), o = n / Math.floor( this._outerHeight ), r = Math.floor( 4 * this._pixelRatio / 2 ), s = [], a = 0, u = this._zones.length; a < u; a++ ) {
            const l = this._zones[ a ];
            if ( !e ) {
              const c = l.getColorZones();
              if ( c ) {
                s.push( c );
                continue
              }
            }
            const d = Math.floor( o * this._getVerticalOffsetForLine( l.startLineNumber ) );
            const h = Math.floor( o * ( this._getVerticalOffsetForLine( l.endLineNumber ) + t ) );
            let p = Math.floor( ( d + h ) / 2 );
            let f = h - p;
            f < r && ( f = r ), p - f < 0 && ( p = f ), p + f > n && ( p = n - f );
            const g = l.color;
            let m = this._color2Id[ g ];
            m || ( m = ++this._lastAssignedId, this._color2Id[ g ] = m, this._id2Color[ m ] = g );
            const _ = new i( p - f, p + f, m );
            l.setColorZone( _ ), s.push( _ )
          }
          return this._colorZonesInvalid = !1, s.sort( i.compare ), s
        }, e;
      } )();
    },
    Mzro( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "shell",
        extensions: [ ".sh", ".bash" ],
        aliases: [ "Shell", "sh" ],
        loader() {
          return o.Promise.wrap( n.e( 304 ).then( n.bind( null, "l/4i" ) ) )
        }
      } )
    },
    N0LK( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "empty", ( () => {
        return i
      } ) ), n.d( t, "isFalsyOrWhitespace", ( () => {
        return o
      } ) ), n.d( t, "pad", ( () => {
        return r
      } ) ), n.d( t, "format", ( () => {
        return a
      } ) ), n.d( t, "escape", ( () => {
        return u
      } ) ), n.d( t, "escapeRegExpCharacters", ( () => {
        return l
      } ) ), n.d( t, "trim", ( () => {
        return c
      } ) ), n.d( t, "ltrim", ( () => {
        return d
      } ) ), n.d( t, "rtrim", ( () => {
        return h
      } ) ), n.d( t, "convertSimple2RegExpPattern", ( () => {
        return p
      } ) ), n.d( t, "startsWith", ( () => {
        return f
      } ) ), n.d( t, "endsWith", ( () => {
        return g
      } ) ), n.d( t, "createRegExp", ( () => {
        return m
      } ) ), n.d( t, "regExpLeadsToEndlessLoop", ( () => {
        return _
      } ) ), n.d( t, "firstNonWhitespaceIndex", ( () => {
        return v
      } ) ), n.d( t, "getLeadingWhitespace", ( () => {
        return y
      } ) ), n.d( t, "lastNonWhitespaceIndex", ( () => {
        return b
      } ) ), n.d( t, "compare", ( () => {
        return C
      } ) ), n.d( t, "compareIgnoreCase", ( () => {
        return w
      } ) ), n.d( t, "isLowerAsciiLetter", ( () => {
        return S
      } ) ), n.d( t, "isUpperAsciiLetter", ( () => {
        return O
      } ) ), n.d( t, "equalsIgnoreCase", ( () => {
        return x
      } ) ), n.d( t, "startsWithIgnoreCase", ( () => {
        return E
      } ) ), n.d( t, "commonPrefixLength", ( () => {
        return k
      } ) ), n.d( t, "commonSuffixLength", ( () => {
        return I
      } ) ), n.d( t, "isHighSurrogate", ( () => {
        return D
      } ) ), n.d( t, "isLowSurrogate", ( () => {
        return M
      } ) ), n.d( t, "containsRTL", ( () => {
        return R
      } ) ), n.d( t, "containsEmoji", ( () => {
        return A
      } ) ), n.d( t, "isBasicASCII", ( () => {
        return W
      } ) ), n.d( t, "containsFullWidthCharacter", ( () => {
        return j
      } ) ), n.d( t, "isFullWidthCharacter", ( () => {
        return V
      } ) ), n.d( t, "UTF8_BOM_CHARACTER", ( () => {
        return B
      } ) ), n.d( t, "startsWithUTF8BOM", ( () => {
        return H
      } ) ), n.d( t, "safeBtoa", ( () => {
        return z
      } ) ), n.d( t, "repeat", ( () => {
        return U
      } ) );
      var i = "";

      function o( e ) {
        return !e || "string" !== typeof e || 0 === e.trim().length
      }

      function r( e, t, n ) {
        void 0 === n && ( n = "0" );
        for ( var i = "" + e, o = [ i ], r = i.length; r < t; r++ ) o.push( n );
        return o.reverse().join( "" )
      }
      const s = /{(\d+)}/g;

      function a( e ) {
        for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
        return 0 === t.length ? e : e.replace( s, ( ( e, n ) => {
          const i = parseInt( n, 10 );
          return isNaN( i ) || i < 0 || i >= t.length ? e : t[ i ]
        } ) );
      }

      function u( e ) {
        return e.replace( /[<|>|&]/g, ( e => {
          switch ( e ) {
            case "<":
              return "&lt;";
            case ">":
              return "&gt;";
            case "&":
              return "&amp;";
            default:
              return e
          }
        } ) );
      }

      function l( e ) {
        return e.replace( /[\-\\\{\}\*\+\?\|\^\$\.\[\]\(\)\#]/g, "\\$&" )
      }

      function c( e, t ) {
        return void 0 === t && ( t = " " ), h( d( e, t ), t )
      }

      function d( e, t ) {
        if ( !e || !t ) return e;
        const n = t.length;
        if ( 0 === n || 0 === e.length ) return e;
        for ( var i = 0; e.indexOf( t, i ) === i; ) i += n;
        return e.substring( i )
      }

      function h( e, t ) {
        if ( !e || !t ) return e;
        const n = t.length,
          i = e.length;
        if ( 0 === n || 0 === i ) return e;
        for ( var o = i, r = -1; - 1 !== ( r = e.lastIndexOf( t, o - 1 ) ) && r + n === o; ) {
          if ( 0 === r ) return "";
          o = r
        }
        return e.substring( 0, o )
      }

      function p( e ) {
        return e.replace( /[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&" ).replace( /[\*]/g, ".*" )
      }

      function f( e, t ) {
        if ( e.length < t.length ) return !1;
        if ( e === t ) return !0;
        for ( let n = 0; n < t.length; n++ )
          if ( e[ n ] !== t[ n ] ) return !1;
        return !0
      }

      function g( e, t ) {
        const n = e.length - t.length;
        return n > 0 ? e.indexOf( t, n ) === n : 0 === n && e === t
      }

      function m( e, t, n ) {
        if ( void 0 === n && ( n = {} ), !e ) throw new Error( "Cannot create regex from empty string" );
        t || ( e = l( e ) ), n.wholeWord && ( /\B/.test( e.charAt( 0 ) ) || ( e = "\\b" + e ), /\B/.test( e.charAt( e.length - 1 ) ) || ( e += "\\b" ) );
        let i = "";
        return n.global && ( i += "g" ), n.matchCase || ( i += "i" ), n.multiline && ( i += "m" ), new RegExp( e, i )
      }

      function _( e ) {
        return "^" !== e.source && "^$" !== e.source && "$" !== e.source && "^\\s*$" !== e.source && ( e.exec( "" ) && 0 === e.lastIndex )
      }

      function v( e ) {
        for ( let t = 0, n = e.length; t < n; t++ ) {
          const i = e.charCodeAt( t );
          if ( 32 !== i && 9 !== i ) return t
        }
        return -1
      }

      function y( e, t, n ) {
        void 0 === t && ( t = 0 ), void 0 === n && ( n = e.length );
        for ( let i = t; i < n; i++ ) {
          const o = e.charCodeAt( i );
          if ( 32 !== o && 9 !== o ) return e.substring( t, i )
        }
        return e.substring( t, n )
      }

      function b( e, t ) {
        void 0 === t && ( t = e.length - 1 );
        for ( let n = t; n >= 0; n-- ) {
          const i = e.charCodeAt( n );
          if ( 32 !== i && 9 !== i ) return n
        }
        return -1
      }

      function C( e, t ) {
        return e < t ? -1 : e > t ? 1 : 0
      }

      function w( e, t ) {
        for ( let n = Math.min( e.length, t.length ), i = 0; i < n; i++ ) {
          let o = e.charCodeAt( i ),
            r = t.charCodeAt( i );
          if ( o !== r ) {
            O( o ) && ( o += 32 ), O( r ) && ( r += 32 );
            const s = o - r;
            if ( 0 !== s ) return S( o ) && S( r ) ? s : C( e.toLowerCase(), t.toLowerCase() )
          }
        }
        return e.length < t.length ? -1 : e.length > t.length ? 1 : 0
      }

      function S( e ) {
        return e >= 97 && e <= 122
      }

      function O( e ) {
        return e >= 65 && e <= 90
      }

      function L( e ) {
        return S( e ) || O( e )
      }

      function x( e, t ) {
        return ( e ? e.length : 0 ) === ( t ? t.length : 0 ) && N( e, t )
      }

      function N( e, t, n ) {
        if ( void 0 === n && ( n = e.length ), "string" !== typeof e || "string" !== typeof t ) return !1;
        for ( let i = 0; i < n; i++ ) {
          const o = e.charCodeAt( i ),
            r = t.charCodeAt( i );
          if ( o !== r )
            if ( L( o ) && L( r ) ) {
              const s = Math.abs( o - r );
              if ( 0 !== s && 32 !== s ) return !1
            } else if ( String.fromCharCode( o ).toLowerCase() !== String.fromCharCode( r ).toLowerCase() ) return !1
        }
        return !0
      }

      function E( e, t ) {
        const n = t.length;
        return !( t.length > e.length ) && N( e, t, n )
      }

      function k( e, t ) {
        let n;
        const i = Math.min( e.length, t.length );
        for ( n = 0; n < i; n++ )
          if ( e.charCodeAt( n ) !== t.charCodeAt( n ) ) return n;
        return i
      }

      function I( e, t ) {
        let n;
        const i = Math.min( e.length, t.length );
        const o = e.length - 1;
        const r = t.length - 1;
        for ( n = 0; n < i; n++ )
          if ( e.charCodeAt( o - n ) !== t.charCodeAt( r - n ) ) return n;
        return i
      }

      function D( e ) {
        return 55296 <= e && e <= 56319
      }

      function M( e ) {
        return 56320 <= e && e <= 57343
      }
      const T = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;

      function R( e ) {
        return T.test( e )
      }
      const P = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEF8]|\uD83E[\uDD00-\uDDE6])/;

      function A( e ) {
        return P.test( e )
      }
      const F = /^[\t\n\r\x20-\x7E]*$/;

      function W( e ) {
        return F.test( e )
      }

      function j( e ) {
        for ( let t = 0, n = e.length; t < n; t++ )
          if ( V( e.charCodeAt( t ) ) ) return !0;
        return !1
      }

      function V( e ) {
        return ( e = +e ) >= 11904 && e <= 55215 || e >= 63744 && e <= 64255 || e >= 65281 && e <= 65374
      }
      var B = String.fromCharCode( 65279 );

      function H( e ) {
        return e && e.length > 0 && 65279 === e.charCodeAt( 0 )
      }

      function z( e ) {
        return btoa( encodeURIComponent( e ) )
      }

      function U( e, t ) {
        for ( var n = "", i = 0; i < t; i++ ) n += e;
        return n
      }
    },
    NR8r( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return m
      } ) );
      n( "synD" );
      const i = n( "3/fG" );
      const o = n( "X+cX" );
      const r = n( "pmY6" );
      const s = n( "OBOq" );
      const a = n( "aokT" );
      const u = n( "sswD" );
      const l = n( "sFUC" );
      const c = n( "T8No" );
      const d = n( "t9D7" );
      const h = n( "MD5Z" );
      const p = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const f = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const g = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };

      var m = ( e => {
        function t( n, i ) {
          const o = e.call( this ) || this;
          return o._messageListeners = [], o._editor = n, o._visible = t.MESSAGE_VISIBLE.bindTo( i ), o._register( o._editor.onDidAttemptReadOnlyEdit( ( () => {
            return o._onDidAttemptReadOnlyEdit()
          } ) ) ), o;
        }
        return p( t, e ), t.get = e => {
          return e.getContribution( t._id )
        }, t.prototype.getId = () => {
          return t._id
        }, t.prototype.dispose = function () {
          e.prototype.dispose.call( this ), this._visible.reset()
        }, t.prototype.showMessage = function ( e, t ) {
          let n;
          const i = this;
          Object( s.a )( e ), this._visible.set( !0 ), Object( r.d )( this._messageWidget ), this._messageListeners = Object( r.d )( this._messageListeners ), this._messageWidget = new v( this._editor, t, e ), this._messageListeners.push( this._editor.onDidBlurEditorText( ( () => {
            return i.closeMessage()
          } ) ) ), this._messageListeners.push( this._editor.onDidChangeCursorPosition( ( () => {
            return i.closeMessage()
          } ) ) ), this._messageListeners.push( this._editor.onDidDispose( ( () => {
            return i.closeMessage()
          } ) ) ), this._messageListeners.push( this._editor.onDidChangeModel( ( () => {
            return i.closeMessage()
          } ) ) ), this._messageListeners.push( Object( o.l )( ( () => {
            return i.closeMessage()
          } ), 3e3 ) ), this._messageListeners.push( this._editor.onMouseMove( ( e => {
            e.target.position && ( n ? n.containsPosition( e.target.position ) || i.closeMessage() : n = new a.a( t.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1 ) )
          } ) ) )
        }, t.prototype.closeMessage = function () {
          this._visible.reset(), this._messageListeners = Object( r.d )( this._messageListeners ), this._messageListeners.push( v.fadeOut( this._messageWidget ) )
        }, t.prototype._onDidAttemptReadOnlyEdit = function () {
          this.showMessage( i.a( "editor.readonly", "Cannot edit in read-only editor" ), this._editor.getPosition() )
        }, t._id = "editor.contrib.messageController", t.MESSAGE_VISIBLE = new c.f( "messageVisible", !1 ), t = f( [ g( 1, c.e ) ], t );
      } )( r.a );

      const _ = u.c.bindToContribution( m.get );
      Object( u.g )( new _( {
        id: "leaveEditorMessage",
        precondition: m.MESSAGE_VISIBLE,
        handler( e ) {
          return e.closeMessage()
        },
        kbOpts: {
          weight: 130,
          primary: 9
        }
      } ) );
      var v = ( () => {
        function e( e, t, n ) {
          const i = t.lineNumber,
            o = t.column;
          this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._editor = e, this._editor.revealLinesInCenterIfOutsideViewport( i, i, 0 ), this._position = {
            lineNumber: i,
            column: o - 1
          }, this._domNode = document.createElement( "div" ), this._domNode.classList.add( "monaco-editor-overlaymessage" );
          const r = document.createElement( "div" );
          r.classList.add( "message" ), r.textContent = n, this._domNode.appendChild( r );
          const s = document.createElement( "div" );
          s.classList.add( "anchor" ), this._domNode.appendChild( s ), this._editor.addContentWidget( this ), this._domNode.classList.add( "fadeIn" )
        }
        return e.fadeOut = e => {
          let t;
          const n = () => {
            e.dispose(), clearTimeout( t ), e.getDomNode().removeEventListener( "animationend", n )
          };
          return t = setTimeout( n, 110 ), e.getDomNode().addEventListener( "animationend", n ), e.getDomNode().classList.add( "fadeOut" ), {
            dispose: n
          }
        }, e.prototype.dispose = function () {
          this._editor.removeContentWidget( this )
        }, e.prototype.getId = () => {
          return "messageoverlay"
        }, e.prototype.getDomNode = function () {
          return this._domNode
        }, e.prototype.getPosition = function () {
          return {
            position: this._position,
            preference: [ l.a.ABOVE ]
          }
        }, e;
      } )();
      Object( u.h )( m ), Object( d.e )( ( ( e, t ) => {
        const n = e.getColor( h.Q );
        if ( n ) {
          const i = e.type === d.b ? 2 : 1;
          t.addRule( ".monaco-editor .monaco-editor-overlaymessage .anchor { border-top-color: " + n + "; }" ), t.addRule( ".monaco-editor .monaco-editor-overlaymessage .message { border: " + i + "px solid " + n + "; }" )
        }
        const o = e.getColor( h.P );
        o && t.addRule( ".monaco-editor .monaco-editor-overlaymessage .message { background-color: " + o + "; }" )
      } ) )
    },
    OBOq( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return l
      } ) ), n.d( t, "a", ( () => {
        return c
      } ) ), n.d( t, "c", ( () => {
        return d
      } ) );
      n( "UCkY" );
      let i;
      let o;
      let r;
      const s = n( "3/fG" );
      const a = n( "MNsG" );
      const u = n( "EffR" );

      function l( e ) {
        ( i = document.createElement( "div" ) ).className = "monaco-aria-container", ( o = document.createElement( "div" ) ).className = "monaco-alert", o.setAttribute( "role", "alert" ), o.setAttribute( "aria-atomic", "true" ), i.appendChild( o ), ( r = document.createElement( "div" ) ).className = "monaco-status", r.setAttribute( "role", "status" ), r.setAttribute( "aria-atomic", "true" ), i.appendChild( r ), e.appendChild( i )
      }

      function c( e ) {
        f( o, e )
      }

      function d( e ) {
        a.d ? c( e ) : f( r, e )
      }
      let h = 0,
        p = void 0;

      function f( e, t ) {
        if ( i ) {
          switch ( p === t ? h++ : ( p = t, h = 0 ), h ) {
            case 0:
              break;
            case 1:
              t = s.a( "repeated", "{0} (occurred again)", t );
              break;
            default:
              t = s.a( "repeatedNtimes", "{0} (occurred {1} times)", t, h )
          }
          u.l( e ), e.textContent = t, e.style.visibility = "hidden", e.style.visibility = "visible"
        }
      }
    },
    OKK6( e, t, n ) {},
    OOlL( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "azcli",
        extensions: [ ".azcli" ],
        aliases: [ "Azure CLI", "azcli" ],
        loader() {
          return o.Promise.wrap( n.e( 255 ).then( n.bind( null, "NlLO" ) ) )
        }
      } )
    },
    OhnE( e, t, n ) {},
    OlfL( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return d
      } ) ), n.d( t, "a", ( () => {
        return p
      } ) ), n.d( t, "c", ( () => {
        return f
      } ) );
      const i = n( "3/fG" );
      const o = n( "MI8n" );
      const r = n( "4J+e" );
      const s = n( "pmY6" );
      const a = n( "N0LK" );
      const u = n( "nD70" );
      const l = n( "VMIq" );
      const c = n( "aokT" );
      var d = ( () => {
        function e( e, t ) {
          this._parent = e, this._range = t, this._onRefChanged = new o.a, this.onRefChanged = this._onRefChanged.event, this._id = u.b.nextId()
        }
        return Object.defineProperty( e.prototype, "id", {
          get() {
            return this._id
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "parent", {
          get() {
            return this._parent
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "uri", {
          get() {
            return this._parent.uri
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "range", {
          get() {
            return this._range
          },
          set( e ) {
            this._range = e, this._onRefChanged.fire( this )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.getAriaMessage = function () {
          return Object( i.a )( "aria.oneReference", "symbol in {0} on line {1} at column {2}", Object( r.a )( this.uri.fsPath ), this.range.startLineNumber, this.range.startColumn )
        }, e;
      } )();
      const h = ( () => {
        function e( e ) {
          this._modelReference = e
        }
        return Object.defineProperty( e.prototype, "_model", {
          get() {
            return this._modelReference.object.textEditorModel
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.preview = function ( e, t ) {
          void 0 === t && ( t = 8 );
          const n = this._model;
          if ( n ) {
            const i = e.startLineNumber,
              o = e.startColumn,
              r = e.endLineNumber,
              s = e.endColumn,
              u = n.getWordUntilPosition( {
                lineNumber: i,
                column: o - t
              } ),
              l = new c.a( i, u.startColumn, i, o ),
              d = new c.a( r, s, r, Number.MAX_VALUE );
            return {
              before: n.getValueInRange( l ).replace( /^\s+/, a.empty ),
              inside: n.getValueInRange( e ),
              after: n.getValueInRange( d ).replace( /\s+$/, a.empty )
            }
          }
        }, e.prototype.dispose = function () {
          this._modelReference && ( this._modelReference.dispose(), this._modelReference = null )
        }, e;
      } )();
      var p = ( () => {
        function e( e, t ) {
          this._parent = e, this._uri = t, this._children = []
        }
        return Object.defineProperty( e.prototype, "id", {
          get() {
            return this._uri.toString()
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "parent", {
          get() {
            return this._parent
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "children", {
          get() {
            return this._children
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "uri", {
          get() {
            return this._uri
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "preview", {
          get() {
            return this._preview
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "failure", {
          get() {
            return this._loadFailure
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.getAriaMessage = function () {
          const e = this.children.length;
          return 1 === e ? Object( i.a )( "aria.fileReferences.1", "1 symbol in {0}, full path {1}", Object( r.a )( this.uri.fsPath ), this.uri.fsPath ) : Object( i.a )( "aria.fileReferences.N", "{0} symbols in {1}, full path {2}", e, Object( r.a )( this.uri.fsPath ), this.uri.fsPath )
        }, e.prototype.resolve = function ( e ) {
          const t = this;
          return this._resolved ? l.b.as( this ) : e.createModelReference( this._uri ).then( ( e => {
            if ( !e.object ) throw ( e.dispose(), new Error );
            return t._preview = new h( e ), t._resolved = !0, t
          } ), ( e => {
            return t._children = [], t._resolved = !0, t._loadFailure = e, t
          } ) );
        }, e.prototype.dispose = function () {
          this._preview && ( this._preview.dispose(), this._preview = null )
        }, e;
      } )();

      var f = ( () => {
        function e( t ) {
          let n;
          const i = this;
          this._groups = [], this._references = [], this._onDidChangeReferenceRange = new o.a, this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event, this._disposables = [], t.sort( e._compareReferences );
          for ( let r = 0, s = t; r < s.length; r++ ) {
            const a = s[ r ];
            if ( n && n.uri.toString() === a.uri.toString() || ( n = new p( this, a.uri ), this.groups.push( n ) ), 0 === n.children.length || !c.a.equalsRange( a.range, n.children[ n.children.length - 1 ].range ) ) {
              const u = new d( n, a.range );
              this._disposables.push( u.onRefChanged( ( e => {
                return i._onDidChangeReferenceRange.fire( e )
              } ) ) ), this._references.push( u ), n.children.push( u )
            }
          }
        }
        return Object.defineProperty( e.prototype, "empty", {
          get() {
            return 0 === this._groups.length
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "references", {
          get() {
            return this._references
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "groups", {
          get() {
            return this._groups
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.getAriaMessage = function () {
          return this.empty ? Object( i.a )( "aria.result.0", "No results found" ) : 1 === this.references.length ? Object( i.a )( "aria.result.1", "Found 1 symbol in {0}", this.references[ 0 ].uri.fsPath ) : 1 === this.groups.length ? Object( i.a )( "aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[ 0 ].uri.fsPath ) : Object( i.a )( "aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length )
        }, e.prototype.nextOrPreviousReference = ( e, t ) => {
          const n = e.parent;
          let i = n.children.indexOf( e );
          const o = n.children.length;
          const r = n.parent.groups.length;
          return 1 === r || t && i + 1 < o || !t && i > 0 ? ( i = t ? ( i + 1 ) % o : ( i + o - 1 ) % o, n.children[ i ] ) : ( i = n.parent.groups.indexOf( n ), t ? ( i = ( i + 1 ) % r, n.parent.groups[ i ].children[ 0 ] ) : ( i = ( i + r - 1 ) % r, n.parent.groups[ i ].children[ n.parent.groups[ i ].children.length - 1 ] ) )
        }, e.prototype.nearestReference = function ( e, t ) {
          const n = this._references.map( ( ( n, i ) => {
            return {
              idx: i,
              prefixLen: a.commonPrefixLength( n.uri.toString(), e.toString() ),
              offsetDist: 100 * Math.abs( n.range.startLineNumber - t.lineNumber ) + Math.abs( n.range.startColumn - t.column )
            }
          } ) ).sort( ( ( e, t ) => {
            return e.prefixLen > t.prefixLen ? -1 : e.prefixLen < t.prefixLen ? 1 : e.offsetDist < t.offsetDist ? -1 : e.offsetDist > t.offsetDist ? 1 : 0
          } ) )[ 0 ];
          if ( n ) return this._references[ n.idx ]
        }, e.prototype.dispose = function () {
          this._groups = Object( s.d )( this._groups ), Object( s.d )( this._disposables ), this._disposables.length = 0
        }, e._compareReferences = ( e, t ) => {
          const n = e.uri.toString(),
            i = t.uri.toString();
          return n < i ? -1 : n > i ? 1 : c.a.compareRangesUsingStarts( e.range, t.range )
        }, e;
      } )();
    },
    PGsk( e, t, n ) {
      "use strict";
      const i = n( "S3by" ),
        o = n( "bY76" ),
        r = n( "VMIq" ),
        s = n( "nnTU" ),
        a = n( "3/fG" ),
        u = n( "pmY6" ),
        l = n( "MI8n" ),
        c = n( "X+cX" ),
        d = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        h = ( e => {
          function t( t, n, i, o, r ) {
            const s = e.call( this ) || this;
            return s._contextKeyService = t, s._commandService = n, s._telemetryService = i, s._statusService = r, s._notificationService = o, s._currentChord = null, s._currentChordChecker = new c.b, s._currentChordStatusMessage = null, s._onDidUpdateKeybindings = s._register( new l.a ), s
          }
          return d( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, Object.defineProperty( t.prototype, "onDidUpdateKeybindings", {
            get() {
              return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : l.b.None
            },
            enumerable: !0,
            configurable: !0
          } ), t.prototype.lookupKeybinding = function ( e ) {
            const t = this._getResolver().lookupPrimaryKeybinding( e );
            return t ? t.resolvedKeybinding : null
          }, t.prototype._enterChordMode = function ( e, t ) {
            const n = this;
            this._currentChord = {
              keypress: e,
              label: t
            }, this._statusService && ( this._currentChordStatusMessage = this._statusService.setStatusMessage( a.a( "first.chord", "({0}) was pressed. Waiting for second key of chord...", t ) ) );
            const i = Date.now();
            this._currentChordChecker.cancelAndSet( ( () => {
              n._documentHasFocus() ? Date.now() - i > 5e3 && n._leaveChordMode() : n._leaveChordMode()
            } ), 500 )
          }, t.prototype._leaveChordMode = function () {
            this._currentChordStatusMessage && ( this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null ), this._currentChordChecker.cancel(), this._currentChord = null
          }, t.prototype._dispatch = function ( e, t ) {
            const n = this;
            let i = !1;
            const o = this.resolveKeyboardEvent( e );
            if ( o.isChord() ) return console.warn( "Unexpected keyboard event mapped to a chord" ), null;
            const r = o.getDispatchParts()[ 0 ];
            if ( null === r ) return i;
            const s = this._contextKeyService.getContext( t ),
              u = this._currentChord ? this._currentChord.keypress : null,
              l = o.getLabel(),
              c = this._getResolver().resolve( s, u, r );
            return c && c.enterChord ? ( i = !0, this._enterChordMode( r, l ), i ) : ( this._statusService && this._currentChord && ( c && c.commandId || ( this._statusService.setStatusMessage( a.a( "missing.chord", "The key combination ({0}, {1}) is not a command.", this._currentChord.label, l ), 1e4 ), i = !0 ) ), this._leaveChordMode(), c && c.commandId && ( c.bubble || ( i = !0 ), "undefined" === typeof c.commandArgs ? this._commandService.executeCommand( c.commandId ).done( void 0, ( e => {
              return n._notificationService.warn( e )
            } ) ) : this._commandService.executeCommand( c.commandId, c.commandArgs ).done( void 0, ( e => {
              return n._notificationService.warn( e )
            } ) ), this._telemetryService.publicLog( "workbenchActionExecuted", {
              id: c.commandId,
              from: "keybinding"
            } ) ), i );
          }, t;
        } )( u.a ),
        p = n( "/kV6" ),
        f = n( "i04g" ),
        g = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        m = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            if ( i._os = n, null === t ) throw new Error( "Invalid USLayoutResolvedKeybinding" );
            return 2 === t.type ? ( i._firstPart = t.firstPart, i._chordPart = t.chordPart ) : ( i._firstPart = t, i._chordPart = null ), i
          }
          return g( t, e ), t.prototype._keyCodeToUILabel = function ( e ) {
            if ( 2 === this._os ) switch ( e ) {
              case 15:
                return "\u2190";
              case 16:
                return "\u2191";
              case 17:
                return "\u2192";
              case 18:
                return "\u2193"
            }
            return p.b.toString( e )
          }, t.prototype._getUILabelForKeybinding = function ( e ) {
            return e ? e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel( e.keyCode ) : null
          }, t.prototype.getLabel = function () {
            const e = this._getUILabelForKeybinding( this._firstPart ),
              t = this._getUILabelForKeybinding( this._chordPart );
            return f.b.toLabel( this._firstPart, e, this._chordPart, t, this._os )
          }, t.prototype._getAriaLabelForKeybinding = e => {
            return e ? e.isDuplicateModifierCase() ? "" : p.b.toString( e.keyCode ) : null
          }, t.prototype.getAriaLabel = function () {
            const e = this._getAriaLabelForKeybinding( this._firstPart ),
              t = this._getAriaLabelForKeybinding( this._chordPart );
            return f.a.toLabel( this._firstPart, e, this._chordPart, t, this._os )
          }, t.prototype.isChord = function () {
            return !!this._chordPart
          }, t.prototype.getParts = function () {
            return [ this._toResolvedKeybindingPart( this._firstPart ), this._toResolvedKeybindingPart( this._chordPart ) ]
          }, t.prototype._toResolvedKeybindingPart = function ( e ) {
            return e ? new p.d( e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getUILabelForKeybinding( e ), this._getAriaLabelForKeybinding( e ) ) : null
          }, t.prototype.getDispatchParts = function () {
            return [ this._firstPart ? t.getDispatchStr( this._firstPart ) : null, this._chordPart ? t.getDispatchStr( this._chordPart ) : null ]
          }, t.getDispatchStr = e => {
            if ( e.isModifierKey() ) return null;
            let t = "";
            return e.ctrlKey && ( t += "ctrl+" ), e.shiftKey && ( t += "shift+" ), e.altKey && ( t += "alt+" ), e.metaKey && ( t += "meta+" ), t += p.b.toString( e.keyCode )
          }, t;
        } )( p.c ),
        _ = n( "YcIv" ),
        v = n( "bexQ" ),
        y = n( "EWX2" ),
        b = n( "sFUC" ),
        C = n( "QDVR" ),
        w = n( "6OMU" ),
        S = n( "746U" ),
        O = n( "qj0h" ),
        L = n( "CRAX" ),
        x = n( "+7oY" ),
        N = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        E = ( () => {
          function e( e, t, n ) {
            void 0 === e && ( e = {} ), void 0 === t && ( t = [] ), void 0 === n && ( n = [] ), this._contents = e, this._keys = t, this._overrides = n, this.isFrozen = !1
          }
          return Object.defineProperty( e.prototype, "contents", {
            get() {
              return this.checkAndFreeze( this._contents )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "overrides", {
            get() {
              return this.checkAndFreeze( this._overrides )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "keys", {
            get() {
              return this.checkAndFreeze( this._keys )
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.getValue = function ( e ) {
            return e ? Object( x.e )( this.contents, e ) : this.contents
          }, e.prototype.override = function ( t ) {
            const n = this.getContentsForOverrideIdentifer( t );
            if ( !n || "object" !== typeof n || !Object.keys( n ).length ) return this;
            for ( var i = {}, o = 0, r = w.d( Object.keys( this.contents ).concat( Object.keys( n ) ) ); o < r.length; o++ ) {
              const s = r[ o ];
              let a = this.contents[ s ];
              const u = n[ s ];
              u && ( "object" === typeof a && "object" === typeof u ? ( a = O.c( a ), this.mergeContents( a, u ) ) : a = u ), i[ s ] = a
            }
            return new e( i )
          }, e.prototype.merge = function () {
            for ( var t = [], n = 0; n < arguments.length; n++ ) t[ n ] = arguments[ n ];
            for ( var i = O.c( this.contents ), o = O.c( this.overrides ), r = this.keys.slice(), s = 0, a = t; s < a.length; s++ ) {
              const u = a[ s ];
              this.mergeContents( i, u.contents );
              for ( let l = e => {
                  const t = o.filter( ( t => {
                    return w.e( t.identifiers, e.identifiers )
                  } ) )[ 0 ];
                  t ? c.mergeContents( t.contents, e.contents ) : o.push( O.c( e ) )
                }, c = this, d = 0, h = u.overrides; d < h.length; d++ ) {
                const p = h[ d ];
                l( p )
              }
              for ( let f = 0, g = u.keys; f < g.length; f++ ) {
                const m = g[ f ]; - 1 === r.indexOf( m ) && r.push( m )
              }
            }
            return new e( i, r, o )
          }, e.prototype.freeze = function () {
            return this.isFrozen = !0, this
          }, e.prototype.mergeContents = function ( e, t ) {
            for ( let n = 0, i = Object.keys( t ); n < i.length; n++ ) {
              const o = i[ n ];
              o in e && S.g( e[ o ] ) && S.g( t[ o ] ) ? this.mergeContents( e[ o ], t[ o ] ) : e[ o ] = O.c( t[ o ] )
            }
          }, e.prototype.checkAndFreeze = function ( e ) {
            return this.isFrozen && !Object.isFrozen( e ) ? O.d( e ) : e
          }, e.prototype.getContentsForOverrideIdentifer = function ( e ) {
            for ( let t = 0, n = this.overrides; t < n.length; t++ ) {
              const i = n[ t ];
              if ( -1 !== i.identifiers.indexOf( e ) ) return i.contents
            }
            return null
          }, e.prototype.toJSON = function () {
            return {
              contents: this.contents,
              overrides: this.overrides,
              keys: this.keys
            }
          }, e.prototype.setValue = function ( e, t ) {
            this.addKey( e ), Object( x.c )( this.contents, e, t, ( e => {
              throw new Error( e )
            } ) )
          }, e.prototype.removeValue = function ( e ) {
            this.removeKey( e ) && Object( x.h )( this.contents, e )
          }, e.prototype.addKey = function ( e ) {
            for ( var t = this.keys.length, n = 0; n < t; n++ ) 0 === e.indexOf( this.keys[ n ] ) && ( t = n );
            this.keys.splice( t, 1, e )
          }, e.prototype.removeKey = function ( e ) {
            const t = this.keys.indexOf( e );
            return -1 !== t && ( this.keys.splice( t, 1 ), !0 )
          }, e;
        } )(),
        k = ( e => {
          function t() {
            for ( var t = Object( x.f )(), n = Object( x.d )(), i = [], o = 0, r = Object.keys( t ); o < r.length; o++ ) {
              const s = r[ o ];
              L.c.test( s ) && i.push( {
                identifiers: [ Object( x.g )( s ).trim() ],
                contents: Object( x.i )( t[ s ], ( e => {
                  return console.error( "Conflict in default settings file: " + e )
                } ) )
              } )
            }
            return e.call( this, t, n, i ) || this
          }
          return N( t, e ), t
        } )( E ),
        I = ( () => {
          function e( e, t, n, i, o, r, s ) {
            void 0 === n && ( n = new E ), void 0 === i && ( i = new C.b ), void 0 === o && ( o = new E ), void 0 === r && ( r = new C.b ), void 0 === s && ( s = !0 ), this._defaultConfiguration = e, this._userConfiguration = t, this._workspaceConfiguration = n, this._folderConfigurations = i, this._memoryConfiguration = o, this._memoryConfigurationByResource = r, this._freeze = s, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new C.b
          }
          return e.prototype.getValue = function ( e, t, n ) {
            return this.getConsolidateConfigurationModel( t, n ).getValue( e )
          }, e.prototype.updateValue = function ( e, t, n ) {
            let i;
            void 0 === n && ( n = {} ), n.resource ? ( i = this._memoryConfigurationByResource.get( n.resource ) ) || ( i = new E, this._memoryConfigurationByResource.set( n.resource, i ) ) : i = this._memoryConfiguration, void 0 === t ? i.removeValue( e ) : i.setValue( e, t ), n.resource || ( this._workspaceConsolidatedConfiguration = null )
          }, e.prototype.getConsolidateConfigurationModel = function ( e, t ) {
            const n = this.getConsolidatedConfigurationModelForResource( e, t );
            return e.overrideIdentifier ? n.override( e.overrideIdentifier ) : n
          }, e.prototype.getConsolidatedConfigurationModelForResource = function ( e, t ) {
            const n = e.resource;
            let i = this.getWorkspaceConsolidatedConfiguration();
            if ( t && n ) {
              const o = t.getFolder( n );
              o && ( i = this.getFolderConsolidatedConfiguration( o.uri ) || i );
              const r = this._memoryConfigurationByResource.get( n );
              r && ( i = i.merge( r ) )
            }
            return i
          }, e.prototype.getWorkspaceConsolidatedConfiguration = function () {
            return this._workspaceConsolidatedConfiguration || ( this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge( this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration ), this._freeze && ( this._workspaceConfiguration = this._workspaceConfiguration.freeze() ) ), this._workspaceConsolidatedConfiguration
          }, e.prototype.getFolderConsolidatedConfiguration = function ( e ) {
            let t = this._foldersConsolidatedConfigurations.get( e );
            if ( !t ) {
              const n = this.getWorkspaceConsolidatedConfiguration(),
                i = this._folderConfigurations.get( e );
              i ? ( t = n.merge( i ), this._freeze && ( t = t.freeze() ), this._foldersConsolidatedConfigurations.set( e, t ) ) : t = n
            }
            return t
          }, e;
        } )(),
        D = n( "EffR" ),
        M = n( "uDWl" ),
        T = n( "nrhi" ),
        R = n( "T8No" ),
        P = n( "fjLI" ),
        A = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        F = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        W = ( () => {
          function e( t, n, i, o ) {
            const r = this;
            this._commandService = i, this._contextKeyService = o, this._menuGroups = [], this._disposables = [], this._onDidChange = new l.a, n.then( ( n => {
              let i;
              const o = P.d.getMenuItems( t );
              const s = new Set;
              o.sort( e._compareMenuItems );
              for ( let a = 0, u = o; a < u.length; a++ ) {
                const l = u[ a ],
                  c = l.group;
                i && i[ 0 ] === c || ( i = [ c, [] ], r._menuGroups.push( i ) ), i[ 1 ].push( l ), e._fillInKbExprKeys( l.when, s )
              }
              r._disposables.push( r._contextKeyService.onDidChangeContext( ( e => {
                e.affectsSome( s ) && r._onDidChange.fire()
              } ) ) ), r._onDidChange.fire( r )
            } ) )
          }
          return e.prototype.dispose = function () {
            this._disposables = Object( u.d )( this._disposables ), this._onDidChange.dispose()
          }, e.prototype.getActions = function ( e ) {
            for ( var t = [], n = 0, i = this._menuGroups; n < i.length; n++ ) {
              for ( var o = i[ n ], r = o[ 0 ], s = [], a = 0, u = o[ 1 ]; a < u.length; a++ ) {
                const l = u[ a ];
                if ( this._contextKeyService.contextMatchesRules( l.when ) ) {
                  const c = Object( P.f )( l ) ? new P.c( l.command, l.alt, e, this._contextKeyService, this._commandService ) : new P.e( l );
                  c.order = l.order, s.push( c )
                }
              }
              s.length > 0 && t.push( [ r, s ] )
            }
            return t
          }, e._fillInKbExprKeys = ( e, t ) => {
            if ( e )
              for ( let n = 0, i = e.keys(); n < i.length; n++ ) {
                const o = i[ n ];
                t.add( o )
              }
          }, e._compareMenuItems = ( e, t ) => {
            const n = e.group,
              i = t.group;
            if ( n !== i ) {
              if ( !n ) return 1;
              if ( !i ) return -1;
              if ( "navigation" === n ) return -1;
              if ( "navigation" === i ) return 1;
              const o = n.localeCompare( i );
              if ( 0 !== o ) return o
            }
            const r = e.order || 0,
              s = t.order || 0;
            if ( r < s ) return -1;
            if ( r > s ) return 1;
            const a = "string" === typeof e.command.title ? e.command.title : e.command.title.value,
              u = "string" === typeof t.command.title ? t.command.title : t.command.title.value;
            return a.localeCompare( u )
          }, e = A( [ F( 2, s.b ), F( 3, R.e ) ], e );
        } )(),
        j = function ( e, t, n, i, o ) {
          if ( this.resolvedKeybinding = e, e ) {
            const r = e.getDispatchParts(),
              s = r[ 0 ],
              a = r[ 1 ];
            this.keypressFirstPart = s, this.keypressChordPart = a
          } else this.keypressFirstPart = null, this.keypressChordPart = null;
          this.bubble = !!t && 94 === t.charCodeAt( 0 ), this.command = this.bubble ? t.substr( 1 ) : t, this.commandArgs = n, this.when = i, this.isDefault = o
        },
        V = n( "MNsG" ),
        B = n( "aokT" ),
        H = n( "sM1p" ),
        z = n( "cGHE" ),
        U = n( "iDAx" ),
        K = n( "twdY" ),
        q = n( "0/Sa" );
      n.d( t, "f", ( () => {
        return Y
      } ) ), n.d( t, "d", ( () => {
        return X
      } ) ), n.d( t, "h", ( () => {
        return $
      } ) ), n.d( t, "c", ( () => {
        return Z
      } ) ), n.d( t, "g", ( () => {
        return Q
      } ) ), n.d( t, "l", ( () => {
        return J
      } ) ), n.d( t, "m", ( () => {
        return ee
      } ) ), n.d( t, "b", ( () => {
        return ne
      } ) ), n.d( t, "i", ( () => {
        return ie
      } ) ), n.d( t, "e", ( () => {
        return oe
      } ) ), n.d( t, "n", ( () => {
        return re
      } ) ), n.d( t, "k", ( () => {
        return se
      } ) ), n.d( t, "o", ( () => {
        return ae
      } ) ), n.d( t, "a", ( () => {
        return ue
      } ) ), n.d( t, "j", ( () => {
        return le
      } ) );
      const G = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var Y = ( () => {
        function e( e ) {
          this.model = e, this._onDispose = new l.a
        }
        return Object.defineProperty( e.prototype, "textEditorModel", {
          get() {
            return this.model
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.dispose = function () {
          this._onDispose.fire()
        }, e;
      } )();
      var X = ( () => {
          function e() {}
          return e.prototype.setEditor = function ( e ) {
            this.editor = e
          }, e.prototype.createModelReference = function ( e ) {
            let t;
            let n;
            let i;
            let o;
            const s = this;
            return n = this.editor, i = t => {
              return s.findModel( t, e )
            }, o = t => {
              return s.findModel( t.getOriginalEditor(), e ) || s.findModel( t.getModifiedEditor(), e )
            }, ( t = Object( b.d )( n ) ? i( n ) : o( n ) ) ? r.b.as( new u.b( new Y( t ) ) ) : r.b.as( new u.b( null ) );
          }, e.prototype.findModel = ( e, t ) => {
            const n = e.getModel();
            return n.uri.toString() !== t.toString() ? null : n
          }, e;
        } )(),
        $ = ( () => {
          function e() {}
          return e.prototype.showWhile = ( e, t ) => {
            return null
          }, e;
        } )(),
        Z = () => {},
        Q = ( () => {
          function e() {}
          return e.prototype.info = function ( e ) {
            return this.notify( {
              severity: i.a.Info,
              message: e
            } )
          }, e.prototype.warn = function ( e ) {
            return this.notify( {
              severity: i.a.Warning,
              message: e
            } )
          }, e.prototype.error = function ( e ) {
            return this.notify( {
              severity: i.a.Error,
              message: e
            } )
          }, e.prototype.notify = t => {
            switch ( t.severity ) {
              case i.a.Error:
                console.error( t.message );
                break;
              case i.a.Warning:
                console.warn( t.message );
                break;
              default:
                console.log( t.message )
            }
            return e.NO_OP
          }, e.NO_OP = new H.b, e;
        } )(),
        J = ( () => {
          function e( e ) {
            this._onWillExecuteCommand = new l.a, this._instantiationService = e, this._dynamicCommands = Object.create( null )
          }
          return e.prototype.addCommand = function ( e ) {
            const t = this,
              n = e.id;
            return this._dynamicCommands[ n ] = e, Object( u.f )( ( () => {
              delete t._dynamicCommands[ n ]
            } ) );
          }, e.prototype.executeCommand = function ( e ) {
            for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
            const i = s.a.getCommand( e ) || this._dynamicCommands[ e ];
            if ( !i ) return r.b.wrapError( new Error( "command '" + e + "' not found" ) );
            try {
              this._onWillExecuteCommand.fire( {
                commandId: e
              } );
              const o = this._instantiationService.invokeFunction.apply( this._instantiationService, [ i.handler ].concat( t ) );
              return r.b.as( o )
            } catch ( a ) {
              return r.b.wrapError( a )
            }
          }, e;
        } )(),
        ee = ( e => {
          function t( t, n, i, o, r ) {
            const s = e.call( this, t, n, i, o ) || this;
            return s._cachedResolver = null, s._dynamicKeybindings = [], s._register( D.g( r, D.d.KEY_DOWN, ( e => {
              const t = new M.a( e );
              s._dispatch( t, t.target ) && t.preventDefault()
            } ) ) ), s;
          }
          return G( t, e ), t.prototype.addDynamicKeybinding = function ( e, t, n, i ) {
            const o = this,
              r = [];
            this._dynamicKeybindings.push( {
              keybinding: Object( p.f )( t, V.a ),
              command: e,
              when: i,
              weight1: 1e3,
              weight2: 0
            } ), r.push( Object( u.f )( ( () => {
              for ( let t = 0; t < o._dynamicKeybindings.length; t++ ) {
                if ( o._dynamicKeybindings[ t ].command === e ) return o._dynamicKeybindings.splice( t, 1 ), void o.updateResolver( {
                  source: v.b.Default
                } )
              }
            } ) ) );
            const s = this._commandService;
            if ( !( s instanceof J ) ) throw new Error( "Unknown command service!" );
            return r.push( s.addCommand( {
              id: e,
              handler: n
            } ) ), this.updateResolver( {
              source: v.b.Default
            } ), Object( u.c )( r )
          }, t.prototype.updateResolver = function ( e ) {
            this._cachedResolver = null, this._onDidUpdateKeybindings.fire( e )
          }, t.prototype._getResolver = function () {
            if ( !this._cachedResolver ) {
              const e = this._toNormalizedKeybindingItems( T.a.getDefaultKeybindings(), !0 ),
                t = this._toNormalizedKeybindingItems( this._dynamicKeybindings, !1 );
              this._cachedResolver = new _.a( e, t )
            }
            return this._cachedResolver
          }, t.prototype._documentHasFocus = () => {
            return document.hasFocus()
          }, t.prototype._toNormalizedKeybindingItems = function ( e, t ) {
            for ( var n = [], i = 0, o = 0, r = e.length; o < r; o++ ) {
              const s = e[ o ],
                a = s.when ? s.when.normalize() : null,
                u = s.keybinding;
              if ( u )
                for ( let l = this.resolveKeybinding( u ), c = 0; c < l.length; c++ ) n[ i++ ] = new j( l[ c ], s.command, s.commandArgs, a, t );
              else n[ i++ ] = new j( null, s.command, s.commandArgs, a, t )
            }
            return n
          }, t.prototype.resolveKeybinding = e => {
            return [ new m( e, V.a ) ]
          }, t.prototype.resolveKeyboardEvent = e => {
            const t = new p.e( e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode );
            return new m( t, V.a )
          }, t;
        } )( h );

      function te( e ) {
        return e && "object" === typeof e && ( !e.overrideIdentifier || "string" === typeof e.overrideIdentifier ) && ( !e.resource || e.resource instanceof o.a )
      }
      var ne = ( () => {
          function e() {
            this._onDidChangeConfiguration = new l.a, this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._configuration = new I( new k, new E )
          }
          return e.prototype.configuration = function () {
            return this._configuration
          }, e.prototype.getValue = function ( e, t ) {
            const n = "string" === typeof e ? e : void 0,
              i = te( e ) ? e : te( t ) ? t : {};
            return this.configuration().getValue( n, i, null )
          }, e.prototype.updateValue = function ( e, t, n, i ) {
            return this.configuration().updateValue( e, t ), r.b.as( null )
          }, e;
        } )(),
        ie = ( () => {
          function e( e ) {
            const t = this;
            this.configurationService = e, this._onDidChangeConfigurationEmitter = new l.a, this.configurationService.onDidChangeConfiguration( ( e => {
              t._onDidChangeConfigurationEmitter.fire( e )
            } ) )
          }
          return e.prototype.getValue = function ( e, t, n ) {
            const i = ( z.a.isIPosition( t ) ? t : null ) ? "string" === typeof n ? n : void 0 : "string" === typeof t ? t : void 0;
            return this.configurationService.getValue( i )
          }, e;
        } )(),
        oe = ( () => {
          function e( e ) {
            this._commandService = e
          }
          return e.prototype.createMenu = function ( e, t ) {
            return new W( e, r.b.as( !0 ), this._commandService, t )
          }, e
        } )(),
        re = ( () => {
          function e() {}
          return e.prototype.publicLog = ( e, t ) => {
            return r.b.wrap( null )
          }, e;
        } )(),
        se = ( () => {
          function e() {
            const t = o.a.from( {
              scheme: e.SCHEME,
              authority: "model",
              path: "/"
            } );
            this.workspace = {
              id: "4064f6ec-cb38-4ad0-af64-ee6467e63c82",
              folders: [ new y.b( {
                uri: t,
                name: "",
                index: 0
              } ) ],
              name: t.fsPath
            }
          }
          return e.prototype.getWorkspace = function () {
            return this.workspace
          }, e.prototype.getWorkspaceFolder = function ( t ) {
            return t && t.scheme === e.SCHEME ? this.workspace.folders[ 0 ] : void 0
          }, e
        } )();

      function ae( e, t, n ) {
        t && e instanceof ne && Object.keys( t ).forEach( ( i => {
          Object( U.d )( i ) && e.updateValue( "editor." + i, t[ i ] ), n && Object( U.c )( i ) && e.updateValue( "diffEditor." + i, t[ i ] )
        } ) )
      }
      var ue = ( () => {
          function e( e ) {
            this._modelService = e
          }
          return e.prototype.apply = function ( e, t ) {
            for ( var n = new Map, i = 0, o = e.edits; i < o.length; i++ ) {
              const s = o[ i ];
              if ( !Object( K.A )( s ) ) return r.b.wrapError( new Error( "bad edit - only text edits are supported" ) );
              const u = this._modelService.getModel( s.resource );
              if ( !u ) return r.b.wrapError( new Error( "bad edit - model not found" ) );
              let l = n.get( u );
              l || ( l = [] ), n.set( u, l.concat( s.edits ) )
            }
            let c = 0,
              d = 0;
            return n.forEach( ( ( e, t ) => {
              t.applyEdits( e.map( ( e => {
                return q.a.replaceMove( B.a.lift( e.range ), e.text )
              } ) ) ), d += 1, c += e.length
            } ) ), r.b.as( {
              selection: void 0,
              ariaSummary: Object( a.a )( "summary", "Made {0} edits in {1} files", c, d )
            } );
          }, e;
        } )(),
        le = ( () => {
          function e() {}
          return e.prototype.getLabel = ( e, t ) => {
            return "file" === e.scheme ? e.fsPath : e.path
          }, e;
        } )()
    },
    PQU8( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "Y/05" );
      const o = 25,
        r = {
          area: !0,
          base: !0,
          br: !0,
          col: !0,
          command: !0,
          embed: !0,
          frame: !0,
          hr: !0,
          img: !0,
          input: !0,
          keygen: !0,
          link: !0,
          meta: !0,
          param: !0,
          source: !0,
          track: !0,
          wbr: !0,
          menuitem: !0
        },
        s = {
          dd: !0,
          li: !0,
          optgroup: !0,
          option: !0,
          p: !0,
          rp: !0,
          rt: !0,
          tbody: !0,
          td: !0,
          tfoot: !0,
          th: !0,
          tr: !0
        },
        a = {
          dd: {
            dd: !0,
            dt: !0
          },
          dt: {
            dd: !0,
            dt: !0
          },
          li: {
            li: !0
          },
          option: {
            option: !0,
            optgroup: !0
          },
          optgroup: {
            optgroup: !0
          },
          p: {
            address: !0,
            article: !0,
            aside: !0,
            blockquote: !0,
            dir: !0,
            div: !0,
            dl: !0,
            fieldset: !0,
            footer: !0,
            form: !0,
            h1: !0,
            h2: !0,
            h3: !0,
            h4: !0,
            h5: !0,
            h6: !0,
            header: !0,
            hgroup: !0,
            hr: !0,
            menu: !0,
            nav: !0,
            ol: !0,
            p: !0,
            pre: !0,
            section: !0,
            table: !0,
            ul: !0
          },
          rp: {
            rp: !0,
            rt: !0
          },
          rt: {
            rp: !0,
            rt: !0
          },
          tbody: {
            tbody: !0,
            tfoot: !0
          },
          td: {
            td: !0,
            th: !0
          },
          tfoot: {
            tbody: !0
          },
          th: {
            td: !0,
            th: !0
          },
          thead: {
            tbody: !0,
            tfoot: !0
          },
          tr: {
            tr: !0
          }
        };

      function u( e ) {
        return 45 == e || 46 == e || 58 == e || e >= 65 && e <= 90 || 95 == e || e >= 97 && e <= 122 || e >= 161
      }
      let l = null,
        c = null,
        d = 0;

      function h( e, t ) {
        if ( d == t && c == e ) return l;
        let n = e.get( t );
        for ( ; 9 == ( i = n ) || 10 == i || 13 == i || 32 == i; ) n = e.get( ++t );
        var i;
        let o = t;
        for ( ; u( n ); ) n = e.get( ++t );
        return c = e, d = t, l = t > o ? e.read( o, t ).toLowerCase() : n == p || n == f ? void 0 : null
      }
      const p = 63,
        f = 33;

      function g( e, t ) {
        this.name = e, this.parent = t, this.hash = t ? t.hash : 0;
        for ( let n = 0; n < e.length; n++ ) this.hash += ( this.hash << 4 ) + e.charCodeAt( n ) + ( e.charCodeAt( n ) << 8 )
      }
      const m = new i.a( {
          start: null,
          shift: ( e, t, n, i ) => 1 == t ? new g( h( n, i.pos ) || "", e ) : e,
          reduce: ( e, t ) => 10 == t && e ? e.parent : e,
          reuse( e, t, n, i ) {
            let o = t.type.id;
            return 1 == o || 11 == o ? new g( h( n, i.pos - t.length + 1 ) || "", e ) : e
          },
          hash: () => 0
        } ),
        _ = new i.b( ( e, t, n ) => {
          let i, o = t.start,
            r = e.get( o );
          if ( r < 0 && n.context && t.accept( 34, t.start ), 60 != r ) return;
          o++, ( i = 47 == e.get( o ) ) && o++;
          let u = h( e, o );
          if ( void 0 === u ) return;
          if ( !u ) return t.accept( i ? 4 : 1, o );
          let l = n.context ? n.context.name : null;
          if ( i ) {
            if ( u == l ) return t.accept( 2, o );
            if ( l && s[ l ] ) return t.accept( 34, t.start );
            if ( n.dialectEnabled( 0 ) ) return t.accept( 2, o );
            for ( let e = n.context; e; e = e.parent )
              if ( e.name == u ) return;
            t.accept( 3, o )
          } else l && a[ l ] && a[ l ][ u ] ? t.accept( 34, t.start ) : t.accept( 1, o )
        } ),
        v = new i.b( ( e, t, n ) => {
          let i = e.get( t.start ),
            o = t.start + 1;
          if ( 47 == i ) {
            if ( 62 != e.get( o ) ) return;
            o++
          } else if ( 62 != i ) return;
          n.context && r[ n.context.name ] && t.accept( 5, o )
        } ),
        y = new i.b( ( e, t ) => {
          let n = t.start,
            i = 0;
          for ( ;; ) {
            let t = e.get( n );
            if ( t < 0 ) break;
            if ( n++, t == "--\x3e".charCodeAt( i ) ) {
              if ( i++, 3 == i ) {
                n -= 3;
                break
              }
            } else i = 0
          }
          n > t.start && t.accept( 35, n )
        } ),
        b = /^<\/?\s*([\.\-\:\w\xa1-\uffff]+)/;

      function C( e ) {
        let t = b.exec( e );
        return t ? t[ 1 ].toLowerCase() : null
      }

      function w( e ) {
        let t = b.exec( e ),
          n = {};
        if ( t ) {
          let i, o = /\s*([\.\-\:\w\xa1-\uffff]+)\s*(?:=("[^"]*"|'[^']*'|[^\s=<>"'/]+))?/g;
          for ( o.lastIndex = t.index + t[ 0 ].length; i = o.exec( e ); ) n[ i[ 1 ] ] = i[ 2 ] || i[ 1 ]
        }
        return n
      }

      function S( e ) {
        return t => C( t ) == e
      }

      function O( e ) {
        let t = null;
        for ( let n of e ) t || ( t = Object.create( null ) ), ( t[ n.tag ] || ( t[ n.tag ] = [] ) ).push( {
          attrs: n.attrs,
          value: {
            filterEnd: S( n.tag ),
            startParse: n.parser.startParse.bind( n.parser )
          }
        } );
        return ( e, n ) => {
          let i, r, s = e.read( n.ruleStart, n.pos ),
            a = C( s );
          if ( !a ) return null;
          if ( t && ( i = t[ a ] ) )
            for ( let t of i )
              if ( !t.attrs || t.attrs( r || ( r = w( s ) ) ) ) return t.value;
          return "script" == a || "textarea" == a || "style" == a ? {
            filterEnd: S( a ),
            wrapType: o
          } : null
        };
      }
      const L = O( [] );
      const x = i.d.deserialize( {
        version: 13,
        states: "+^OQOXOOOoO`O'#CgS!cOXO'#CfOOOP'#Cf'#CfO!mOdO'#CqO!uO`O'#CsOOOP'#DQ'#DQOOOP'#Cv'#CvQQOXOOOOOQ'#Cw'#CwO!}O`O,59RO#VOrO,59ROOOP'#C{'#C{O#eOXO'#DWO#oOPO,59QOOOS'#C|'#C|O#wOdO,59]OOOP,59],59]O$PO`O,59_O$XO`O,59_OOOP-E6t-E6tOOOQ-E6u-E6uO$aOrO1G.mO$aOrO1G.mO$oOrO'#CiOOOQ'#Cx'#CxO%QOrO1G.mOOOP1G.m1G.mOOOP1G.v1G.vOOOP-E6y-E6yO%]O`O'#CoOOOP1G.l1G.lOOOS-E6z-E6zOOOP1G.w1G.wO%eO`O1G.yO%eO`O1G.yOOOP1G.y1G.yO%mOrO7+$XO%{OrO7+$XOOOP7+$X7+$XOOOP7+$b7+$bO&WOrO,59TO&iO!bO,59TOOOQ-E6v-E6vO&wO`O,59ZO'PO`O,59ZO'XO`O7+$eOOOP7+$e7+$eO'aOrO<<GsOOOP<<Gs<<GsOOOP<<G|<<G|O'lO!bO1G.oO'lO!bO1G.oO'zO#tO'#ClO(YO&jO'#ClO(hOrO1G.oO(vO`O1G.uO(vO`O1G.uOOOP1G.u1G.uOOOP<<HP<<HPOOOPAN=_AN=_OOOPAN=hAN=hO)OO!bO7+$ZO)^OrO7+$ZOOOO'#Cy'#CyO)lO#tO,59WOOOQ,59W,59WOOOO'#Cz'#CzO)zO&jO,59WO)^OrO7+$ZO*YO`O7+$aOOOP7+$a7+$aO*bOrO<<GuO*bOrO<<GuOOOO-E6w-E6wOOOQ1G.r1G.rOOOO-E6x-E6xOOOP<<G{<<G{O*pOrOAN=a",
        stateData: "+T~OPPORTOSUOVUOWUOXUOfUOhVO{SO~O[ZOuXO~OPPORTOSUOVUOWUOXUOfUO{SO~OQzPrzP~PwOs_O|aO~O[cOuXO~O[fOuXO~OTlO^hObkOuXO~OQzXrzX~PwOQnOroO~Os_O|qO~O[rOuXO~ObtOuXO~OTxO^hObwOuXO~O_zOuXOT]X^]Xb]X~OTxO^hObwO~O[}OuXO~Ob!POuXO~OT!SO^hOb!ROuXO~OT!SO^hOb!RO~O_!TOuXOT]a^]ab]a~Oa!XOuXOv!VOx!WO~O[!YOuXO~Ob![OuXO~Ob!]OuXO~OT!_O^hOb!^O~Oa!aOuXOv!VOx!WO~OW!bOX!bOv!dOw!bO~OW!eOX!eOx!dOy!eO~OuXOT]i^]ib]i~Ob!iOuXO~Oa!jOuXOv!VOx!WO~OuXOT]q^]qb]q~OW!bOX!bOv!mOw!bO~OW!eOX!eOx!mOy!eO~Ob!oOuXO~OuXOT]y^]yb]y~OuXOT]!R^]!Rb]!R~O{fhf~",
        goto: "%b{PPPPPPPPPP|!SP!YPP!cPP!m!p|P|PP!v!|$^$m$s$y%PPPP%VPPPPP%_XUOQW]XQOQW]_iZfgjuv!QQ!XzS!a!T!UR!j!`Ro^XROQW]QWORdWQYPQbTneYbgsuy|!O!U!Z!`!g!h!k!pQgZQscQufQyhQ|nQ!OrQ!UzQ!Z}Q!`!TQ!g!XQ!h!YQ!k!aR!p!jQjZSvfgU{jv!QR!QuQ!c!VR!l!cQ!f!WR!n!fQ]QRm]Q`SRp`SVOWT[Q]R^Q",
        nodeNames: "\u26a0 StartTag StartCloseTag StartCloseTag IncompleteCloseTag SelfCloseEndTag Document Text EntityReference CharacterReference Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl RawText",
        maxTerm: 44,
        context: m,
        nodeProps: [
          [ i.c.closedBy, -2, 1, 2, "EndTag SelfCloseEndTag", 11, "CloseTag" ],
          [ i.c.openedBy, 5, "StartTag", 18, "StartTag StartCloseTag", 19, "OpenTag" ]
        ],
        skippedNodes: [ 0, 25 ],
        repeatNodeCount: 7,
        tokenData: "!$|!aR!WOX$kXY)sYZ)sZ]$k]^)s^p$kpq)sqr$krs*zsv$kvw+dwx2wx}$k}!O3d!O!P$k!P!Q7]!Q![$k![!]8s!]!^$k!^!_>`!_!`!!n!`!a8R!a!c$k!c!}8s!}#R$k#R#S8s#S#T$k#T#o8s#o$f$k$f$g&R$g%W$k%W%o8s%o%p$k%p&a8s&a&b$k&b1p8s1p4U$k4U4d8s4d4e$k4e$IS8s$IS$I`$k$I`$Ib8s$Ib$Kh$k$Kh%#t8s%#t&/x$k&/x&Et8s&Et&FV$k&FV;'S8s;'S;:j!#`;:j?&r$k?&r?Ah8s?Ah?BY$k?BY?Mn8s?Mn~$k!Z$vcVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!R&[VVPw`ypOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&Rq&xTVPypOv&qwx'Xx!^&q!^!_'g!_~&qP'^RVPOv'Xw!^'X!_~'Xp'lQypOv'gx~'ga'yUVPw`Or'rrs'Xsv'rw!^'r!^!_(]!_~'r`(bRw`Or(]sv(]w~(]!Q(rTw`ypOr(krs'gsv(kwx(]x~(kW)WXaWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!a*O^VPw`ypu^OX&RXY)sYZ)sZ]&R]^)s^p&Rpq)sqr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!Z+TTvhVPypOv&qwx'Xx!^&q!^!_'g!_~&q!Z+ibaWOX,qXZ.OZ],q]^.O^p,qqr,qrs.Ost/Ztw,qwx.Ox!P,q!P!Q.O!Q!],q!]!^)R!^!a.O!a$f,q$f$g.O$g~,q!Z,vbaWOX,qXZ.OZ],q]^.O^p,qqr,qrs.Ost)Rtw,qwx.Ox!P,q!P!Q.O!Q!],q!]!^.g!^!a.O!a$f,q$f$g.O$g~,q!R.RTOp.Oqs.Ot!].O!]!^.b!^~.O!R.gOW!R!Z.nXW!RaWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z/`aaWOX0eXZ1oZ]0e]^1o^p0eqr0ers1osw0ewx1ox!P0e!P!Q1o!Q!]0e!]!^)R!^!a1o!a$f0e$f$g1o$g~0e!Z0jaaWOX0eXZ1oZ]0e]^1o^p0eqr0ers1osw0ewx1ox!P0e!P!Q1o!Q!]0e!]!^2T!^!a1o!a$f0e$f$g1o$g~0e!R1rSOp1oq!]1o!]!^2O!^~1o!R2TOX!R!Z2[XX!RaWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z3QUxxVPw`Or'rrs'Xsv'rw!^'r!^!_(]!_~'r!]3oeVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O5Q!O!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!]5]dVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!`&R!`!a6k!a$f$k$f$g&R$g~$k!T6vVVPw`yp|QOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!X7fXVPw`ypOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_!`&R!`!a8R!a~&R!X8^VbUVPw`ypOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!a9S!Y^S[QVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O8s!O!P8s!P!Q&R!Q![8s![!]8s!]!^$k!^!_(k!_!a&R!a!c$k!c!}8s!}#R$k#R#S8s#S#T$k#T#o8s#o$f$k$f$g&R$g$}$k$}%O8s%O%W$k%W%o8s%o%p$k%p&a8s&a&b$k&b1p8s1p4U8s4U4d8s4d4e$k4e$IS8s$IS$I`$k$I`$Ib8s$Ib$Je$k$Je$Jg8s$Jg$Kh$k$Kh%#t8s%#t&/x$k&/x&Et8s&Et&FV$k&FV;'S8s;'S;:j<r;:j?&r$k?&r?Ah8s?Ah?BY$k?BY?Mn8s?Mn~$k!a<}eVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g;=`$k;=`<%l8s<%l~$k!R>gWw`ypOq(kqr?Prs'gsv(kwx(]x!a(k!a!bKh!b~(k!R?WZw`ypOr(krs'gsv(kwx(]x}(k}!O?y!O!f(k!f!gAP!g#W(k#W#XGx#X~(k!R@QVw`ypOr(krs'gsv(kwx(]x}(k}!O@g!O~(k!R@pTw`yp{POr(krs'gsv(kwx(]x~(k!RAWVw`ypOr(krs'gsv(kwx(]x!q(k!q!rAm!r~(k!RAtVw`ypOr(krs'gsv(kwx(]x!e(k!e!fBZ!f~(k!RBbVw`ypOr(krs'gsv(kwx(]x!v(k!v!wBw!w~(k!RCOVw`ypOr(krs'gsv(kwx(]x!{(k!{!|Ce!|~(k!RClVw`ypOr(krs'gsv(kwx(]x!r(k!r!sDR!s~(k!RDYVw`ypOr(krs'gsv(kwx(]x!g(k!g!hDo!h~(k!RDvWw`ypOrDorsE`svDovwEtwxFdx!`Do!`!aG`!a~DoqEeTypOvE`vxEtx!`E`!`!aFV!a~E`PEwRO!`Et!`!aFQ!a~EtPFVOhPqF^QyphPOv'gx~'gaFiVw`OrFdrsEtsvFdvwEtw!`Fd!`!aGO!a~FdaGVRw`hPOr(]sv(]w~(]!RGiTw`yphPOr(krs'gsv(kwx(]x~(k!RHPVw`ypOr(krs'gsv(kwx(]x#c(k#c#dHf#d~(k!RHmVw`ypOr(krs'gsv(kwx(]x#V(k#V#WIS#W~(k!RIZVw`ypOr(krs'gsv(kwx(]x#h(k#h#iIp#i~(k!RIwVw`ypOr(krs'gsv(kwx(]x#m(k#m#nJ^#n~(k!RJeVw`ypOr(krs'gsv(kwx(]x#d(k#d#eJz#e~(k!RKRVw`ypOr(krs'gsv(kwx(]x#X(k#X#YDo#Y~(k!RKoWw`ypOrKhrsLXsvKhvwLmwxM}x!aKh!a!b! e!b~KhqL^TypOvLXvxLmx!aLX!a!bM[!b~LXPLpRO!aLm!a!bLy!b~LmPL|RO!`Lm!`!aMV!a~LmPM[OfPqMaTypOvLXvxLmx!`LX!`!aMp!a~LXqMwQypfPOv'gx~'gaNSVw`OrM}rsLmsvM}vwLmw!aM}!a!bNi!b~M}aNnVw`OrM}rsLmsvM}vwLmw!`M}!`!a! T!a~M}a! [Rw`fPOr(]sv(]w~(]!R! lWw`ypOrKhrsLXsvKhvwLmwxM}x!`Kh!`!a!!U!a~Kh!R!!_Tw`ypfPOr(krs'gsv(kwx(]x~(k!V!!yV_SVPw`ypOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!a!#keVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g;=`$k;=`<%l8s<%l~$k",
        tokenizers: [ _, v, y, 0, 1, 2, 3, 4, 5 ],
        topRules: {
          Document: [ 0, 6 ]
        },
        nested: [
          [ "elementContent", L, "&k~RP!^!_U~XP!P!Q[~_dXY!mYZ!m]^!mpq!m![!]$O!c!}$O#R#S$O#T#o$O%W%o$O%p&a$O&b1p$O4U4d$O4e$IS$O$I`$Ib$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&e?&r?Ah$O?BY?Mn$O~!pdXY!mYZ!m]^!mpq!m![!]$O!c!}$O#R#S$O#T#o$O%W%o$O%p&a$O&b1p$O4U4d$O4e$IS$O$I`$Ib$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&e?&r?Ah$O?BY?Mn$O~$RkXY%vYZ%v]^%vpq%v}!O$O!O!P$O!Q![$O![!]$O!`!a&Y!c!}$O#R#S$O#T#o$O$}%O$O%W%o$O%p&a$O&b1p$O1p4U$O4U4d$O4e$IS$O$I`$Ib$O$Je$Jg$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&_?&r?Ah$O?BY?Mn$O~%yTXY%vYZ%v]^%vpq%v!`!a&Y~&_Oq~~&bP;=`<%l$O~&hP;=`<%l$O", 42 ]
        ],
        dialects: {
          noMatch: 0
        },
        tokenPrec: 460
      } );
      const N = n( "Bxk6" ),
        E = n( "tzg4" ),
        k = n( "yqQ+" ),
        I = n( "ubVE" );
      n.d( t, "html", ( () => {
        return Z
      } ) ), n.d( t, "htmlCompletion", ( () => {
        return $
      } ) ), n.d( t, "htmlLanguage", ( () => {
        return Y
      } ) );
      const D = [ "_blank", "_self", "_top", "_parent" ],
        M = [ "ascii", "utf-8", "utf-16", "latin1", "latin1" ],
        T = [ "get", "post", "put", "delete" ],
        R = [ "application/x-www-form-urlencoded", "multipart/form-data", "text/plain" ],
        P = [ "true", "false" ],
        A = {},
        F = {
          a: {
            attrs: {
              href: null,
              ping: null,
              type: null,
              media: null,
              target: D,
              hreflang: null
            }
          },
          abbr: A,
          acronym: A,
          address: A,
          applet: A,
          area: {
            attrs: {
              alt: null,
              coords: null,
              href: null,
              target: null,
              ping: null,
              media: null,
              hreflang: null,
              type: null,
              shape: [ "default", "rect", "circle", "poly" ]
            }
          },
          article: A,
          aside: A,
          audio: {
            attrs: {
              src: null,
              mediagroup: null,
              crossorigin: [ "anonymous", "use-credentials" ],
              preload: [ "none", "metadata", "auto" ],
              autoplay: [ "autoplay" ],
              loop: [ "loop" ],
              controls: [ "controls" ]
            }
          },
          b: A,
          base: {
            attrs: {
              href: null,
              target: D
            }
          },
          basefont: A,
          bdi: A,
          bdo: A,
          big: A,
          blockquote: {
            attrs: {
              cite: null
            }
          },
          body: A,
          br: A,
          button: {
            attrs: {
              form: null,
              formaction: null,
              name: null,
              value: null,
              autofocus: [ "autofocus" ],
              disabled: [ "autofocus" ],
              formenctype: R,
              formmethod: T,
              formnovalidate: [ "novalidate" ],
              formtarget: D,
              type: [ "submit", "reset", "button" ]
            }
          },
          canvas: {
            attrs: {
              width: null,
              height: null
            }
          },
          caption: A,
          center: A,
          cite: A,
          code: A,
          col: {
            attrs: {
              span: null
            }
          },
          colgroup: {
            attrs: {
              span: null
            }
          },
          command: {
            attrs: {
              type: [ "command", "checkbox", "radio" ],
              label: null,
              icon: null,
              radiogroup: null,
              command: null,
              title: null,
              disabled: [ "disabled" ],
              checked: [ "checked" ]
            }
          },
          data: {
            attrs: {
              value: null
            }
          },
          datagrid: {
            attrs: {
              disabled: [ "disabled" ],
              multiple: [ "multiple" ]
            }
          },
          datalist: {
            attrs: {
              data: null
            }
          },
          dd: A,
          del: {
            attrs: {
              cite: null,
              datetime: null
            }
          },
          details: {
            attrs: {
              open: [ "open" ]
            }
          },
          dfn: A,
          dir: A,
          div: A,
          dl: A,
          dt: A,
          em: A,
          embed: {
            attrs: {
              src: null,
              type: null,
              width: null,
              height: null
            }
          },
          eventsource: {
            attrs: {
              src: null
            }
          },
          fieldset: {
            attrs: {
              disabled: [ "disabled" ],
              form: null,
              name: null
            }
          },
          figcaption: A,
          figure: A,
          font: A,
          footer: A,
          form: {
            attrs: {
              action: null,
              name: null,
              "accept-charset": M,
              autocomplete: [ "on", "off" ],
              enctype: R,
              method: T,
              novalidate: [ "novalidate" ],
              target: D
            }
          },
          frame: A,
          frameset: A,
          h1: A,
          h2: A,
          h3: A,
          h4: A,
          h5: A,
          h6: A,
          head: {
            children: [ "title", "base", "link", "style", "meta", "script", "noscript", "command" ]
          },
          header: A,
          hgroup: A,
          hr: A,
          html: {
            attrs: {
              manifest: null
            },
            children: [ "head", "body" ]
          },
          i: A,
          iframe: {
            attrs: {
              src: null,
              srcdoc: null,
              name: null,
              width: null,
              height: null,
              sandbox: [ "allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts" ],
              seamless: [ "seamless" ]
            }
          },
          img: {
            attrs: {
              alt: null,
              src: null,
              ismap: null,
              usemap: null,
              width: null,
              height: null,
              crossorigin: [ "anonymous", "use-credentials" ]
            }
          },
          input: {
            attrs: {
              alt: null,
              dirname: null,
              form: null,
              formaction: null,
              height: null,
              list: null,
              max: null,
              maxlength: null,
              min: null,
              name: null,
              pattern: null,
              placeholder: null,
              size: null,
              src: null,
              step: null,
              value: null,
              width: null,
              accept: [ "audio/*", "video/*", "image/*" ],
              autocomplete: [ "on", "off" ],
              autofocus: [ "autofocus" ],
              checked: [ "checked" ],
              disabled: [ "disabled" ],
              formenctype: R,
              formmethod: T,
              formnovalidate: [ "novalidate" ],
              formtarget: D,
              multiple: [ "multiple" ],
              readonly: [ "readonly" ],
              required: [ "required" ],
              type: [ "hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month", "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio", "file", "submit", "image", "reset", "button" ]
            }
          },
          ins: {
            attrs: {
              cite: null,
              datetime: null
            }
          },
          kbd: A,
          keygen: {
            attrs: {
              challenge: null,
              form: null,
              name: null,
              autofocus: [ "autofocus" ],
              disabled: [ "disabled" ],
              keytype: [ "RSA" ]
            }
          },
          label: {
            attrs: {
              for: null,
              form: null
            }
          },
          legend: A,
          li: {
            attrs: {
              value: null
            }
          },
          link: {
            attrs: {
              href: null,
              type: null,
              hreflang: null,
              media: null,
              sizes: [ "all", "16x16", "16x16 32x32", "16x16 32x32 64x64" ]
            }
          },
          map: {
            attrs: {
              name: null
            }
          },
          mark: A,
          menu: {
            attrs: {
              label: null,
              type: [ "list", "context", "toolbar" ]
            }
          },
          meta: {
            attrs: {
              content: null,
              charset: M,
              name: [ "viewport", "application-name", "author", "description", "generator", "keywords" ],
              "http-equiv": [ "content-language", "content-type", "default-style", "refresh" ]
            }
          },
          meter: {
            attrs: {
              value: null,
              min: null,
              low: null,
              high: null,
              max: null,
              optimum: null
            }
          },
          nav: A,
          noframes: A,
          noscript: A,
          object: {
            attrs: {
              data: null,
              type: null,
              name: null,
              usemap: null,
              form: null,
              width: null,
              height: null,
              typemustmatch: [ "typemustmatch" ]
            }
          },
          ol: {
            attrs: {
              reversed: [ "reversed" ],
              start: null,
              type: [ "1", "a", "A", "i", "I" ]
            },
            children: [ "li", "script", "template", "ul", "ol" ]
          },
          optgroup: {
            attrs: {
              disabled: [ "disabled" ],
              label: null
            }
          },
          option: {
            attrs: {
              disabled: [ "disabled" ],
              label: null,
              selected: [ "selected" ],
              value: null
            }
          },
          output: {
            attrs: {
              for: null,
              form: null,
              name: null
            }
          },
          p: A,
          param: {
            attrs: {
              name: null,
              value: null
            }
          },
          pre: A,
          progress: {
            attrs: {
              value: null,
              max: null
            }
          },
          q: {
            attrs: {
              cite: null
            }
          },
          rp: A,
          rt: A,
          ruby: A,
          s: A,
          samp: A,
          script: {
            attrs: {
              type: [ "text/javascript" ],
              src: null,
              async: [ "async" ],
              defer: [ "defer" ],
              charset: M
            }
          },
          section: A,
          select: {
            attrs: {
              form: null,
              name: null,
              size: null,
              autofocus: [ "autofocus" ],
              disabled: [ "disabled" ],
              multiple: [ "multiple" ]
            }
          },
          small: A,
          source: {
            attrs: {
              src: null,
              type: null,
              media: null
            }
          },
          span: A,
          strike: A,
          strong: A,
          style: {
            attrs: {
              type: [ "text/css" ],
              media: null,
              scoped: null
            }
          },
          sub: A,
          summary: A,
          sup: A,
          table: A,
          tbody: A,
          td: {
            attrs: {
              colspan: null,
              rowspan: null,
              headers: null
            }
          },
          textarea: {
            attrs: {
              dirname: null,
              form: null,
              maxlength: null,
              name: null,
              placeholder: null,
              rows: null,
              cols: null,
              autofocus: [ "autofocus" ],
              disabled: [ "disabled" ],
              readonly: [ "readonly" ],
              required: [ "required" ],
              wrap: [ "soft", "hard" ]
            }
          },
          tfoot: A,
          th: {
            attrs: {
              colspan: null,
              rowspan: null,
              headers: null,
              scope: [ "row", "col", "rowgroup", "colgroup" ]
            }
          },
          thead: A,
          time: {
            attrs: {
              datetime: null
            }
          },
          title: A,
          tr: A,
          track: {
            attrs: {
              src: null,
              label: null,
              default: null,
              kind: [ "subtitles", "captions", "descriptions", "chapters", "metadata" ],
              srclang: null
            }
          },
          tt: A,
          u: A,
          ul: {
            children: [ "li", "script", "template", "ul", "ol" ]
          },
          var: A,
          video: {
            attrs: {
              src: null,
              poster: null,
              width: null,
              height: null,
              crossorigin: [ "anonymous", "use-credentials" ],
              preload: [ "auto", "metadata", "none" ],
              autoplay: [ "autoplay" ],
              mediagroup: [ "movie" ],
              muted: [ "muted" ],
              controls: [ "controls" ]
            }
          },
          wbr: A
        },
        W = {
          accesskey: null,
          class: null,
          contenteditable: P,
          contextmenu: null,
          dir: [ "ltr", "rtl", "auto" ],
          draggable: [ "true", "false", "auto" ],
          dropzone: [ "copy", "move", "link", "string:", "file:" ],
          hidden: [ "hidden" ],
          id: null,
          inert: [ "inert" ],
          itemid: null,
          itemprop: null,
          itemref: null,
          itemscope: [ "itemscope" ],
          itemtype: null,
          lang: [ "ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh" ],
          spellcheck: P,
          autocorrect: P,
          autocapitalize: P,
          style: null,
          tabindex: null,
          title: null,
          translate: [ "yes", "no" ],
          onclick: null,
          rel: [ "stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag" ],
          role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split( " " ),
          "aria-activedescendant": null,
          "aria-atomic": P,
          "aria-autocomplete": [ "inline", "list", "both", "none" ],
          "aria-busy": P,
          "aria-checked": [ "true", "false", "mixed", "undefined" ],
          "aria-controls": null,
          "aria-describedby": null,
          "aria-disabled": P,
          "aria-dropeffect": null,
          "aria-expanded": [ "true", "false", "undefined" ],
          "aria-flowto": null,
          "aria-grabbed": [ "true", "false", "undefined" ],
          "aria-haspopup": P,
          "aria-hidden": P,
          "aria-invalid": [ "true", "false", "grammar", "spelling" ],
          "aria-label": null,
          "aria-labelledby": null,
          "aria-level": null,
          "aria-live": [ "off", "polite", "assertive" ],
          "aria-multiline": P,
          "aria-multiselectable": P,
          "aria-owns": null,
          "aria-posinset": null,
          "aria-pressed": [ "true", "false", "mixed", "undefined" ],
          "aria-readonly": P,
          "aria-relevant": null,
          "aria-required": P,
          "aria-selected": [ "true", "false", "undefined" ],
          "aria-setsize": null,
          "aria-sort": [ "ascending", "descending", "none", "other" ],
          "aria-valuemax": null,
          "aria-valuemin": null,
          "aria-valuenow": null,
          "aria-valuetext": null
        },
        j = Object.keys( F ),
        V = Object.keys( W );

      function B( e, t ) {
        let n = t.firstChild;
        if ( !n || "OpenTag" != n.name ) return "";
        let i = n.getChild( "TagName" );
        return i ? e.sliceString( i.from, i.to ) : ""
      }

      function H( e, t = !1 ) {
        for ( let n = e.parent; n; n = n.parent )
          if ( "Element" == n.name ) {
            if ( !t ) return n;
            t = !1
          } return null
      }

      function z( e, t ) {
        let n = H( t, !0 ),
          i = n ? F[ B( e, n ) ] : null;
        return ( null === i || void 0 === i ? void 0 : i.children ) || j
      }

      function U( e, t ) {
        let n = [];
        for ( let i = t; i = H( i ); ) {
          let t = B( e, i );
          if ( t && "CloseTag" == i.lastChild.name ) break;
          t && n.indexOf( t ) < 0 && n.push( t )
        }
        return n
      }
      const K = /^[:\-\.\w\u00b7-\uffff]+$/;

      function q( e, t, n, i ) {
        let o = /\s*>/.test( e.sliceDoc( i, i + 5 ) ) ? "" : ">";
        return {
          from: n,
          to: i,
          options: z( e.doc, t ).map( e => ( {
            label: e,
            type: "type"
          } ) ).concat( U( e.doc, t ).map( ( e, t ) => ( {
            label: "/" + e,
            apply: "/" + e + o,
            type: "type",
            boost: 99 - t
          } ) ) ),
          span: /^\/?[:\-\.\w\u00b7-\uffff]*$/
        }
      }

      function G( e, t, n, i ) {
        let o = /\s*>/.test( e.sliceDoc( i, i + 5 ) ) ? "" : ">";
        return {
          from: n,
          to: i,
          options: U( e.doc, t ).map( ( e, t ) => ( {
            label: e,
            apply: e + o,
            type: "type",
            boost: 99 - t
          } ) ),
          span: K
        }
      }
      const Y = k.LezerLanguage.define( {
        parser: x.configure( {
          props: [ k.indentNodeProp.add( {
            Element( e ) {
              let t = /^(\s*)(<\/)?/.exec( e.textAfter );
              return e.node.to <= e.pos + t[ 0 ].length ? e.continue() : e.lineIndent( e.state.doc.lineAt( e.node.from ) ) + ( t[ 1 ] ? 0 : e.unit )
            },
            "OpenTag CloseTag SelfClosingTag": e => e.column( e.node.from ) + e.unit,
            Document( e ) {
              if ( e.pos + /\s*/.exec( e.textAfter )[ 0 ].length < e.node.to ) return e.continue();
              let t, n = null;
              for ( let i = e.node;; ) {
                let e = i.lastChild;
                if ( !e || "Element" != e.name || e.to != i.to ) break;
                n = i = e
              }
              return n && ( !( t = n.lastChild ) || "CloseTag" != t.name && "SelfClosingTag" != t.name ) ? e.lineIndent( e.state.doc.lineAt( n.from ) ) + e.unit : null
            }
          } ), k.foldNodeProp.add( {
            Element( e ) {
              let t = e.firstChild,
                n = e.lastChild;
              return t && "OpenTag" == t.name ? {
                from: t.to,
                to: "CloseTag" == n.name ? n.from : e.to
              } : null
            }
          } ), Object( I.styleTags )( {
            AttributeValue: I.tags.string,
            "Text RawText": I.tags.content,
            "StartTag StartCloseTag SelfCloserEndTag EndTag SelfCloseEndTag": I.tags.angleBracket,
            TagName: I.tags.tagName,
            "MismatchedCloseTag/TagName": [ I.tags.tagName, I.tags.invalid ],
            AttributeName: I.tags.propertyName,
            UnquotedAttributeValue: I.tags.string,
            Is: I.tags.definitionOperator,
            "EntityReference CharacterReference": I.tags.character,
            Comment: I.tags.blockComment,
            ProcessingInst: I.tags.processingInstruction,
            DoctypeDecl: I.tags.documentMeta
          } ) ],
          nested: ( X = [ {
            tag: "script",
            attrs: e => !e.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test( e.type ),
            parser: E.javascriptLanguage.parser
          }, {
            tag: "style",
            attrs: e => ( !e.lang || "css" == e.lang ) && ( !e.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test( e.type ) ),
            parser: N.cssLanguage.parser
          } ], {
            elementContent: O( X )
          } )
        } ),
        languageData: {
          commentTokens: {
            block: {
              open: "\x3c!--",
              close: "--\x3e"
            }
          },
          indentOnInput: /^\s*<\/$/
        }
      } );
      var X;
      const $ = Y.data.of( {
        autocomplete( e ) {
          let {
            state: t,
            pos: n
          } = e, i = Object( k.syntaxTree )( t ).resolve( n ), o = i.resolve( n, -1 );
          return "TagName" == o.name ? o.parent && /CloseTag$/.test( o.parent.name ) ? G( t, o, o.from, n ) : q( t, o, o.from, n ) : "StartTag" == o.name ? q( t, o, n, n ) : "StartCloseTag" == o.name || "IncompleteCloseTag" == o.name ? G( t, o, n, n ) : e.explicit && ( "OpenTag" == o.name || "SelfClosingTag" == o.name ) || "AttributeName" == o.name ? ( ( e, t, n, i ) => {
            let o = H( t ),
              r = o ? F[ B( e.doc, o ) ] : null;
            return {
              from: n,
              to: i,
              options: ( r && r.attrs ? Object.keys( r.attrs ).concat( V ) : V ).map( e => ( {
                label: e,
                type: "property"
              } ) ),
              span: K
            }
          } )( t, o, "AttributeName" == o.name ? o.from : n, n ) : "Is" == o.name || "AttributeValue" == o.name || "UnquotedAttributeValue" == o.name ? ( ( e, t, n, i ) => {
            var o;
            let r = null === ( o = t.parent ) || void 0 === o ? void 0 : o.getChild( "AttributeName" ),
              s = [],
              a = void 0;
            if ( r ) {
              let o = e.sliceDoc( r.from, r.to ),
                u = W[ o ];
              if ( !u ) {
                let n = H( t ),
                  i = n ? F[ B( e.doc, n ) ] : null;
                u = ( null === i || void 0 === i ? void 0 : i.attrs ) && i.attrs[ o ]
              }
              if ( u ) {
                let t = e.sliceDoc( n, i ).toLowerCase(),
                  o = '"',
                  r = '"';
                /^['"]/.test( t ) ? ( a = '"' == t[ 0 ] ? /^[^"]*$/ : /^[^']*$/, o = "", r = e.sliceDoc( i, i + 1 ) == t[ 0 ] ? "" : t[ 0 ], t = t.slice( 1 ), n++ ) : a = /^[^\s<>='"]*$/;
                for ( let e of u ) s.push( {
                  label: e,
                  apply: o + e + r,
                  type: "constant"
                } )
              }
            }
            return {
              from: n,
              to: i,
              options: s,
              span: a
            }
          } )( t, o, "Is" == o.name ? n : o.from, n ) : !e.explicit || "Element" != i.name && "Text" != i.name && "Document" != i.name ? null : ( ( e, t, n ) => {
            let i = [],
              o = 0;
            for ( let r of z( e.doc, t ) ) i.push( {
              label: "<" + r,
              type: "type"
            } );
            for ( let r of U( e.doc, t ) ) i.push( {
              label: "</" + r + ">",
              type: "type",
              boost: 99 - o++
            } );
            return {
              from: n,
              to: n,
              options: i,
              span: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
            }
          } )( t, o, n );
        }
      } );

      function Z() {
        return new k.LanguageSupport( Y, [ $, Object( E.javascript )().support, Object( N.css )().support ] )
      }
    },
    Q631( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "/cxE" ),
        r = n( "VMIq" ),
        s = n( "T8No" ),
        a = n( "tTk5" ),
        u = n( "sswD" ),
        l = n( "wQH0" ),
        c = ( n( "BjKj" ), n( "pmY6" ) ),
        d = n( "aokT" ),
        h = n( "sFUC" ),
        p = n( "t9D7" ),
        f = n( "MD5Z" ),
        g = n( "cGHE" ),
        m = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        _ = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        v = ( () => {
          function e( e, t ) {
            const n = this;
            this.themeService = t, this._disposables = [], this.allowEditorOverflow = !0, this._currentAcceptInput = null, this._currentCancelInput = null, this._editor = e, this._editor.addContentWidget( this ), this._disposables.push( e.onDidChangeConfiguration( ( e => {
              e.fontInfo && n.updateFont()
            } ) ) ), this._disposables.push( t.onThemeChange( ( e => {
              return n.onThemeChange( e )
            } ) ) )
          }
          return e.prototype.onThemeChange = function ( e ) {
            this.updateStyles( e )
          }, e.prototype.dispose = function () {
            this._disposables = Object( c.d )( this._disposables ), this._editor.removeContentWidget( this )
          }, e.prototype.getId = () => {
            return "__renameInputWidget"
          }, e.prototype.getDomNode = function () {
            return this._domNode || ( this._inputField = document.createElement( "input" ), this._inputField.className = "rename-input", this._inputField.type = "text", this._inputField.setAttribute( "aria-label", Object( i.a )( "renameAriaLabel", "Rename input. Type new name and press Enter to commit." ) ), this._domNode = document.createElement( "div" ), this._domNode.style.height = this._editor.getConfiguration().lineHeight + "px", this._domNode.className = "monaco-editor rename-box", this._domNode.appendChild( this._inputField ), this.updateFont(), this.updateStyles( this.themeService.getTheme() ) ), this._domNode
          }, e.prototype.updateStyles = function ( e ) {
            if ( this._inputField ) {
              const t = e.getColor( f.K ),
                n = e.getColor( f.M ),
                i = e.getColor( f.rb ),
                o = e.getColor( f.L );
              this._inputField.style.backgroundColor = t ? t.toString() : null, this._inputField.style.color = n ? n.toString() : null, this._inputField.style.borderWidth = o ? "1px" : "0px", this._inputField.style.borderStyle = o ? "solid" : "none", this._inputField.style.borderColor = o ? o.toString() : "none", this._domNode.style.boxShadow = i ? " 0 2px 8px " + i : null
            }
          }, e.prototype.updateFont = function () {
            if ( this._inputField ) {
              const e = this._editor.getConfiguration().fontInfo;
              this._inputField.style.fontFamily = e.fontFamily, this._inputField.style.fontWeight = e.fontWeight, this._inputField.style.fontSize = e.fontSize + "px"
            }
          }, e.prototype.getPosition = function () {
            return this._visible ? {
              position: this._position,
              preference: [ h.a.BELOW, h.a.ABOVE ]
            } : null
          }, e.prototype.acceptInput = function () {
            this._currentAcceptInput && this._currentAcceptInput()
          }, e.prototype.cancelInput = function ( e ) {
            this._currentCancelInput && this._currentCancelInput( e )
          }, e.prototype.getInput = function ( e, t, n, i ) {
            const o = this;
            this._position = new g.a( e.startLineNumber, e.startColumn ), this._inputField.value = t, this._inputField.setAttribute( "selectionStart", n.toString() ), this._inputField.setAttribute( "selectionEnd", i.toString() ), this._inputField.size = Math.max( 1.1 * ( e.endColumn - e.startColumn ), 20 );
            let s;
            const a = [];
            return s = () => {
              Object( c.d )( a ), o._hide()
            }, new r.b( ( n => {
              o._currentCancelInput = e => {
                return o._currentAcceptInput = null, o._currentCancelInput = null, n( e ), !0
              }, o._currentAcceptInput = () => {
                0 !== o._inputField.value.trim().length && o._inputField.value !== t ? ( o._currentAcceptInput = null, o._currentCancelInput = null, n( o._inputField.value ) ) : o.cancelInput( !0 )
              };
              a.push( o._editor.onDidChangeCursorSelection( ( () => {
                d.a.containsPosition( e, o._editor.getPosition() ) || o.cancelInput( !0 )
              } ) ) ), a.push( o._editor.onDidBlurEditorWidget( ( () => {
                return o.cancelInput( !1 )
              } ) ) ), o._show()
            } ), ( () => {
              o._currentCancelInput( !0 )
            } ) ).then( ( e => {
              return s(), e
            } ), ( e => {
              return s(), r.b.wrapError( e )
            } ) );
          }, e.prototype._show = function () {
            const e = this;
            this._editor.revealLineInCenterIfOutsideViewport( this._position.lineNumber, 0 ), this._visible = !0, this._editor.layoutContentWidget( this ), setTimeout( ( () => {
              e._inputField.focus(), e._inputField.setSelectionRange( parseInt( e._inputField.getAttribute( "selectionStart" ) ), parseInt( e._inputField.getAttribute( "selectionEnd" ) ) )
            } ), 100 )
          }, e.prototype._hide = function () {
            this._visible = !1, this._editor.layoutContentWidget( this )
          }, e = m( [ _( 1, p.c ) ], e );
        } )(),
        y = n( "X+cX" ),
        b = n( "twdY" ),
        C = n( "OBOq" ),
        w = n( "NR8r" ),
        S = n( "vATl" ),
        O = n( "sM1p" ),
        L = n( "x/UI" ),
        x = n( "bY76" ),
        N = n( "Vxe3" );
      n.d( t, "rename", ( () => {
        return R
      } ) ), n.d( t, "RenameAction", ( () => {
        return F
      } ) );
      const E = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        k = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        I = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        D = ( e, t, n, i ) => {
          return new( n || ( n = Promise ) )( ( ( o, r ) => {
            function s( e ) {
              try {
                u( i.next( e ) )
              } catch ( t ) {
                r( t )
              }
            }

            function a( e ) {
              try {
                u( i.throw( e ) )
              } catch ( t ) {
                r( t )
              }
            }

            function u( e ) {
              e.done ? o( e.value ) : new n( ( t => {
                t( e.value )
              } ) ).then( s, a )
            }
            u( ( i = i.apply( e, t || [] ) ).next() )
          } ) );
        },
        M = ( e, t ) => {
          let n, i, o, r, s = {
            label: 0,
            sent() {
              if ( 1 & o[ 0 ] ) throw o[ 1 ];
              return o[ 1 ]
            },
            trys: [],
            ops: []
          };
          return r = {
            next: a( 0 ),
            throw: a( 1 ),
            return: a( 2 )
          }, "function" === typeof Symbol && ( r[ Symbol.iterator ] = function () {
            return this
          } ), r;

          function a( r ) {
            return a => {
              return ( r => {
                if ( n ) throw new TypeError( "Generator is already executing." );
                for ( ; s; ) try {
                  if ( n = 1, i && ( o = 2 & r[ 0 ] ? i.return : r[ 0 ] ? i.throw || ( ( o = i.return ) && o.call( i ), 0 ) : i.next ) && !( o = o.call( i, r[ 1 ] ) ).done ) return o;
                  switch ( i = 0, o && ( r = [ 2 & r[ 0 ], o.value ] ), r[ 0 ] ) {
                    case 0:
                    case 1:
                      o = r;
                      break;
                    case 4:
                      return s.label++, {
                        value: r[ 1 ],
                        done: !1
                      };
                    case 5:
                      s.label++, i = r[ 1 ], r = [ 0 ];
                      continue;
                    case 7:
                      r = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if ( !( o = ( o = s.trys ).length > 0 && o[ o.length - 1 ] ) && ( 6 === r[ 0 ] || 2 === r[ 0 ] ) ) {
                        s = 0;
                        continue
                      }
                      if ( 3 === r[ 0 ] && ( !o || r[ 1 ] > o[ 0 ] && r[ 1 ] < o[ 3 ] ) ) {
                        s.label = r[ 1 ];
                        break
                      }
                      if ( 6 === r[ 0 ] && s.label < o[ 1 ] ) {
                        s.label = o[ 1 ], o = r;
                        break
                      }
                      if ( o && s.label < o[ 2 ] ) {
                        s.label = o[ 2 ], s.ops.push( r );
                        break
                      }
                      o[ 2 ] && s.ops.pop(), s.trys.pop();
                      continue
                  }
                  r = t.call( e, s )
                } catch ( a ) {
                  r = [ 6, a ], i = 0
                } finally {
                  n = o = 0
                }
                if ( 5 & r[ 0 ] ) throw r[ 1 ];
                return {
                  value: r[ 0 ] ? r[ 1 ] : void 0,
                  done: !0
                }
              } )( [ r, a ] );
            };
          }
        },
        T = ( () => {
          function e( e, t ) {
            this.model = e, this.position = t, this._provider = b.s.ordered( e )
          }
          return e.prototype.hasProvider = function () {
            return this._provider.length > 0
          }, e.prototype.resolveRenameLocation = function () {
            return D( this, void 0, void 0, ( function () {
              let e;
              let t;
              let n;
              const i = this;
              return M( this, ( function ( o ) {
                switch ( o.label ) {
                  case 0:
                    return ( e = this._provider[ 0 ] ).resolveRenameLocation ? [ 4, Object( y.h )( ( t => {
                      return e.resolveRenameLocation( i.model, i.position, t )
                    } ) ) ] : [ 3, 2 ];
                  case 1:
                    t = o.sent(), o.label = 2;
                  case 2:
                    return t || ( n = this.model.getWordAtPosition( this.position ) ) && ( t = {
                      range: new d.a( this.position.lineNumber, n.startColumn, this.position.lineNumber, n.endColumn ),
                      text: n.word
                    } ), [ 2, t ]
                }
              } ) );
            } ) );
          }, e.prototype.provideRenameEdits = function ( e, t, n, o ) {
            return void 0 === t && ( t = 0 ), void 0 === n && ( n = [] ), void 0 === o && ( o = this.position ), D( this, void 0, void 0, ( function () {
              let o;
              let r;
              const s = this;
              return M( this, ( function ( a ) {
                switch ( a.label ) {
                  case 0:
                    return t >= this._provider.length ? [ 2, {
                      edits: void 0,
                      rejectReason: n.join( "\n" )
                    } ] : ( o = this._provider[ t ], [ 4, Object( y.h )( ( t => {
                      return o.provideRenameEdits( s.model, s.position, e, t )
                    } ) ) ] );
                  case 1:
                    return ( r = a.sent() ) ? r.rejectReason ? [ 2, this.provideRenameEdits( e, t + 1, n.concat( r.rejectReason ) ) ] : [ 2, r ] : [ 2, this.provideRenameEdits( e, t + 1, n.concat( i.a( "no result", "No result." ) ) ) ]
                }
              } ) );
            } ) );
          }, e;
        } )();

      function R( e, t, n ) {
        return D( this, void 0, void 0, ( function () {
          return M( this, ( i => {
            return [ 2, new T( e, t ).provideRenameEdits( n ) ]
          } ) );
        } ) );
      }
      const P = new s.f( "renameInputVisible", !1 );

      const A = ( () => {
        function e( e, t, n, i, o, r ) {
          this.editor = e, this._notificationService = t, this._bulkEditService = n, this._progressService = i, this._renameInputField = new v( e, r ), this._renameInputVisible = P.bindTo( o )
        }
        return e.get = t => {
          return t.getContribution( e.ID )
        }, e.prototype.dispose = function () {
          this._renameInputField.dispose()
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.run = function () {
          return D( this, void 0, void 0, ( function () {
            let e;
            let t;
            let n;
            let o;
            let s;
            let a;
            let u;
            const l = this;
            return M( this, ( function ( c ) {
              switch ( c.label ) {
                case 0:
                  if ( e = this.editor.getPosition(), !( t = new T( this.editor.getModel(), e ) ).hasProvider() ) return [ 2, void 0 ];
                  c.label = 1;
                case 1:
                  return c.trys.push( [ 1, 3, , 4 ] ), [ 4, t.resolveRenameLocation() ];
                case 2:
                  return n = c.sent(), [ 3, 4 ];
                case 3:
                  return o = c.sent(), w.a.get( this.editor ).showMessage( o, e ), [ 2, void 0 ];
                case 4:
                  return n ? ( s = this.editor.getSelection(), a = 0, u = n.text.length, d.a.isEmpty( s ) || d.a.spansMultipleLines( s ) || !d.a.containsRange( n.range, s ) || ( a = Math.max( 0, s.startColumn - n.range.startColumn ), u = Math.min( n.range.endColumn, s.endColumn ) - n.range.startColumn ), this._renameInputVisible.set( !0 ), [ 2, this._renameInputField.getInput( n.range, n.text, a, u ).then( ( e => {
                    if ( l._renameInputVisible.reset(), "boolean" !== typeof e ) {
                      l.editor.focus();
                      const o = new S.a( l.editor, 15 ),
                        s = r.b.wrap( t.provideRenameEdits( e, 0, [], d.a.lift( n.range ).getStartPosition() ).then( ( t => {
                          if ( !t.rejectReason ) return l._bulkEditService.apply( t, {
                            editor: l.editor
                          } ).then( ( t => {
                            t.ariaSummary && Object( C.a )( i.a( "aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", n.text, e, t.ariaSummary ) )
                          } ) );
                          o.validate( l.editor ) ? w.a.get( l.editor ).showMessage( t.rejectReason, l.editor.getPosition() ) : l._notificationService.info( t.rejectReason )
                        } ), ( e => {
                          return l._notificationService.error( i.a( "rename.failed", "Rename failed to execute." ) ), r.b.wrapError( e )
                        } ) ) );
                      return l._progressService.showWhile( s, 250 ), s
                    }
                    e && l.editor.focus()
                  } ), ( e => {
                    return l._renameInputVisible.reset(), r.b.wrapError( e )
                  } ) ) ] ) : [ 2, void 0 ];
              }
            } ) );
          } ) );
        }, e.prototype.acceptRenameInput = function () {
          this._renameInputField.acceptInput()
        }, e.prototype.cancelRenameInput = function () {
          this._renameInputField.cancelInput( !0 )
        }, e.ID = "editor.contrib.renameController", e = k( [ I( 1, O.a ), I( 2, L.a ), I( 3, a.a ), I( 4, s.e ), I( 5, p.c ) ], e );
      } )();

      var F = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.rename",
            label: i.a( "rename.label", "Rename Symbol" ),
            alias: "Rename Symbol",
            precondition: s.d.and( l.a.writable, l.a.hasRenameProvider ),
            kbOpts: {
              kbExpr: l.a.editorTextFocus,
              primary: 60,
              weight: 100
            },
            menuOpts: {
              group: "1_modification",
              order: 1.1
            }
          } ) || this
        }
        return E( t, e ), t.prototype.runCommand = function ( t, n ) {
          const i = this,
            r = t.get( N.a ),
            s = n || [ void 0, void 0 ],
            a = s[ 0 ],
            u = s[ 1 ];
          return x.a.isUri( a ) && g.a.isIPosition( u ) ? r.openCodeEditor( {
            resource: a
          }, r.getActiveCodeEditor() ).then( ( e => {
            e.setPosition( u ), e.invokeWithinContext( ( t => {
              return i.reportTelemetry( t, e ), i.run( t, e )
            } ) )
          } ), o.e ) : e.prototype.runCommand.call( this, t, n );
        }, t.prototype.run = ( e, t ) => {
          const n = A.get( t );
          if ( n ) return r.b.wrap( n.run() )
        }, t;
      } )( u.b );
      Object( u.h )( A ), Object( u.f )( F );
      const W = u.c.bindToContribution( A.get );
      Object( u.g )( new W( {
        id: "acceptRenameInput",
        precondition: P,
        handler( e ) {
          return e.acceptRenameInput()
        },
        kbOpts: {
          weight: 199,
          kbExpr: l.a.focus,
          primary: 3
        }
      } ) ), Object( u.g )( new W( {
        id: "cancelRenameInput",
        precondition: P,
        handler( e ) {
          return e.cancelRenameInput()
        },
        kbOpts: {
          weight: 199,
          kbExpr: l.a.focus,
          primary: 9,
          secondary: [ 1033 ]
        }
      } ) ), Object( u.e )( "_executeDocumentRenameProvider", ( ( e, t, n ) => {
        const i = n.newName;
        if ( "string" !== typeof i ) throw Object( o.b )( "newName" );
        return R( e, t, i )
      } ) )
    },
    QDVR( e, t, n ) {
      "use strict";
      n.d( t, "d", ( () => {
        return o
      } ) ), n.d( t, "c", ( () => {
        return l
      } ) ), n.d( t, "b", ( () => {
        return c
      } ) ), n.d( t, "a", ( () => {
        return d
      } ) );
      const i = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      function o( e ) {
        const t = [];
        return e.forEach( ( e => {
          return t.push( e )
        } ) ), t;
      }
      let r;
      const s = ( () => {
        function e() {
          this._value = "", this._pos = 0
        }
        return e.prototype.reset = function ( e ) {
          return this._value = e, this._pos = 0, this
        }, e.prototype.next = function () {
          return this._pos += 1, this
        }, e.prototype.hasNext = function () {
          return this._pos < this._value.length - 1
        }, e.prototype.cmp = function ( e ) {
          return e.charCodeAt( 0 ) - this._value.charCodeAt( this._pos )
        }, e.prototype.value = function () {
          return this._value[ this._pos ]
        }, e
      } )();
      const a = ( () => {
        function e() {}
        return e.prototype.reset = function ( e ) {
          return this._value = e.replace( /\\$|\/$/, "" ), this._from = 0, this._to = 0, this.next()
        }, e.prototype.hasNext = function () {
          return this._to < this._value.length
        }, e.prototype.next = function () {
          this._from = this._to;
          for ( let e = !0; this._to < this._value.length; this._to++ ) {
            const t = this._value.charCodeAt( this._to );
            if ( 47 === t || 92 === t ) {
              if ( !e ) break;
              this._from++
            } else e = !1
          }
          return this
        }, e.prototype.cmp = function ( e ) {
          for ( var t = 0, n = e.length, i = this._from; t < n && i < this._to; ) {
            const o = e.charCodeAt( t ) - this._value.charCodeAt( i );
            if ( 0 !== o ) return o;
            t += 1, i += 1
          }
          return n === this._to - this._from ? 0 : t < n ? -1 : 1
        }, e.prototype.value = function () {
          return this._value.substring( this._from, this._to )
        }, e;
      } )();
      const u = () => {};

      var l = ( () => {
        function e( e ) {
          this._iter = e
        }
        return e.forPaths = () => {
          return new e( new a )
        }, e.forStrings = () => {
          return new e( new s )
        }, e.prototype.clear = function () {
          this._root = void 0
        }, e.prototype.set = function ( e, t ) {
          let n;
          const i = this._iter.reset( e );
          for ( this._root || ( this._root = new u, this._root.segment = i.value() ), n = this._root;; ) {
            const o = i.cmp( n.segment );
            if ( o > 0 ) n.left || ( n.left = new u, n.left.segment = i.value() ), n = n.left;
            else if ( o < 0 ) n.right || ( n.right = new u, n.right.segment = i.value() ), n = n.right;
            else {
              if ( !i.hasNext() ) break;
              i.next(), n.mid || ( n.mid = new u, n.mid.segment = i.value() ), n = n.mid
            }
          }
          const r = n.value;
          return n.value = t, n.key = e, r
        }, e.prototype.get = function ( e ) {
          for ( var t = this._iter.reset( e ), n = this._root; n; ) {
            const i = t.cmp( n.segment );
            if ( i > 0 ) n = n.left;
            else if ( i < 0 ) n = n.right;
            else {
              if ( !t.hasNext() ) break;
              t.next(), n = n.mid
            }
          }
          return n ? n.value : void 0
        }, e.prototype.findSubstr = function ( e ) {
          for ( var t, n = this._iter.reset( e ), i = this._root; i; ) {
            const o = n.cmp( i.segment );
            if ( o > 0 ) i = i.left;
            else if ( o < 0 ) i = i.right;
            else {
              if ( !n.hasNext() ) break;
              n.next(), t = i.value || t, i = i.mid
            }
          }
          return i && i.value || t
        }, e.prototype.forEach = function ( e ) {
          this._forEach( this._root, e )
        }, e.prototype._forEach = function ( e, t ) {
          e && ( this._forEach( e.left, t ), e.value && t( e.value, e.key ), this._forEach( e.mid, t ), this._forEach( e.right, t ) )
        }, e;
      } )();

      var c = ( () => {
        function e() {
          this.map = new Map, this.ignoreCase = !1
        }
        return e.prototype.set = function ( e, t ) {
          this.map.set( this.toKey( e ), t )
        }, e.prototype.get = function ( e ) {
          return this.map.get( this.toKey( e ) )
        }, e.prototype.toKey = function ( e ) {
          let t = e.toString();
          return this.ignoreCase && ( t = t.toLowerCase() ), t
        }, e;
      } )();
      !( e => {
        e[ e.None = 0 ] = "None", e[ e.AsOld = 1 ] = "AsOld", e[ e.AsNew = 2 ] = "AsNew"
      } )( r || ( r = {} ) );
      var d = ( e => {
        function t( t, n ) {
          void 0 === n && ( n = 1 );
          const i = e.call( this ) || this;
          return i._limit = t, i._ratio = Math.min( Math.max( 0, n ), 1 ), i
        }
        return i( t, e ), t.prototype.get = function ( t ) {
          return e.prototype.get.call( this, t, r.AsNew )
        }, t.prototype.set = function ( t, n ) {
          e.prototype.set.call( this, t, n, r.AsNew ), this.checkTrim()
        }, t.prototype.checkTrim = function () {
          this.size > this._limit && this.trimOld( Math.round( this._limit * this._ratio ) )
        }, t
      } )(
        ( () => {
          function e() {
            this._map = new Map, this._head = void 0, this._tail = void 0, this._size = 0
          }
          return e.prototype.clear = function () {
            this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0
          }, Object.defineProperty( e.prototype, "size", {
            get() {
              return this._size
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.get = function ( e, t ) {
            void 0 === t && ( t = r.None );
            const n = this._map.get( e );
            if ( n ) return t !== r.None && this.touch( n, t ), n.value
          }, e.prototype.set = function ( e, t, n ) {
            void 0 === n && ( n = r.None );
            let i = this._map.get( e );
            if ( i ) i.value = t, n !== r.None && this.touch( i, n );
            else {
              switch ( i = {
                key: e,
                value: t,
                next: void 0,
                previous: void 0
              }, n ) {
                case r.None:
                  this.addItemLast( i );
                  break;
                case r.AsOld:
                  this.addItemFirst( i );
                  break;
                case r.AsNew:
                default:
                  this.addItemLast( i )
              }
              this._map.set( e, i ), this._size++
            }
          }, e.prototype.forEach = function ( e, t ) {
            for ( let n = this._head; n; ) t ? e.bind( t )( n.value, n.key, this ) : e( n.value, n.key, this ), n = n.next
          }, e.prototype.trimOld = function ( e ) {
            if ( !( e >= this.size ) )
              if ( 0 !== e ) {
                for ( var t = this._head, n = this.size; t && n > e; ) this._map.delete( t.key ), t = t.next, n--;
                this._head = t, this._size = n, t.previous = void 0
              } else this.clear()
          }, e.prototype.addItemFirst = function ( e ) {
            if ( this._head || this._tail ) {
              if ( !this._head ) throw new Error( "Invalid list" );
              e.next = this._head, this._head.previous = e
            } else this._tail = e;
            this._head = e
          }, e.prototype.addItemLast = function ( e ) {
            if ( this._head || this._tail ) {
              if ( !this._tail ) throw new Error( "Invalid list" );
              e.previous = this._tail, this._tail.next = e
            } else this._head = e;
            this._tail = e
          }, e.prototype.touch = function ( e, t ) {
            if ( !this._head || !this._tail ) throw new Error( "Invalid list" );
            if ( t === r.AsOld || t === r.AsNew )
              if ( t === r.AsOld ) {
                if ( e === this._head ) return;
                var n = e.next,
                  i = e.previous;
                e === this._tail ? ( i.next = void 0, this._tail = i ) : ( n.previous = i, i.next = n ), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e
              } else if ( t === r.AsNew ) {
              if ( e === this._tail ) return;
              n = e.next, i = e.previous;
              e === this._head ? ( n.previous = void 0, this._head = n ) : ( n.previous = i, i.next = n ), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e
            }
          }, e.prototype.toJSON = function () {
            const e = [];
            return this.forEach( ( ( t, n ) => {
              e.push( [ n, t ] )
            } ) ), e;
          }, e;
        } )()
      )
    },
    QFiB( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "markdown",
        extensions: [ ".md", ".markdown", ".mdown", ".mkdn", ".mkd", ".mdwn", ".mdtxt", ".mdtext" ],
        aliases: [ "Markdown", "markdown" ],
        loader() {
          return o.Promise.wrap( n.e( 277 ).then( n.bind( null, "PhST" ) ) )
        }
      } )
    },
    QVNv( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return p
      } ) ), n.d( t, "b", ( () => {
        return f
      } ) ), n.d( t, "d", ( () => {
        return g
      } ) ), n.d( t, "c", ( () => {
        return C
      } ) ), n.d( t, "e", ( () => {
        return S
      } ) );
      let i;
      const o = n( "X+cX" );
      const r = n( "6OMU" );
      const s = n( "N0LK" );
      const a = n( "qj0h" );
      const u = n( "/cxE" );
      const l = n( "sswD" );
      const c = n( "twdY" );
      const d = n( "T8No" );
      const h = n( "JQT/" );
      var p = {
        Visible: new d.f( "suggestWidgetVisible", !1 ),
        MultipleSuggestions: new d.f( "suggestWidgetMultipleSuggestions", !1 ),
        MakesTextEdit: new d.f( "suggestionMakesTextEdit", !0 ),
        AcceptOnKey: new d.f( "suggestionSupportsAcceptOnKey", !0 ),
        AcceptSuggestionsOnEnter: new d.f( "acceptSuggestionOnEnter", !0 )
      };

      function f() {
        return i
      }

      function g( e, t, n, s, a, l ) {
        void 0 === n && ( n = "bottom" ), void 0 === l && ( l = h.a.None );
        const d = [],
          p = ( e => {
            return "none" === e ? e => {
              return "snippet" !== e.type
            } : () => {
              return !0
            };
          } )( n );
        t = t.clone();
        const f = c.u.orderedGroups( e );
        "none" !== n && i && f.unshift( [ i ] );
        const g = a || {
          triggerKind: c.v.Invoke
        };
        let v = !1;
        const y = f.map( ( n => {
          return () => {
            return Promise.all( n.map( ( n => {
              if ( Object( r.k )( s ) || !( s.indexOf( n ) < 0 ) ) return Promise.resolve( n.provideCompletionItems( e, t, g, l ) ).then( ( o => {
                const s = d.length;
                if ( o && !Object( r.k )( o.suggestions ) )
                  for ( let a = 0, u = o.suggestions; a < u.length; a++ ) {
                    const l = u[ a ];
                    p( l ) && ( m( l, o ), d.push( {
                      position: t,
                      container: o,
                      suggestion: l,
                      support: n,
                      resolve: _( n, l, e, t )
                    } ) )
                  }
                s !== d.length && n !== i && ( v = !0 )
              } ), u.f );
            } ) ) );
          };
        } ) );
        return Object( o.k )( y, ( () => {
          return v
        } ) ).then( ( () => {
          return d.sort( C( n ) )
        } ) );
      }

      function m( e, t ) {
        "number" !== typeof e.overwriteBefore && ( e.overwriteBefore = 0 ), ( "number" !== typeof e.overwriteAfter || e.overwriteAfter < 0 ) && ( e.overwriteAfter = 0 )
      }

      function _( e, t, n, i ) {
        return o => {
          return "function" === typeof e.resolveCompletionItem ? Promise.resolve( e.resolveCompletionItem( n, i, t, o ) ).then( ( e => {
            Object( a.a )( t, e )
          } ) ) : Promise.resolve( void 0 );
        };
      }

      function v( e, t ) {
        let n = 0;
        return "string" === typeof e.suggestion.sortText && "string" === typeof t.suggestion.sortText && ( n = Object( s.compareIgnoreCase )( e.suggestion.sortText, t.suggestion.sortText ) ), 0 === n && ( n = Object( s.compareIgnoreCase )( e.suggestion.label, t.suggestion.label ) ), 0 === n && e.suggestion.type !== t.suggestion.type && ( "snippet" === e.suggestion.type ? n = 1 : "snippet" === t.suggestion.type && ( n = -1 ) ), n
      }

      function y( e, t ) {
        if ( e.suggestion.type !== t.suggestion.type ) {
          if ( "snippet" === e.suggestion.type ) return -1;
          if ( "snippet" === t.suggestion.type ) return 1
        }
        return v( e, t )
      }

      function b( e, t ) {
        if ( e.suggestion.type !== t.suggestion.type ) {
          if ( "snippet" === e.suggestion.type ) return 1;
          if ( "snippet" === t.suggestion.type ) return -1
        }
        return v( e, t )
      }

      function C( e ) {
        return "top" === e ? y : "bottom" === e ? b : v
      }
      Object( l.e )( "_executeCompletionItemProvider", ( ( e, t, n ) => {
        const i = {
            incomplete: !1,
            suggestions: []
          },
          o = [],
          r = n.maxItemsToResolve || 0;
        return g( e, t ).then( ( e => {
          for ( let t = 0, n = e; t < n.length; t++ ) {
            const s = n[ t ];
            o.length < r && o.push( s.resolve( h.a.None ) ), i.incomplete = i.incomplete || s.container.incomplete, i.suggestions.push( s.suggestion )
          }
        } ) ).then( ( () => {
          return Promise.all( o )
        } ) ).then( ( () => {
          return i
        } ) );
      } ) );
      const w = new( ( () => {
        function e() {
          this.onlyOnceSuggestions = []
        }
        return e.prototype.provideCompletionItems = function () {
          const e = {
            suggestions: this.onlyOnceSuggestions.slice( 0 )
          };
          return this.onlyOnceSuggestions.length = 0, e
        }, e;
      } )() )();

      function S( e, t ) {
        setTimeout( ( () => {
          let n;
          ( n = w.onlyOnceSuggestions ).push.apply( n, t ), e.getContribution( "editor.contrib.suggestController" ).triggerSuggest( [ w ] )
        } ), 0 )
      }
      c.u.register( "*", w )
    },
    QaAZ( e, t, n ) {},
    QiAa( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "redis",
        extensions: [ ".redis" ],
        aliases: [ "redis" ],
        loader() {
          return o.Promise.wrap( n.e( 295 ).then( n.bind( null, "j6Xs" ) ) )
        }
      } )
    },
    QuOb( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return i
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) );
      var i;
      const o = n( "pmY6" );
      const r = n( "MI8n" );
      const s = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      !( e => {
        e[ e.Auto = 1 ] = "Auto", e[ e.Hidden = 2 ] = "Hidden", e[ e.Visible = 3 ] = "Visible"
      } )( i || ( i = {} ) );
      const a = ( () => {
        function e( e, t, n, i, o, r ) {
          ( e |= 0 ) < 0 && ( e = 0 ), ( n |= 0 ) + e > ( t |= 0 ) && ( n = t - e ), n < 0 && ( n = 0 ), ( i |= 0 ) < 0 && ( i = 0 ), ( r |= 0 ) + i > ( o |= 0 ) && ( r = o - i ), r < 0 && ( r = 0 ), this.width = e, this.scrollWidth = t, this.scrollLeft = n, this.height = i, this.scrollHeight = o, this.scrollTop = r
        }
        return e.prototype.equals = function ( e ) {
          return this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop
        }, e.prototype.withScrollDimensions = function ( t ) {
          return new e( "undefined" !== typeof t.width ? t.width : this.width, "undefined" !== typeof t.scrollWidth ? t.scrollWidth : this.scrollWidth, this.scrollLeft, "undefined" !== typeof t.height ? t.height : this.height, "undefined" !== typeof t.scrollHeight ? t.scrollHeight : this.scrollHeight, this.scrollTop )
        }, e.prototype.withScrollPosition = function ( t ) {
          return new e( this.width, this.scrollWidth, "undefined" !== typeof t.scrollLeft ? t.scrollLeft : this.scrollLeft, this.height, this.scrollHeight, "undefined" !== typeof t.scrollTop ? t.scrollTop : this.scrollTop )
        }, e.prototype.createScrollEvent = function ( e ) {
          const t = this.width !== e.width,
            n = this.scrollWidth !== e.scrollWidth,
            i = this.scrollLeft !== e.scrollLeft,
            o = this.height !== e.height,
            r = this.scrollHeight !== e.scrollHeight,
            s = this.scrollTop !== e.scrollTop;
          return {
            width: this.width,
            scrollWidth: this.scrollWidth,
            scrollLeft: this.scrollLeft,
            height: this.height,
            scrollHeight: this.scrollHeight,
            scrollTop: this.scrollTop,
            widthChanged: t,
            scrollWidthChanged: n,
            scrollLeftChanged: i,
            heightChanged: o,
            scrollHeightChanged: r,
            scrollTopChanged: s
          }
        }, e;
      } )();
      var u = ( e => {
        function t( t, n ) {
          const i = e.call( this ) || this;
          return i._onScroll = i._register( new r.a ), i.onScroll = i._onScroll.event, i._smoothScrollDuration = t, i._scheduleAtNextAnimationFrame = n, i._state = new a( 0, 0, 0, 0, 0, 0 ), i._smoothScrolling = null, i
        }
        return s( t, e ), t.prototype.dispose = function () {
          this._smoothScrolling && ( this._smoothScrolling.dispose(), this._smoothScrolling = null ), e.prototype.dispose.call( this )
        }, t.prototype.setSmoothScrollDuration = function ( e ) {
          this._smoothScrollDuration = e
        }, t.prototype.validateScrollPosition = function ( e ) {
          return this._state.withScrollPosition( e )
        }, t.prototype.getScrollDimensions = function () {
          return this._state
        }, t.prototype.setScrollDimensions = function ( e ) {
          const t = this._state.withScrollDimensions( e );
          this._setState( t ), this._smoothScrolling && this._smoothScrolling.acceptScrollDimensions( this._state )
        }, t.prototype.getFutureScrollPosition = function () {
          return this._smoothScrolling ? this._smoothScrolling.to : this._state
        }, t.prototype.getCurrentScrollPosition = function () {
          return this._state
        }, t.prototype.setScrollPositionNow = function ( e ) {
          const t = this._state.withScrollPosition( e );
          this._smoothScrolling && ( this._smoothScrolling.dispose(), this._smoothScrolling = null ), this._setState( t )
        }, t.prototype.setScrollPositionSmooth = function ( e ) {
          const t = this;
          if ( 0 === this._smoothScrollDuration ) return this.setScrollPositionNow( e );
          if ( this._smoothScrolling ) {
            e = {
              scrollLeft: "undefined" === typeof e.scrollLeft ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
              scrollTop: "undefined" === typeof e.scrollTop ? this._smoothScrolling.to.scrollTop : e.scrollTop
            };
            var n = this._state.withScrollPosition( e );
            if ( this._smoothScrolling.to.scrollLeft === n.scrollLeft && this._smoothScrolling.to.scrollTop === n.scrollTop ) return;
            const i = this._smoothScrolling.combine( this._state, n, this._smoothScrollDuration );
            this._smoothScrolling.dispose(), this._smoothScrolling = i
          } else {
            n = this._state.withScrollPosition( e );
            this._smoothScrolling = d.start( this._state, n, this._smoothScrollDuration )
          }
          this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame( ( () => {
            t._smoothScrolling && ( t._smoothScrolling.animationFrameDisposable = null, t._performSmoothScrolling() )
          } ) )
        }, t.prototype._performSmoothScrolling = function () {
          const e = this,
            t = this._smoothScrolling.tick(),
            n = this._state.withScrollPosition( t );
          if ( this._setState( n ), t.isDone ) return this._smoothScrolling.dispose(), void( this._smoothScrolling = null );
          this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame( ( () => {
            e._smoothScrolling && ( e._smoothScrolling.animationFrameDisposable = null, e._performSmoothScrolling() )
          } ) )
        }, t.prototype._setState = function ( e ) {
          const t = this._state;
          t.equals( e ) || ( this._state = e, this._onScroll.fire( this._state.createScrollEvent( t ) ) )
        }, t;
      } )( o.a );
      const l = function ( e, t, n ) {
        this.scrollLeft = e, this.scrollTop = t, this.isDone = n
      };

      function c( e, t ) {
        const n = t - e;
        return t => {
          return e + n * ( 1 - ( e => {
            return Math.pow( e, 3 )
          } )( 1 - t ) );
        };
      }
      var d = ( () => {
        function e( e, t, n, i ) {
          this.from = e, this.to = t, this.duration = i, this._startTime = n, this.animationFrameDisposable = null, this._initAnimations()
        }
        return e.prototype._initAnimations = function () {
          this.scrollLeft = this._initAnimation( this.from.scrollLeft, this.to.scrollLeft, this.to.width ), this.scrollTop = this._initAnimation( this.from.scrollTop, this.to.scrollTop, this.to.height )
        }, e.prototype._initAnimation = ( e, t, n ) => {
          let i, o, r;
          if ( Math.abs( e - t ) > 2.5 * n ) {
            let s = void 0,
              a = void 0;
            return e < t ? ( s = e + .75 * n, a = t - .75 * n ) : ( s = e - .75 * n, a = t + .75 * n ), i = c( e, s ), o = c( a, t ), r = .33, e => {
              return e < r ? i( e / r ) : o( ( e - r ) / ( 1 - r ) )
            };
          }
          return c( e, t )
        }, e.prototype.dispose = function () {
          null !== this.animationFrameDisposable && ( this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null )
        }, e.prototype.acceptScrollDimensions = function ( e ) {
          this.to = e.withScrollPosition( this.to ), this._initAnimations()
        }, e.prototype.tick = function () {
          return this._tick( Date.now() )
        }, e.prototype._tick = function ( e ) {
          const t = ( e - this._startTime ) / this.duration;
          if ( t < 1 ) {
            const n = this.scrollLeft( t ),
              i = this.scrollTop( t );
            return new l( n, i, !1 )
          }
          return new l( this.to.scrollLeft, this.to.scrollTop, !0 )
        }, e.prototype.combine = ( t, n, i ) => {
          return e.start( t, n, i )
        }, e.start = ( t, n, i ) => {
          return i += 10, new e( t, n, Date.now() - 10, i )
        }, e;
      } )()
    },
    QvA3( e, t, n ) {},
    RMfO( e, t, n ) {},
    Rpxm( e, t, n ) {
      "use strict";
      const i = n( "3/fG" ),
        o = n( "VMIq" ),
        r = n( "xONI" ),
        s = n( "WqXY" ),
        a = n( "7lZ/" ),
        u = n( "EffR" ),
        l = ( n( "q/I2" ), n( "qj0h" ) ),
        c = n( "i04g" ),
        d = u.a,
        h = ( () => {
          function e( e, t ) {
            this.os = t, this.domNode = u.k( e, d( ".monaco-keybinding" ) ), this.didEverRender = !1, e.appendChild( this.domNode )
          }
          return e.prototype.set = function ( t, n ) {
            this.didEverRender && this.keybinding === t && e.areSame( this.matches, n ) || ( this.keybinding = t, this.matches = n, this.render() )
          }, e.prototype.render = function () {
            if ( u.l( this.domNode ), this.keybinding ) {
              const e = this.keybinding.getParts(),
                t = e[ 0 ],
                n = e[ 1 ];
              t && this.renderPart( this.domNode, t, this.matches ? this.matches.firstPart : null ), n && ( u.k( this.domNode, d( "span.monaco-keybinding-key-chord-separator", null, " " ) ), this.renderPart( this.domNode, n, this.matches ? this.matches.chordPart : null ) ), this.domNode.title = this.keybinding.getAriaLabel()
            }
            this.didEverRender = !0
          }, e.prototype.renderPart = function ( e, t, n ) {
            const i = c.b.modifierLabels[ this.os ];
            t.ctrlKey && this.renderKey( e, i.ctrlKey, n && n.ctrlKey, i.separator ), t.shiftKey && this.renderKey( e, i.shiftKey, n && n.shiftKey, i.separator ), t.altKey && this.renderKey( e, i.altKey, n && n.altKey, i.separator ), t.metaKey && this.renderKey( e, i.metaKey, n && n.metaKey, i.separator );
            const o = t.keyLabel;
            o && this.renderKey( e, o, n && n.keyCode, "" )
          }, e.prototype.renderKey = ( e, t, n, i ) => {
            u.k( e, d( "span.monaco-keybinding-key" + ( n ? ".highlight" : "" ), null, t ) ), i && u.k( e, d( "span.monaco-keybinding-key-separator", null, i ) )
          }, e.prototype.dispose = function () {
            this.keybinding = null
          }, e.areSame = ( e, t ) => {
            return e === t || !e && !t || !!e && !!t && Object( l.e )( e.firstPart, t.firstPart ) && Object( l.e )( e.chordPart, t.chordPart )
          }, e;
        } )(),
        p = n( "MNsG" );
      n.d( t, "a", ( () => {
        return m
      } ) ), n.d( t, "b", ( () => {
        return _
      } ) ), n.d( t, "c", ( () => {
        return b
      } ) );
      const f = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      let g = 0;
      var m = ( () => {
        function e( e ) {
          void 0 === e && ( e = [] ), this.id = ( g++ ).toString(), this.labelHighlights = e, this.descriptionHighlights = []
        }
        return e.prototype.getId = function () {
          return this.id
        }, e.prototype.getLabel = () => {
          return null
        }, e.prototype.getLabelOptions = () => {
          return null
        }, e.prototype.getAriaLabel = function () {
          return [ this.getLabel(), this.getDescription(), this.getDetail() ].filter( ( e => {
            return !!e
          } ) ).join( ", " );
        }, e.prototype.getDetail = () => {
          return null
        }, e.prototype.getIcon = () => {
          return null
        }, e.prototype.getDescription = () => {
          return null
        }, e.prototype.getTooltip = () => {
          return null
        }, e.prototype.getDescriptionTooltip = () => {
          return null
        }, e.prototype.getKeybinding = () => {
          return null
        }, e.prototype.isHidden = function () {
          return this.hidden
        }, e.prototype.setHighlights = function ( e, t, n ) {
          this.labelHighlights = e, this.descriptionHighlights = t, this.detailHighlights = n
        }, e.prototype.getHighlights = function () {
          return [ this.labelHighlights, this.descriptionHighlights, this.detailHighlights ]
        }, e.prototype.run = ( e, t ) => {
          return !1
        }, e;
      } )();
      var _ = ( e => {
        function t( t, n, i ) {
          const o = e.call( this ) || this;
          return o.entry = t, o.groupLabel = n, o.withBorder = i, o
        }
        return f( t, e ), t.prototype.getGroupLabel = function () {
          return this.groupLabel
        }, t.prototype.setGroupLabel = function ( e ) {
          this.groupLabel = e
        }, t.prototype.showBorder = function () {
          return this.withBorder
        }, t.prototype.setShowBorder = function ( e ) {
          this.withBorder = e
        }, t.prototype.getLabel = function () {
          return this.entry ? this.entry.getLabel() : e.prototype.getLabel.call( this )
        }, t.prototype.getLabelOptions = function () {
          return this.entry ? this.entry.getLabelOptions() : e.prototype.getLabelOptions.call( this )
        }, t.prototype.getAriaLabel = function () {
          return this.entry ? this.entry.getAriaLabel() : e.prototype.getAriaLabel.call( this )
        }, t.prototype.getDetail = function () {
          return this.entry ? this.entry.getDetail() : e.prototype.getDetail.call( this )
        }, t.prototype.getIcon = function () {
          return this.entry ? this.entry.getIcon() : e.prototype.getIcon.call( this )
        }, t.prototype.getDescription = function () {
          return this.entry ? this.entry.getDescription() : e.prototype.getDescription.call( this )
        }, t.prototype.getHighlights = function () {
          return this.entry ? this.entry.getHighlights() : e.prototype.getHighlights.call( this )
        }, t.prototype.isHidden = function () {
          return this.entry ? this.entry.isHidden() : e.prototype.isHidden.call( this )
        }, t.prototype.setHighlights = function ( t, n, i ) {
          this.entry ? this.entry.setHighlights( t, n, i ) : e.prototype.setHighlights.call( this, t, n, i )
        }, t.prototype.run = function ( t, n ) {
          return this.entry ? this.entry.run( t, n ) : e.prototype.run.call( this, t, n )
        }, t
      } )( m );
      const v = ( () => {
        function e() {}
        return e.prototype.hasActions = ( e, t ) => {
          return !1
        }, e.prototype.getActions = ( e, t ) => {
          return o.b.as( null )
        }, e;
      } )();

      const y = ( () => {
        function e( e, t ) {
          void 0 === e && ( e = new v ), void 0 === t && ( t = null ), this.actionProvider = e, this.actionRunner = t
        }
        return e.prototype.getHeight = e => {
          return e.getDetail() ? 44 : 22
        }, e.prototype.getTemplateId = e => {
          return e instanceof _ ? "quickOpenEntryGroup" : "quickOpenEntry"
        }, e.prototype.renderTemplate = function ( e, t, n ) {
          const i = document.createElement( "div" );
          u.f( i, "sub-content" ), t.appendChild( i );
          const o = u.a( ".quick-open-row" ),
            l = u.a( ".quick-open-row" ),
            c = u.a( ".quick-open-entry", null, o, l );
          i.appendChild( c );
          const d = document.createElement( "span" );
          o.appendChild( d );
          const f = new r.b( o, {
              supportHighlights: !0,
              supportDescriptionHighlights: !0
            } ),
            g = document.createElement( "span" );
          o.appendChild( g ), u.f( g, "quick-open-entry-keybinding" );
          const m = new h( g, p.a ),
            _ = document.createElement( "div" );
          l.appendChild( _ ), u.f( _, "quick-open-entry-meta" );
          let v;
          const y = new a.a( _ );
          "quickOpenEntryGroup" === e && ( v = document.createElement( "div" ), u.f( v, "results-group" ), t.appendChild( v ) ), u.f( t, "actions" );
          const b = document.createElement( "div" );
          return u.f( b, "primary-action-bar" ), t.appendChild( b ), {
            container: t,
            entry: c,
            icon: d,
            label: f,
            detail: y,
            keybinding: m,
            group: v,
            actionBar: new s.a( b, {
              actionRunner: this.actionRunner
            } )
          }
        }, e.prototype.renderElement = function ( e, t, n, i ) {
          if ( this.actionProvider.hasActions( null, e ) ? u.f( n.container, "has-actions" ) : u.G( n.container, "has-actions" ), n.actionBar.context = e, this.actionProvider.getActions( null, e ).then( ( e => {
              n.actionBar.isEmpty() && e && e.length > 0 ? n.actionBar.push( e, {
                icon: !0,
                label: !1
              } ) : n.actionBar.isEmpty() || e && 0 !== e.length || n.actionBar.clear()
            } ) ), e instanceof _ && e.getGroupLabel() ? u.f( n.container, "has-group-label" ) : u.G( n.container, "has-group-label" ), e instanceof _ ) {
            const o = e,
              r = n;
            o.showBorder() ? ( u.f( r.container, "results-group-separator" ), r.container.style.borderTopColor = i.pickerGroupBorder.toString() ) : ( u.G( r.container, "results-group-separator" ), r.container.style.borderTopColor = null );
            const s = o.getGroupLabel() || "";
            r.group.textContent = s, r.group.style.color = i.pickerGroupForeground.toString()
          }
          if ( e instanceof m ) {
            const a = e.getHighlights(),
              l = a[ 0 ],
              c = a[ 1 ],
              d = a[ 2 ],
              h = e.getIcon() ? "quick-open-entry-icon " + e.getIcon() : "";
            n.icon.className = h;
            const p = e.getLabelOptions() || Object.create( null );
            p.matches = l || [], p.title = e.getTooltip(), p.descriptionTitle = e.getDescriptionTooltip() || e.getDescription(), p.descriptionMatches = c || [], n.label.setValue( e.getLabel(), e.getDescription(), p ), n.detail.set( e.getDetail(), d ), n.keybinding.set( e.getKeybinding(), null )
          }
        }, e.prototype.disposeTemplate = ( e, t ) => {
          const n = t;
          n.actionBar.dispose(), n.actionBar = null, n.container = null, n.entry = null, n.keybinding.dispose(), n.keybinding = null, n.detail.dispose(), n.detail = null, n.group = null, n.icon = null, n.label.dispose(), n.label = null
        }, e;
      } )();

      var b = ( () => {
        function e( e, t ) {
          void 0 === e && ( e = [] ), void 0 === t && ( t = new v ), this._entries = e, this._dataSource = this, this._renderer = new y( t ), this._filter = this, this._runner = this, this._accessibilityProvider = this
        }
        return Object.defineProperty( e.prototype, "entries", {
          get() {
            return this._entries
          },
          set( e ) {
            this._entries = e
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "dataSource", {
          get() {
            return this._dataSource
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "renderer", {
          get() {
            return this._renderer
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "filter", {
          get() {
            return this._filter
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "runner", {
          get() {
            return this._runner
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "accessibilityProvider", {
          get() {
            return this._accessibilityProvider
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.getId = e => {
          return e.getId()
        }, e.prototype.getLabel = e => {
          return e.getLabel()
        }, e.prototype.getAriaLabel = e => {
          return e.getAriaLabel() ? i.a( "quickOpenAriaLabelEntry", "{0}, picker", e.getAriaLabel() ) : i.a( "quickOpenAriaLabel", "picker" )
        }, e.prototype.isVisible = e => {
          return !e.isHidden()
        }, e.prototype.run = ( e, t, n ) => {
          return e.run( t, n )
        }, e;
      } )();
    },
    S3by( e, t, n ) {
      "use strict";
      let i;
      const o = n( "3/fG" );
      const r = n( "N0LK" );
      !( e => {
        e[ e.Ignore = 0 ] = "Ignore", e[ e.Info = 1 ] = "Info", e[ e.Warning = 2 ] = "Warning", e[ e.Error = 3 ] = "Error"
      } )( i || ( i = {} ) ), ( e => {
        const t = "error",
          n = "warning",
          i = "warn",
          s = "info",
          a = Object.create( null );
        a[ e.Error ] = o.a( "sev.error", "Error" ), a[ e.Warning ] = o.a( "sev.warning", "Warning" ), a[ e.Info ] = o.a( "sev.info", "Info" ), e.fromValue = o => {
          return o ? r.equalsIgnoreCase( t, o ) ? e.Error : r.equalsIgnoreCase( n, o ) || r.equalsIgnoreCase( i, o ) ? e.Warning : r.equalsIgnoreCase( s, o ) ? e.Info : e.Ignore : e.Ignore
        }
      } )( i || ( i = {} ) ), t.a = i
    },
    SBYE( e, t, n ) {
      "use strict";
      n.r( t );
      n( "QaAZ" );
      const i = n( "3/fG" ),
        o = n( "pmY6" ),
        r = n( "N0LK" ),
        s = n( "EffR" ),
        a = n( "o1O+" ),
        u = n( "ZlPH" ),
        l = n( "G300" ),
        c = n( "Cg/j" ),
        d = n( "bexQ" ),
        h = n( "T8No" ),
        p = n( "wQH0" ),
        f = n( "sswD" ),
        g = n( "k7pc" ),
        m = n( "t9D7" ),
        _ = n( "MD5Z" ),
        v = n( "MNsG" ),
        y = n( "OBOq" ),
        b = n( "W9cx" ),
        C = n( "bY76" ),
        w = n( "D3Dy" ),
        S = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        O = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        L = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        x = new h.f( "accessibilityHelpWidgetVisible", !1 ),
        N = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            return i._editor = t, i._widget = i._register( n.createInstance( T, i._editor ) ), i
          }
          return S( t, e ), t.get = e => {
            return e.getContribution( t.ID )
          }, t.prototype.getId = () => {
            return t.ID
          }, t.prototype.show = function () {
            this._widget.show()
          }, t.prototype.hide = function () {
            this._widget.hide()
          }, t.ID = "editor.contrib.accessibilityHelpController", t = O( [ L( 1, c.a ) ], t );
        } )( o.a ),
        E = i.a( "noSelection", "No selection" ),
        k = i.a( "singleSelectionRange", "Line {0}, Column {1} ({2} selected)" ),
        I = i.a( "singleSelection", "Line {0}, Column {1}" ),
        D = i.a( "multiSelectionRange", "{0} selections ({1} characters selected)" ),
        M = i.a( "multiSelection", "{0} selections" );

      var T = ( e => {
        function t( t, n, o, r ) {
          const a = e.call( this ) || this;
          return a._contextKeyService = n, a._keybindingService = o, a._openerService = r, a._editor = t, a._isVisibleKey = x.bindTo( a._contextKeyService ), a._domNode = Object( u.b )( document.createElement( "div" ) ), a._domNode.setClassName( "accessibilityHelpWidget" ), a._domNode.setDisplay( "none" ), a._domNode.setAttribute( "role", "dialog" ), a._domNode.setAttribute( "aria-hidden", "true" ), a._contentDomNode = Object( u.b )( document.createElement( "div" ) ), a._contentDomNode.setAttribute( "role", "document" ), a._domNode.appendChild( a._contentDomNode ), a._isVisible = !1, a._register( a._editor.onDidLayoutChange( ( () => {
            a._isVisible && a._layout()
          } ) ) ), a._register( s.j( a._contentDomNode.domNode, "keydown", ( e => {
            if ( a._isVisible && ( e.equals( 2083 ) && ( Object( y.a )( i.a( "emergencyConfOn", "Now changing the setting `accessibilitySupport` to 'on'." ) ), a._editor.updateOptions( {
                accessibilitySupport: "on"
              } ), s.l( a._contentDomNode.domNode ), a._buildContent(), a._contentDomNode.domNode.focus(), e.preventDefault(), e.stopPropagation() ), e.equals( 2086 ) ) ) {
              Object( y.a )( i.a( "openingDocs", "Now opening the Editor Accessibility documentation page." ) );
              let t = a._editor.getRawConfiguration().accessibilityHelpUrl;
              "undefined" === typeof t && ( t = "https://go.microsoft.com/fwlink/?linkid=852450" ), a._openerService.open( C.a.parse( t ) ), e.preventDefault(), e.stopPropagation()
            }
          } ) ) ), a.onblur( a._contentDomNode.domNode, ( () => {
            a.hide()
          } ) ), a._editor.addOverlayWidget( a ), a;
        }
        return S( t, e ), t.prototype.dispose = function () {
          this._editor.removeOverlayWidget( this ), e.prototype.dispose.call( this )
        }, t.prototype.getId = () => {
          return t.ID
        }, t.prototype.getDomNode = function () {
          return this._domNode.domNode
        }, t.prototype.getPosition = () => {
          return {
            preference: null
          }
        }, t.prototype.show = function () {
          this._isVisible || ( this._isVisible = !0, this._isVisibleKey.set( !0 ), this._layout(), this._domNode.setDisplay( "block" ), this._domNode.setAttribute( "aria-hidden", "false" ), this._contentDomNode.domNode.tabIndex = 0, this._buildContent(), this._contentDomNode.domNode.focus() )
        }, t.prototype._descriptionForCommand = function ( e, t, n ) {
          const i = this._keybindingService.lookupKeybinding( e );
          return i ? r.format( t, i.getAriaLabel() ) : r.format( n, e )
        }, t.prototype._buildContent = function () {
          const e = this._editor.getConfiguration();
          const t = this._editor.getSelections();
          let n = 0;
          if ( t ) {
            const o = this._editor.getModel();
            o && t.forEach( ( e => {
              n += o.getValueLengthInRange( e )
            } ) )
          }
          let s = ( ( e, t ) => {
            return e && 0 !== e.length ? 1 === e.length ? t ? r.format( k, e[ 0 ].positionLineNumber, e[ 0 ].positionColumn, t ) : r.format( I, e[ 0 ].positionLineNumber, e[ 0 ].positionColumn ) : t ? r.format( D, e.length, t ) : e.length > 0 ? r.format( M, e.length ) : null : E
          } )( t, n );
          switch ( e.wrappingInfo.inDiffEditor ? e.readOnly ? s += i.a( "readonlyDiffEditor", " in a read-only pane of a diff editor." ) : s += i.a( "editableDiffEditor", " in a pane of a diff editor." ) : e.readOnly ? s += i.a( "readonlyEditor", " in a read-only code editor" ) : s += i.a( "editableEditor", " in a code editor" ), e.accessibilitySupport ) {
            case 0:
              const u = v.d ? i.a( "changeConfigToOnMac", "To configure the editor to be optimized for usage with a Screen Reader press Command+E now." ) : i.a( "changeConfigToOnWinLinux", "To configure the editor to be optimized for usage with a Screen Reader press Control+E now." );
              s += "\n\n - " + u;
              break;
            case 2:
              s += "\n\n - " + i.a( "auto_on", "The editor is configured to be optimized for usage with a Screen Reader." );
              break;
            case 1:
              s += "\n\n - " + i.a( "auto_off", "The editor is configured to never be optimized for usage with a Screen Reader, which is not the case at this time." ), s += " " + u
          }
          const l = i.a( "tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}." ),
            c = i.a( "tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding." ),
            d = i.a( "tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}." ),
            h = i.a( "tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding." );
          e.tabFocusMode ? s += "\n\n - " + this._descriptionForCommand( g.ToggleTabFocusModeAction.ID, l, c ) : s += "\n\n - " + this._descriptionForCommand( g.ToggleTabFocusModeAction.ID, d, h ), s += "\n\n - " + ( v.d ? i.a( "openDocMac", "Press Command+H now to open a browser window with more information related to editor accessibility." ) : i.a( "openDocWinLinux", "Press Control+H now to open a browser window with more information related to editor accessibility." ) ), s += "\n\n" + i.a( "outroMsg", "You can dismiss this tooltip and return to the editor by pressing Escape or Shift+Escape." ), this._contentDomNode.domNode.appendChild( Object( a.a )( s ) ), this._contentDomNode.domNode.setAttribute( "aria-label", s )
        }, t.prototype.hide = function () {
          this._isVisible && ( this._isVisible = !1, this._isVisibleKey.reset(), this._domNode.setDisplay( "none" ), this._domNode.setAttribute( "aria-hidden", "true" ), this._contentDomNode.domNode.tabIndex = -1, s.l( this._contentDomNode.domNode ), this._editor.focus() )
        }, t.prototype._layout = function () {
          const e = this._editor.getLayoutInfo(),
            n = Math.max( 5, Math.min( t.WIDTH, e.width - 40 ) ),
            i = Math.max( 5, Math.min( t.HEIGHT, e.height - 40 ) );
          this._domNode.setWidth( n ), this._domNode.setHeight( i );
          const o = Math.round( ( e.height - i ) / 2 );
          this._domNode.setTop( o );
          const r = Math.round( ( e.width - n ) / 2 );
          this._domNode.setLeft( r )
        }, t.ID = "editor.contrib.accessibilityHelpWidget", t.WIDTH = 500, t.HEIGHT = 300, t = O( [ L( 1, h.e ), L( 2, d.a ), L( 3, b.a ) ], t );
      } )( l.a );

      const R = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.showAccessibilityHelp",
            label: i.a( "ShowAccessibilityHelpAction", "Show Accessibility Help" ),
            alias: "Show Accessibility Help",
            precondition: null,
            kbOpts: {
              kbExpr: p.a.focus,
              primary: w.k ? 2107 : 571,
              weight: 100
            }
          } ) || this
        }
        return S( t, e ), t.prototype.run = ( e, t ) => {
          const n = N.get( t );
          n && n.show()
        }, t;
      } )( f.b );
      Object( f.h )( N ), Object( f.f )( R );
      const P = f.c.bindToContribution( N.get );
      Object( f.g )( new P( {
        id: "closeAccessibilityHelp",
        precondition: x,
        handler( e ) {
          return e.hide()
        },
        kbOpts: {
          weight: 200,
          kbExpr: p.a.focus,
          primary: 9,
          secondary: [ 1033 ]
        }
      } ) ), Object( m.e )( ( ( e, t ) => {
        const n = e.getColor( _.D );
        n && t.addRule( ".monaco-editor .accessibilityHelpWidget { background-color: " + n + "; }" );
        const i = e.getColor( _.rb );
        i && t.addRule( ".monaco-editor .accessibilityHelpWidget { box-shadow: 0 2px 8px " + i + "; }" );
        const o = e.getColor( _.e );
        o && t.addRule( ".monaco-editor .accessibilityHelpWidget { border: 2px solid " + o + "; }" )
      } ) )
    },
    SmQN( e, t, n ) {
      "use strict";
      n( "lKfe" );
      const i = n( "3/fG" ),
        o = n( "X+cX" ),
        r = n( "pmY6" ),
        s = n( "qj0h" ),
        a = n( "EffR" ),
        u = n( "ZlPH" ),
        l = n( "cMOf" ),
        c = n( "Cg/j" ),
        d = n( "T8No" ),
        h = n( "Vxe3" ),
        p = n( "aokT" ),
        f = n( "iuje" ),
        g = n( "pAvP" ),
        m = n( "dBaI" ),
        _ = n( "baJR" ),
        v = n( "nB0o" ),
        y = n( "HdwC" ),
        b = n( "qNAo" ),
        C = n( "8HsV" ),
        w = n( "MI8n" ),
        S = n( "/UlZ" ),
        O = n( "t9D7" ),
        L = n( "MD5Z" ),
        x = n( "MvK1" ),
        N = n( "tX9W" ),
        E = ( n( "DTDp" ), n( "4bUh" ) ),
        k = n( "cGHE" ),
        I = n( "GJhM" ),
        D = n( "kYye" ),
        M = n( "WqXY" ),
        T = n( "8HAY" ),
        R = n( "sswD" ),
        P = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        A = ( () => {
          function e( e, t, n, i ) {
            this.originalLineStart = e, this.originalLineEnd = t, this.modifiedLineStart = n, this.modifiedLineEnd = i
          }
          return e.prototype.getType = function () {
            return 0 === this.originalLineStart ? 1 : 0 === this.modifiedLineStart ? 2 : 0
          }, e
        } )(),
        F = function ( e ) {
          this.entries = e
        },
        W = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._width = 0, n._diffEditor = t, n._isVisible = !1, n.shadow = Object( u.b )( document.createElement( "div" ) ), n.shadow.setClassName( "diff-review-shadow" ), n.actionBarContainer = Object( u.b )( document.createElement( "div" ) ), n.actionBarContainer.setClassName( "diff-review-actions" ), n._actionBar = n._register( new M.a( n.actionBarContainer.domNode ) ), n._actionBar.push( new T.a( "diffreview.close", i.a( "label.close", "Close" ), "close-diff-review", !0, ( () => {
              return n.hide(), null
            } ) ), {
              label: !1,
              icon: !0
            } ), n.domNode = Object( u.b )( document.createElement( "div" ) ), n.domNode.setClassName( "diff-review monaco-editor-background" ), n._content = Object( u.b )( document.createElement( "div" ) ), n._content.setClassName( "diff-review-content" ), n.scrollbar = n._register( new I.a( n._content.domNode, {} ) ), n.domNode.domNode.appendChild( n.scrollbar.getDomNode() ), n._register( t.onDidUpdateDiff( ( () => {
              n._isVisible && ( n._diffs = n._compute(), n._render() )
            } ) ) ), n._register( t.getModifiedEditor().onDidChangeCursorPosition( ( () => {
              n._isVisible && n._render()
            } ) ) ), n._register( t.getOriginalEditor().onDidFocusEditorWidget( ( () => {
              n._isVisible && n.hide()
            } ) ) ), n._register( t.getModifiedEditor().onDidFocusEditorWidget( ( () => {
              n._isVisible && n.hide()
            } ) ) ), n._register( a.j( n.domNode.domNode, "click", ( e => {
              e.preventDefault();
              const t = a.p( e.target, "diff-review-row" );
              t && n._goToRow( t )
            } ) ) ), n._register( a.j( n.domNode.domNode, "keydown", ( e => {
              ( e.equals( 18 ) || e.equals( 2066 ) || e.equals( 530 ) ) && ( e.preventDefault(), n._goToRow( n._getNextRow() ) ), ( e.equals( 16 ) || e.equals( 2064 ) || e.equals( 528 ) ) && ( e.preventDefault(), n._goToRow( n._getPrevRow() ) ), ( e.equals( 9 ) || e.equals( 2057 ) || e.equals( 521 ) || e.equals( 1033 ) ) && ( e.preventDefault(), n.hide() ), ( e.equals( 10 ) || e.equals( 3 ) ) && ( e.preventDefault(), n.accept() )
            } ) ) ), n._diffs = [], n._currentDiff = null, n;
          }
          return P( t, e ), t.prototype.prev = function () {
            let e = 0;
            if ( this._isVisible || ( this._diffs = this._compute() ), this._isVisible ) {
              for ( var t = -1, n = 0, i = this._diffs.length; n < i; n++ )
                if ( this._diffs[ n ] === this._currentDiff ) {
                  t = n;
                  break
                } e = this._diffs.length + t - 1
            } else e = this._findDiffIndex( this._diffEditor.getPosition() );
            0 !== this._diffs.length && ( e %= this._diffs.length, this._diffEditor.setPosition( new k.a( this._diffs[ e ].entries[ 0 ].modifiedLineStart, 1 ) ), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow( this._getNextRow() ) )
          }, t.prototype.next = function () {
            let e = 0;
            if ( this._isVisible || ( this._diffs = this._compute() ), this._isVisible ) {
              for ( var t = -1, n = 0, i = this._diffs.length; n < i; n++ )
                if ( this._diffs[ n ] === this._currentDiff ) {
                  t = n;
                  break
                } e = t + 1
            } else e = this._findDiffIndex( this._diffEditor.getPosition() );
            0 !== this._diffs.length && ( e %= this._diffs.length, this._diffEditor.setPosition( new k.a( this._diffs[ e ].entries[ 0 ].modifiedLineStart, 1 ) ), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow( this._getNextRow() ) )
          }, t.prototype.accept = function () {
            let e = -1;
            const t = this._getCurrentFocusedRow();
            if ( t ) {
              const n = parseInt( t.getAttribute( "data-line" ), 10 );
              isNaN( n ) || ( e = n )
            }
            this.hide(), -1 !== e && ( this._diffEditor.setPosition( new k.a( e, 1 ) ), this._diffEditor.revealPosition( new k.a( e, 1 ), 1 ) )
          }, t.prototype.hide = function () {
            this._isVisible = !1, this._diffEditor.focus(), this._diffEditor.doLayout(), this._render()
          }, t.prototype._getPrevRow = function () {
            const e = this._getCurrentFocusedRow();
            return e ? e.previousElementSibling ? e.previousElementSibling : e : this._getFirstRow()
          }, t.prototype._getNextRow = function () {
            const e = this._getCurrentFocusedRow();
            return e ? e.nextElementSibling ? e.nextElementSibling : e : this._getFirstRow()
          }, t.prototype._getFirstRow = function () {
            return this.domNode.domNode.querySelector( ".diff-review-row" )
          }, t.prototype._getCurrentFocusedRow = () => {
            const e = document.activeElement;
            return e && /diff-review-row/.test( e.className ) ? e : null
          }, t.prototype._goToRow = function ( e ) {
            const t = this._getCurrentFocusedRow();
            e.tabIndex = 0, e.focus(), t && t !== e && ( t.tabIndex = -1 ), this.scrollbar.scanDomNode()
          }, t.prototype.isVisible = function () {
            return this._isVisible
          }, t.prototype.layout = function ( e, t, n ) {
            this._width = t, this.shadow.setTop( e - 6 ), this.shadow.setWidth( t ), this.shadow.setHeight( this._isVisible ? 6 : 0 ), this.domNode.setTop( e ), this.domNode.setWidth( t ), this.domNode.setHeight( n ), this._content.setHeight( n ), this._content.setWidth( t ), this._isVisible ? ( this.actionBarContainer.setAttribute( "aria-hidden", "false" ), this.actionBarContainer.setDisplay( "block" ) ) : ( this.actionBarContainer.setAttribute( "aria-hidden", "true" ), this.actionBarContainer.setDisplay( "none" ) )
          }, t.prototype._compute = function () {
            const e = this._diffEditor.getLineChanges();
            if ( !e || 0 === e.length ) return [];
            const n = this._diffEditor.getOriginalEditor().getModel(),
              i = this._diffEditor.getModifiedEditor().getModel();
            return n && i ? t._mergeAdjacent( e, n.getLineCount(), i.getLineCount() ) : []
          }, t._mergeAdjacent = ( e, t, n ) => {
            if ( !e || 0 === e.length ) return [];
            for ( var i = [], o = 0, r = 0, s = e.length; r < s; r++ ) {
              const a = e[ r ];
              const u = a.originalStartLineNumber;
              const l = a.originalEndLineNumber;
              const c = a.modifiedStartLineNumber;
              const d = a.modifiedEndLineNumber;
              const h = [];
              let p = 0;
              const f = 0 === l ? u : u - 1;
              const g = 0 === d ? c : c - 1;
              let m = 1;
              let _ = 1;
              if ( r > 0 ) {
                const v = e[ r - 1 ];
                m = 0 === v.originalEndLineNumber ? v.originalStartLineNumber + 1 : v.originalEndLineNumber + 1, _ = 0 === v.modifiedEndLineNumber ? v.modifiedStartLineNumber + 1 : v.modifiedEndLineNumber + 1
              }
              let y = f - 3 + 1,
                b = g - 3 + 1;
              if ( y < m ) y += x = m - y, b += x;
              if ( b < _ ) y += x = _ - b, b += x;
              h[ p++ ] = new A( y, f, b, g ), 0 !== l && ( h[ p++ ] = new A( u, l, 0, 0 ) ), 0 !== d && ( h[ p++ ] = new A( 0, 0, c, d ) );
              const C = 0 === l ? u + 1 : l + 1;
              const w = 0 === d ? c + 1 : d + 1;
              let S = t;
              let O = n;
              if ( r + 1 < s ) {
                const L = e[ r + 1 ];
                S = 0 === L.originalEndLineNumber ? L.originalStartLineNumber : L.originalStartLineNumber - 1, O = 0 === L.modifiedEndLineNumber ? L.modifiedStartLineNumber : L.modifiedStartLineNumber - 1
              }
              var x;
              let N = C + 3 - 1;
              let E = w + 3 - 1;
              if ( N > S ) N += x = S - N, E += x;
              if ( E > O ) N += x = O - E, E += x;
              h[ p++ ] = new A( C, N, w, E ), i[ o++ ] = new F( h )
            }
            let k = i[ 0 ].entries;
            const I = [];
            let D = 0;
            for ( r = 1, s = i.length; r < s; r++ ) {
              const M = i[ r ].entries,
                T = k[ k.length - 1 ],
                R = M[ 0 ];
              0 === T.getType() && 0 === R.getType() && R.originalLineStart <= T.originalLineEnd ? ( k[ k.length - 1 ] = new A( T.originalLineStart, R.originalLineEnd, T.modifiedLineStart, R.modifiedLineEnd ), k = k.concat( M.slice( 1 ) ) ) : ( I[ D++ ] = new F( k ), k = M )
            }
            return I[ D++ ] = new F( k ), I
          }, t.prototype._findDiffIndex = function ( e ) {
            for ( let t = e.lineNumber, n = 0, i = this._diffs.length; n < i; n++ ) {
              const o = this._diffs[ n ].entries;
              if ( t <= o[ o.length - 1 ].modifiedLineEnd ) return n
            }
            return 0
          }, t.prototype._render = function () {
            const e = this._diffEditor.getOriginalEditor().getConfiguration(),
              n = this._diffEditor.getModifiedEditor().getConfiguration(),
              o = this._diffEditor.getOriginalEditor().getModel(),
              r = this._diffEditor.getModifiedEditor().getModel(),
              s = o.getOptions(),
              u = r.getOptions();
            if ( !this._isVisible || !o || !r ) return a.l( this._content.domNode ), this._currentDiff = null, void this.scrollbar.scanDomNode();
            const l = this._diffEditor.getPosition(),
              c = this._findDiffIndex( l );
            if ( this._diffs[ c ] !== this._currentDiff ) {
              this._currentDiff = this._diffs[ c ];
              const d = this._diffs[ c ].entries,
                h = document.createElement( "div" );
              h.className = "diff-review-table", h.setAttribute( "role", "list" ), y.a.applyFontInfoSlow( h, n.fontInfo );
              for ( var p = 0, f = 0, g = 0, m = 0, _ = 0, v = d.length; _ < v; _++ ) {
                const b = ( M = d[ _ ] ).originalLineStart,
                  C = M.originalLineEnd,
                  w = M.modifiedLineStart,
                  S = M.modifiedLineEnd;
                0 !== b && ( 0 === p || b < p ) && ( p = b ), 0 !== C && ( 0 === f || C > f ) && ( f = C ), 0 !== w && ( 0 === g || w < g ) && ( g = w ), 0 !== S && ( 0 === m || S > m ) && ( m = S )
              }
              const O = document.createElement( "div" );
              O.className = "diff-review-row";
              const L = document.createElement( "div" );
              L.className = "diff-review-cell diff-review-summary";
              const x = f - p + 1,
                N = m - g + 1;
              L.appendChild( document.createTextNode( c + 1 + "/" + this._diffs.length + ": @@ -" + p + "," + x + " +" + g + "," + N + " @@" ) ), O.setAttribute( "data-line", String( g ) );
              const E = e => {
                  return 0 === e ? i.a( "no_lines", "no lines" ) : 1 === e ? i.a( "one_line", "1 line" ) : i.a( "more_lines", "{0} lines", e )
                },
                k = E( x ),
                I = E( N );
              O.setAttribute( "aria-label", i.a( {
                key: "header",
                comment: [ "This is the ARIA label for a git diff header.", "A git diff header looks like this: @@ -154,12 +159,39 @@.", "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.", "Variables 0 and 1 refer to the diff index out of total number of diffs.", "Variables 2 and 4 will be numbers (a line number).", 'Variables 3 and 5 will be "no lines", "1 line" or "X lines", localized separately.' ]
              }, "Difference {0} of {1}: original {2}, {3}, modified {4}, {5}", c + 1, this._diffs.length, p, k, g, I ) ), O.appendChild( L ), O.setAttribute( "role", "listitem" ), h.appendChild( O );
              let D = g;
              for ( _ = 0, v = d.length; _ < v; _++ ) {
                var M = d[ _ ];
                t._renderSection( h, M, D, this._width, e, o, s, n, r, u ), 0 !== M.modifiedLineStart && ( D = M.modifiedLineEnd )
              }
              a.l( this._content.domNode ), this._content.domNode.appendChild( h ), this.scrollbar.scanDomNode()
            }
          }, t._renderSection = function ( e, t, n, o, r, s, a, u, l, c ) {
            const d = t.getType();
            let h = "diff-review-row";
            let p = "";
            let f = "diff-review-spacer";
            switch ( d ) {
              case 1:
                h = "diff-review-row line-insert", p = " char-insert", f = "diff-review-spacer insert-sign";
                break;
              case 2:
                h = "diff-review-row line-delete", p = " char-delete", f = "diff-review-spacer delete-sign"
            }
            for ( let g = t.originalLineStart, m = t.originalLineEnd, _ = t.modifiedLineStart, v = t.modifiedLineEnd, y = Math.max( v - _, m - g ), b = r.layoutInfo.glyphMarginWidth + r.layoutInfo.lineNumbersWidth, C = 10 + u.layoutInfo.glyphMarginWidth + u.layoutInfo.lineNumbersWidth, w = 0; w <= y; w++ ) {
              const S = 0 === g ? 0 : g + w,
                O = 0 === _ ? 0 : _ + w,
                L = document.createElement( "div" );
              L.style.minWidth = o + "px", L.className = h, L.setAttribute( "role", "listitem" ), 0 !== O && ( n = O ), L.setAttribute( "data-line", String( n ) );
              const x = document.createElement( "div" );
              x.className = "diff-review-cell", L.appendChild( x );
              const N = document.createElement( "span" );
              N.style.width = b + "px", N.style.minWidth = b + "px", N.className = "diff-review-line-number" + p, 0 !== S ? N.appendChild( document.createTextNode( String( S ) ) ) : N.innerHTML = "&nbsp;", x.appendChild( N );
              const E = document.createElement( "span" );
              E.style.width = C + "px", E.style.minWidth = C + "px", E.style.paddingRight = "10px", E.className = "diff-review-line-number" + p, 0 !== O ? E.appendChild( document.createTextNode( String( O ) ) ) : E.innerHTML = "&nbsp;", x.appendChild( E );
              const k = document.createElement( "span" );
              k.className = f, k.innerHTML = "&nbsp;&nbsp;", x.appendChild( k );
              let I = void 0;
              0 !== O ? ( x.insertAdjacentHTML( "beforeend", this._renderLine( l, u, c.tabSize, O ) ), I = l.getLineContent( O ) ) : ( x.insertAdjacentHTML( "beforeend", this._renderLine( s, r, a.tabSize, S ) ), I = s.getLineContent( S ) ), 0 === I.length && ( I = i.a( "blankLine", "blank" ) );
              let D = void 0;
              switch ( d ) {
                case 0:
                  D = i.a( "equalLine", "original {0}, modified {1}: {2}", S, O, I );
                  break;
                case 1:
                  D = i.a( "insertLine", "+ modified {0}: {1}", O, I );
                  break;
                case 2:
                  D = i.a( "deleteLine", "- original {0}: {1}", S, I )
              }
              L.setAttribute( "aria-label", D ), e.appendChild( L )
            }
          }, t._renderLine = ( e, t, n, i ) => {
            const o = e.getLineContent( i ),
              r = new Uint32Array( 2 );
            r[ 0 ] = o.length, r[ 1 ] = 16793600;
            const s = new E.a( r, o ),
              a = b.d.isBasicASCII( o, e.mightContainNonBasicASCII() ),
              u = b.d.containsRTL( o, a, e.mightContainRTL() );
            return Object( _.d )( new _.b( t.fontInfo.isMonospace && !t.viewInfo.disableMonospaceOptimizations, o, !1, a, u, 0, s, [], n, t.fontInfo.spaceWidth, t.viewInfo.stopRenderingLineAfter, t.viewInfo.renderWhitespace, t.viewInfo.renderControlCharacters, t.viewInfo.fontLigatures ) ).html
          }, t;
        } )( r.a );
      Object( O.e )( ( ( e, t ) => {
        const n = e.getColor( D.q );
        n && t.addRule( ".monaco-diff-editor .diff-review-line-number { color: " + n + "; }" );
        const i = e.getColor( L.lb );
        i && t.addRule( ".monaco-diff-editor .diff-review-shadow { box-shadow: " + i + " 0 -6px 6px -6px inset; }" )
      } ) );
      const j = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.diffReview.next",
              label: i.a( "editor.action.diffReview.next", "Go to Next Difference" ),
              alias: "Go to Next Difference",
              precondition: d.d.has( "isInDiffEditor" ),
              kbOpts: {
                kbExpr: null,
                primary: 65,
                weight: 100
              }
            } ) || this
          }
          return P( t, e ), t.prototype.run = ( e, t ) => {
            const n = B( e );
            n && n.diffReviewNext()
          }, t;
        } )( R.b ),
        V = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.diffReview.prev",
              label: i.a( "editor.action.diffReview.prev", "Go to Previous Difference" ),
              alias: "Go to Previous Difference",
              precondition: d.d.has( "isInDiffEditor" ),
              kbOpts: {
                kbExpr: null,
                primary: 1089,
                weight: 100
              }
            } ) || this
          }
          return P( t, e ), t.prototype.run = ( e, t ) => {
            const n = B( e );
            n && n.diffReviewPrev()
          }, t;
        } )( R.b );

      function B( e ) {
        for ( let t = e.get( h.a ).listDiffEditors(), n = 0, i = t.length; n < i; n++ ) {
          const o = t[ n ];
          if ( o.hasWidgetFocus() ) return o
        }
        return null
      }
      Object( R.f )( j ), Object( R.f )( V );
      const H = n( "erNZ" ),
        z = n( "sM1p" ),
        U = n( "vATl" );
      n.d( t, "a", ( () => {
        return $
      } ) );
      const K = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const q = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const G = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      const Y = ( () => {
        function e() {
          this._zones = [], this._zonesMap = {}, this._decorations = []
        }
        return e.prototype.getForeignViewZones = function ( e ) {
          const t = this;
          return e.filter( ( e => {
            return !t._zonesMap[ String( e.id ) ]
          } ) );
        }, e.prototype.clean = function ( e ) {
          const t = this;
          this._zones.length > 0 && e.changeViewZones( ( e => {
            for ( let n = 0, i = t._zones.length; n < i; n++ ) e.removeZone( t._zones[ n ] )
          } ) ), this._zones = [], this._zonesMap = {}, this._decorations = e.deltaDecorations( this._decorations, [] )
        }, e.prototype.apply = function ( e, t, n, i ) {
          const o = this,
            r = i ? U.b.capture( e ) : null;
          e.changeViewZones( ( e => {
            for ( var t = 0, i = o._zones.length; t < i; t++ ) e.removeZone( o._zones[ t ] );
            o._zones = [], o._zonesMap = {};
            t = 0;
            for ( const r = n.zones.length; t < r; t++ ) {
              n.zones[ t ].suppressMouseDown = !0;
              const s = e.addZone( n.zones[ t ] );
              o._zones.push( s ), o._zonesMap[ String( s ) ] = !0
            }
          } ) ), r && r.restore( e ), this._decorations = e.deltaDecorations( this._decorations, n.decorations ), t && t.setZones( n.overviewZones )
        }, e;
      } )();
      let X = 0;
      var $ = ( e => {
        function t( n, i, r, s, l, c, h, p ) {
          const f = e.call( this ) || this;
          f._onDidDispose = f._register( new w.a ), f.onDidDispose = f._onDidDispose.event, f._onDidUpdateDiff = f._register( new w.a ), f.onDidUpdateDiff = f._onDidUpdateDiff.event, f._lastOriginalWarning = null, f._lastModifiedWarning = null, f._editorWorkerService = r, f._codeEditorService = c, f._contextKeyService = f._register( s.createScoped( n ) ), f._contextKeyService.createKey( "isInDiffEditor", !0 ), f._themeService = h, f._notificationService = p, f.id = ++X, f._domElement = n, i = i || {}, f._renderSideBySide = !0, "undefined" !== typeof i.renderSideBySide && ( f._renderSideBySide = i.renderSideBySide ), f._ignoreTrimWhitespace = !0, "undefined" !== typeof i.ignoreTrimWhitespace && ( f._ignoreTrimWhitespace = i.ignoreTrimWhitespace ), f._renderIndicators = !0, "undefined" !== typeof i.renderIndicators && ( f._renderIndicators = i.renderIndicators ), f._originalIsEditable = !1, "undefined" !== typeof i.originalEditable && ( f._originalIsEditable = Boolean( i.originalEditable ) ), f._updateDecorationsRunner = f._register( new o.c( ( () => {
            return f._updateDecorations()
          } ), 0 ) ), f._containerDomElement = document.createElement( "div" ), f._containerDomElement.className = t._getClassName( f._themeService.getTheme(), f._renderSideBySide ), f._containerDomElement.style.position = "relative", f._containerDomElement.style.height = "100%", f._domElement.appendChild( f._containerDomElement ), f._overviewViewportDomElement = Object( u.b )( document.createElement( "div" ) ), f._overviewViewportDomElement.setClassName( "diffViewport" ), f._overviewViewportDomElement.setPosition( "absolute" ), f._overviewDomElement = document.createElement( "div" ), f._overviewDomElement.className = "diffOverview", f._overviewDomElement.style.position = "absolute", f._overviewDomElement.appendChild( f._overviewViewportDomElement.domNode ), f._register( a.j( f._overviewDomElement, "mousedown", ( e => {
            f.modifiedEditor.delegateVerticalScrollbarMouseDown( e )
          } ) ) ), f._containerDomElement.appendChild( f._overviewDomElement ), f._createLeftHandSide(), f._createRightHandSide(), f._beginUpdateDecorationsTimeout = -1, f._currentlyChangingViewZones = !1, f._diffComputationToken = 0, f._originalEditorState = new Y, f._modifiedEditorState = new Y, f._isVisible = !0, f._isHandlingScrollEvent = !1, f._width = 0, f._height = 0, f._reviewHeight = 0, f._lineChanges = null;
          const g = f._contextKeyService.createScoped();
          g.createKey( "isInDiffLeftEditor", !0 );
          const m = new C.a;
          m.set( d.e, g );
          const _ = l.createChild( m ),
            v = f._contextKeyService.createScoped();
          v.createKey( "isInDiffRightEditor", !0 );
          const y = new C.a;
          y.set( d.e, v );
          const b = l.createChild( y );
          return f._createLeftHandSideEditor( i, _ ), f._createRightHandSideEditor( i, b ), f._reviewPane = new W( f ), f._containerDomElement.appendChild( f._reviewPane.domNode.domNode ), f._containerDomElement.appendChild( f._reviewPane.shadow.domNode ), f._containerDomElement.appendChild( f._reviewPane.actionBarContainer.domNode ), i.automaticLayout && ( f._measureDomElementToken = window.setInterval( ( () => {
            return f._measureDomElement( !1 )
          } ), 100 ) ), f._enableSplitViewResizing = !0, "undefined" !== typeof i.enableSplitViewResizing && ( f._enableSplitViewResizing = i.enableSplitViewResizing ), f._renderSideBySide ? f._setStrategy( new ne( f._createDataSource(), f._enableSplitViewResizing ) ) : f._setStrategy( new oe( f._createDataSource(), f._enableSplitViewResizing ) ), f._register( h.onThemeChange( ( e => {
            f._strategy && f._strategy.applyColors( e ) && f._updateDecorationsRunner.schedule(), f._containerDomElement.className = t._getClassName( f._themeService.getTheme(), f._renderSideBySide )
          } ) ) ), f._codeEditorService.addDiffEditor( f ), f;
        }
        return K( t, e ), t.prototype.hasWidgetFocus = function () {
          return a.B( document.activeElement, this._domElement )
        }, t.prototype.diffReviewNext = function () {
          this._reviewPane.next()
        }, t.prototype.diffReviewPrev = function () {
          this._reviewPane.prev()
        }, t._getClassName = ( e, t ) => {
          let n = "monaco-diff-editor monaco-editor-background ";
          return t && ( n += "side-by-side " ), n += Object( O.d )( e.type )
        }, t.prototype._recreateOverviewRulers = function () {
          this._originalOverviewRuler && ( this._overviewDomElement.removeChild( this._originalOverviewRuler.getDomNode() ), this._originalOverviewRuler.dispose() ), this._originalOverviewRuler = this.originalEditor.createOverviewRuler( "original diffOverviewRuler" ), this._overviewDomElement.appendChild( this._originalOverviewRuler.getDomNode() ), this._modifiedOverviewRuler && ( this._overviewDomElement.removeChild( this._modifiedOverviewRuler.getDomNode() ), this._modifiedOverviewRuler.dispose() ), this._modifiedOverviewRuler = this.modifiedEditor.createOverviewRuler( "modified diffOverviewRuler" ), this._overviewDomElement.appendChild( this._modifiedOverviewRuler.getDomNode() ), this._layoutOverviewRulers()
        }, t.prototype._createLeftHandSide = function () {
          this._originalDomNode = document.createElement( "div" ), this._originalDomNode.className = "editor original", this._originalDomNode.style.position = "absolute", this._originalDomNode.style.height = "100%", this._containerDomElement.appendChild( this._originalDomNode )
        }, t.prototype._createRightHandSide = function () {
          this._modifiedDomNode = document.createElement( "div" ), this._modifiedDomNode.className = "editor modified", this._modifiedDomNode.style.position = "absolute", this._modifiedDomNode.style.height = "100%", this._containerDomElement.appendChild( this._modifiedDomNode )
        }, t.prototype._createLeftHandSideEditor = function ( e, t ) {
          const n = this;
          this.originalEditor = this._createInnerEditor( t, this._originalDomNode, this._adjustOptionsForLeftHandSide( e, this._originalIsEditable ) ), this._register( this.originalEditor.onDidScrollChange( ( e => {
            n._isHandlingScrollEvent || ( e.scrollTopChanged || e.scrollLeftChanged || e.scrollHeightChanged ) && ( n._isHandlingScrollEvent = !0, n.modifiedEditor.setScrollPosition( {
              scrollLeft: e.scrollLeft,
              scrollTop: e.scrollTop
            } ), n._isHandlingScrollEvent = !1, n._layoutOverviewViewport() )
          } ) ) ), this._register( this.originalEditor.onDidChangeViewZones( ( () => {
            n._onViewZonesChanged()
          } ) ) ), this._register( this.originalEditor.onDidChangeModelContent( ( () => {
            n._isVisible && n._beginUpdateDecorationsSoon()
          } ) ) )
        }, t.prototype._createRightHandSideEditor = function ( e, t ) {
          const n = this;
          this.modifiedEditor = this._createInnerEditor( t, this._modifiedDomNode, this._adjustOptionsForRightHandSide( e ) ), this._register( this.modifiedEditor.onDidScrollChange( ( e => {
            n._isHandlingScrollEvent || ( e.scrollTopChanged || e.scrollLeftChanged || e.scrollHeightChanged ) && ( n._isHandlingScrollEvent = !0, n.originalEditor.setScrollPosition( {
              scrollLeft: e.scrollLeft,
              scrollTop: e.scrollTop
            } ), n._isHandlingScrollEvent = !1, n._layoutOverviewViewport() )
          } ) ) ), this._register( this.modifiedEditor.onDidChangeViewZones( ( () => {
            n._onViewZonesChanged()
          } ) ) ), this._register( this.modifiedEditor.onDidChangeConfiguration( ( e => {
            e.fontInfo && n.modifiedEditor.getModel() && n._onViewZonesChanged()
          } ) ) ), this._register( this.modifiedEditor.onDidChangeModelContent( ( () => {
            n._isVisible && n._beginUpdateDecorationsSoon()
          } ) ) )
        }, t.prototype._createInnerEditor = ( e, t, n ) => {
          return e.createInstance( v.a, t, n, {} )
        }, t.prototype.dispose = function () {
          this._codeEditorService.removeDiffEditor( this ), -1 !== this._beginUpdateDecorationsTimeout && ( window.clearTimeout( this._beginUpdateDecorationsTimeout ), this._beginUpdateDecorationsTimeout = -1 ), window.clearInterval( this._measureDomElementToken ), this._cleanViewZonesAndDecorations(), this._originalOverviewRuler && ( this._overviewDomElement.removeChild( this._originalOverviewRuler.getDomNode() ), this._originalOverviewRuler.dispose() ), this._modifiedOverviewRuler && ( this._overviewDomElement.removeChild( this._modifiedOverviewRuler.getDomNode() ), this._modifiedOverviewRuler.dispose() ), this._overviewDomElement.removeChild( this._overviewViewportDomElement.domNode ), this._containerDomElement.removeChild( this._overviewDomElement ), this._containerDomElement.removeChild( this._originalDomNode ), this.originalEditor.dispose(), this._containerDomElement.removeChild( this._modifiedDomNode ), this.modifiedEditor.dispose(), this._strategy.dispose(), this._containerDomElement.removeChild( this._reviewPane.domNode.domNode ), this._containerDomElement.removeChild( this._reviewPane.shadow.domNode ), this._containerDomElement.removeChild( this._reviewPane.actionBarContainer.domNode ), this._reviewPane.dispose(), this._domElement.removeChild( this._containerDomElement ), this._onDidDispose.fire(), e.prototype.dispose.call( this )
        }, t.prototype.getId = function () {
          return this.getEditorType() + ":" + this.id
        }, t.prototype.getEditorType = () => {
          return f.a.IDiffEditor
        }, t.prototype.getLineChanges = function () {
          return this._lineChanges
        }, t.prototype.getOriginalEditor = function () {
          return this.originalEditor
        }, t.prototype.getModifiedEditor = function () {
          return this.modifiedEditor
        }, t.prototype.updateOptions = function ( e ) {
          let n = !1;
          "undefined" !== typeof e.renderSideBySide && this._renderSideBySide !== e.renderSideBySide && ( this._renderSideBySide = e.renderSideBySide, n = !0 );
          let i = !1;
          "undefined" !== typeof e.ignoreTrimWhitespace && this._ignoreTrimWhitespace !== e.ignoreTrimWhitespace && ( this._ignoreTrimWhitespace = e.ignoreTrimWhitespace, i = !0 ), "undefined" !== typeof e.renderIndicators && this._renderIndicators !== e.renderIndicators && ( this._renderIndicators = e.renderIndicators, i = !0 ), i && this._beginUpdateDecorations(), "undefined" !== typeof e.originalEditable && ( this._originalIsEditable = Boolean( e.originalEditable ) ), this.modifiedEditor.updateOptions( this._adjustOptionsForRightHandSide( e ) ), this.originalEditor.updateOptions( this._adjustOptionsForLeftHandSide( e, this._originalIsEditable ) ), "undefined" !== typeof e.enableSplitViewResizing && ( this._enableSplitViewResizing = e.enableSplitViewResizing ), this._strategy.setEnableSplitViewResizing( this._enableSplitViewResizing ), n && ( this._renderSideBySide ? this._setStrategy( new ne( this._createDataSource(), this._enableSplitViewResizing ) ) : this._setStrategy( new oe( this._createDataSource(), this._enableSplitViewResizing ) ), this._containerDomElement.className = t._getClassName( this._themeService.getTheme(), this._renderSideBySide ) )
        }, t.prototype.getModel = function () {
          return {
            original: this.originalEditor.getModel(),
            modified: this.modifiedEditor.getModel()
          }
        }, t.prototype.setModel = function ( e ) {
          if ( e && ( !e.original || !e.modified ) ) throw new Error( e.original ? "DiffEditorWidget.setModel: Modified model is null" : "DiffEditorWidget.setModel: Original model is null" );
          this._cleanViewZonesAndDecorations(), this.originalEditor.setModel( e ? e.original : null ), this.modifiedEditor.setModel( e ? e.modified : null ), this._updateDecorationsRunner.cancel(), e && ( this.originalEditor.setScrollTop( 0 ), this.modifiedEditor.setScrollTop( 0 ) ), this._lineChanges = null, this._diffComputationToken++, e ? ( this._recreateOverviewRulers(), this._beginUpdateDecorations() ) : this._lineChanges = null, this._layoutOverviewViewport()
        }, t.prototype.getDomNode = function () {
          return this._domElement
        }, t.prototype.getVisibleColumnFromPosition = function ( e ) {
          return this.modifiedEditor.getVisibleColumnFromPosition( e )
        }, t.prototype.getPosition = function () {
          return this.modifiedEditor.getPosition()
        }, t.prototype.setPosition = function ( e ) {
          this.modifiedEditor.setPosition( e )
        }, t.prototype.revealLine = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.modifiedEditor.revealLine( e, t )
        }, t.prototype.revealLineInCenter = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.modifiedEditor.revealLineInCenter( e, t )
        }, t.prototype.revealLineInCenterIfOutsideViewport = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.modifiedEditor.revealLineInCenterIfOutsideViewport( e, t )
        }, t.prototype.revealPosition = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.modifiedEditor.revealPosition( e, t )
        }, t.prototype.revealPositionInCenter = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.modifiedEditor.revealPositionInCenter( e, t )
        }, t.prototype.revealPositionInCenterIfOutsideViewport = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.modifiedEditor.revealPositionInCenterIfOutsideViewport( e, t )
        }, t.prototype.getSelection = function () {
          return this.modifiedEditor.getSelection()
        }, t.prototype.getSelections = function () {
          return this.modifiedEditor.getSelections()
        }, t.prototype.setSelection = function ( e ) {
          this.modifiedEditor.setSelection( e )
        }, t.prototype.setSelections = function ( e ) {
          this.modifiedEditor.setSelections( e )
        }, t.prototype.revealLines = function ( e, t, n ) {
          void 0 === n && ( n = 0 ), this.modifiedEditor.revealLines( e, t, n )
        }, t.prototype.revealLinesInCenter = function ( e, t, n ) {
          void 0 === n && ( n = 0 ), this.modifiedEditor.revealLinesInCenter( e, t, n )
        }, t.prototype.revealLinesInCenterIfOutsideViewport = function ( e, t, n ) {
          void 0 === n && ( n = 0 ), this.modifiedEditor.revealLinesInCenterIfOutsideViewport( e, t, n )
        }, t.prototype.revealRange = function ( e, t, n, i ) {
          void 0 === t && ( t = 0 ), void 0 === n && ( n = !1 ), void 0 === i && ( i = !0 ), this.modifiedEditor.revealRange( e, t, n, i )
        }, t.prototype.revealRangeInCenter = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.modifiedEditor.revealRangeInCenter( e, t )
        }, t.prototype.revealRangeInCenterIfOutsideViewport = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.modifiedEditor.revealRangeInCenterIfOutsideViewport( e, t )
        }, t.prototype.revealRangeAtTop = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.modifiedEditor.revealRangeAtTop( e, t )
        }, t.prototype.getSupportedActions = function () {
          return this.modifiedEditor.getSupportedActions()
        }, t.prototype.saveViewState = function () {
          return {
            original: this.originalEditor.saveViewState(),
            modified: this.modifiedEditor.saveViewState()
          }
        }, t.prototype.restoreViewState = function ( e ) {
          if ( e.original && e.original ) {
            const t = e;
            this.originalEditor.restoreViewState( t.original ), this.modifiedEditor.restoreViewState( t.modified )
          }
        }, t.prototype.layout = function ( e ) {
          this._measureDomElement( !1, e )
        }, t.prototype.focus = function () {
          this.modifiedEditor.focus()
        }, t.prototype.hasTextFocus = function () {
          return this.originalEditor.hasTextFocus() || this.modifiedEditor.hasTextFocus()
        }, t.prototype.trigger = function ( e, t, n ) {
          this.modifiedEditor.trigger( e, t, n )
        }, t.prototype.changeDecorations = function ( e ) {
          return this.modifiedEditor.changeDecorations( e )
        }, t.prototype._measureDomElement = function ( e, t ) {
          if ( ( t = t || {
              width: this._containerDomElement.clientWidth,
              height: this._containerDomElement.clientHeight
            } ).width <= 0 ) return this._width = 0, this._height = 0, void( this._reviewHeight = 0 );
          ( e || t.width !== this._width || t.height !== this._height ) && ( this._width = t.width, this._height = t.height, this._reviewHeight = this._reviewPane.isVisible() ? this._height : 0, this._doLayout() )
        }, t.prototype._layoutOverviewRulers = function () {
          const e = t.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * t.ONE_OVERVIEW_WIDTH;
          this.modifiedEditor.getLayoutInfo() && ( this._originalOverviewRuler.setLayout( {
            top: 0,
            width: t.ONE_OVERVIEW_WIDTH,
            right: e + t.ONE_OVERVIEW_WIDTH,
            height: this._height - this._reviewHeight
          } ), this._modifiedOverviewRuler.setLayout( {
            top: 0,
            right: 0,
            width: t.ONE_OVERVIEW_WIDTH,
            height: this._height - this._reviewHeight
          } ) )
        }, t.prototype._onViewZonesChanged = function () {
          this._currentlyChangingViewZones || this._updateDecorationsRunner.schedule()
        }, t.prototype._beginUpdateDecorationsSoon = function () {
          const e = this; - 1 !== this._beginUpdateDecorationsTimeout && ( window.clearTimeout( this._beginUpdateDecorationsTimeout ), this._beginUpdateDecorationsTimeout = -1 ), this._beginUpdateDecorationsTimeout = window.setTimeout( ( () => {
            return e._beginUpdateDecorations()
          } ), t.UPDATE_DIFF_DECORATIONS_DELAY )
        }, t._equals = ( e, t ) => {
          return !e && !t || !( !e || !t ) && e.toString() === t.toString()
        }, t.prototype._beginUpdateDecorations = function () {
          const e = this;
          this._beginUpdateDecorationsTimeout = -1;
          const n = this.originalEditor.getModel(),
            o = this.modifiedEditor.getModel();
          if ( n && o ) {
            this._diffComputationToken++;
            const r = this._diffComputationToken;
            this._editorWorkerService.canComputeDiff( n.uri, o.uri ) ? this._editorWorkerService.computeDiff( n.uri, o.uri, this._ignoreTrimWhitespace ).then( ( t => {
              r === e._diffComputationToken && n === e.originalEditor.getModel() && o === e.modifiedEditor.getModel() && ( e._lineChanges = t, e._updateDecorationsRunner.schedule(), e._onDidUpdateDiff.fire() )
            } ), ( t => {
              r === e._diffComputationToken && n === e.originalEditor.getModel() && o === e.modifiedEditor.getModel() && ( e._lineChanges = null, e._updateDecorationsRunner.schedule() )
            } ) ) : t._equals( n.uri, this._lastOriginalWarning ) && t._equals( o.uri, this._lastModifiedWarning ) || ( this._lastOriginalWarning = n.uri, this._lastModifiedWarning = o.uri, this._notificationService.warn( i.a( "diff.tooLarge", "Cannot compare files because one file is too large." ) ) )
          }
        }, t.prototype._cleanViewZonesAndDecorations = function () {
          this._originalEditorState.clean( this.originalEditor ), this._modifiedEditorState.clean( this.modifiedEditor )
        }, t.prototype._updateDecorations = function () {
          if ( this.originalEditor.getModel() && this.modifiedEditor.getModel() ) {
            const e = this._lineChanges || [],
              t = this._originalEditorState.getForeignViewZones( this.originalEditor.getWhitespaces() ),
              n = this._modifiedEditorState.getForeignViewZones( this.modifiedEditor.getWhitespaces() ),
              i = this._strategy.getEditorsDiffDecorations( e, this._ignoreTrimWhitespace, this._renderIndicators, t, n, this.originalEditor, this.modifiedEditor );
            try {
              this._currentlyChangingViewZones = !0, this._originalEditorState.apply( this.originalEditor, this._originalOverviewRuler, i.original, !1 ), this._modifiedEditorState.apply( this.modifiedEditor, this._modifiedOverviewRuler, i.modified, !0 )
            } finally {
              this._currentlyChangingViewZones = !1
            }
          }
        }, t.prototype._adjustOptionsForSubEditor = e => {
          const t = s.c( e || {} );
          return t.inDiffEditor = !0, t.wordWrap = "off", t.wordWrapMinified = !1, t.automaticLayout = !1, t.scrollbar = t.scrollbar || {}, t.scrollbar.vertical = "visible", t.folding = !1, t.codeLens = !1, t.fixedOverflowWidgets = !0, t.lineDecorationsWidth = "2ch", t.minimap || ( t.minimap = {} ), t.minimap.enabled = !1, t
        }, t.prototype._adjustOptionsForLeftHandSide = function ( e, t ) {
          const n = this._adjustOptionsForSubEditor( e );
          return n.readOnly = !t, n.overviewRulerLanes = 1, n.extraEditorClassName = "original-in-monaco-diff-editor", n
        }, t.prototype._adjustOptionsForRightHandSide = function ( e ) {
          const n = this._adjustOptionsForSubEditor( e );
          return n.revealHorizontalRightPadding = S.a.viewInfo.revealHorizontalRightPadding + t.ENTIRE_DIFF_OVERVIEW_WIDTH, n.scrollbar.verticalHasArrows = !1, n.extraEditorClassName = "modified-in-monaco-diff-editor", n
        }, t.prototype.doLayout = function () {
          this._measureDomElement( !0 )
        }, t.prototype._doLayout = function () {
          const e = this._strategy.layout();
          this._originalDomNode.style.width = e + "px", this._originalDomNode.style.left = "0px", this._modifiedDomNode.style.width = this._width - e + "px", this._modifiedDomNode.style.left = e + "px", this._overviewDomElement.style.top = "0px", this._overviewDomElement.style.height = this._height - this._reviewHeight + "px", this._overviewDomElement.style.width = t.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewDomElement.style.left = this._width - t.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewViewportDomElement.setWidth( t.ENTIRE_DIFF_OVERVIEW_WIDTH ), this._overviewViewportDomElement.setHeight( 30 ), this.originalEditor.layout( {
            width: e,
            height: this._height - this._reviewHeight
          } ), this.modifiedEditor.layout( {
            width: this._width - e - t.ENTIRE_DIFF_OVERVIEW_WIDTH,
            height: this._height - this._reviewHeight
          } ), ( this._originalOverviewRuler || this._modifiedOverviewRuler ) && this._layoutOverviewRulers(), this._reviewPane.layout( this._height - this._reviewHeight, this._width, this._reviewHeight ), this._layoutOverviewViewport()
        }, t.prototype._layoutOverviewViewport = function () {
          const e = this._computeOverviewViewport();
          e ? ( this._overviewViewportDomElement.setTop( e.top ), this._overviewViewportDomElement.setHeight( e.height ) ) : ( this._overviewViewportDomElement.setTop( 0 ), this._overviewViewportDomElement.setHeight( 0 ) )
        }, t.prototype._computeOverviewViewport = function () {
          const e = this.modifiedEditor.getLayoutInfo();
          if ( !e ) return null;
          const t = this.modifiedEditor.getScrollTop(),
            n = this.modifiedEditor.getScrollHeight(),
            i = Math.max( 0, e.contentHeight ),
            o = Math.max( 0, i - 0 ),
            r = n > 0 ? o / n : 0;
          return {
            height: Math.max( 0, Math.floor( e.contentHeight * r ) ),
            top: Math.floor( t * r )
          }
        }, t.prototype._createDataSource = function () {
          const e = this;
          return {
            getWidth() {
              return e._width
            },
            getHeight() {
              return e._height - e._reviewHeight
            },
            getContainerDomNode() {
              return e._containerDomElement
            },
            relayoutEditors() {
              e._doLayout()
            },
            getOriginalEditor() {
              return e.originalEditor
            },
            getModifiedEditor() {
              return e.modifiedEditor
            }
          };
        }, t.prototype._setStrategy = function ( e ) {
          this._strategy && this._strategy.dispose(), this._strategy = e, e.applyColors( this._themeService.getTheme() ), this._lineChanges && this._updateDecorations(), this._measureDomElement( !0 )
        }, t.prototype._getLineChangeAtOrBeforeLineNumber = function ( e, t ) {
          if ( 0 === this._lineChanges.length || e < t( this._lineChanges[ 0 ] ) ) return null;
          for ( var n = 0, i = this._lineChanges.length - 1; n < i; ) {
            const o = Math.floor( ( n + i ) / 2 ),
              r = t( this._lineChanges[ o ] ),
              s = o + 1 <= i ? t( this._lineChanges[ o + 1 ] ) : Number.MAX_VALUE;
            e < r ? i = o - 1 : e >= s ? n = o + 1 : ( n = o, i = o )
          }
          return this._lineChanges[ n ]
        }, t.prototype._getEquivalentLineForOriginalLineNumber = function ( e ) {
          const t = this._getLineChangeAtOrBeforeLineNumber( e, ( e => {
            return e.originalStartLineNumber
          } ) );
          if ( !t ) return e;
          const n = t.originalStartLineNumber + ( t.originalEndLineNumber > 0 ? -1 : 0 ),
            i = t.modifiedStartLineNumber + ( t.modifiedEndLineNumber > 0 ? -1 : 0 ),
            o = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0,
            r = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0,
            s = e - n;
          return s <= o ? i + Math.min( s, r ) : i + r - o + s
        }, t.prototype._getEquivalentLineForModifiedLineNumber = function ( e ) {
          const t = this._getLineChangeAtOrBeforeLineNumber( e, ( e => {
            return e.modifiedStartLineNumber
          } ) );
          if ( !t ) return e;
          const n = t.originalStartLineNumber + ( t.originalEndLineNumber > 0 ? -1 : 0 ),
            i = t.modifiedStartLineNumber + ( t.modifiedEndLineNumber > 0 ? -1 : 0 ),
            o = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0,
            r = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0,
            s = e - i;
          return s <= r ? n + Math.min( s, o ) : n + o - r + s
        }, t.prototype.getDiffLineInformationForOriginal = function ( e ) {
          return this._lineChanges ? {
            equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber( e )
          } : null
        }, t.prototype.getDiffLineInformationForModified = function ( e ) {
          return this._lineChanges ? {
            equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber( e )
          } : null
        }, t.ONE_OVERVIEW_WIDTH = 15, t.ENTIRE_DIFF_OVERVIEW_WIDTH = 30, t.UPDATE_DIFF_DECORATIONS_DELAY = 200, t = q( [ G( 2, g.a ), G( 3, d.e ), G( 4, c.a ), G( 5, h.a ), G( 6, O.c ), G( 7, z.a ) ], t );
      } )( r.a );
      const Z = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n._dataSource = t, n
        }
        return K( t, e ), t.prototype.applyColors = function ( e ) {
          const t = ( e.getColor( L.i ) || L.f ).transparent( 2 ),
            n = ( e.getColor( L.k ) || L.g ).transparent( 2 ),
            i = !t.equals( this._insertColor ) || !n.equals( this._removeColor );
          return this._insertColor = t, this._removeColor = n, i
        }, t.prototype.getEditorsDiffDecorations = function ( e, t, n, i, o, r, s ) {
          o = o.sort( ( ( e, t ) => {
            return e.afterLineNumber - t.afterLineNumber
          } ) ), i = i.sort( ( ( e, t ) => {
            return e.afterLineNumber - t.afterLineNumber
          } ) );
          const a = this._getViewZones( e, i, o, r, s, n ),
            u = this._getOriginalEditorDecorations( e, t, n, r, s ),
            l = this._getModifiedEditorDecorations( e, t, n, r, s );
          return {
            original: {
              decorations: u.decorations,
              overviewZones: u.overviewZones,
              zones: a.original
            },
            modified: {
              decorations: l.decorations,
              overviewZones: l.overviewZones,
              zones: a.modified
            }
          }
        }, t;
      } )( r.a );
      const Q = ( () => {
        function e( e ) {
          this._source = e, this._index = -1, this.advance()
        }
        return e.prototype.advance = function () {
          this._index++, this._index < this._source.length ? this.current = this._source[ this._index ] : this.current = null
        }, e
      } )();
      const J = ( () => {
        function e( e, t, n ) {
          this.lineChanges = e, this.originalForeignVZ = t, this.modifiedForeignVZ = n
        }
        return e.prototype.getViewZones = function () {
          for ( var e = {
              original: [],
              modified: []
            }, t = 0, n = 0, i = 0, o = 0, r = 0, s = 0, a = ( e, t ) => {
              return e.afterLineNumber - t.afterLineNumber
            }, u = ( e, t ) => {
              if ( null === t.domNode && e.length > 0 ) {
                const n = e[ e.length - 1 ];
                if ( n.afterLineNumber === t.afterLineNumber && null === n.domNode ) return void( n.heightInLines += t.heightInLines )
              }
              e.push( t )
            }, l = new Q( this.modifiedForeignVZ ), c = new Q( this.originalForeignVZ ), d = 0, h = this.lineChanges.length; d <= h; d++ ) {
            const p = d < h ? this.lineChanges[ d ] : null;
            null !== p ? ( i = p.originalStartLineNumber + ( p.originalEndLineNumber > 0 ? -1 : 0 ), o = p.modifiedStartLineNumber + ( p.modifiedEndLineNumber > 0 ? -1 : 0 ), n = p.originalEndLineNumber > 0 ? p.originalEndLineNumber - p.originalStartLineNumber + 1 : 0, t = p.modifiedEndLineNumber > 0 ? p.modifiedEndLineNumber - p.modifiedStartLineNumber + 1 : 0, r = Math.max( p.originalStartLineNumber, p.originalEndLineNumber ), s = Math.max( p.modifiedStartLineNumber, p.modifiedEndLineNumber ) ) : ( r = i += 1e7 + n, s = o += 1e7 + t );
            for ( var f, g = [], m = []; l.current && l.current.afterLineNumber <= s; ) {
              var _ = void 0;
              _ = l.current.afterLineNumber <= o ? i - o + l.current.afterLineNumber : r, g.push( {
                afterLineNumber: _,
                heightInLines: l.current.heightInLines,
                domNode: null
              } ), l.advance()
            }
            for ( ; c.current && c.current.afterLineNumber <= r; ) {
              _ = void 0;
              _ = c.current.afterLineNumber <= i ? o - i + c.current.afterLineNumber : s, m.push( {
                afterLineNumber: _,
                heightInLines: c.current.heightInLines,
                domNode: null
              } ), c.advance()
            }
            if ( null !== p && se( p ) )( f = this._produceOriginalFromDiff( p, n, t ) ) && g.push( f );
            if ( null !== p && ae( p ) )( f = this._produceModifiedFromDiff( p, n, t ) ) && m.push( f );
            let v = 0,
              y = 0;
            for ( g = g.sort( a ), m = m.sort( a ); v < g.length && y < m.length; ) {
              const b = g[ v ],
                C = m[ y ],
                w = b.afterLineNumber - i,
                S = C.afterLineNumber - o;
              w < S ? ( u( e.original, b ), v++ ) : S < w ? ( u( e.modified, C ), y++ ) : b.shouldNotShrink ? ( u( e.original, b ), v++ ) : C.shouldNotShrink ? ( u( e.modified, C ), y++ ) : b.heightInLines >= C.heightInLines ? ( b.heightInLines -= C.heightInLines, y++ ) : ( C.heightInLines -= b.heightInLines, v++ )
            }
            for ( ; v < g.length; ) u( e.original, g[ v ] ), v++;
            for ( ; y < m.length; ) u( e.modified, m[ y ] ), y++
          }
          const O = e => {
            e.domNode || ( e.domNode = ( () => {
              const e = document.createElement( "div" );
              return e.className = "diagonal-fill", e
            } )() )
          };
          return e.original.forEach( O ), e.modified.forEach( O ), e
        }, e;
      } )();

      function ee( e, t, n, i, o ) {
        return {
          range: new p.a( e, t, n, i ),
          options: o
        }
      }
      const te = {
        charDelete: N.a.register( {
          className: "char-delete"
        } ),
        charDeleteWholeLine: N.a.register( {
          className: "char-delete",
          isWholeLine: !0
        } ),
        charInsert: N.a.register( {
          className: "char-insert"
        } ),
        charInsertWholeLine: N.a.register( {
          className: "char-insert",
          isWholeLine: !0
        } ),
        lineInsert: N.a.register( {
          className: "line-insert",
          marginClassName: "line-insert",
          isWholeLine: !0
        } ),
        lineInsertWithSign: N.a.register( {
          className: "line-insert",
          linesDecorationsClassName: "insert-sign",
          marginClassName: "line-insert",
          isWholeLine: !0
        } ),
        lineDelete: N.a.register( {
          className: "line-delete",
          marginClassName: "line-delete",
          isWholeLine: !0
        } ),
        lineDeleteWithSign: N.a.register( {
          className: "line-delete",
          linesDecorationsClassName: "delete-sign",
          marginClassName: "line-delete",
          isWholeLine: !0
        } ),
        lineDeleteMargin: N.a.register( {
          marginClassName: "line-delete"
        } )
      };

      var ne = ( e => {
        function t( t, n ) {
          const i = e.call( this, t ) || this;
          return i._disableSash = !1 === n, i._sashRatio = null, i._sashPosition = null, i._sash = i._register( new l.b( i._dataSource.getContainerDomNode(), i ) ), i._disableSash && ( i._sash.state = l.c.Disabled ), i._sash.onDidStart( ( () => {
            return i.onSashDragStart()
          } ) ), i._sash.onDidChange( ( e => {
            return i.onSashDrag( e )
          } ) ), i._sash.onDidEnd( ( () => {
            return i.onSashDragEnd()
          } ) ), i._sash.onDidReset( ( () => {
            return i.onSashReset()
          } ) ), i;
        }
        return K( t, e ), t.prototype.setEnableSplitViewResizing = function ( e ) {
          const t = !1 === e;
          this._disableSash !== t && ( this._disableSash = t, this._sash.state = this._disableSash ? l.c.Disabled : l.c.Enabled )
        }, t.prototype.layout = function ( e ) {
          void 0 === e && ( e = this._sashRatio );
          const n = this._dataSource.getWidth() - $.ENTIRE_DIFF_OVERVIEW_WIDTH;
          let i = Math.floor( ( e || .5 ) * n );
          const o = Math.floor( .5 * n );
          return i = this._disableSash ? o : i || o, n > 2 * t.MINIMUM_EDITOR_WIDTH ? ( i < t.MINIMUM_EDITOR_WIDTH && ( i = t.MINIMUM_EDITOR_WIDTH ), i > n - t.MINIMUM_EDITOR_WIDTH && ( i = n - t.MINIMUM_EDITOR_WIDTH ) ) : i = o, this._sashPosition !== i && ( this._sashPosition = i, this._sash.layout() ), this._sashPosition
        }, t.prototype.onSashDragStart = function () {
          this._startSashPosition = this._sashPosition
        }, t.prototype.onSashDrag = function ( e ) {
          const t = this._dataSource.getWidth() - $.ENTIRE_DIFF_OVERVIEW_WIDTH,
            n = this.layout( ( this._startSashPosition + ( e.currentX - e.startX ) ) / t );
          this._sashRatio = n / t, this._dataSource.relayoutEditors()
        }, t.prototype.onSashDragEnd = function () {
          this._sash.layout()
        }, t.prototype.onSashReset = function () {
          this._sashRatio = .5, this._dataSource.relayoutEditors(), this._sash.layout()
        }, t.prototype.getVerticalSashTop = e => {
          return 0
        }, t.prototype.getVerticalSashLeft = function ( e ) {
          return this._sashPosition
        }, t.prototype.getVerticalSashHeight = function ( e ) {
          return this._dataSource.getHeight()
        }, t.prototype._getViewZones = ( e, t, n, i, o ) => {
          return new ie( e, t, n ).getViewZones()
        }, t.prototype._getOriginalEditorDecorations = function ( e, t, n, i, o ) {
          for ( var r = this._removeColor.toString(), s = {
              decorations: [],
              overviewZones: []
            }, a = i.getModel(), u = 0, l = e.length; u < l; u++ ) {
            const c = e[ u ];
            if ( ae( c ) && ( s.decorations.push( {
                range: new p.a( c.originalStartLineNumber, 1, c.originalEndLineNumber, Number.MAX_VALUE ),
                options: n ? te.lineDeleteWithSign : te.lineDelete
              } ), se( c ) && c.charChanges || s.decorations.push( ee( c.originalStartLineNumber, 1, c.originalEndLineNumber, Number.MAX_VALUE, te.charDeleteWholeLine ) ), s.overviewZones.push( new x.a( c.originalStartLineNumber, c.originalEndLineNumber, r ) ), c.charChanges ) )
              for ( let d = 0, h = c.charChanges.length; d < h; d++ ) {
                const f = c.charChanges[ d ];
                if ( ae( f ) )
                  if ( t )
                    for ( let g = f.originalStartLineNumber; g <= f.originalEndLineNumber; g++ ) {
                      let m = void 0,
                        _ = void 0;
                      m = g === f.originalStartLineNumber ? f.originalStartColumn : a.getLineFirstNonWhitespaceColumn( g ), _ = g === f.originalEndLineNumber ? f.originalEndColumn : a.getLineLastNonWhitespaceColumn( g ), s.decorations.push( ee( g, m, g, _, te.charDelete ) )
                    } else s.decorations.push( ee( f.originalStartLineNumber, f.originalStartColumn, f.originalEndLineNumber, f.originalEndColumn, te.charDelete ) )
              }
          }
          return s
        }, t.prototype._getModifiedEditorDecorations = function ( e, t, n, i, o ) {
          for ( var r = this._insertColor.toString(), s = {
              decorations: [],
              overviewZones: []
            }, a = o.getModel(), u = 0, l = e.length; u < l; u++ ) {
            const c = e[ u ];
            if ( se( c ) && ( s.decorations.push( {
                range: new p.a( c.modifiedStartLineNumber, 1, c.modifiedEndLineNumber, Number.MAX_VALUE ),
                options: n ? te.lineInsertWithSign : te.lineInsert
              } ), ae( c ) && c.charChanges || s.decorations.push( ee( c.modifiedStartLineNumber, 1, c.modifiedEndLineNumber, Number.MAX_VALUE, te.charInsertWholeLine ) ), s.overviewZones.push( new x.a( c.modifiedStartLineNumber, c.modifiedEndLineNumber, r ) ), c.charChanges ) )
              for ( let d = 0, h = c.charChanges.length; d < h; d++ ) {
                const f = c.charChanges[ d ];
                if ( se( f ) )
                  if ( t )
                    for ( let g = f.modifiedStartLineNumber; g <= f.modifiedEndLineNumber; g++ ) {
                      let m = void 0,
                        _ = void 0;
                      m = g === f.modifiedStartLineNumber ? f.modifiedStartColumn : a.getLineFirstNonWhitespaceColumn( g ), _ = g === f.modifiedEndLineNumber ? f.modifiedEndColumn : a.getLineLastNonWhitespaceColumn( g ), s.decorations.push( ee( g, m, g, _, te.charInsert ) )
                    } else s.decorations.push( ee( f.modifiedStartLineNumber, f.modifiedStartColumn, f.modifiedEndLineNumber, f.modifiedEndColumn, te.charInsert ) )
              }
          }
          return s
        }, t.MINIMUM_EDITOR_WIDTH = 100, t;
      } )( Z );

      const ie = ( e => {
        function t( t, n, i ) {
          return e.call( this, t, n, i ) || this
        }
        return K( t, e ), t.prototype._produceOriginalFromDiff = ( e, t, n ) => {
          return n > t ? {
            afterLineNumber: Math.max( e.originalStartLineNumber, e.originalEndLineNumber ),
            heightInLines: n - t,
            domNode: null
          } : null
        }, t.prototype._produceModifiedFromDiff = ( e, t, n ) => {
          return t > n ? {
            afterLineNumber: Math.max( e.modifiedStartLineNumber, e.modifiedEndLineNumber ),
            heightInLines: t - n,
            domNode: null
          } : null
        }, t;
      } )( J );
      var oe = ( e => {
        function t( t, n ) {
          const i = e.call( this, t ) || this;
          return i.decorationsLeft = t.getOriginalEditor().getLayoutInfo().decorationsLeft, i._register( t.getOriginalEditor().onDidLayoutChange( ( e => {
            i.decorationsLeft !== e.decorationsLeft && ( i.decorationsLeft = e.decorationsLeft, t.relayoutEditors() )
          } ) ) ), i;
        }
        return K( t, e ), t.prototype.setEnableSplitViewResizing = e => {}, t.prototype._getViewZones = ( e, t, n, i, o, r ) => {
          return new re( e, t, n, i, o, r ).getViewZones()
        }, t.prototype._getOriginalEditorDecorations = function ( e, t, n, i, o ) {
          for ( var r = this._removeColor.toString(), s = {
              decorations: [],
              overviewZones: []
            }, a = 0, u = e.length; a < u; a++ ) {
            const l = e[ a ];
            ae( l ) && ( s.decorations.push( {
              range: new p.a( l.originalStartLineNumber, 1, l.originalEndLineNumber, Number.MAX_VALUE ),
              options: te.lineDeleteMargin
            } ), s.overviewZones.push( new x.a( l.originalStartLineNumber, l.originalEndLineNumber, r ) ) )
          }
          return s
        }, t.prototype._getModifiedEditorDecorations = function ( e, t, n, i, o ) {
          for ( var r = this._insertColor.toString(), s = {
              decorations: [],
              overviewZones: []
            }, a = o.getModel(), u = 0, l = e.length; u < l; u++ ) {
            const c = e[ u ];
            if ( se( c ) )
              if ( s.decorations.push( {
                  range: new p.a( c.modifiedStartLineNumber, 1, c.modifiedEndLineNumber, Number.MAX_VALUE ),
                  options: n ? te.lineInsertWithSign : te.lineInsert
                } ), s.overviewZones.push( new x.a( c.modifiedStartLineNumber, c.modifiedEndLineNumber, r ) ), c.charChanges )
                for ( let d = 0, h = c.charChanges.length; d < h; d++ ) {
                  const f = c.charChanges[ d ];
                  if ( se( f ) )
                    if ( t )
                      for ( let g = f.modifiedStartLineNumber; g <= f.modifiedEndLineNumber; g++ ) {
                        let m = void 0,
                          _ = void 0;
                        m = g === f.modifiedStartLineNumber ? f.modifiedStartColumn : a.getLineFirstNonWhitespaceColumn( g ), _ = g === f.modifiedEndLineNumber ? f.modifiedEndColumn : a.getLineLastNonWhitespaceColumn( g ), s.decorations.push( ee( g, m, g, _, te.charInsert ) )
                      } else s.decorations.push( ee( f.modifiedStartLineNumber, f.modifiedStartColumn, f.modifiedEndLineNumber, f.modifiedEndColumn, te.charInsert ) )
                } else s.decorations.push( ee( c.modifiedStartLineNumber, 1, c.modifiedEndLineNumber, Number.MAX_VALUE, te.charInsertWholeLine ) )
          }
          return s
        }, t.prototype.layout = function () {
          return Math.max( 5, this.decorationsLeft )
        }, t;
      } )( Z );
      const re = ( e => {
        function t( t, n, i, o, r, s ) {
          const a = e.call( this, t, n, i ) || this;
          return a.originalModel = o.getModel(), a.modifiedEditorConfiguration = r.getConfiguration(), a.modifiedEditorTabSize = r.getModel().getOptions().tabSize, a.renderIndicators = s, a
        }
        return K( t, e ), t.prototype._produceOriginalFromDiff = function ( e, t, n ) {
          const i = document.createElement( "div" );
          return i.className = "inline-added-margin-view-zone", y.a.applyFontInfoSlow( i, this.modifiedEditorConfiguration.fontInfo ), {
            afterLineNumber: Math.max( e.originalStartLineNumber, e.originalEndLineNumber ),
            heightInLines: n,
            domNode: document.createElement( "div" ),
            marginDomNode: i
          }
        }, t.prototype._produceModifiedFromDiff = function ( e, t, n ) {
          const i = [];
          if ( e.charChanges )
            for ( let o = 0, r = e.charChanges.length; o < r; o++ ) {
              const s = e.charChanges[ o ];
              ae( s ) && i.push( new b.a( new p.a( s.originalStartLineNumber, s.originalStartColumn, s.originalEndLineNumber, s.originalEndColumn ), "char-delete", 0 ) )
            }
          for ( var a = Object( H.a )( 1e4 ), u = [], l = this.modifiedEditorConfiguration.layoutInfo.decorationsWidth, c = this.modifiedEditorConfiguration.lineHeight, d = this.modifiedEditorConfiguration.fontInfo.typicalHalfwidthCharacterWidth, h = 0, f = e.originalStartLineNumber; f <= e.originalEndLineNumber; f++ )
            if ( h = Math.max( h, this._renderOriginalLine( f - e.originalStartLineNumber, this.originalModel, this.modifiedEditorConfiguration, this.modifiedEditorTabSize, f, i, a ) ), this.renderIndicators ) {
              const g = f - e.originalStartLineNumber;
              u = u.concat( [ '<div class="delete-sign" style="position:absolute;top:' + g * c + "px;width:" + l + "px;height:" + c + 'px;right:0;"></div>' ] )
            } h += this.modifiedEditorConfiguration.viewInfo.scrollBeyondLastColumn;
          const m = document.createElement( "div" );
          m.className = "view-lines line-delete", m.innerHTML = a.build(), y.a.applyFontInfoSlow( m, this.modifiedEditorConfiguration.fontInfo );
          const _ = document.createElement( "div" );
          return _.className = "inline-deleted-margin-view-zone", _.innerHTML = u.join( "" ), y.a.applyFontInfoSlow( _, this.modifiedEditorConfiguration.fontInfo ), {
            shouldNotShrink: !0,
            afterLineNumber: 0 === e.modifiedEndLineNumber ? e.modifiedStartLineNumber : e.modifiedStartLineNumber - 1,
            heightInLines: t,
            minWidthInPx: h * d,
            domNode: m,
            marginDomNode: _
          }
        }, t.prototype._renderOriginalLine = ( e, t, n, i, o, r, s ) => {
          const a = t.getLineTokens( o ),
            u = a.getLineContent(),
            l = m.a.filter( r, o, 1, u.length + 1 );
          s.appendASCIIString( '<div class="view-line' ), 0 === r.length && s.appendASCIIString( " char-delete" ), s.appendASCIIString( '" style="top:' ), s.appendASCIIString( String( e * n.lineHeight ) ), s.appendASCIIString( 'px;width:1000000px;">' );
          const c = b.d.isBasicASCII( u, t.mightContainNonBasicASCII() ),
            d = b.d.containsRTL( u, c, t.mightContainRTL() ),
            h = Object( _.c )( new _.b( n.fontInfo.isMonospace && !n.viewInfo.disableMonospaceOptimizations, u, !1, c, d, 0, a, l, i, n.fontInfo.spaceWidth, n.viewInfo.stopRenderingLineAfter, n.viewInfo.renderWhitespace, n.viewInfo.renderControlCharacters, n.viewInfo.fontLigatures ), s );
          s.appendASCIIString( "</div>" );
          const p = h.characterMapping.getAbsoluteOffsets();
          return p.length > 0 ? p[ p.length - 1 ] : 0
        }, t;
      } )( J );

      function se( e ) {
        return e.modifiedEndLineNumber > 0
      }

      function ae( e ) {
        return e.originalEndLineNumber > 0
      }
      Object( O.e )( ( ( e, t ) => {
        const n = e.getColor( L.i );
        n && ( t.addRule( ".monaco-editor .line-insert, .monaco-editor .char-insert { background-color: " + n + "; }" ), t.addRule( ".monaco-diff-editor .line-insert, .monaco-diff-editor .char-insert { background-color: " + n + "; }" ), t.addRule( ".monaco-editor .inline-added-margin-view-zone { background-color: " + n + "; }" ) );
        const i = e.getColor( L.k );
        i && ( t.addRule( ".monaco-editor .line-delete, .monaco-editor .char-delete { background-color: " + i + "; }" ), t.addRule( ".monaco-diff-editor .line-delete, .monaco-diff-editor .char-delete { background-color: " + i + "; }" ), t.addRule( ".monaco-editor .inline-deleted-margin-view-zone { background-color: " + i + "; }" ) );
        const o = e.getColor( L.j );
        o && t.addRule( ".monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px " + ( "hc" === e.type ? "dashed" : "solid" ) + " " + o + "; }" );
        const r = e.getColor( L.l );
        r && t.addRule( ".monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px " + ( "hc" === e.type ? "dashed" : "solid" ) + " " + r + "; }" );
        const s = e.getColor( L.lb );
        s && t.addRule( ".monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px " + s + "; }" );
        const a = e.getColor( L.h );
        a && t.addRule( ".monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid " + a + "; }" )
      } ) )
    },
    SvYn( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "dockerfile",
        extensions: [ ".dockerfile" ],
        filenames: [ "Dockerfile" ],
        aliases: [ "Dockerfile" ],
        loader() {
          return o.Promise.wrap( n.e( 264 ).then( n.bind( null, "Dsrv" ) ) )
        }
      } )
    },
    T8No( e, t, n ) {
      "use strict";
      n.d( t, "d", ( () => {
        return a
      } ) ), n.d( t, "b", ( () => {
        return l
      } ) ), n.d( t, "c", ( () => {
        return c
      } ) ), n.d( t, "a", ( () => {
        return f
      } ) ), n.d( t, "f", ( () => {
        return g
      } ) ), n.d( t, "e", ( () => {
        return m
      } ) ), n.d( t, "g", ( () => {
        return _
      } ) );
      let i;
      const o = n( "Cg/j" );
      const r = n( "N0LK" );
      const s = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      !( e => {
        e[ e.Defined = 1 ] = "Defined", e[ e.Not = 2 ] = "Not", e[ e.Equals = 3 ] = "Equals", e[ e.NotEquals = 4 ] = "NotEquals", e[ e.And = 5 ] = "And", e[ e.Regex = 6 ] = "Regex"
      } )( i || ( i = {} ) );
      var a = ( () => {
        function e() {}
        return e.has = e => {
          return new l( e )
        }, e.equals = ( e, t ) => {
          return new c( e, t )
        }, e.regex = ( e, t ) => {
          return new p( e, t )
        }, e.not = e => {
          return new h( e )
        }, e.and = function () {
          for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
          return new f( e )
        }, e.deserialize = function ( e ) {
          const t = this;
          if ( !e ) return null;
          const n = e.split( "&&" );
          return new f( n.map( ( e => {
            return t._deserializeOne( e )
          } ) ) ).normalize();
        }, e._deserializeOne = function ( e ) {
          if ( ( e = e.trim() ).indexOf( "!=" ) >= 0 ) {
            var t = e.split( "!=" );
            return new d( t[ 0 ].trim(), this._deserializeValue( t[ 1 ] ) )
          }
          if ( e.indexOf( "==" ) >= 0 ) {
            t = e.split( "==" );
            return new c( t[ 0 ].trim(), this._deserializeValue( t[ 1 ] ) )
          }
          if ( e.indexOf( "=~" ) >= 0 ) {
            t = e.split( "=~" );
            return new p( t[ 0 ].trim(), this._deserializeRegexValue( t[ 1 ] ) )
          }
          return /^\!\s*/.test( e ) ? new h( e.substr( 1 ).trim() ) : new l( e )
        }, e._deserializeValue = e => {
          if ( "true" === ( e = e.trim() ) ) return !0;
          if ( "false" === e ) return !1;
          const t = /^'([^']*)'$/.exec( e );
          return t ? t[ 1 ].trim() : e
        }, e._deserializeRegexValue = e => {
          if ( Object( r.isFalsyOrWhitespace )( e ) ) return console.warn( "missing regexp-value for =~-expression" ), null;
          const t = e.indexOf( "/" ),
            n = e.lastIndexOf( "/" );
          if ( t === n || t < 0 ) return console.warn( "bad regexp-value '" + e + "', missing /-enclosure" ), null;
          const i = e.slice( t + 1, n ),
            o = "i" === e[ n + 1 ] ? "i" : "";
          try {
            return new RegExp( i, o )
          } catch ( s ) {
            return console.warn( "bad regexp-value '" + e + "', parse error: " + s ), null
          }
        }, e;
      } )();

      function u( e, t ) {
        const n = e.getType(),
          o = t.getType();
        if ( n !== o ) return n - o;
        switch ( n ) {
          case i.Defined:
          case i.Not:
          case i.Equals:
          case i.NotEquals:
          case i.Regex:
            return e.cmp( t );
          default:
            throw new Error( "Unknown ContextKeyExpr!" )
        }
      }
      var l = ( () => {
          function e( e ) {
            this.key = e
          }
          return e.prototype.getType = () => {
            return i.Defined
          }, e.prototype.cmp = function ( e ) {
            return this.key < e.key ? -1 : this.key > e.key ? 1 : 0
          }, e.prototype.equals = function ( t ) {
            return t instanceof e && this.key === t.key
          }, e.prototype.evaluate = function ( e ) {
            return !!e.getValue( this.key )
          }, e.prototype.normalize = function () {
            return this
          }, e.prototype.keys = function () {
            return [ this.key ]
          }, e;
        } )(),
        c = ( () => {
          function e( e, t ) {
            this.key = e, this.value = t
          }
          return e.prototype.getType = () => {
            return i.Equals
          }, e.prototype.cmp = function ( e ) {
            return this.key < e.key ? -1 : this.key > e.key ? 1 : this.value < e.value ? -1 : this.value > e.value ? 1 : 0
          }, e.prototype.equals = function ( t ) {
            return t instanceof e && ( this.key === t.key && this.value === t.value )
          }, e.prototype.evaluate = function ( e ) {
            return e.getValue( this.key ) == this.value
          }, e.prototype.normalize = function () {
            return "boolean" === typeof this.value ? this.value ? new l( this.key ) : new h( this.key ) : this
          }, e.prototype.keys = function () {
            return [ this.key ]
          }, e;
        } )(),
        d = ( () => {
          function e( e, t ) {
            this.key = e, this.value = t
          }
          return e.prototype.getType = () => {
            return i.NotEquals
          }, e.prototype.cmp = function ( e ) {
            return this.key < e.key ? -1 : this.key > e.key ? 1 : this.value < e.value ? -1 : this.value > e.value ? 1 : 0
          }, e.prototype.equals = function ( t ) {
            return t instanceof e && ( this.key === t.key && this.value === t.value )
          }, e.prototype.evaluate = function ( e ) {
            return e.getValue( this.key ) != this.value
          }, e.prototype.normalize = function () {
            return "boolean" === typeof this.value ? this.value ? new h( this.key ) : new l( this.key ) : this
          }, e.prototype.keys = function () {
            return [ this.key ]
          }, e;
        } )(),
        h = ( () => {
          function e( e ) {
            this.key = e
          }
          return e.prototype.getType = () => {
            return i.Not
          }, e.prototype.cmp = function ( e ) {
            return this.key < e.key ? -1 : this.key > e.key ? 1 : 0
          }, e.prototype.equals = function ( t ) {
            return t instanceof e && this.key === t.key
          }, e.prototype.evaluate = function ( e ) {
            return !e.getValue( this.key )
          }, e.prototype.normalize = function () {
            return this
          }, e.prototype.keys = function () {
            return [ this.key ]
          }, e;
        } )(),
        p = ( () => {
          function e( e, t ) {
            this.key = e, this.regexp = t
          }
          return e.prototype.getType = () => {
            return i.Regex
          }, e.prototype.cmp = function ( e ) {
            if ( this.key < e.key ) return -1;
            if ( this.key > e.key ) return 1;
            const t = this.regexp ? this.regexp.source : void 0;
            return t < e.regexp.source ? -1 : t > e.regexp.source ? 1 : 0
          }, e.prototype.equals = function ( t ) {
            if ( t instanceof e ) {
              const n = this.regexp ? this.regexp.source : void 0;
              return this.key === t.key && n === t.regexp.source
            }
            return !1
          }, e.prototype.evaluate = function ( e ) {
            return !!this.regexp && this.regexp.test( e.getValue( this.key ) )
          }, e.prototype.normalize = function () {
            return this
          }, e.prototype.keys = function () {
            return [ this.key ]
          }, e;
        } )(),
        f = ( () => {
          function e( t ) {
            this.expr = e._normalizeArr( t )
          }
          return e.prototype.getType = () => {
            return i.And
          }, e.prototype.equals = function ( t ) {
            if ( t instanceof e ) {
              if ( this.expr.length !== t.expr.length ) return !1;
              for ( let n = 0, i = this.expr.length; n < i; n++ )
                if ( !this.expr[ n ].equals( t.expr[ n ] ) ) return !1;
              return !0
            }
            return !1
          }, e.prototype.evaluate = function ( e ) {
            for ( let t = 0, n = this.expr.length; t < n; t++ )
              if ( !this.expr[ t ].evaluate( e ) ) return !1;
            return !0
          }, e._normalizeArr = t => {
            let n = [];
            if ( t ) {
              for ( let i = 0, o = t.length; i < o; i++ ) {
                let r = t[ i ];
                r && ( ( r = r.normalize() ) && ( r instanceof e ? n = n.concat( r.expr ) : n.push( r ) ) )
              }
              n.sort( u )
            }
            return n
          }, e.prototype.normalize = function () {
            return 0 === this.expr.length ? null : 1 === this.expr.length ? this.expr[ 0 ] : this
          }, e.prototype.keys = function () {
            for ( var e = [], t = 0, n = this.expr; t < n.length; t++ ) {
              const i = n[ t ];
              e.push.apply( e, i.keys() )
            }
            return e
          }, e;
        } )(),
        g = ( e => {
          function t( t, n ) {
            const i = e.call( this, t ) || this;
            return i._defaultValue = n, i
          }
          return s( t, e ), t.prototype.bindTo = function ( e ) {
            return e.createKey( this.key, this._defaultValue )
          }, t.prototype.toNegated = function () {
            return a.not( this.key )
          }, t
        } )( l ),
        m = Object( o.c )( "contextKeyService" ),
        _ = "setContext"
    },
    TC2m( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "defaultReferenceSearchOptions", ( () => {
        return E
      } ) ), n.d( t, "ReferenceController", ( () => {
        return k
      } ) ), n.d( t, "ReferenceAction", ( () => {
        return I
      } ) ), n.d( t, "provideReferences", ( () => {
        return T
      } ) );
      const i = n( "3/fG" );
      const o = n( "VMIq" );
      const r = n( "T8No" );
      const s = n( "nrhi" );
      const a = n( "cGHE" );
      const u = n( "sswD" );
      const l = n( "twdY" );
      const c = n( "aokT" );
      const d = n( "5aqo" );
      const h = n( "qkNm" );
      const p = n( "OlfL" );
      const f = n( "X+cX" );
      const g = n( "/cxE" );
      const m = n( "wQH0" );
      const _ = n( "03kh" );
      const v = n( "sFUC" );
      const y = n( "k9mg" );
      const b = n( "cSGN" );
      const C = n( "nnTU" );
      const w = n( "bY76" );
      const S = n( "Vxe3" );
      const O = n( "JQT/" );
      const L = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const x = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const N = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      var E = {
        getMetaTitle( e ) {
          return e.references.length > 1 && i.a( "meta.titleReference", " \u2013 {0} references", e.references.length )
        }
      };
      var k = ( () => {
        function e( e, t ) {
          e instanceof _.a && d.a.inPeekEditor.bindTo( t )
        }
        return e.prototype.dispose = () => {}, e.prototype.getId = () => {
          return e.ID
        }, e.ID = "editor.contrib.referenceController", e = x( [ N( 1, r.e ) ], e );
      } )();
      var I = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.referenceSearch.trigger",
            label: i.a( "references.action.label", "Find All References" ),
            alias: "Find All References",
            precondition: r.d.and( m.a.hasReferenceProvider, d.a.notInPeekEditor, m.a.isInEmbeddedEditor.toNegated() ),
            kbOpts: {
              kbExpr: m.a.editorTextFocus,
              primary: 1094,
              weight: 100
            },
            menuOpts: {
              group: "navigation",
              order: 1.5
            }
          } ) || this
        }
        return L( t, e ), t.prototype.run = ( e, t ) => {
          const n = h.a.get( t );
          if ( n ) {
            const i = t.getSelection(),
              o = t.getModel(),
              r = Object( f.i )( ( e => {
                return T( o, i.getStartPosition(), e ).then( ( e => {
                  return new p.c( e )
                } ) );
              } ) );
            n.toggleWidget( i, r, E )
          }
        }, t;
      } )( u.b );
      Object( u.h )( k ), Object( u.f )( I );

      function D( e, t ) {
        M( e, ( e => {
          return e.closeWidget()
        } ) )
      }

      function M( e, t ) {
        const n = Object( d.c )( e );
        if ( n ) {
          const i = h.a.get( n );
          i && t( i )
        }
      }

      function T( e, t, n ) {
        const i = l.r.ordered( e ).map( ( n => {
          return Object( f.h )( ( i => {
            return n.provideReferences( e, t, {
              includeDeclaration: !0
            }, i )
          } ) ).then( ( e => {
            if ( Array.isArray( e ) ) return e
          } ), ( e => {
            Object( g.f )( e )
          } ) );
        } ) );
        return Promise.all( i ).then( ( e => {
          for ( var t = [], n = 0, i = e; n < i.length; n++ ) {
            const o = i[ n ];
            o && t.push.apply( t, o )
          }
          return t
        } ) );
      }
      C.a.registerCommand( {
        id: "editor.action.findReferences",
        handler( e, t, n ) {
          if ( !( t instanceof w.a ) ) throw new Error( "illegal argument, uri" );
          if ( !n ) throw new Error( "illegal argument, position" );
          const i = e.get( S.a );
          return i.openCodeEditor( {
            resource: t
          }, i.getFocusedCodeEditor() ).then( ( e => {
            if ( Object( v.d )( e ) ) {
              const t = h.a.get( e );
              if ( t ) {
                const i = Object( f.i )( ( t => {
                    return T( e.getModel(), a.a.lift( n ), t ).then( ( e => {
                      return new p.c( e )
                    } ) );
                  } ) ),
                  r = new c.a( n.lineNumber, n.column, n.lineNumber, n.column );
                return o.b.as( t.toggleWidget( r, i, E ) )
              }
            }
          } ) );
        }
      } ), C.a.registerCommand( {
        id: "editor.action.showReferences",
        handler( e, t, n, i ) {
          if ( !( t instanceof w.a ) ) throw new Error( "illegal argument, uri expected" );
          const r = e.get( S.a );
          return r.openCodeEditor( {
            resource: t
          }, r.getFocusedCodeEditor() ).then( ( e => {
            if ( Object( v.d )( e ) ) {
              const t = h.a.get( e );
              if ( t ) return o.b.as( t.toggleWidget( new c.a( n.lineNumber, n.column, n.lineNumber, n.column ), Object( f.i )( ( e => {
                return Promise.resolve( new p.c( i ) )
              } ) ), E ) ).then( ( () => {
                return !0
              } ) );
            }
          } ) );
        },
        description: {
          description: "Show references at a position in a file",
          args: [ {
            name: "uri",
            description: "The text document in which to show references",
            constraint: w.a
          }, {
            name: "position",
            description: "The position at which to show",
            constraint: a.a.isIPosition
          }, {
            name: "locations",
            description: "An array of locations.",
            constraint: Array
          } ]
        }
      } ), s.a.registerCommandAndKeybindingRule( {
        id: "goToNextReference",
        weight: 250,
        primary: 62,
        when: h.b,
        handler( e ) {
          M( e, ( e => {
            e.goToNextOrPreviousReference( !0 )
          } ) )
        }
      } ), s.a.registerCommandAndKeybindingRule( {
        id: "goToNextReferenceFromEmbeddedEditor",
        weight: 150,
        primary: 62,
        when: d.a.inPeekEditor,
        handler( e ) {
          M( e, ( e => {
            e.goToNextOrPreviousReference( !0 )
          } ) )
        }
      } ), s.a.registerCommandAndKeybindingRule( {
        id: "goToPreviousReference",
        weight: 250,
        primary: 1086,
        when: h.b,
        handler( e ) {
          M( e, ( e => {
            e.goToNextOrPreviousReference( !1 )
          } ) )
        }
      } ), s.a.registerCommandAndKeybindingRule( {
        id: "goToPreviousReferenceFromEmbeddedEditor",
        weight: 150,
        primary: 1086,
        when: d.a.inPeekEditor,
        handler( e ) {
          M( e, ( e => {
            e.goToNextOrPreviousReference( !1 )
          } ) )
        }
      } ), s.a.registerCommandAndKeybindingRule( {
        id: "closeReferenceSearch",
        weight: 250,
        primary: 9,
        secondary: [ 1033 ],
        when: r.d.and( h.b, r.d.not( "config.editor.stablePeek" ) ),
        handler: D
      } ), s.a.registerCommandAndKeybindingRule( {
        id: "closeReferenceSearchEditor",
        weight: -1,
        primary: 9,
        secondary: [ 1033 ],
        when: r.d.and( d.a.inPeekEditor, r.d.not( "config.editor.stablePeek" ) ),
        handler: D
      } ), s.a.registerCommandAndKeybindingRule( {
        id: "openReferenceToSide",
        weight: 100,
        primary: 2051,
        mac: {
          primary: 259
        },
        when: r.d.and( h.b, b.b ),
        handler( e, t ) {
          const n = e.get( y.a ),
            i = n.lastFocusedList && n.lastFocusedList.getFocus();
          i instanceof p.b && M( e, ( e => {
            return e.openReference( i, !0 )
          } ) )
        }
      } ), Object( u.e )( "_executeReferenceProvider", ( ( e, t ) => {
        return T( e, t, O.a.None )
      } ) )
    },
    TQUy( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) );
      const i = n( "N0LK" ),
        o = n( "twdY" ),
        r = n( "i/Ef" ),
        s = n( "4bUh" );

      function a( e, t ) {
        return ( ( e, t ) => {
          for ( var n = '<div class="monaco-tokenized-source">', o = e.split( /\r\n|\r|\n/ ), r = t.getInitialState(), a = 0, u = o.length; a < u; a++ ) {
            const l = o[ a ];
            a > 0 && ( n += "<br/>" );
            const c = t.tokenize2( l, r, 0 );
            s.a.convertToEndOffset( c.tokens, l.length );
            for ( let d = new s.a( c.tokens, l ).inflate(), h = 0, p = 0, f = d.getCount(); p < f; p++ ) {
              const g = d.getClassName( p ),
                m = d.getEndOffset( p );
              n += '<span class="' + g + '">' + i.escape( l.substring( h, m ) ) + "</span>", h = m
            }
            r = c.endState
          }
          return n += "</div>"
        } )(
          e,
          ( e => {
            const t = o.y.get( e );
            if ( t ) return t;
            return {
              getInitialState() {
                return r.c
              },
              tokenize: void 0,
              tokenize2( e, t, n ) {
                return Object( r.e )( 0, e, t, n )
              }
            };
          } )( t )
        );
      }

      function u( e, t, n, i, o, r ) {
        for ( var s = "<div>", a = i, u = 0, l = 0, c = t.getCount(); l < c; l++ ) {
          const d = t.getEndOffset( l );
          if ( !( d <= i ) ) {
            for ( var h = ""; a < d && a < o; a++ ) {
              const p = e.charCodeAt( a );
              switch ( p ) {
                case 9:
                  let f = r - ( a + u ) % r;
                  for ( u += f - 1; f > 0; ) h += "&nbsp;", f--;
                  break;
                case 60:
                  h += "&lt;";
                  break;
                case 62:
                  h += "&gt;";
                  break;
                case 38:
                  h += "&amp;";
                  break;
                case 0:
                  h += "&#00;";
                  break;
                case 65279:
                case 8232:
                  h += "\ufffd";
                  break;
                case 13:
                  h += "&#8203";
                  break;
                default:
                  h += String.fromCharCode( p )
              }
            }
            if ( s += '<span style="' + t.getInlineStyle( l, n ) + '">' + h + "</span>", d > o || a >= o ) break
          }
        }
        return s += "</div>"
      }
    },
    TT2d( e, t, n ) {},
    Tcc1( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "b", ( () => {
        return o
      } ) ), n.d( t, "c", ( () => {
        return r
      } ) );
      var i = ( () => {
          function e( e, t, n ) {
            this.offset = 0 | e, this.type = t, this.language = n
          }
          return e.prototype.toString = function () {
            return "(" + this.offset + ", " + this.type + ")"
          }, e
        } )(),
        o = function ( e, t ) {
          this.tokens = e, this.endState = t
        },
        r = function ( e, t ) {
          this.tokens = e, this.endState = t
        }
    },
    Tn3x( e, t, n ) {},
    UCkY( e, t, n ) {},
    UH51( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return c
      } ) ), n.d( t, "b", ( () => {
        return d
      } ) ), n.d( t, "c", ( () => {
        return h
      } ) );
      const i = n( "6OMU" ),
        o = n( "X+cX" ),
        r = n( "/cxE" ),
        s = n( "VMIq" ),
        a = n( "sswD" ),
        u = n( "twdY" );

      function l( e, t, n, a ) {
        const u = n.ordered( e ).map( ( n => {
          return Object( o.h )( ( i => {
            return a( n, e, t, i )
          } ) ).then( void 0, ( e => {
            return Object( r.f )( e ), null
          } ) );
        } ) );
        return s.b.join( u ).then( i.i ).then( ( e => {
          return Object( i.c )( e )
        } ) );
      }

      function c( e, t ) {
        return l( e, t, u.e, ( ( e, t, n, i ) => {
          return e.provideDefinition( t, n, i )
        } ) );
      }

      function d( e, t ) {
        return l( e, t, u.n, ( ( e, t, n, i ) => {
          return e.provideImplementation( t, n, i )
        } ) );
      }

      function h( e, t ) {
        return l( e, t, u.z, ( ( e, t, n, i ) => {
          return e.provideTypeDefinition( t, n, i )
        } ) );
      }
      Object( a.e )( "_executeDefinitionProvider", c ), Object( a.e )( "_executeImplementationProvider", d ), Object( a.e )( "_executeTypeDefinitionProvider", h )
    },
    UHym( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "d", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) ), n.d( t, "c", ( () => {
        return s
      } ) );
      var i = ( () => {
        function e( e, t, n ) {
          for ( var i = new Uint8Array( e * t ), o = 0, r = e * t; o < r; o++ ) i[ o ] = n;
          this._data = i, this.rows = e, this.cols = t
        }
        return e.prototype.get = function ( e, t ) {
          return this._data[ e * this.cols + t ]
        }, e.prototype.set = function ( e, t, n ) {
          this._data[ e * this.cols + t ] = n
        }, e
      } )();

      function o( e ) {
        return e < 0 ? 0 : e > 255 ? 255 : 0 | e
      }

      function r( e ) {
        return e < 0 ? 0 : e > 4294967295 ? 4294967295 : 0 | e
      }

      function s( e ) {
        for ( var t = e.length, n = new Uint32Array( t ), i = 0; i < t; i++ ) n[ i ] = r( e[ i ] );
        return n
      }
    },
    UsjR( e, t, n ) {},
    Uzvx( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return o
      } ) ), n.d( t, "a", ( () => {
        return r
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "contextViewService" );
      var r = Object( i.c )( "contextMenuService" );
    },
    VMIq( e, t, n ) {
      "use strict";
      ( ( ( e, i ) => {
        let o;
        n.d( t, "a", ( () => {
          return r
        } ) ), n.d( t, "b", ( () => {
          return s
        } ) ), ( () => {
          const t = Object.create( null );
          t[ "WinJS/Core/_WinJS" ] = {};
          const n = ( e, n, i ) => {
            const o = {};
            let r = !1;
            const s = n.map( ( e => {
              return "exports" === e ? ( r = !0, o ) : t[ e ]
            } ) );
            const a = i.apply( {}, s );
            t[ e ] = r ? o : a
          };
          n( "WinJS/Core/_Global", [], ( () => {
            return "undefined" !== typeof window ? window : "undefined" !== typeof self ? self : "undefined" !== typeof e ? e : {}
          } ) ), n( "WinJS/Core/_BaseCoreUtils", [ "WinJS/Core/_Global" ], ( e => {
            const t = !!e.Windows;
            let n = null;
            return {
              hasWinRT: t,
              markSupportedForProcessing( e ) {
                return e.supportedForProcessing = !0, e
              },
              _setImmediate( t ) {
                null === n && ( n = e.setImmediate ? e.setImmediate.bind( e ) : "undefined" !== typeof i && "function" === typeof i.nextTick ? i.nextTick.bind( i ) : e.setTimeout.bind( e ) ), n( t )
              }
            };
          } ) ), n( "WinJS/Core/_WriteProfilerMark", [ "WinJS/Core/_Global" ], ( e => {
            return e.msWriteProfilerMark || ( () => {} );
          } ) ), n( "WinJS/Core/_Base", [ "WinJS/Core/_WinJS", "WinJS/Core/_Global", "WinJS/Core/_BaseCoreUtils", "WinJS/Core/_WriteProfilerMark" ], ( ( e, t, n, i ) => {
            function o( e, t, n ) {
              let i;
              let o;
              let r;
              const s = Object.keys( t );
              const a = Array.isArray( e );
              for ( o = 0, r = s.length; o < r; o++ ) {
                const u = s[ o ],
                  l = 95 !== u.charCodeAt( 0 ),
                  c = t[ u ];
                !c || "object" !== typeof c || void 0 === c.value && "function" !== typeof c.get && "function" !== typeof c.set ? l ? a ? e.forEach( ( e => {
                  e[ u ] = c
                } ) ) : e[ u ] = c : ( i = i || {} )[ u ] = {
                  value: c,
                  enumerable: l,
                  configurable: !0,
                  writable: !0
                } : ( void 0 === c.enumerable && ( c.enumerable = l ), n && c.setName && "function" === typeof c.setName && c.setName( n + "." + u ), ( i = i || {} )[ u ] = c )
              }
              i && ( a ? e.forEach( ( e => {
                Object.defineProperties( e, i )
              } ) ) : Object.defineProperties( e, i ) )
            }
            return ( () => {
              const n = e;

              function r( n, i ) {
                let o = n || {};
                if ( i ) {
                  const r = i.split( "." );
                  o === t && "WinJS" === r[ 0 ] && ( o = e, r.splice( 0, 1 ) );
                  for ( let s = 0, a = r.length; s < a; s++ ) {
                    const u = r[ s ];
                    o[ u ] || Object.defineProperty( o, u, {
                      value: {},
                      writable: !1,
                      enumerable: !0,
                      configurable: !0
                    } ), o = o[ u ]
                  }
                }
                return o
              }

              function s( e, t, n ) {
                const i = r( e, t );
                return n && o( i, n, t || "<ANONYMOUS>" ), i
              }
              n.Namespace || ( n.Namespace = Object.create( Object.prototype ) );
              const a = {
                uninitialized: 1,
                working: 2,
                initialized: 3
              };
              Object.defineProperties( n.Namespace, {
                defineWithParent: {
                  value: s,
                  writable: !0,
                  enumerable: !0,
                  configurable: !0
                },
                define: {
                  value( e, n ) {
                    return s( t, e, n )
                  },
                  writable: !0,
                  enumerable: !0,
                  configurable: !0
                },
                _lazy: {
                  value( e ) {
                    let t, n, o = a.uninitialized;
                    return {
                      setName( e ) {
                        t = e
                      },
                      get() {
                        switch ( o ) {
                          case a.initialized:
                            return n;
                          case a.uninitialized:
                            o = a.working;
                            try {
                              i( "WinJS.Namespace._lazy:" + t + ",StartTM" ), n = e()
                            } finally {
                              i( "WinJS.Namespace._lazy:" + t + ",StopTM" ), o = a.uninitialized
                            }
                            return e = null, o = a.initialized, n;
                          case a.working:
                            throw "Illegal: reentrancy on initialization";
                          default:
                            throw "Illegal"
                        }
                      },
                      set( e ) {
                        switch ( o ) {
                          case a.working:
                            throw "Illegal: reentrancy on initialization";
                          default:
                            o = a.initialized, n = e
                        }
                      },
                      enumerable: !0,
                      configurable: !0
                    };
                  },
                  writable: !0,
                  enumerable: !0,
                  configurable: !0
                },
                _moduleDefine: {
                  value( e, n, i ) {
                    const s = [ e ];
                    let a = null;
                    return n && ( a = r( t, n ), s.push( a ) ), o( s, i, n || "<ANONYMOUS>" ), a
                  },
                  writable: !0,
                  enumerable: !0,
                  configurable: !0
                }
              } )
            } )(), ( () => {
              function t( e, t, i ) {
                return e = e || ( () => {} ), n.markSupportedForProcessing( e ), t && o( e.prototype, t ), i && o( e, i ), e;
              }
              e.Namespace.define( "WinJS.Class", {
                define: t,
                derive( e, i, r, s ) {
                  if ( e ) {
                    i = i || ( () => {} );
                    const a = e.prototype;
                    return i.prototype = Object.create( a ), n.markSupportedForProcessing( i ), Object.defineProperty( i.prototype, "constructor", {
                      value: i,
                      writable: !0,
                      configurable: !0,
                      enumerable: !0
                    } ), r && o( i.prototype, r ), s && o( i, s ), i
                  }
                  return t( i, r, s )
                },
                mix( e ) {
                  let t, n;
                  for ( e = e || ( () => {} ), t = 1, n = arguments.length; t < n; t++ ) o( e.prototype, arguments[ t ] );
                  return e
                }
              } )
            } )(), {
              Namespace: e.Namespace,
              Class: e.Class
            };
          } ) ), n( "WinJS/Core/_ErrorFromName", [ "WinJS/Core/_Base" ], ( e => {
            const t = e.Class.derive( Error, ( function ( e, t ) {
              this.name = e, this.message = t || e
            } ), {}, {
              supportedForProcessing: !1
            } );
            return e.Namespace.define( "WinJS", {
              ErrorFromName: t
            } ), t
          } ) ), n( "WinJS/Core/_Events", [ "exports", "WinJS/Core/_Base" ], ( ( e, t ) => {
            function n( e ) {
              const t = "_on" + e + "state";
              return {
                get() {
                  const e = this[ t ];
                  return e && e.userHandler
                },
                set( n ) {
                  let i = this[ t ];
                  n ? ( i || ( i = {
                    wrapper( e ) {
                      return i.userHandler( e )
                    },
                    userHandler: n
                  }, Object.defineProperty( this, t, {
                    value: i,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                  } ), this.addEventListener( e, i.wrapper, !1 ) ), i.userHandler = n ) : i && ( this.removeEventListener( e, i.wrapper, !1 ), this[ t ] = null )
                },
                enumerable: !0
              };
            }
            const i = t.Class.define( ( function ( e, t, n ) {
                this.detail = t, this.target = n, this.timeStamp = Date.now(), this.type = e
              } ), {
                bubbles: {
                  value: !1,
                  writable: !1
                },
                cancelable: {
                  value: !1,
                  writable: !1
                },
                currentTarget: {
                  get() {
                    return this.target
                  }
                },
                defaultPrevented: {
                  get() {
                    return this._preventDefaultCalled
                  }
                },
                trusted: {
                  value: !1,
                  writable: !1
                },
                eventPhase: {
                  value: 0,
                  writable: !1
                },
                target: null,
                timeStamp: null,
                type: null,
                preventDefault() {
                  this._preventDefaultCalled = !0
                },
                stopImmediatePropagation() {
                  this._stopImmediatePropagationCalled = !0
                },
                stopPropagation() {}
              }, {
                supportedForProcessing: !1
              } ),
              o = {
                _listeners: null,
                addEventListener( e, t, n ) {
                  n = n || !1, this._listeners = this._listeners || {};
                  for ( var i = this._listeners[ e ] = this._listeners[ e ] || [], o = 0, r = i.length; o < r; o++ ) {
                    const s = i[ o ];
                    if ( s.useCapture === n && s.listener === t ) return
                  }
                  i.push( {
                    listener: t,
                    useCapture: n
                  } )
                },
                dispatchEvent( e, t ) {
                  let n = this._listeners && this._listeners[ e ];
                  if ( n ) {
                    for ( var o = new i( e, t, this ), r = 0, s = ( n = n.slice( 0, n.length ) ).length; r < s && !o._stopImmediatePropagationCalled; r++ ) n[ r ].listener( o );
                    return o.defaultPrevented || !1
                  }
                  return !1
                },
                removeEventListener( e, t, n ) {
                  n = n || !1;
                  const i = this._listeners && this._listeners[ e ];
                  if ( i )
                    for ( let o = 0, r = i.length; o < r; o++ ) {
                      const s = i[ o ];
                      if ( s.listener === t && s.useCapture === n ) {
                        i.splice( o, 1 ), 0 === i.length && delete this._listeners[ e ];
                        break
                      }
                    }
                }
              };
            t.Namespace._moduleDefine( e, "WinJS.Utilities", {
              _createEventProperty: n,
              createEventProperties() {
                for ( var e = {}, t = 0, i = arguments.length; t < i; t++ ) {
                  const o = arguments[ t ];
                  e[ "on" + o ] = n( o )
                }
                return e
              },
              eventMixin: o
            } )
          } ) ), n( "WinJS/Core/_Trace", [ "WinJS/Core/_Global" ], ( e => {
            function t( e ) {
              return e
            }
            return {
              _traceAsyncOperationStarting: e.Debug && e.Debug.msTraceAsyncOperationStarting && e.Debug.msTraceAsyncOperationStarting.bind( e.Debug ) || t,
              _traceAsyncOperationCompleted: e.Debug && e.Debug.msTraceAsyncOperationCompleted && e.Debug.msTraceAsyncOperationCompleted.bind( e.Debug ) || t,
              _traceAsyncCallbackStarting: e.Debug && e.Debug.msTraceAsyncCallbackStarting && e.Debug.msTraceAsyncCallbackStarting.bind( e.Debug ) || t,
              _traceAsyncCallbackCompleted: e.Debug && e.Debug.msTraceAsyncCallbackCompleted && e.Debug.msTraceAsyncCallbackCompleted.bind( e.Debug ) || t
            }
          } ) ), n( "WinJS/Promise/_StateMachine", [ "WinJS/Core/_Global", "WinJS/Core/_BaseCoreUtils", "WinJS/Core/_Base", "WinJS/Core/_ErrorFromName", "WinJS/Core/_Events", "WinJS/Core/_Trace" ], ( ( e, t, n, i, o, r ) => {
            e.Debug && ( e.Debug.setNonUserCodeExceptions = !0 );
            const s = new( n.Class.mix( n.Class.define( null, {}, {
              supportedForProcessing: !1
            } ), o.eventMixin ) );
            s._listeners = {};
            const a = "error";
            const u = "Canceled";
            let l = !1;
            const c = {
              promise: 1,
              thenPromise: 2,
              errorPromise: 4,
              exceptionPromise: 8,
              completePromise: 16
            };
            c.all = c.promise | c.thenPromise | c.errorPromise | c.exceptionPromise | c.completePromise;
            let d, h, p, f, g, m, _, v, y, b, C = 1;

            function w() {}
            d = {
              name: "created",
              enter( e ) {
                e._setState( h )
              },
              cancel: w,
              done: w,
              then: w,
              _completed: w,
              _error: w,
              _notify: w,
              _progress: w,
              _setCompleteValue: w,
              _setErrorValue: w
            }, h = {
              name: "working",
              enter: w,
              cancel( e ) {
                e._setState( g )
              },
              done: I,
              then: V,
              _completed: O,
              _error: D,
              _notify: w,
              _progress: P,
              _setCompleteValue: j,
              _setErrorValue: W
            }, p = {
              name: "waiting",
              enter( e ) {
                const t = e._value;
                if ( t instanceof H && t._state !== b && t._state !== v ) A( t, {
                  promise: e
                } );
                else {
                  const n = i => {
                    t._errorId ? e._chainedError( i, t ) : ( R( e, i, x, t, n ), e._error( i ) )
                  };
                  n.handlesOnError = !0, t.then( e._completed.bind( e ), n, e._progress.bind( e ) )
                }
              },
              cancel( e ) {
                e._setState( f )
              },
              done: I,
              then: V,
              _completed: O,
              _error: D,
              _notify: w,
              _progress: P,
              _setCompleteValue: j,
              _setErrorValue: W
            }, f = {
              name: "waiting_canceled",
              enter( e ) {
                e._setState( m );
                const t = e._value;
                t.cancel && t.cancel()
              },
              cancel: w,
              done: I,
              then: V,
              _completed: O,
              _error: D,
              _notify: w,
              _progress: P,
              _setCompleteValue: j,
              _setErrorValue: W
            }, g = {
              name: "canceled",
              enter( e ) {
                e._setState( m ), e._cancelAction()
              },
              cancel: w,
              done: I,
              then: V,
              _completed: O,
              _error: D,
              _notify: w,
              _progress: P,
              _setCompleteValue: j,
              _setErrorValue: W
            }, m = {
              name: "canceling",
              enter( e ) {
                const t = new Error( u );
                t.name = t.message, e._value = t, e._setState( y )
              },
              cancel: w,
              done: w,
              then: w,
              _completed: w,
              _error: w,
              _notify: w,
              _progress: w,
              _setCompleteValue: w,
              _setErrorValue: w
            }, _ = {
              name: "complete_notify",
              enter( e ) {
                if ( e.done = K.prototype.done, e.then = K.prototype.then, e._listeners )
                  for ( let t, n = [ e ]; n.length; )( t = n.shift() )._state._notify( t, n );
                e._setState( v )
              },
              cancel: w,
              done: null,
              then: null,
              _completed: w,
              _error: w,
              _notify: M,
              _progress: w,
              _setCompleteValue: w,
              _setErrorValue: w
            }, v = {
              name: "success",
              enter( e ) {
                e.done = K.prototype.done, e.then = K.prototype.then, e._cleanupAction()
              },
              cancel: w,
              done: null,
              then: null,
              _completed: w,
              _error: w,
              _notify: M,
              _progress: w,
              _setCompleteValue: w,
              _setErrorValue: w
            }, y = {
              name: "error_notify",
              enter( e ) {
                if ( e.done = z.prototype.done, e.then = z.prototype.then, e._listeners )
                  for ( let t, n = [ e ]; n.length; )( t = n.shift() )._state._notify( t, n );
                e._setState( b )
              },
              cancel: w,
              done: null,
              then: null,
              _completed: w,
              _error: w,
              _notify: T,
              _progress: w,
              _setCompleteValue: w,
              _setErrorValue: w
            }, b = {
              name: "error",
              enter( e ) {
                e.done = z.prototype.done, e.then = z.prototype.then, e._cleanupAction()
              },
              cancel: w,
              done: null,
              then: null,
              _completed: w,
              _error: w,
              _notify: T,
              _progress: w,
              _setCompleteValue: w,
              _setErrorValue: w
            };
            const S = n.Class.define( null, {
              _listeners: null,
              _nextState: null,
              _state: null,
              _value: null,
              cancel() {
                this._state.cancel( this ), this._run()
              },
              done( e, t, n ) {
                this._state.done( this, e, t, n )
              },
              then: function e( t, n, i ) {
                if ( this.then === e ) return this._state.then( this, t, n, i );
                this.then( t, n, i )
              },
              _chainedError( e, t ) {
                const n = this._state._error( this, e, N, t );
                return this._run(), n
              },
              _completed( e ) {
                const t = this._state._completed( this, e );
                return this._run(), t
              },
              _error( e ) {
                const t = this._state._error( this, e, E );
                return this._run(), t
              },
              _progress( e ) {
                this._state._progress( this, e )
              },
              _setState( e ) {
                this._nextState = e
              },
              _setCompleteValue( e ) {
                this._state._setCompleteValue( this, e ), this._run()
              },
              _setChainedErrorValue( e, t ) {
                const n = this._state._setErrorValue( this, e, N, t );
                return this._run(), n
              },
              _setExceptionValue( e ) {
                const t = this._state._setErrorValue( this, e, k );
                return this._run(), t
              },
              _run() {
                for ( ; this._nextState; ) this._state = this._nextState, this._nextState = null, this._state.enter( this )
              }
            }, {
              supportedForProcessing: !1
            } );

            function O( e, t ) {
              let n;
              n = t && "object" === typeof t && "function" === typeof t.then ? p : _, e._value = t, e._setState( n )
            }

            function L( e, t, n, i, o, r ) {
              return {
                exception: e,
                error: t,
                promise: n,
                handler: r,
                id: i,
                parent: o
              }
            }

            function x( e, t, n, i ) {
              const o = n._isException;
              return L( o ? t : null, o ? null : t, e, n._errorId, n, i )
            }

            function N( e, t, n ) {
              const i = n._isException,
                o = n._errorId;
              return F( e, o, i ), L( i ? t : null, i ? null : t, e, o, n )
            }

            function E( e, t ) {
              const n = ++C;
              return F( e, n ), L( null, t, e, n )
            }

            function k( e, t ) {
              const n = ++C;
              return F( e, n, !0 ), L( t, null, e, n )
            }

            function I( e, t, n, i ) {
              A( e, {
                c: t,
                e: n,
                p: i,
                asyncOpID: r._traceAsyncOperationStarting( "WinJS.Promise.done" )
              } )
            }

            function D( e, t, n, i ) {
              e._value = t, R( e, t, n, i ), e._setState( y )
            }

            function M( t, n ) {
              let i;
              let o;
              const s = t._value;
              const a = t._listeners;
              if ( a )
                for ( t._listeners = null, i = 0, o = Array.isArray( a ) ? a.length : 1; i < o; i++ ) {
                  const u = 1 === o ? a : a[ i ],
                    l = u.c,
                    c = u.promise;
                  if ( r._traceAsyncOperationCompleted( u.asyncOpID, e.Debug && e.Debug.MS_ASYNC_OP_STATUS_SUCCESS ), c ) {
                    r._traceAsyncCallbackStarting( u.asyncOpID );
                    try {
                      c._setCompleteValue( l ? l( s ) : s )
                    } catch ( d ) {
                      c._setExceptionValue( d )
                    } finally {
                      r._traceAsyncCallbackCompleted()
                    }
                    c._state !== p && c._listeners && n.push( c )
                  } else K.prototype.done.call( t, l )
                }
            }

            function T( t, n ) {
              let i;
              let o;
              const s = t._value;
              const a = t._listeners;
              if ( a )
                for ( t._listeners = null, i = 0, o = Array.isArray( a ) ? a.length : 1; i < o; i++ ) {
                  const l = 1 === o ? a : a[ i ],
                    c = l.e,
                    d = l.promise,
                    h = e.Debug && ( s && s.name === u ? e.Debug.MS_ASYNC_OP_STATUS_CANCELED : e.Debug.MS_ASYNC_OP_STATUS_ERROR );
                  if ( r._traceAsyncOperationCompleted( l.asyncOpID, h ), d ) {
                    let f = !1;
                    try {
                      c ? ( r._traceAsyncCallbackStarting( l.asyncOpID ), f = !0, c.handlesOnError || R( d, s, x, t, c ), d._setCompleteValue( c( s ) ) ) : d._setChainedErrorValue( s, t )
                    } catch ( g ) {
                      d._setExceptionValue( g )
                    } finally {
                      f && r._traceAsyncCallbackCompleted()
                    }
                    d._state !== p && d._listeners && n.push( d )
                  } else z.prototype.done.call( t, null, c )
                }
            }

            function R( e, t, n, i, o ) {
              if ( s._listeners[ a ] ) {
                if ( t instanceof Error && t.message === u ) return;
                s.dispatchEvent( a, n( e, t, i, o ) )
              }
            }

            function P( e, t ) {
              let n;
              let i;
              const o = e._listeners;
              if ( o )
                for ( n = 0, i = Array.isArray( o ) ? o.length : 1; n < i; n++ ) {
                  const r = 1 === i ? o : o[ n ],
                    s = r.p;
                  if ( s ) try {
                    s( t )
                  } catch ( a ) {}
                  r.c || r.e || !r.promise || r.promise._progress( t )
                }
            }

            function A( e, t ) {
              let n = e._listeners;
              n ? ( n = Array.isArray( n ) ? n : [ n ] ).push( t ) : n = t, e._listeners = n
            }

            function F( e, t, n ) {
              e._isException = n || !1, e._errorId = t
            }

            function W( e, t, n, i ) {
              e._value = t, R( e, t, n, i ), e._setState( b )
            }

            function j( e, t ) {
              let n;
              n = t && "object" === typeof t && "function" === typeof t.then ? p : v, e._value = t, e._setState( n )
            }

            function V( e, t, n, i ) {
              const o = new H( e );
              return A( e, {
                promise: o,
                c: t,
                e: n,
                p: i,
                asyncOpID: r._traceAsyncOperationStarting( "WinJS.Promise.then" )
              } ), o
            }
            let B;
            var H = n.Class.derive( S, ( function ( e ) {
              l && ( !0 === l || l & c.thenPromise ) && ( this._stack = q._getStack() ), this._creator = e, this._setState( d ), this._run()
            } ), {
              _creator: null,
              _cancelAction() {
                this._creator && this._creator.cancel()
              },
              _cleanupAction() {
                this._creator = null
              }
            }, {
              supportedForProcessing: !1
            } );

            var z = n.Class.define( ( function ( e ) {
              l && ( !0 === l || l & c.errorPromise ) && ( this._stack = q._getStack() ), this._value = e, R( this, e, E )
            } ), {
              cancel() {},
              done( e, t ) {
                let n = this._value;
                if ( t ) try {
                  t.handlesOnError || R( null, n, x, this, t );
                  const i = t( n );
                  return void( i && "object" === typeof i && "function" === typeof i.done && i.done() )
                } catch ( o ) {
                  n = o
                }
                n instanceof Error && n.message === u || q._doneHandler( n )
              },
              then( e, t ) {
                if ( !t ) return this;
                let n;
                const i = this._value;
                try {
                  t.handlesOnError || R( null, i, x, this, t ), n = new K( t( i ) )
                } catch ( o ) {
                  n = o === i ? this : new U( o )
                }
                return n
              }
            }, {
              supportedForProcessing: !1
            } );

            const U = n.Class.derive( z, ( function ( e ) {
              l && ( !0 === l || l & c.exceptionPromise ) && ( this._stack = q._getStack() ), this._value = e, R( this, e, k )
            } ), {}, {
              supportedForProcessing: !1
            } );
            var K = n.Class.define( ( function ( e ) {
              if ( l && ( !0 === l || l & c.completePromise ) && ( this._stack = q._getStack() ), e && "object" === typeof e && "function" === typeof e.then ) {
                const t = new H( null );
                return t._setCompleteValue( e ), t
              }
              this._value = e
            } ), {
              cancel() {},
              done( e ) {
                if ( e ) try {
                  const t = e( this._value );
                  t && "object" === typeof t && "function" === typeof t.done && t.done()
                } catch ( n ) {
                  q._doneHandler( n )
                }
              },
              then( e ) {
                try {
                  const t = e ? e( this._value ) : this._value;
                  return t === this._value ? this : new K( t )
                } catch ( n ) {
                  return new U( n )
                }
              }
            }, {
              supportedForProcessing: !1
            } );
            var q = n.Class.derive( S, ( function ( e, t ) {
              l && ( !0 === l || l & c.promise ) && ( this._stack = q._getStack() ), this._oncancel = t, this._setState( d ), this._run();
              try {
                e( this._completed.bind( this ), this._error.bind( this ), this._progress.bind( this ) )
              } catch ( n ) {
                this._setExceptionValue( n )
              }
            } ), {
              _oncancel: null,
              _cancelAction() {
                try {
                  if ( !this._oncancel ) throw new Error( "Promise did not implement oncancel" );
                  this._oncancel()
                } catch ( e ) {
                  e.message, e.stack;
                  s.dispatchEvent( "error", e )
                }
              },
              _cleanupAction() {
                this._oncancel = null
              }
            }, {
              addEventListener( e, t, n ) {
                s.addEventListener( e, t, n )
              },
              any( e ) {
                return new q( ( ( t, n ) => {
                  const i = Object.keys( e );
                  0 === i.length && t();
                  let o = 0;
                  i.forEach( ( r => {
                    q.as( e[ r ] ).then( ( () => {
                      t( {
                        key: r,
                        value: e[ r ]
                      } )
                    } ), ( s => {
                      s instanceof Error && s.name === u ? ++o === i.length && t( q.cancel ) : n( {
                        key: r,
                        value: e[ r ]
                      } )
                    } ) )
                  } ) )
                } ), ( () => {
                  Object.keys( e ).forEach( ( t => {
                    const n = q.as( e[ t ] );
                    "function" === typeof n.cancel && n.cancel()
                  } ) )
                } ) );
              },
              as( e ) {
                return e && "object" === typeof e && "function" === typeof e.then ? e : new K( e )
              },
              cancel: {
                get() {
                  return B = B || new z( new i( u ) )
                }
              },
              dispatchEvent( e, t ) {
                return s.dispatchEvent( e, t )
              },
              is( e ) {
                return e && "object" === typeof e && "function" === typeof e.then
              },
              join( e ) {
                return new q( ( ( t, n, i ) => {
                  const o = Object.keys( e );
                  const r = Array.isArray( e ) ? [] : {};
                  const s = Array.isArray( e ) ? [] : {};
                  let a = 0;
                  let l = o.length;
                  const c = e => {
                    if ( 0 === --l ) {
                      const a = Object.keys( r ).length;
                      if ( 0 === a ) t( s );
                      else {
                        let c = 0;
                        o.forEach( ( e => {
                          const t = r[ e ];
                          t instanceof Error && t.name === u && c++
                        } ) ), c === a ? t( q.cancel ) : n( r )
                      }
                    } else i( {
                      Key: e,
                      Done: !0
                    } )
                  };
                  o.forEach( ( t => {
                    const n = e[ t ];
                    void 0 === n ? a++ : q.then( n, ( e => {
                      s[ t ] = e, c( t )
                    } ), ( e => {
                      r[ t ] = e, c( t )
                    } ) )
                  } ) ), 0 !== ( l -= a ) || t( s )
                } ), ( () => {
                  Object.keys( e ).forEach( ( t => {
                    const n = q.as( e[ t ] );
                    "function" === typeof n.cancel && n.cancel()
                  } ) )
                } ) );
              },
              removeEventListener( e, t, n ) {
                s.removeEventListener( e, t, n )
              },
              supportedForProcessing: !1,
              then( e, t, n, i ) {
                return q.as( e ).then( t, n, i )
              },
              thenEach( e, t, n, i ) {
                const o = Array.isArray( e ) ? [] : {};
                return Object.keys( e ).forEach( ( r => {
                  o[ r ] = q.as( e[ r ] ).then( t, n, i )
                } ) ), q.join( o );
              },
              timeout( n, i ) {
                const o = ( n => {
                  let i;
                  return new q( ( o => {
                    n ? i = e.setTimeout( o, n ) : t._setImmediate( o )
                  } ), ( () => {
                    i && e.clearTimeout( i )
                  } ) );
                } )( n );
                return i ? ( ( e, t ) => {
                  const n = () => {
                    e.cancel()
                  };
                  return e.then( ( () => {
                    t.cancel()
                  } ) ), t.then( n, n ), t;
                } )( o, i ) : o;
              },
              wrap( e ) {
                return new K( e )
              },
              wrapError( e ) {
                return new z( e )
              },
              _veryExpensiveTagWithStack: {
                get() {
                  return l
                },
                set( e ) {
                  l = e
                }
              },
              _veryExpensiveTagWithStack_tag: c,
              _getStack() {
                if ( e.Debug && e.Debug.debuggerEnabled ) try {
                  throw new Error
                } catch ( t ) {
                  return t.stack
                }
              },
              _cancelBlocker( e, t ) {
                if ( !q.is( e ) ) return q.wrap( e );
                let n;
                let i;
                const o = new q( ( ( e, t ) => {
                  n = e, i = t
                } ), ( () => {
                  n = null, i = null, t && t()
                } ) );
                return e.then( ( e => {
                  n && n( e )
                } ), ( e => {
                  i && i( e )
                } ) ), o;
              }
            } );
            return Object.defineProperties( q, o.createEventProperties( a ) ), q._doneHandler = e => {
              t._setImmediate( ( () => {
                throw e
              } ) )
            }, {
              PromiseStateMachine: S,
              Promise: q,
              state_created: d
            };
          } ) ), n( "WinJS/Promise", [ "WinJS/Core/_Base", "WinJS/Promise/_StateMachine" ], ( ( e, t ) => {
            return e.Namespace.define( "WinJS", {
              Promise: t.Promise
            } ), t.Promise
          } ) ), ( o = t[ "WinJS/Core/_WinJS" ] ).TPromise = o.Promise, o.PPromise = o.Promise
        } )();
        var r = o.Promise,
          s = o.TPromise;
        o.PPromise
      } ) ).call( this, n( "yLpj" ), n( "8oxB" ) )
    },
    VPJY( e, t, n ) {},
    Vtyv( e, t, n ) {},
    VvMK( e, t, n ) {},
    Vxe3( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "codeEditorService" );
    },
    W9cx( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return r
      } ) ), n.d( t, "b", ( () => {
        return s
      } ) );
      const i = n( "VMIq" );
      const o = n( "Cg/j" );
      var r = Object( o.c )( "openerService" );
      var s = Object.freeze( {
        _serviceBrand: void 0,
        open() {
          return i.b.as( void 0 )
        }
      } );
    },
    WBhO( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "modeService" );
    },
    WQDh( e, t, n ) {
      "use strict";
      n.r( t );
      n( "QvA3" );
      const i = n( "3/fG" ),
        o = n( "fpMC" ),
        r = n( "N0LK" ),
        s = n( "Rpxm" ),
        a = n( "ksmt" ),
        u = n( "wQH0" ),
        l = n( "twdY" ),
        c = n( "rzPn" ),
        d = n( "/cxE" ),
        h = n( "bY76" ),
        p = n( "VMIq" ),
        f = n( "aokT" ),
        g = n( "sswD" ),
        m = n( "G2kB" ),
        _ = n( "X+cX" );

      function v( e ) {
        const t = [],
          n = l.j.all( e ).map( ( n => {
            return Object( _.h )( ( t => {
              return n.provideDocumentSymbols( e, t )
            } ) ).then( ( e => {
              Array.isArray( e ) && t.push.apply( t, e )
            } ), ( e => {
              Object( d.f )( e )
            } ) );
          } ) );
        return p.b.join( n ).then( ( () => {
          const e = [];
          return function e( t, n, i ) {
            for ( let o = 0, r = n; o < r.length; o++ ) {
              const s = r[ o ];
              t.push( {
                kind: s.kind,
                name: s.name,
                detail: s.detail,
                containerName: s.containerName || i,
                range: s.range,
                selectionRange: s.selectionRange,
                children: void 0
              } ), s.children && e( t, s.children, s.name )
            }
          }( e, t, "" ), e.sort( y ), e;
        } ) );
      }

      function y( e, t ) {
        return f.a.compareRangesUsingStarts( e.range, t.range )
      }
      Object( g.j )( "_executeDocumentSymbolProvider", ( ( e, t ) => {
        const n = t.resource;
        if ( !( n instanceof h.a ) ) throw Object( d.b )( "resource" );
        const i = e.get( m.a ).getModel( n );
        if ( !i ) throw Object( d.b )( "resource" );
        return v( i )
      } ) ), n.d( t, "SymbolEntry", ( () => {
        return C
      } ) ), n.d( t, "QuickOutlineAction", ( () => {
        return w
      } ) );
      const b = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var C = ( e => {
        function t( t, n, i, o, r, s, a ) {
          const u = e.call( this ) || this;
          return u.name = t, u.type = n, u.description = i, u.range = o, u.setHighlights( r ), u.editor = s, u.decorator = a, u
        }
        return b( t, e ), t.prototype.getLabel = function () {
          return this.name
        }, t.prototype.getAriaLabel = function () {
          return i.a( "entryAriaLabel", "{0}, symbols", this.name )
        }, t.prototype.getIcon = function () {
          return this.type
        }, t.prototype.getDescription = function () {
          return this.description
        }, t.prototype.getType = function () {
          return this.type
        }, t.prototype.getRange = function () {
          return this.range
        }, t.prototype.run = function ( e, t ) {
          return e === a.a.OPEN ? this.runOpen( t ) : this.runPreview()
        }, t.prototype.runOpen = function ( e ) {
          const t = this.toSelection();
          return this.editor.setSelection( t ), this.editor.revealRangeInCenter( t, 0 ), this.editor.focus(), !0
        }, t.prototype.runPreview = function () {
          const e = this.toSelection();
          return this.editor.revealRangeInCenter( e, 0 ), this.decorator.decorateLine( this.range, this.editor ), !1
        }, t.prototype.toSelection = function () {
          return new f.a( this.range.startLineNumber, this.range.startColumn || 1, this.range.startLineNumber, this.range.startColumn || 1 )
        }, t;
      } )( s.b );

      var w = ( e => {
        function t() {
          return e.call( this, i.a( "quickOutlineActionInput", "Type the name of an identifier you wish to navigate to" ), {
            id: "editor.action.quickOutline",
            label: i.a( "QuickOutlineAction.label", "Go to Symbol..." ),
            alias: "Go to Symbol...",
            precondition: u.a.hasDocumentSymbolProvider,
            kbOpts: {
              kbExpr: u.a.focus,
              primary: 3117,
              weight: 100
            },
            menuOpts: {
              group: "navigation",
              order: 3
            }
          } ) || this
        }
        return b( t, e ), t.prototype.run = function ( e, t ) {
          const n = this,
            i = t.getModel();
          return l.j.has( i ) ? v( i ).then( ( e => {
            0 !== e.length && n._run( t, e )
          } ) ) : null;
        }, t.prototype._run = function ( e, t ) {
          const n = this;
          this._show( this.getController( e ), {
            getModel( i ) {
              return new s.c( n.toQuickOpenEntries( e, t, i ) )
            },
            getAutoFocus( e ) {
              return 0 === e.indexOf( ":" ) && ( e = e.substr( ":".length ) ), {
                autoFocusPrefixMatch: e,
                autoFocusFirstEntry: !!e
              }
            }
          } )
        }, t.prototype.symbolEntry = ( e, t, n, i, o, r, s ) => {
          return new C( e, t, n, f.a.lift( i ), o, r, s )
        }, t.prototype.toQuickOpenEntries = function ( e, t, n ) {
          const s = this.getController( e );
          let a = [];
          let u = n;
          0 === n.indexOf( ":" ) && ( u = u.substr( ":".length ) );
          for ( var c = 0; c < t.length; c++ ) {
            const d = t[ c ],
              h = r.trim( d.name ),
              p = Object( o.e )( u, h );
            if ( p ) {
              let f = null;
              d.containerName && ( f = d.containerName ), a.push( this.symbolEntry( h, Object( l.B )( d.kind ), f, d.range, p, e, s ) )
            }
          }
          if ( n && ( a = 0 === n.indexOf( ":" ) ? a.sort( this.sortScoped.bind( this, n.toLowerCase() ) ) : a.sort( this.sortNormal.bind( this, n.toLowerCase() ) ) ), a.length > 0 && 0 === n.indexOf( ":" ) ) {
            let g = null,
              m = null,
              _ = 0;
            for ( c = 0; c < a.length; c++ ) {
              const v = a[ c ];
              g !== v.getType() ? ( m && m.setGroupLabel( this.typeToLabel( g, _ ) ), g = v.getType(), m = v, _ = 1, v.setShowBorder( c > 0 ) ) : _++
            }
            m && m.setGroupLabel( this.typeToLabel( g, _ ) )
          } else a.length > 0 && a[ 0 ].setGroupLabel( i.a( "symbols", "symbols ({0})", a.length ) );
          return a
        }, t.prototype.typeToLabel = ( e, t ) => {
          switch ( e ) {
            case "module":
              return i.a( "modules", "modules ({0})", t );
            case "class":
              return i.a( "class", "classes ({0})", t );
            case "interface":
              return i.a( "interface", "interfaces ({0})", t );
            case "method":
              return i.a( "method", "methods ({0})", t );
            case "function":
              return i.a( "function", "functions ({0})", t );
            case "property":
              return i.a( "property", "properties ({0})", t );
            case "variable":
              return i.a( "variable", "variables ({0})", t );
            case "var":
              return i.a( "variable2", "variables ({0})", t );
            case "constructor":
              return i.a( "_constructor", "constructors ({0})", t );
            case "call":
              return i.a( "call", "calls ({0})", t )
          }
          return e
        }, t.prototype.sortNormal = ( e, t, n ) => {
          const i = t.getLabel().toLowerCase(),
            o = n.getLabel().toLowerCase(),
            r = i.localeCompare( o );
          if ( 0 !== r ) return r;
          const s = t.getRange(),
            a = n.getRange();
          return s.startLineNumber - a.startLineNumber
        }, t.prototype.sortScoped = ( e, t, n ) => {
          e = e.substr( ":".length );
          const i = t.getType(),
            o = n.getType(),
            r = i.localeCompare( o );
          if ( 0 !== r ) return r;
          if ( e ) {
            const s = t.getLabel().toLowerCase(),
              a = n.getLabel().toLowerCase(),
              u = s.localeCompare( a );
            if ( 0 !== u ) return u
          }
          const l = t.getRange(),
            c = n.getRange();
          return l.startLineNumber - c.startLineNumber
        }, t;
      } )( c.a );

      Object( g.f )( w )
    },
    WqXY( e, t, n ) {
      "use strict";
      n.d( t, "d", ( () => {
        return g
      } ) ), n.d( t, "e", ( () => {
        return m
      } ) ), n.d( t, "b", ( () => {
        return _
      } ) ), n.d( t, "c", ( () => {
        return i
      } ) ), n.d( t, "a", ( () => {
        return y
      } ) );
      n( "yEoX" );
      var i;
      const o = n( "MNsG" );
      const r = n( "3/fG" );
      const s = n( "pmY6" );
      const a = n( "lCHf" );
      const u = n( "8HAY" );
      const l = n( "EffR" );
      const c = n( "746U" );
      const d = n( "pg8w" );
      const h = n( "uDWl" );
      const p = n( "MI8n" );
      const f = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var g = ( () => {
        function e( e, t, n ) {
          const i = this;
          this.options = n, this._callOnDispose = [], this._context = e || this, this._action = t, t instanceof u.a && this._callOnDispose.push( t.onDidChange( ( e => {
            i.builder && i._handleActionChangeEvent( e )
          } ) ) )
        }
        return e.prototype._handleActionChangeEvent = function ( e ) {
          void 0 !== e.enabled && this._updateEnabled(), void 0 !== e.checked && this._updateChecked(), void 0 !== e.class && this._updateClass(), void 0 !== e.label && ( this._updateLabel(), this._updateTooltip() ), void 0 !== e.tooltip && this._updateTooltip()
        }, Object.defineProperty( e.prototype, "actionRunner", {
          get() {
            return this._actionRunner
          },
          set( e ) {
            this._actionRunner = e
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.getAction = function () {
          return this._action
        }, e.prototype.isEnabled = function () {
          return this._action.enabled
        }, e.prototype.setActionContext = function ( e ) {
          this._context = e
        }, e.prototype.render = function ( e ) {
          const t = this;
          this.builder = Object( a.a )( e ), d.b.addTarget( e );
          const n = this.options && this.options.draggable;
          n && ( e.draggable = !0 ), this.builder.on( d.a.Tap, ( e => {
            return t.onClick( e )
          } ) ), this.builder.on( l.d.MOUSE_DOWN, ( e => {
            n || l.c.stop( e, !0 );
            const i = e;
            t._action.enabled && 0 === i.button && t.builder.addClass( "active" )
          } ) ), this.builder.on( l.d.CLICK, ( e => {
            l.c.stop( e, !0 ), t.options && t.options.isMenu ? t.onClick( e ) : o.h( ( () => {
              return t.onClick( e )
            } ) )
          } ) ), this.builder.on( [ l.d.MOUSE_UP, l.d.MOUSE_OUT ], ( e => {
            l.c.stop( e ), t.builder.removeClass( "active" )
          } ) )
        }, e.prototype.onClick = function ( e ) {
          let t;
          l.c.stop( e, !0 ), c.j( this._context ) || !c.g( this._context ) ? t = e : ( t = this._context ).event = e, this._actionRunner.run( this._action, t )
        }, e.prototype._updateEnabled = () => {}, e.prototype._updateLabel = () => {}, e.prototype._updateTooltip = () => {}, e.prototype._updateClass = () => {}, e.prototype._updateChecked = () => {}, e.prototype.dispose = function () {
          this.builder && ( this.builder.destroy(), this.builder = null ), this._callOnDispose = s.d( this._callOnDispose )
        }, e;
      } )();
      var m = ( e => {
        function t( n, i ) {
          const o = e.call( this, t.ID, n, n ? "separator text" : "separator" ) || this;
          return o.checked = !1, o.radio = !1, o.enabled = !1, o.order = i, o
        }
        return f( t, e ), t.ID = "vs.actions.separator", t
      } )( u.a );
      var _ = ( e => {
        function t( t, n, i ) {
          void 0 === i && ( i = {} );
          const o = e.call( this, t, n, i ) || this;
          return o.options = i, o.options.icon = void 0 !== i.icon && i.icon, o.options.label = void 0 === i.label || i.label, o.cssClass = "", o
        }
        return f( t, e ), t.prototype.render = function ( t ) {
          e.prototype.render.call( this, t ), this.$e = Object( a.a )( "a.action-label" ).appendTo( this.builder ), this._action.id === m.ID ? this.$e.attr( {
            role: "presentation"
          } ) : this.options.isMenu ? this.$e.attr( {
            role: "menuitem"
          } ) : this.$e.attr( {
            role: "button"
          } ), this.options.label && this.options.keybinding && Object( a.a )( "span.keybinding" ).text( this.options.keybinding ).appendTo( this.builder ), this._updateClass(), this._updateLabel(), this._updateTooltip(), this._updateEnabled(), this._updateChecked()
        }, t.prototype._updateLabel = function () {
          this.options.label && this.$e.text( this.getAction().label )
        }, t.prototype._updateTooltip = function () {
          let e = null;
          this.getAction().tooltip ? e = this.getAction().tooltip : !this.options.label && this.getAction().label && this.options.icon && ( e = this.getAction().label, this.options.keybinding && ( e = r.a( {
            key: "titleLabel",
            comment: [ "action title", "action keybinding" ]
          }, "{0} ({1})", e, this.options.keybinding ) ) ), e && this.$e.attr( {
            title: e
          } )
        }, t.prototype._updateClass = function () {
          this.cssClass && this.$e.removeClass( this.cssClass ), this.options.icon ? ( this.cssClass = this.getAction().class, this.$e.addClass( "icon" ), this.cssClass && this.$e.addClass( this.cssClass ), this._updateEnabled() ) : this.$e.removeClass( "icon" )
        }, t.prototype._updateEnabled = function () {
          this.getAction().enabled ? ( this.builder.removeClass( "disabled" ), this.$e.removeClass( "disabled" ), this.$e.attr( {
            tabindex: 0
          } ) ) : ( this.builder.addClass( "disabled" ), this.$e.addClass( "disabled" ), l.H( this.$e.getHTMLElement() ) )
        }, t.prototype._updateChecked = function () {
          this.getAction().checked ? this.$e.addClass( "checked" ) : this.$e.removeClass( "checked" )
        }, t;
      } )( g );
      !( e => {
        e[ e.HORIZONTAL = 0 ] = "HORIZONTAL", e[ e.HORIZONTAL_REVERSE = 1 ] = "HORIZONTAL_REVERSE", e[ e.VERTICAL = 2 ] = "VERTICAL", e[ e.VERTICAL_REVERSE = 3 ] = "VERTICAL_REVERSE"
      } )( i || ( i = {} ) );
      const v = {
        orientation: i.HORIZONTAL,
        context: null
      };

      var y = ( () => {
        function e( e, t ) {
          void 0 === t && ( t = v );
          let n;
          let o;
          const r = this;
          switch ( this._onDidBlur = new p.a, this._onDidCancel = new p.a, this._onDidRun = new p.a, this._onDidBeforeRun = new p.a, this.options = t, this._context = t.context, this.toDispose = [], this._actionRunner = this.options.actionRunner, this._actionRunner || ( this._actionRunner = new u.b, this.toDispose.push( this._actionRunner ) ), this.toDispose.push( this._actionRunner.onDidRun( ( e => {
            return r._onDidRun.fire( e )
          } ) ) ), this.toDispose.push( this._actionRunner.onDidBeforeRun( ( e => {
            return r._onDidBeforeRun.fire( e )
          } ) ) ), this.items = [], this.focusedItem = void 0, this.domNode = document.createElement( "div" ), this.domNode.className = "monaco-action-bar", !1 !== t.animated && l.f( this.domNode, "animated" ), this.options.orientation ) {
            case i.HORIZONTAL:
              n = 15, o = 17;
              break;
            case i.HORIZONTAL_REVERSE:
              n = 17, o = 15, this.domNode.className += " reverse";
              break;
            case i.VERTICAL:
              n = 16, o = 18, this.domNode.className += " vertical";
              break;
            case i.VERTICAL_REVERSE:
              n = 18, o = 16, this.domNode.className += " vertical reverse"
          }
          Object( a.a )( this.domNode ).on( l.d.KEY_DOWN, ( e => {
            const t = new h.a( e );
            let i = !0;
            t.equals( n ) ? r.focusPrevious() : t.equals( o ) ? r.focusNext() : t.equals( 9 ) ? r.cancel() : t.equals( 3 ) || t.equals( 10 ) || ( i = !1 ), i && ( t.preventDefault(), t.stopPropagation() )
          } ) ), Object( a.a )( this.domNode ).on( l.d.KEY_UP, ( e => {
            const t = new h.a( e );
            t.equals( 3 ) || t.equals( 10 ) ? ( r.doTrigger( t ), t.preventDefault(), t.stopPropagation() ) : ( t.equals( 2 ) || t.equals( 1026 ) ) && r.updateFocusedItem()
          } ) ), this.focusTracker = l.O( this.domNode ), this.toDispose.push( this.focusTracker.onDidBlur( ( () => {
            document.activeElement !== r.domNode && l.B( document.activeElement, r.domNode ) || ( r._onDidBlur.fire(), r.focusedItem = void 0 )
          } ) ) ), this.toDispose.push( this.focusTracker.onDidFocus( ( () => {
            return r.updateFocusedItem()
          } ) ) ), this.actionsList = document.createElement( "ul" ), this.actionsList.className = "actions-container", this.options.isMenu ? this.actionsList.setAttribute( "role", "menu" ) : this.actionsList.setAttribute( "role", "toolbar" ), this.options.ariaLabel && this.actionsList.setAttribute( "aria-label", this.options.ariaLabel ), this.options.isMenu && ( this.domNode.tabIndex = 0, Object( a.a )( this.domNode ).on( l.d.MOUSE_OUT, ( e => {
            const t = e.relatedTarget;
            l.B( t, r.domNode ) || ( r.focusedItem = void 0, r.updateFocus(), e.stopPropagation() )
          } ) ), Object( a.a )( this.actionsList ).on( l.d.MOUSE_OVER, ( e => {
            let t = e.target;
            if ( t && l.B( t, r.actionsList ) && t !== r.actionsList ) {
              for ( ; t.parentElement !== r.actionsList; ) t = t.parentElement;
              if ( l.z( t, "action-item" ) ) {
                const n = r.focusedItem;
                r.setFocusedItem( t ), n !== r.focusedItem && r.updateFocus()
              }
            }
          } ) ) ), this.domNode.appendChild( this.actionsList ), e.appendChild( this.domNode )
        }
        return Object.defineProperty( e.prototype, "onDidBlur", {
          get() {
            return this._onDidBlur.event
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "onDidCancel", {
          get() {
            return this._onDidCancel.event
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "onDidRun", {
          get() {
            return this._onDidRun.event
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "onDidBeforeRun", {
          get() {
            return this._onDidBeforeRun.event
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.setFocusedItem = function ( e ) {
          for ( let t = 0; t < this.actionsList.children.length; t++ ) {
            if ( e === this.actionsList.children[ t ] ) {
              this.focusedItem = t;
              break
            }
          }
        }, e.prototype.updateFocusedItem = function () {
          for ( let e = 0; e < this.actionsList.children.length; e++ ) {
            const t = this.actionsList.children[ e ];
            if ( l.B( document.activeElement, t ) ) {
              this.focusedItem = e;
              break
            }
          }
        }, Object.defineProperty( e.prototype, "context", {
          get() {
            return this._context
          },
          set( e ) {
            this._context = e, this.items.forEach( ( t => {
              return t.setActionContext( e )
            } ) )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.getContainer = function () {
          return this.domNode
        }, e.prototype.push = function ( e, t ) {
          const n = this;
          void 0 === t && ( t = {} );
          const i = Array.isArray( e ) ? e : [ e ];
          let o = c.f( t.index ) ? t.index : null;
          i.forEach( ( e => {
            const i = document.createElement( "li" );
            i.className = "action-item", i.setAttribute( "role", "presentation" ), Object( a.a )( i ).on( l.d.CONTEXT_MENU, ( e => {
              e.preventDefault(), e.stopPropagation()
            } ) );
            let r = null;
            n.options.actionItemProvider && ( r = n.options.actionItemProvider( e ) ), r || ( r = new _( n.context, e, t ) ), r.actionRunner = n._actionRunner, r.setActionContext( n.context ), r.render( i ), null === o || o < 0 || o >= n.actionsList.children.length ? ( n.actionsList.appendChild( i ), n.items.push( r ) ) : ( n.actionsList.insertBefore( i, n.actionsList.children[ o ] ), n.items.splice( o, 0, r ), o++ )
          } ) )
        }, e.prototype.clear = function () {
          this.items = s.d( this.items ), Object( a.a )( this.actionsList ).empty()
        }, e.prototype.isEmpty = function () {
          return 0 === this.items.length
        }, e.prototype.focus = function ( e ) {
          e && "undefined" === typeof this.focusedItem ? ( this.focusedItem = this.items.length - 1, this.focusNext() ) : this.updateFocus()
        }, e.prototype.focusNext = function () {
          "undefined" === typeof this.focusedItem && ( this.focusedItem = this.items.length - 1 );
          let e;
          const t = this.focusedItem;
          do {
            this.focusedItem = ( this.focusedItem + 1 ) % this.items.length, e = this.items[ this.focusedItem ]
          } while ( this.focusedItem !== t && !e.isEnabled() );
          this.focusedItem !== t || e.isEnabled() || ( this.focusedItem = void 0 ), this.updateFocus()
        }, e.prototype.focusPrevious = function () {
          "undefined" === typeof this.focusedItem && ( this.focusedItem = 0 );
          let e;
          const t = this.focusedItem;
          do {
            this.focusedItem = this.focusedItem - 1, this.focusedItem < 0 && ( this.focusedItem = this.items.length - 1 ), e = this.items[ this.focusedItem ]
          } while ( this.focusedItem !== t && !e.isEnabled() );
          this.focusedItem !== t || e.isEnabled() || ( this.focusedItem = void 0 ), this.updateFocus( !0 )
        }, e.prototype.updateFocus = function ( e ) {
          "undefined" === typeof this.focusedItem && this.domNode.focus();
          for ( let t = 0; t < this.items.length; t++ ) {
            const n = this.items[ t ];
            t === this.focusedItem ? c.e( n.isEnabled ) && ( n.isEnabled() && c.e( n.focus ) ? n.focus( e ) : this.domNode.focus() ) : c.e( n.blur ) && n.blur()
          }
        }, e.prototype.doTrigger = function ( e ) {
          if ( "undefined" !== typeof this.focusedItem ) {
            const t = this.items[ this.focusedItem ];
            if ( t instanceof g ) {
              const n = null === t._context || void 0 === t._context ? e : t._context;
              this.run( t._action, n ).done()
            }
          }
        }, e.prototype.cancel = function () {
          document.activeElement instanceof HTMLElement && document.activeElement.blur(), this._onDidCancel.fire()
        }, e.prototype.run = function ( e, t ) {
          return this._actionRunner.run( e, t )
        }, e.prototype.dispose = function () {
          null !== this.items && s.d( this.items ), this.items = null, this.focusTracker && ( this.focusTracker.dispose(), this.focusTracker = null ), this.toDispose = s.d( this.toDispose ), Object( a.a )( this.getContainer() ).destroy()
        }, e;
      } )();
    },
    WwIK( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "pmY6" ),
        r = n( "Cg/j" ),
        s = n( "wQH0" ),
        a = n( "T8No" ),
        u = n( "sswD" ),
        l = ( n( "yrU1" ), n( "VMIq" ) ),
        c = n( "EffR" ),
        d = n( "OBOq" ),
        h = n( "twdY" ),
        p = n( "sFUC" ),
        f = n( "X+cX" ),
        g = n( "/cxE" ),
        m = n( "MI8n" ),
        _ = n( "4y0V" ),
        v = n( "JQT/" ),
        y = {
          Visible: new a.f( "parameterHintsVisible", !1 ),
          MultipleSignatures: new a.f( "parameterHintsMultipleSignatures", !1 )
        };

      function b( e, t, n ) {
        const i = h.t.ordered( e );
        return Object( f.k )( i.map( ( i => {
          return () => {
            return Promise.resolve( i.provideSignatureHelp( e, t, n ) ).catch( g.f )
          };
        } ) ) );
      }
      Object( u.e )( "_executeSignatureHelpProvider", ( ( e, t ) => {
        return b( e, t, v.a.None )
      } ) );
      const C = n( "GJhM" ),
        w = n( "MXAL" ),
        S = n( "t9D7" ),
        O = n( "MD5Z" ),
        L = n( "W9cx" ),
        x = n( "WBhO" ),
        N = n( "3qCu" ),
        E = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        k = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        I = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        D = c.a,
        M = ( e => {
          function t( n ) {
            const i = e.call( this ) || this;
            return i._onHint = i._register( new m.a ), i.onHint = i._onHint.event, i._onCancel = i._register( new m.a ), i.onCancel = i._onCancel.event, i.editor = n, i.enabled = !1, i.triggerCharactersListeners = [], i.throttledDelayer = new f.c( ( () => {
              return i.doTrigger()
            } ), t.DELAY ), i.active = !1, i._register( i.editor.onDidChangeConfiguration( ( () => {
              return i.onEditorConfigurationChange()
            } ) ) ), i._register( i.editor.onDidChangeModel( ( e => {
              return i.onModelChanged()
            } ) ) ), i._register( i.editor.onDidChangeModelLanguage( ( e => {
              return i.onModelChanged()
            } ) ) ), i._register( i.editor.onDidChangeCursorSelection( ( e => {
              return i.onCursorChange( e )
            } ) ) ), i._register( i.editor.onDidChangeModelContent( ( e => {
              return i.onModelContentChange()
            } ) ) ), i._register( h.t.onDidChange( i.onModelChanged, i ) ), i.onEditorConfigurationChange(), i.onModelChanged(), i;
          }
          return E( t, e ), t.prototype.cancel = function ( e ) {
            void 0 === e && ( e = !1 ), this.active = !1, this.throttledDelayer.cancel(), e || this._onCancel.fire( void 0 ), this.provideSignatureHelpRequest && ( this.provideSignatureHelpRequest.cancel(), this.provideSignatureHelpRequest = void 0 )
          }, t.prototype.trigger = function ( e ) {
            if ( void 0 === e && ( e = t.DELAY ), h.t.has( this.editor.getModel() ) ) return this.cancel( !0 ), this.throttledDelayer.schedule( e )
          }, t.prototype.doTrigger = function () {
            const e = this;
            this.provideSignatureHelpRequest && this.provideSignatureHelpRequest.cancel(), this.provideSignatureHelpRequest = Object( f.i )( ( t => {
              return b( e.editor.getModel(), e.editor.getPosition(), t )
            } ) ), this.provideSignatureHelpRequest.then( ( t => {
              if ( !t || !t.signatures || 0 === t.signatures.length ) return e.cancel(), e._onCancel.fire( void 0 ), !1;
              e.active = !0;
              const n = {
                hints: t
              };
              return e._onHint.fire( n ), !0
            } ) ).catch( g.e )
          }, t.prototype.isTriggered = function () {
            return this.active || this.throttledDelayer.isScheduled()
          }, t.prototype.onModelChanged = function () {
            const e = this;
            this.cancel(), this.triggerCharactersListeners = Object( o.d )( this.triggerCharactersListeners );
            const t = this.editor.getModel();
            if ( t ) {
              for ( var n = new w.b, i = 0, r = h.t.ordered( t ); i < r.length; i++ ) {
                const s = r[ i ];
                if ( Array.isArray( s.signatureHelpTriggerCharacters ) )
                  for ( let a = 0, u = s.signatureHelpTriggerCharacters; a < u.length; a++ ) {
                    const l = u[ a ];
                    n.add( l.charCodeAt( 0 ) )
                  }
              }
              this.triggerCharactersListeners.push( this.editor.onDidType( ( t => {
                e.enabled && n.has( t.charCodeAt( t.length - 1 ) ) && e.trigger()
              } ) ) )
            }
          }, t.prototype.onCursorChange = function ( e ) {
            "mouse" === e.source ? this.cancel() : this.isTriggered() && this.trigger()
          }, t.prototype.onModelContentChange = function () {
            this.isTriggered() && this.trigger()
          }, t.prototype.onEditorConfigurationChange = function () {
            this.enabled = this.editor.getConfiguration().contribInfo.parameterHints, this.enabled || this.cancel()
          }, t.prototype.dispose = function () {
            this.cancel( !0 ), this.triggerCharactersListeners = Object( o.d )( this.triggerCharactersListeners ), e.prototype.dispose.call( this )
          }, t.DELAY = 120, t;
        } )( o.a ),
        T = ( () => {
          function e( e, t, n, i ) {
            const o = this;
            this.editor = e, this.allowEditorOverflow = !0, this.markdownRenderer = new N.a( e, i, n ), this.model = new M( e ), this.keyVisible = y.Visible.bindTo( t ), this.keyMultipleSignatures = y.MultipleSignatures.bindTo( t ), this.visible = !1, this.disposables = [], this.disposables.push( this.model.onHint( ( e => {
              o.show(), o.hints = e.hints, o.currentSignature = e.hints.activeSignature, o.render()
            } ) ) ), this.disposables.push( this.model.onCancel( ( () => {
              o.hide()
            } ) ) )
          }
          return e.prototype.createParamaterHintDOMNodes = function () {
            const e = this;
            this.element = D( ".editor-widget.parameter-hints-widget" );
            const t = c.k( this.element, D( ".wrapper" ) ),
              n = c.k( t, D( ".buttons" ) ),
              i = c.k( n, D( ".button.previous" ) ),
              o = c.k( n, D( ".button.next" ) );
            Object( _.b )( Object( _.a )( i, "click" ) )( this.previous, this, this.disposables ), Object( _.b )( Object( _.a )( o, "click" ) )( this.next, this, this.disposables ), this.overloads = c.k( t, D( ".overloads" ) );
            const r = D( ".body" );
            this.scrollbar = new C.a( r, {} ), this.disposables.push( this.scrollbar ), t.appendChild( this.scrollbar.getDomNode() ), this.signature = c.k( r, D( ".signature" ) ), this.docs = c.k( r, D( ".docs" ) ), this.currentSignature = 0, this.editor.addContentWidget( this ), this.hide(), this.disposables.push( this.editor.onDidChangeCursorSelection( ( t => {
              e.visible && e.editor.layoutContentWidget( e )
            } ) ) );
            const s = () => {
              const t = e.editor.getConfiguration().fontInfo;
              e.element.style.fontSize = t.fontSize + "px"
            };
            s(), Object( m.g )( this.editor.onDidChangeConfiguration.bind( this.editor ) ).filter( ( e => {
              return e.fontInfo
            } ) ).on( s, null, this.disposables ), this.disposables.push( this.editor.onDidLayoutChange( ( t => {
              return e.updateMaxHeight()
            } ) ) ), this.updateMaxHeight()
          }, e.prototype.show = function () {
            const e = this;
            this.model && !this.visible && ( this.element || this.createParamaterHintDOMNodes(), this.keyVisible.set( !0 ), this.visible = !0, l.b.timeout( 100 ).done( ( () => {
              return c.f( e.element, "visible" )
            } ) ), this.editor.layoutContentWidget( this ) )
          }, e.prototype.hide = function () {
            this.model && this.visible && ( this.element || this.createParamaterHintDOMNodes(), this.keyVisible.reset(), this.visible = !1, this.hints = null, this.announcedLabel = null, c.G( this.element, "visible" ), this.editor.layoutContentWidget( this ) )
          }, e.prototype.getPosition = function () {
            return this.visible ? {
              position: this.editor.getPosition(),
              preference: [ p.a.ABOVE, p.a.BELOW ]
            } : null
          }, e.prototype.render = function () {
            const e = this.hints.signatures.length > 1;
            c.N( this.element, "multiple", e ), this.keyMultipleSignatures.set( e ), this.signature.innerHTML = "", this.docs.innerHTML = "";
            const t = this.hints.signatures[ this.currentSignature ];
            if ( t ) {
              const n = c.k( this.signature, D( ".code" ) ),
                r = t.parameters.length > 0,
                s = this.editor.getConfiguration().fontInfo;
              if ( n.style.fontSize = s.fontSize + "px", n.style.fontFamily = s.fontFamily, r ) this.renderParameters( n, t, this.hints.activeParameter );
              else c.k( n, D( "span" ) ).textContent = t.label;
              Object( o.d )( this.renderDisposeables ), this.renderDisposeables = [];
              const a = t.parameters[ this.hints.activeParameter ];
              if ( a && a.documentation ) {
                const u = D( "span.documentation" );
                if ( "string" === typeof a.documentation ) u.textContent = a.documentation;
                else {
                  var l = this.markdownRenderer.render( a.documentation );
                  c.f( l.element, "markdown-docs" ), this.renderDisposeables.push( l ), u.appendChild( l.element )
                }
                c.k( this.docs, D( "p", null, u ) )
              }
              if ( c.N( this.signature, "has-docs", !!t.documentation ), "string" === typeof t.documentation ) c.k( this.docs, D( "p", null, t.documentation ) );
              else {
                l = this.markdownRenderer.render( t.documentation );
                c.f( l.element, "markdown-docs" ), this.renderDisposeables.push( l ), c.k( this.docs, l.element )
              }
              let h = String( this.currentSignature + 1 );
              if ( this.hints.signatures.length < 10 && ( h += "/" + this.hints.signatures.length ), this.overloads.textContent = h, a ) {
                const p = a.label;
                this.announcedLabel !== p && ( d.a( i.a( "hint", "{0}, hint", p ) ), this.announcedLabel = p )
              }
              this.editor.layoutContentWidget( this ), this.scrollbar.scanDomNode()
            }
          }, e.prototype.renderParameters = ( e, t, n ) => {
            for ( var i, o = t.label.length, r = 0, s = t.parameters.length - 1; s >= 0; s-- ) {
              const a = t.parameters[ s ];
              let u = 0;
              let l = 0;
              ( r = t.label.lastIndexOf( a.label, o - 1 ) ) >= 0 && ( u = r, l = r + a.label.length ), ( i = document.createElement( "span" ) ).textContent = t.label.substring( l, o ), c.E( e, i ), ( i = document.createElement( "span" ) ).className = "parameter " + ( s === n ? "active" : "" ), i.textContent = t.label.substring( u, l ), c.E( e, i ), o = u
            }( i = document.createElement( "span" ) ).textContent = t.label.substring( 0, o ), c.E( e, i )
          }, e.prototype.next = function () {
            const e = this.hints.signatures.length,
              t = this.currentSignature % e === e - 1;
            return e < 2 || t ? ( this.cancel(), !1 ) : ( this.currentSignature++, this.render(), !0 )
          }, e.prototype.previous = function () {
            const e = this.hints.signatures.length,
              t = 0 === this.currentSignature;
            return e < 2 || t ? ( this.cancel(), !1 ) : ( this.currentSignature--, this.render(), !0 )
          }, e.prototype.cancel = function () {
            this.model.cancel()
          }, e.prototype.getDomNode = function () {
            return this.element
          }, e.prototype.getId = () => {
            return e.ID
          }, e.prototype.trigger = function () {
            this.model.trigger( 0 )
          }, e.prototype.updateMaxHeight = function () {
            const e = Math.max( this.editor.getLayoutInfo().height / 4, 250 );
            this.element.style.maxHeight = e + "px"
          }, e.prototype.dispose = function () {
            this.disposables = Object( o.d )( this.disposables ), this.renderDisposeables = Object( o.d )( this.renderDisposeables ), this.model && ( this.model.dispose(), this.model = null )
          }, e.ID = "editor.widget.parameterHintsWidget", e = k( [ I( 1, a.e ), I( 2, L.a ), I( 3, x.a ) ], e );
        } )();
      Object( S.e )( ( ( e, t ) => {
        const n = e.getColor( O.w );
        if ( n ) {
          const i = e.type === S.b ? 2 : 1;
          t.addRule( ".monaco-editor .parameter-hints-widget { border: " + i + "px solid " + n + "; }" ), t.addRule( ".monaco-editor .parameter-hints-widget.multiple .body { border-left: 1px solid " + n.transparent( .5 ) + "; }" ), t.addRule( ".monaco-editor .parameter-hints-widget .signature.has-docs { border-bottom: 1px solid " + n.transparent( .5 ) + "; }" )
        }
        const o = e.getColor( O.v );
        o && t.addRule( ".monaco-editor .parameter-hints-widget { background-color: " + o + "; }" );
        const r = e.getColor( O.qb );
        r && t.addRule( ".monaco-editor .parameter-hints-widget a { color: " + r + "; }" );
        const s = e.getColor( O.pb );
        s && t.addRule( ".monaco-editor .parameter-hints-widget code { background-color: " + s + "; }" )
      } ) ), n.d( t, "TriggerParameterHintsAction", ( () => {
        return W
      } ) );
      const R = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const P = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const A = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      const F = ( () => {
        function e( e, t ) {
          this.editor = e, this.widget = t.createInstance( T, this.editor )
        }
        return e.get = t => {
          return t.getContribution( e.ID )
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.cancel = function () {
          this.widget.cancel()
        }, e.prototype.previous = function () {
          this.widget.previous()
        }, e.prototype.next = function () {
          this.widget.next()
        }, e.prototype.trigger = function () {
          this.widget.trigger()
        }, e.prototype.dispose = function () {
          this.widget = Object( o.d )( this.widget )
        }, e.ID = "editor.controller.parameterHints", e = P( [ A( 1, r.a ) ], e );
      } )();
      var W = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.triggerParameterHints",
            label: i.a( "parameterHints.trigger.label", "Trigger Parameter Hints" ),
            alias: "Trigger Parameter Hints",
            precondition: s.a.hasSignatureHelpProvider,
            kbOpts: {
              kbExpr: s.a.editorTextFocus,
              primary: 3082,
              weight: 100
            }
          } ) || this
        }
        return R( t, e ), t.prototype.run = ( e, t ) => {
          const n = F.get( t );
          n && n.trigger()
        }, t;
      } )( u.b );
      Object( u.h )( F ), Object( u.f )( W );
      const j = u.c.bindToContribution( F.get );
      Object( u.g )( new j( {
        id: "closeParameterHints",
        precondition: y.Visible,
        handler( e ) {
          return e.cancel()
        },
        kbOpts: {
          weight: 175,
          kbExpr: s.a.editorTextFocus,
          primary: 9,
          secondary: [ 1033 ]
        }
      } ) ), Object( u.g )( new j( {
        id: "showPrevParameterHint",
        precondition: a.d.and( y.Visible, y.MultipleSignatures ),
        handler( e ) {
          return e.previous()
        },
        kbOpts: {
          weight: 175,
          kbExpr: s.a.editorTextFocus,
          primary: 16,
          secondary: [ 528 ],
          mac: {
            primary: 16,
            secondary: [ 528, 302 ]
          }
        }
      } ) ), Object( u.g )( new j( {
        id: "showNextParameterHint",
        precondition: a.d.and( y.Visible, y.MultipleSignatures ),
        handler( e ) {
          return e.next()
        },
        kbOpts: {
          weight: 175,
          kbExpr: s.a.editorTextFocus,
          primary: 18,
          secondary: [ 530 ],
          mac: {
            primary: 18,
            secondary: [ 530, 300 ]
          }
        }
      } ) )
    },
    "X+cX": function ( e, t, n ) {
      "use strict";
      n.d( t, "n", ( () => {
        return l
      } ) ), n.d( t, "i", ( () => {
        return c
      } ) ), n.d( t, "h", ( () => {
        return d
      } ) ), n.d( t, "o", ( () => {
        return h
      } ) ), n.d( t, "e", ( () => {
        return p
      } ) ), n.d( t, "a", ( () => {
        return f
      } ) ), n.d( t, "d", ( () => {
        return g
      } ) ), n.d( t, "m", ( () => {
        return m
      } ) ), n.d( t, "g", ( () => {
        return _
      } ) ), n.d( t, "k", ( () => {
        return v
      } ) ), n.d( t, "j", ( () => {
        return y
      } ) ), n.d( t, "l", ( () => {
        return b
      } ) ), n.d( t, "f", ( () => {
        return C
      } ) ), n.d( t, "b", ( () => {
        return w
      } ) ), n.d( t, "c", ( () => {
        return S
      } ) );
      const i = n( "/cxE" ),
        o = n( "VMIq" ),
        r = n( "JQT/" ),
        s = n( "pmY6" ),
        a = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )();

      function u( e ) {
        return e && "function" === typeof e.then
      }

      function l( e ) {
        return u( e ) ? e : o.b.as( e )
      }

      function c( e ) {
        const t = new r.b,
          n = e( t.token ),
          o = new Promise( ( ( e, o ) => {
            t.token.onCancellationRequested( ( () => {
              o( i.a() )
            } ) ), Promise.resolve( n ).then( ( n => {
              t.dispose(), e( n )
            } ), ( e => {
              t.dispose(), o( e )
            } ) )
          } ) );
        return new( ( () => {
          function e() {}
          return e.prototype.cancel = () => {
            t.cancel()
          }, e.prototype.then = ( e, t ) => {
            return o.then( e, t )
          }, e.prototype.catch = function ( e ) {
            return this.then( void 0, e )
          }, e;
        } )() )();
      }

      function d( e ) {
        const t = new r.b;
        return new o.b( ( ( n, i, r ) => {
          const s = e( t.token );
          s instanceof o.b ? s.then( ( e => {
            t.dispose(), n( e )
          } ), ( e => {
            t.dispose(), i( e )
          } ), r ) : u( s ) ? s.then( ( e => {
            t.dispose(), n( e )
          } ), ( e => {
            t.dispose(), i( e )
          } ) ) : ( t.dispose(), n( s ) )
        } ), ( () => {
          t.cancel()
        } ) );
      }

      function h( e, t, n ) {
        const r = e.onCancellationRequested( ( () => {
          return t.cancel()
        } ) );
        return n && ( t = t.then( void 0, ( e => {
          if ( !i.d( e ) ) return o.b.wrapError( e )
        } ) ) ), _( t, ( () => {
          return r.dispose()
        } ) );
      }
      var p = ( () => {
          function e() {
            this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null
          }
          return e.prototype.queue = function ( e ) {
            const t = this;
            if ( this.activePromise ) {
              if ( this.queuedPromiseFactory = e, !this.queuedPromise ) {
                const n = () => {
                  t.queuedPromise = null;
                  const e = t.queue( t.queuedPromiseFactory );
                  return t.queuedPromiseFactory = null, e
                };
                this.queuedPromise = new o.b( ( ( e, i, o ) => {
                  t.activePromise.then( n, n, o ).done( e )
                } ), ( () => {
                  t.activePromise.cancel()
                } ) )
              }
              return new o.b( ( ( e, n, i ) => {
                t.queuedPromise.then( e, n, i )
              } ), ( () => {} ) );
            }
            return this.activePromise = e(), new o.b( ( ( e, n, i ) => {
              t.activePromise.done( ( n => {
                t.activePromise = null, e( n )
              } ), ( e => {
                t.activePromise = null, n( e )
              } ), i )
            } ), ( () => {
              t.activePromise.cancel()
            } ) );
          }, e;
        } )(),
        f = ( () => {
          function e( e ) {
            this.defaultDelay = e, this.timeout = null, this.completionPromise = null, this.onSuccess = null, this.task = null
          }
          return e.prototype.trigger = function ( e, t ) {
            const n = this;
            return void 0 === t && ( t = this.defaultDelay ), this.task = e, this.cancelTimeout(), this.completionPromise || ( this.completionPromise = new o.b( ( e => {
              n.onSuccess = e
            } ), ( () => {} ) ).then( ( () => {
              n.completionPromise = null, n.onSuccess = null;
              const e = n.task;
              return n.task = null, e()
            } ) ) ), this.timeout = setTimeout( ( () => {
              n.timeout = null, n.onSuccess( null )
            } ), t ), this.completionPromise;
          }, e.prototype.cancel = function () {
            this.cancelTimeout(), this.completionPromise && ( this.completionPromise.cancel(), this.completionPromise = null )
          }, e.prototype.cancelTimeout = function () {
            null !== this.timeout && ( clearTimeout( this.timeout ), this.timeout = null )
          }, e;
        } )(),
        g = ( e => {
          function t( t ) {
            let n, o, r, s;
            return n = e.call( this, ( ( e, t, n ) => {
              o = e, r = t, s = n
            } ), ( () => {
              r( i.a() )
            } ) ) || this, t.then( o, r, s ), n;
          }
          return a( t, e ), t
        } )( o.b );

      function m( e ) {
        return c( ( t => {
          return new Promise( ( ( n, o ) => {
            const r = setTimeout( n, e );
            t.onCancellationRequested( ( e => {
              clearTimeout( r ), o( i.a() )
            } ) )
          } ) );
        } ) );
      }

      function _( e, t ) {
        return n = e, o.b.is( n ) && "function" === typeof n.done ? new o.b( ( ( n, o, r ) => {
          e.done( ( e => {
            try {
              t( e )
            } catch ( o ) {
              i.e( o )
            }
            n( e )
          } ), ( e => {
            try {
              t( e )
            } catch ( n ) {
              i.e( n )
            }
            o( e )
          } ), ( e => {
            r( e )
          } ) )
        } ), ( () => {
          e.cancel()
        } ) ) : ( e.then( ( e => {
          return t()
        } ), ( e => {
          return t()
        } ) ), e );
        var n
      }

      function v( e, t, n ) {
        void 0 === t && ( t = e => {
          return !!e
        } ), void 0 === n && ( n = null );
        let i = 0;
        const o = e.length;
        const r = () => {
          return i >= o ? Promise.resolve( n ) : ( 0, e[ i++ ] )().then( ( e => {
            return t( e ) ? Promise.resolve( e ) : r()
          } ) );
        };
        return r()
      }

      function y( e, t, n ) {
        void 0 === t && ( t = e => {
          return !!e
        } ), void 0 === n && ( n = null );
        let i = 0;
        const r = e.length;
        const s = () => {
          return i >= r ? o.b.as( n ) : ( 0, e[ i++ ] )().then( ( e => {
            return t( e ) ? o.b.as( e ) : s()
          } ) );
        };
        return s()
      }

      function b( e, t ) {
        for ( var n = [], i = 2; i < arguments.length; i++ ) n[ i - 2 ] = arguments[ i ];
        const o = setTimeout.apply( void 0, [ e, t ].concat( n ) );
        return {
          dispose() {
            clearTimeout( o )
          }
        };
      }
      var C = ( e => {
          function t() {
            const t = e.call( this ) || this;
            return t._token = -1, t
          }
          return a( t, e ), t.prototype.dispose = function () {
            this.cancel(), e.prototype.dispose.call( this )
          }, t.prototype.cancel = function () {
            -1 !== this._token && ( clearTimeout( this._token ), this._token = -1 )
          }, t.prototype.cancelAndSet = function ( e, t ) {
            const n = this;
            this.cancel(), this._token = setTimeout( ( () => {
              n._token = -1, e()
            } ), t )
          }, t.prototype.setIfNotSet = function ( e, t ) {
            const n = this; - 1 === this._token && ( this._token = setTimeout( ( () => {
              n._token = -1, e()
            } ), t ) )
          }, t;
        } )( s.a ),
        w = ( e => {
          function t() {
            const t = e.call( this ) || this;
            return t._token = -1, t
          }
          return a( t, e ), t.prototype.dispose = function () {
            this.cancel(), e.prototype.dispose.call( this )
          }, t.prototype.cancel = function () {
            -1 !== this._token && ( clearInterval( this._token ), this._token = -1 )
          }, t.prototype.cancelAndSet = function ( e, t ) {
            this.cancel(), this._token = setInterval( ( () => {
              e()
            } ), t )
          }, t;
        } )( s.a ),
        S = ( () => {
          function e( e, t ) {
            this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind( this )
          }
          return e.prototype.dispose = function () {
            this.cancel(), this.runner = null
          }, e.prototype.cancel = function () {
            this.isScheduled() && ( clearTimeout( this.timeoutToken ), this.timeoutToken = -1 )
          }, e.prototype.schedule = function ( e ) {
            void 0 === e && ( e = this.timeout ), this.cancel(), this.timeoutToken = setTimeout( this.timeoutHandler, e )
          }, e.prototype.isScheduled = function () {
            return -1 !== this.timeoutToken
          }, e.prototype.onTimeout = function () {
            this.timeoutToken = -1, this.runner && this.doRun()
          }, e.prototype.doRun = function () {
            this.runner()
          }, e
        } )()
    },
    X8W9( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "g", ( () => {
        return o
      } ) ), n.d( t, "c", ( () => {
        return c
      } ) ), n.d( t, "d", ( () => {
        return d
      } ) ), n.d( t, "e", ( () => {
        return h
      } ) ), n.d( t, "b", ( () => {
        return p
      } ) ), n.d( t, "f", ( () => {
        return f
      } ) );
      var i;
      var o;
      const r = n( "MNsG" );
      const s = n( "/cxE" );
      const a = n( "EffR" );
      const u = n( "/kV6" );
      !( e => {
        e[ e.ON_MOUSE_DOWN = 0 ] = "ON_MOUSE_DOWN", e[ e.ON_MOUSE_UP = 1 ] = "ON_MOUSE_UP"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.SINGLE_CLICK = 0 ] = "SINGLE_CLICK", e[ e.DOUBLE_CLICK = 1 ] = "DOUBLE_CLICK"
      } )( o || ( o = {} ) );
      const l = ( () => {
        function e() {
          this._arr = []
        }
        return e.prototype.set = function ( e, t ) {
          this._arr.push( {
            keybinding: Object( u.f )( e, r.a ),
            callback: t
          } )
        }, e.prototype.dispatch = function ( e ) {
          for ( let t = this._arr.length - 1; t >= 0; t-- ) {
            const n = this._arr[ t ];
            if ( e.equals( n.keybinding ) ) return n.callback
          }
          return null
        }, e;
      } )();
      var c = ( () => {
        function e( e ) {
          void 0 === e && ( e = {
            clickBehavior: i.ON_MOUSE_DOWN,
            keyboardSupport: !0,
            openMode: o.SINGLE_CLICK
          } );
          const t = this;
          this.options = e, this.downKeyBindingDispatcher = new l, this.upKeyBindingDispatcher = new l, ( "boolean" !== typeof e.keyboardSupport || e.keyboardSupport ) && ( this.downKeyBindingDispatcher.set( 16, ( ( e, n ) => {
            return t.onUp( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 18, ( ( e, n ) => {
            return t.onDown( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 15, ( ( e, n ) => {
            return t.onLeft( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 17, ( ( e, n ) => {
            return t.onRight( e, n )
          } ) ), r.d && ( this.downKeyBindingDispatcher.set( 2064, ( ( e, n ) => {
            return t.onLeft( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 300, ( ( e, n ) => {
            return t.onDown( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 302, ( ( e, n ) => {
            return t.onUp( e, n )
          } ) ) ), this.downKeyBindingDispatcher.set( 11, ( ( e, n ) => {
            return t.onPageUp( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 12, ( ( e, n ) => {
            return t.onPageDown( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 14, ( ( e, n ) => {
            return t.onHome( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 13, ( ( e, n ) => {
            return t.onEnd( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 10, ( ( e, n ) => {
            return t.onSpace( e, n )
          } ) ), this.downKeyBindingDispatcher.set( 9, ( ( e, n ) => {
            return t.onEscape( e, n )
          } ) ), this.upKeyBindingDispatcher.set( 3, this.onEnter.bind( this ) ), this.upKeyBindingDispatcher.set( 2051, this.onEnter.bind( this ) ) )
        }
        return e.prototype.onMouseDown = function ( e, t, n, o ) {
          if ( void 0 === o && ( o = "mouse" ), this.options.clickBehavior === i.ON_MOUSE_DOWN && ( n.leftButton || n.middleButton ) ) {
            if ( n.target ) {
              if ( n.target.tagName && "input" === n.target.tagName.toLowerCase() ) return !1;
              if ( a.p( n.target, "scrollbar", "monaco-tree" ) ) return !1;
              if ( a.p( n.target, "monaco-action-bar", "row" ) ) return !1
            }
            return this.onLeftClick( e, t, n, o )
          }
          return !1
        }, e.prototype.onClick = function ( e, t, n ) {
          return r.d && n.ctrlKey ? ( n.preventDefault(), n.stopPropagation(), !1 ) : ( !n.target || !n.target.tagName || "input" !== n.target.tagName.toLowerCase() ) && ( ( this.options.clickBehavior !== i.ON_MOUSE_DOWN || !n.leftButton && !n.middleButton ) && this.onLeftClick( e, t, n ) )
        }, e.prototype.onLeftClick = function ( e, t, n, i ) {
          void 0 === i && ( i = "mouse" );
          const o = n,
            r = {
              origin: i,
              originalEvent: n,
              didClickOnTwistie: this.isClickOnTwistie( o )
            };
          e.getInput() === t ? ( e.clearFocus( r ), e.clearSelection( r ) ) : ( n && o.browserEvent && "mousedown" === o.browserEvent.type && 1 === o.browserEvent.detail || n.preventDefault(), n.stopPropagation(), e.domFocus(), e.setSelection( [ t ], r ), e.setFocus( t, r ), this.shouldToggleExpansion( t, o, i ) && ( e.isExpanded( t ) ? e.collapse( t ).done( null, s.e ) : e.expand( t ).done( null, s.e ) ) );
          return !0
        }, e.prototype.shouldToggleExpansion = function ( e, t, n ) {
          const i = "mouse" === n && 2 === t.detail;
          return this.openOnSingleClick || i || this.isClickOnTwistie( t )
        }, e.prototype.setOpenMode = function ( e ) {
          this.options.openMode = e
        }, Object.defineProperty( e.prototype, "openOnSingleClick", {
          get() {
            return this.options.openMode === o.SINGLE_CLICK
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.isClickOnTwistie = e => {
          const t = e.target;
          if ( !a.z( t, "content" ) ) return !1;
          const n = window.getComputedStyle( t, ":before" );
          if ( "none" === n.backgroundImage || "none" === n.display ) return !1;
          const i = parseInt( n.width ) + parseInt( n.paddingRight );
          return e.browserEvent.offsetX <= i
        }, e.prototype.onContextMenu = ( e, t, n ) => {
          return ( !n.target || !n.target.tagName || "input" !== n.target.tagName.toLowerCase() ) && ( n && ( n.preventDefault(), n.stopPropagation() ), !1 )
        }, e.prototype.onTap = function ( e, t, n ) {
          const i = n.initialTarget;
          return ( !i || !i.tagName || "input" !== i.tagName.toLowerCase() ) && this.onLeftClick( e, t, n, "touch" )
        }, e.prototype.onKeyDown = function ( e, t ) {
          return this.onKey( this.downKeyBindingDispatcher, e, t )
        }, e.prototype.onKeyUp = function ( e, t ) {
          return this.onKey( this.upKeyBindingDispatcher, e, t )
        }, e.prototype.onKey = ( e, t, n ) => {
          const i = e.dispatch( n.toKeybinding() );
          return !( !i || !i( t, n ) ) && ( n.preventDefault(), n.stopPropagation(), !0 )
        }, e.prototype.onUp = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          return e.getHighlight() ? e.clearHighlight( n ) : ( e.focusPrevious( 1, n ), e.reveal( e.getFocus() ).done( null, s.e ) ), !0
        }, e.prototype.onPageUp = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          return e.getHighlight() ? e.clearHighlight( n ) : ( e.focusPreviousPage( n ), e.reveal( e.getFocus() ).done( null, s.e ) ), !0
        }, e.prototype.onDown = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          return e.getHighlight() ? e.clearHighlight( n ) : ( e.focusNext( 1, n ), e.reveal( e.getFocus() ).done( null, s.e ) ), !0
        }, e.prototype.onPageDown = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          return e.getHighlight() ? e.clearHighlight( n ) : ( e.focusNextPage( n ), e.reveal( e.getFocus() ).done( null, s.e ) ), !0
        }, e.prototype.onHome = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          return e.getHighlight() ? e.clearHighlight( n ) : ( e.focusFirst( n ), e.reveal( e.getFocus() ).done( null, s.e ) ), !0
        }, e.prototype.onEnd = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          return e.getHighlight() ? e.clearHighlight( n ) : ( e.focusLast( n ), e.reveal( e.getFocus() ).done( null, s.e ) ), !0
        }, e.prototype.onLeft = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          if ( e.getHighlight() ) e.clearHighlight( n );
          else {
            const i = e.getFocus();
            e.collapse( i ).then( ( t => {
              if ( i && !t ) return e.focusParent( n ), e.reveal( e.getFocus() )
            } ) ).done( null, s.e )
          }
          return !0
        }, e.prototype.onRight = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          if ( e.getHighlight() ) e.clearHighlight( n );
          else {
            const i = e.getFocus();
            e.expand( i ).then( ( t => {
              if ( i && !t ) return e.focusFirstChild( n ), e.reveal( e.getFocus() )
            } ) ).done( null, s.e )
          }
          return !0
        }, e.prototype.onEnter = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          if ( e.getHighlight() ) return !1;
          const i = e.getFocus();
          return i && e.setSelection( [ i ], n ), !0
        }, e.prototype.onSpace = ( e, t ) => {
          if ( e.getHighlight() ) return !1;
          const n = e.getFocus();
          return n && e.toggleExpansion( n ), !0
        }, e.prototype.onEscape = ( e, t ) => {
          const n = {
            origin: "keyboard",
            originalEvent: t
          };
          return e.getHighlight() ? ( e.clearHighlight( n ), !0 ) : e.getSelection().length ? ( e.clearSelection( n ), !0 ) : !!e.getFocus() && ( e.clearFocus( n ), !0 )
        }, e;
      } )();
      var d = ( () => {
        function e() {}
        return e.prototype.getDragURI = ( e, t ) => {
          return null
        }, e.prototype.onDragStart = ( e, t, n ) => {}, e.prototype.onDragOver = ( e, t, n, i ) => {
          return null
        }, e.prototype.drop = ( e, t, n, i ) => {}, e;
      } )();
      var h = ( () => {
        function e() {}
        return e.prototype.isVisible = ( e, t ) => {
          return !0
        }, e;
      } )();
      var p = ( () => {
        function e() {}
        return e.prototype.getAriaLabel = ( e, t ) => {
          return null
        }, e;
      } )();
      var f = ( () => {
        function e( e, t ) {
          this.styleElement = e, this.selectorSuffix = t
        }
        return e.prototype.style = function ( e ) {
          const t = this.selectorSuffix ? "." + this.selectorSuffix : "",
            n = [];
          e.listFocusBackground && n.push( ".monaco-tree" + t + ".focused .monaco-tree-rows > .monaco-tree-row.focused:not(.highlighted) { background-color: " + e.listFocusBackground + "; }" ), e.listFocusForeground && n.push( ".monaco-tree" + t + ".focused .monaco-tree-rows > .monaco-tree-row.focused:not(.highlighted) { color: " + e.listFocusForeground + "; }" ), e.listActiveSelectionBackground && n.push( ".monaco-tree" + t + ".focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { background-color: " + e.listActiveSelectionBackground + "; }" ), e.listActiveSelectionForeground && n.push( ".monaco-tree" + t + ".focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { color: " + e.listActiveSelectionForeground + "; }" ), e.listFocusAndSelectionBackground && n.push( "\n\t\t\t\t.monaco-tree-drag-image,\n\t\t\t\t.monaco-tree" + t + ".focused .monaco-tree-rows > .monaco-tree-row.focused.selected:not(.highlighted) { background-color: " + e.listFocusAndSelectionBackground + "; }\n\t\t\t" ), e.listFocusAndSelectionForeground && n.push( "\n\t\t\t\t.monaco-tree-drag-image,\n\t\t\t\t.monaco-tree" + t + ".focused .monaco-tree-rows > .monaco-tree-row.focused.selected:not(.highlighted) { color: " + e.listFocusAndSelectionForeground + "; }\n\t\t\t" ), e.listInactiveSelectionBackground && n.push( ".monaco-tree" + t + " .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { background-color: " + e.listInactiveSelectionBackground + "; }" ), e.listInactiveSelectionForeground && n.push( ".monaco-tree" + t + " .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { color: " + e.listInactiveSelectionForeground + "; }" ), e.listHoverBackground && n.push( ".monaco-tree" + t + " .monaco-tree-rows > .monaco-tree-row:hover:not(.highlighted):not(.selected):not(.focused) { background-color: " + e.listHoverBackground + "; }" ), e.listHoverForeground && n.push( ".monaco-tree" + t + " .monaco-tree-rows > .monaco-tree-row:hover:not(.highlighted):not(.selected):not(.focused) { color: " + e.listHoverForeground + "; }" ), e.listDropBackground && n.push( "\n\t\t\t\t.monaco-tree" + t + " .monaco-tree-wrapper.drop-target,\n\t\t\t\t.monaco-tree" + t + " .monaco-tree-rows > .monaco-tree-row.drop-target { background-color: " + e.listDropBackground + " !important; color: inherit !important; }\n\t\t\t" ), e.listFocusOutline && n.push( "\n\t\t\t\t.monaco-tree-drag-image\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{ border: 1px solid " + e.listFocusOutline + "; background: #000; }\n\t\t\t\t.monaco-tree" + t + " .monaco-tree-rows > .monaco-tree-row \t\t\t\t\t\t\t\t\t\t\t\t\t\t{ border: 1px solid transparent; }\n\t\t\t\t.monaco-tree" + t + ".focused .monaco-tree-rows > .monaco-tree-row.focused:not(.highlighted) \t\t\t\t\t\t{ border: 1px dotted " + e.listFocusOutline + "; }\n\t\t\t\t.monaco-tree" + t + ".focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) \t\t\t\t\t\t{ border: 1px solid " + e.listFocusOutline + "; }\n\t\t\t\t.monaco-tree" + t + " .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted)  \t\t\t\t\t\t\t{ border: 1px solid " + e.listFocusOutline + "; }\n\t\t\t\t.monaco-tree" + t + " .monaco-tree-rows > .monaco-tree-row:hover:not(.highlighted):not(.selected):not(.focused)  \t{ border: 1px dashed " + e.listFocusOutline + "; }\n\t\t\t\t.monaco-tree" + t + " .monaco-tree-wrapper.drop-target,\n\t\t\t\t.monaco-tree" + t + " .monaco-tree-rows > .monaco-tree-row.drop-target\t\t\t\t\t\t\t\t\t\t\t\t{ border: 1px dashed " + e.listFocusOutline + "; }\n\t\t\t" );
          const i = n.join( "\n" );
          i !== this.styleElement.innerHTML && ( this.styleElement.innerHTML = i )
        }, e;
      } )();
    },
    XQgg( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "rust",
        extensions: [ ".rs", ".rlib" ],
        aliases: [ "Rust", "rust" ],
        loader() {
          return o.Promise.wrap( n.e( 299 ).then( n.bind( null, "/0xJ" ) ) )
        }
      } )
    },
    XSiN( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) ), n.d( t, "c", ( () => {
        return l
      } ) );
      const i = n( "MNsG" );
      const o = n( "D3Dy" );
      const r = n( "51f4" );
      const s = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var a = ( () => {
        function e( e ) {
          this.timestamp = Date.now(), this.browserEvent = e, this.leftButton = 0 === e.button, this.middleButton = 1 === e.button, this.rightButton = 2 === e.button, this.target = e.target, this.detail = e.detail || 1, "dblclick" === e.type && ( this.detail = 2 ), this.ctrlKey = e.ctrlKey, this.shiftKey = e.shiftKey, this.altKey = e.altKey, this.metaKey = e.metaKey, "number" === typeof e.pageX ? ( this.posx = e.pageX, this.posy = e.pageY ) : ( this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop );
          const t = r.a.getPositionOfChildWindowRelativeToAncestorWindow( self, e.view );
          this.posx -= t.left, this.posy -= t.top
        }
        return e.prototype.preventDefault = function () {
          this.browserEvent.preventDefault && this.browserEvent.preventDefault()
        }, e.prototype.stopPropagation = function () {
          this.browserEvent.stopPropagation && this.browserEvent.stopPropagation()
        }, e
      } )();
      var u = ( e => {
        function t( t ) {
          const n = e.call( this, t ) || this;
          return n.dataTransfer = t.dataTransfer, n
        }
        return s( t, e ), t
      } )( a );
      var l = ( () => {
        function e( e, t, n ) {
          if ( void 0 === t && ( t = 0 ), void 0 === n && ( n = 0 ), this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = n, this.deltaX = t, e ) {
            const r = e,
              s = e;
            "undefined" !== typeof r.wheelDeltaY ? this.deltaY = r.wheelDeltaY / 120 : "undefined" !== typeof s.VERTICAL_AXIS && s.axis === s.VERTICAL_AXIS && ( this.deltaY = -s.detail / 3 ), "undefined" !== typeof r.wheelDeltaX ? o.m && i.g ? this.deltaX = -r.wheelDeltaX / 120 : this.deltaX = r.wheelDeltaX / 120 : "undefined" !== typeof s.HORIZONTAL_AXIS && s.axis === s.HORIZONTAL_AXIS && ( this.deltaX = -e.detail / 3 ), 0 === this.deltaY && 0 === this.deltaX && e.wheelDelta && ( this.deltaY = e.wheelDelta / 120 )
          }
        }
        return e.prototype.preventDefault = function () {
          this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault()
        }, e.prototype.stopPropagation = function () {
          this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation()
        }, e
      } )();
    },
    XXBq( e, t, n ) {},
    XXUj( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "telemetryService" );
    },
    XtJs( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "editorWordHighlight", ( () => {
        return w
      } ) ), n.d( t, "editorWordHighlightStrong", ( () => {
        return S
      } ) ), n.d( t, "editorWordHighlightBorder", ( () => {
        return O
      } ) ), n.d( t, "editorWordHighlightStrongBorder", ( () => {
        return L
      } ) ), n.d( t, "overviewRulerWordHighlightForeground", ( () => {
        return x
      } ) ), n.d( t, "overviewRulerWordHighlightStrongForeground", ( () => {
        return N
      } ) ), n.d( t, "ctxHasWordHighlights", ( () => {
        return E
      } ) ), n.d( t, "getOccurrencesAtPosition", ( () => {
        return k
      } ) );
      const i = n( "3/fG" );
      const o = n( "X+cX" );
      const r = n( "/cxE" );
      const s = n( "aokT" );
      const a = n( "sswD" );
      const u = n( "twdY" );
      const l = n( "pmY6" );
      const c = n( "MD5Z" );
      const d = n( "t9D7" );
      const h = n( "uzpd" );
      const p = n( "tX9W" );
      const f = n( "T8No" );
      const g = n( "wQH0" );
      const m = n( "6OMU" );
      const _ = n( "M1Kb" );
      const v = n( "JQT/" );
      const y = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const b = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const C = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      var w = Object( c.kb )( "editor.wordHighlightBackground", {
        dark: "#575757B8",
        light: "#57575740",
        hc: null
      }, i.a( "wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque to not hide underlying decorations." ), !0 );
      var S = Object( c.kb )( "editor.wordHighlightStrongBackground", {
        dark: "#004972B8",
        light: "#0e639c40",
        hc: null
      }, i.a( "wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque to not hide underlying decorations." ), !0 );
      var O = Object( c.kb )( "editor.wordHighlightBorder", {
        light: null,
        dark: null,
        hc: c.b
      }, i.a( "wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable." ) );
      var L = Object( c.kb )( "editor.wordHighlightStrongBorder", {
        light: null,
        dark: null,
        hc: c.b
      }, i.a( "wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable." ) );
      var x = Object( c.kb )( "editorOverviewRuler.wordHighlightForeground", {
        dark: "#A0A0A0CC",
        light: "#A0A0A0CC",
        hc: "#A0A0A0CC"
      }, i.a( "overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque to not hide underlying decorations." ), !0 );
      var N = Object( c.kb )( "editorOverviewRuler.wordHighlightStrongForeground", {
        dark: "#C0A0C0CC",
        light: "#C0A0C0CC",
        hc: "#C0A0C0CC"
      }, i.a( "overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque to not hide underlying decorations." ), !0 );
      var E = new f.f( "hasWordHighlights", !1 );

      function k( e, t, n ) {
        const i = u.h.ordered( e );
        return Object( o.k )( i.map( ( i => {
          return () => {
            return Promise.resolve( i.provideDocumentHighlights( e, t, n ) ).then( void 0, r.f )
          };
        } ) ), ( e => {
          return !Object( m.k )( e )
        } ) );
      }
      Object( a.e )( "_executeDocumentHighlights", ( ( e, t ) => {
        return k( e, t, v.a.None )
      } ) );
      const I = ( () => {
          function e( e, t ) {
            const n = this;
            this.workerRequestTokenId = 0, this.workerRequest = null, this.workerRequestCompleted = !1, this.workerRequestValue = [], this.lastCursorPositionChangeTime = 0, this.renderDecorationsTimer = -1, this.editor = e, this._hasWordHighlights = E.bindTo( t ), this._ignorePositionChangeEvent = !1, this.occurrencesHighlight = this.editor.getConfiguration().contribInfo.occurrencesHighlight, this.model = this.editor.getModel(), this.toUnhook = [], this.toUnhook.push( e.onDidChangeCursorPosition( ( e => {
              n._ignorePositionChangeEvent || n.occurrencesHighlight && n._onPositionChanged( e )
            } ) ) ), this.toUnhook.push( e.onDidChangeModel( ( e => {
              n._stopAll(), n.model = n.editor.getModel()
            } ) ) ), this.toUnhook.push( e.onDidChangeModelContent( ( e => {
              n._stopAll()
            } ) ) ), this.toUnhook.push( e.onDidChangeConfiguration( ( e => {
              const t = n.editor.getConfiguration().contribInfo.occurrencesHighlight;
              n.occurrencesHighlight !== t && ( n.occurrencesHighlight = t, n._stopAll() )
            } ) ) ), this._lastWordRange = null, this._decorationIds = [], this.workerRequestTokenId = 0, this.workerRequest = null, this.workerRequestCompleted = !1, this.lastCursorPositionChangeTime = 0, this.renderDecorationsTimer = -1
          }
          return e.prototype.hasDecorations = function () {
            return this._decorationIds.length > 0
          }, e.prototype.restore = function () {
            this.occurrencesHighlight && this._run()
          }, e.prototype._getSortedHighlights = function () {
            const e = this;
            return this._decorationIds.map( ( t => {
              return e.model.getDecorationRange( t )
            } ) ).sort( s.a.compareRangesUsingStarts );
          }, e.prototype.moveNext = function () {
            const e = this,
              t = this._getSortedHighlights(),
              n = t[ ( Object( m.h )( t, ( t => {
                return t.containsPosition( e.editor.getPosition() )
              } ) ) + 1 ) % t.length ];
            try {
              this._ignorePositionChangeEvent = !0, this.editor.setPosition( n.getStartPosition() ), this.editor.revealRangeInCenterIfOutsideViewport( n )
            } finally {
              this._ignorePositionChangeEvent = !1
            }
          }, e.prototype.moveBack = function () {
            const e = this,
              t = this._getSortedHighlights(),
              n = t[ ( Object( m.h )( t, ( t => {
                return t.containsPosition( e.editor.getPosition() )
              } ) ) - 1 + t.length ) % t.length ];
            try {
              this._ignorePositionChangeEvent = !0, this.editor.setPosition( n.getStartPosition() ), this.editor.revealRangeInCenterIfOutsideViewport( n )
            } finally {
              this._ignorePositionChangeEvent = !1
            }
          }, e.prototype._removeDecorations = function () {
            this._decorationIds.length > 0 && ( this._decorationIds = this.editor.deltaDecorations( this._decorationIds, [] ), this._hasWordHighlights.set( !1 ) )
          }, e.prototype._stopAll = function () {
            this._lastWordRange = null, this._removeDecorations(), -1 !== this.renderDecorationsTimer && ( clearTimeout( this.renderDecorationsTimer ), this.renderDecorationsTimer = -1 ), null !== this.workerRequest && ( this.workerRequest.cancel(), this.workerRequest = null ), this.workerRequestCompleted || ( this.workerRequestTokenId++, this.workerRequestCompleted = !0 )
          }, e.prototype._onPositionChanged = function ( e ) {
            this.occurrencesHighlight && e.reason === h.a.Explicit ? this._run() : this._stopAll()
          }, e.prototype._run = function () {
            const e = this;
            if ( u.h.has( this.model ) ) {
              const t = this.editor.getSelection();
              if ( t.startLineNumber === t.endLineNumber ) {
                const n = t.startLineNumber,
                  i = t.startColumn,
                  a = t.endColumn,
                  l = this.model.getWordAtPosition( {
                    lineNumber: n,
                    column: i
                  } );
                if ( !l || l.startColumn > i || l.endColumn < a ) this._stopAll();
                else {
                  for ( var c = new s.a( n, l.startColumn, n, l.endColumn ), d = this._lastWordRange && this._lastWordRange.equalsRange( c ), h = 0, p = this._decorationIds.length; !d && h < p; h++ ) {
                    const f = this.model.getDecorationRange( this._decorationIds[ h ] );
                    f && f.startLineNumber === n && f.startColumn <= i && f.endColumn >= a && ( d = !0 )
                  }
                  if ( this.lastCursorPositionChangeTime = ( new Date ).getTime(), d ) this.workerRequestCompleted && -1 !== this.renderDecorationsTimer && ( clearTimeout( this.renderDecorationsTimer ), this.renderDecorationsTimer = -1, this._beginRenderDecorations() );
                  else {
                    this._stopAll();
                    const g = ++this.workerRequestTokenId;
                    this.workerRequestCompleted = !1, this.workerRequest = Object( o.i )( ( t => {
                      return k( e.model, e.editor.getPosition(), t )
                    } ) ), this.workerRequest.then( ( t => {
                      g === e.workerRequestTokenId && ( e.workerRequestCompleted = !0, e.workerRequestValue = t || [], e._beginRenderDecorations() )
                    } ), r.e )
                  }
                  this._lastWordRange = c
                }
              } else this._stopAll()
            } else this._stopAll()
          }, e.prototype._beginRenderDecorations = function () {
            const e = this,
              t = ( new Date ).getTime(),
              n = this.lastCursorPositionChangeTime + 250;
            t >= n ? ( this.renderDecorationsTimer = -1, this.renderDecorations() ) : this.renderDecorationsTimer = setTimeout( ( () => {
              e.renderDecorations()
            } ), n - t )
          }, e.prototype.renderDecorations = function () {
            this.renderDecorationsTimer = -1;
            for ( var t = [], n = 0, i = this.workerRequestValue.length; n < i; n++ ) {
              const o = this.workerRequestValue[ n ];
              t.push( {
                range: o.range,
                options: e._getDecorationOptions( o.kind )
              } )
            }
            this._decorationIds = this.editor.deltaDecorations( this._decorationIds, t ), this._hasWordHighlights.set( this.hasDecorations() )
          }, e._getDecorationOptions = function ( e ) {
            return e === u.g.Write ? this._WRITE_OPTIONS : e === u.g.Text ? this._TEXT_OPTIONS : this._REGULAR_OPTIONS
          }, e.prototype.dispose = function () {
            this._stopAll(), this.toUnhook = Object( l.d )( this.toUnhook )
          }, e._WRITE_OPTIONS = p.a.register( {
            stickiness: _.h.NeverGrowsWhenTypingAtEdges,
            className: "wordHighlightStrong",
            overviewRuler: {
              color: Object( d.f )( N ),
              darkColor: Object( d.f )( N ),
              position: _.f.Center
            }
          } ), e._TEXT_OPTIONS = p.a.register( {
            stickiness: _.h.NeverGrowsWhenTypingAtEdges,
            className: "selectionHighlight",
            overviewRuler: {
              color: Object( d.f )( c.gb ),
              darkColor: Object( d.f )( c.gb ),
              position: _.f.Center
            }
          } ), e._REGULAR_OPTIONS = p.a.register( {
            stickiness: _.h.NeverGrowsWhenTypingAtEdges,
            className: "wordHighlight",
            overviewRuler: {
              color: Object( d.f )( x ),
              darkColor: Object( d.f )( x ),
              position: _.f.Center
            }
          } ), e;
        } )(),
        D = ( () => {
          function e( e, t ) {
            this.wordHighligher = new I( e, t )
          }
          return e.get = t => {
            return t.getContribution( e.ID )
          }, e.prototype.getId = () => {
            return e.ID
          }, e.prototype.saveViewState = function () {
            return !!this.wordHighligher.hasDecorations()
          }, e.prototype.moveNext = function () {
            this.wordHighligher.moveNext()
          }, e.prototype.moveBack = function () {
            this.wordHighligher.moveBack()
          }, e.prototype.restoreViewState = function ( e ) {
            e && this.wordHighligher.restore()
          }, e.prototype.dispose = function () {
            this.wordHighligher.dispose()
          }, e.ID = "editor.contrib.wordHighlighter", e = b( [ C( 1, f.e ) ], e );
        } )(),
        M = ( e => {
          function t( t, n ) {
            const i = e.call( this, n ) || this;
            return i._isNext = t, i
          }
          return y( t, e ), t.prototype.run = function ( e, t ) {
            const n = D.get( t );
            n && ( this._isNext ? n.moveNext() : n.moveBack() )
          }, t;
        } )( a.b ),
        T = ( e => {
          function t() {
            return e.call( this, !0, {
              id: "editor.action.wordHighlight.next",
              label: i.a( "wordHighlight.next.label", "Go to Next Symbol Highlight" ),
              alias: "Go to Next Symbol Highlight",
              precondition: E,
              kbOpts: {
                kbExpr: g.a.editorTextFocus,
                primary: 65,
                weight: 100
              }
            } ) || this
          }
          return y( t, e ), t
        } )( M ),
        R = ( e => {
          function t() {
            return e.call( this, !1, {
              id: "editor.action.wordHighlight.prev",
              label: i.a( "wordHighlight.previous.label", "Go to Previous Symbol Highlight" ),
              alias: "Go to Previous Symbol Highlight",
              precondition: E,
              kbOpts: {
                kbExpr: g.a.editorTextFocus,
                primary: 1089,
                weight: 100
              }
            } ) || this
          }
          return y( t, e ), t
        } )( M );
      Object( a.h )( D ), Object( a.f )( T ), Object( a.f )( R ), Object( d.e )( ( ( e, t ) => {
        const n = e.getColor( c.B );
        n && ( t.addRule( ".monaco-editor .focused .selectionHighlight { background-color: " + n + "; }" ), t.addRule( ".monaco-editor .selectionHighlight { background-color: " + n.transparent( .5 ) + "; }" ) );
        const i = e.getColor( w );
        i && t.addRule( ".monaco-editor .wordHighlight { background-color: " + i + "; }" );
        const o = e.getColor( S );
        o && t.addRule( ".monaco-editor .wordHighlightStrong { background-color: " + o + "; }" );
        const r = e.getColor( c.C );
        r && t.addRule( ".monaco-editor .selectionHighlight { border: 1px " + ( "hc" === e.type ? "dotted" : "solid" ) + " " + r + "; box-sizing: border-box; }" );
        const s = e.getColor( O );
        s && t.addRule( ".monaco-editor .wordHighlight { border: 1px " + ( "hc" === e.type ? "dashed" : "solid" ) + " " + s + "; box-sizing: border-box; }" );
        const a = e.getColor( L );
        a && t.addRule( ".monaco-editor .wordHighlightStrong { border: 1px " + ( "hc" === e.type ? "dashed" : "solid" ) + " " + a + "; box-sizing: border-box; }" )
      } ) )
    },
    YHy6( e, t, n ) {},
    YcIv( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "T8No" );
      var o = ( () => {
        function e( t, n ) {
          this._defaultKeybindings = t, this._defaultBoundCommands = new Map;
          for ( var i = 0, o = t.length; i < o; i++ ) {
            const r = t[ i ].command;
            this._defaultBoundCommands.set( r, !0 )
          }
          this._map = new Map, this._lookupMap = new Map, this._keybindings = e.combine( t, n );
          for ( i = 0, o = this._keybindings.length; i < o; i++ ) {
            const s = this._keybindings[ i ];
            null !== s.keypressFirstPart && this._addKeyPress( s.keypressFirstPart, s )
          }
        }
        return e._isTargetedForRemoval = ( e, t, n, i, o ) => {
          if ( e.command !== i ) return !1;
          if ( t && e.keypressFirstPart !== t ) return !1;
          if ( n && e.keypressChordPart !== n ) return !1;
          if ( o ) {
            if ( !e.when ) return !1;
            if ( !o.equals( e.when ) ) return !1
          }
          return !0
        }, e.combine = function ( e, t ) {
          e = e.slice( 0 );
          for ( var n = [], i = 0, o = t.length; i < o; i++ ) {
            const r = t[ i ];
            if ( r.command && 0 !== r.command.length && "-" === r.command.charAt( 0 ) )
              for ( let s = r.command.substr( 1 ), a = r.keypressFirstPart, u = r.keypressChordPart, l = r.when, c = e.length - 1; c >= 0; c-- ) this._isTargetedForRemoval( e[ c ], a, u, s, l ) && e.splice( c, 1 );
            else n.push( r )
          }
          return e.concat( n )
        }, e.prototype._addKeyPress = function ( t, n ) {
          const i = this._map.get( t );
          if ( "undefined" === typeof i ) return this._map.set( t, [ n ] ), void this._addToLookupMap( n );
          for ( let o = i.length - 1; o >= 0; o-- ) {
            const r = i[ o ];
            if ( r.command !== n.command ) {
              const s = null !== r.keypressChordPart,
                a = null !== n.keypressChordPart;
              s && a && r.keypressChordPart !== n.keypressChordPart || e.whenIsEntirelyIncluded( r.when, n.when ) && this._removeFromLookupMap( r )
            }
          }
          i.push( n ), this._addToLookupMap( n )
        }, e.prototype._addToLookupMap = function ( e ) {
          if ( e.command ) {
            let t = this._lookupMap.get( e.command );
            "undefined" === typeof t ? ( t = [ e ], this._lookupMap.set( e.command, t ) ) : t.push( e )
          }
        }, e.prototype._removeFromLookupMap = function ( e ) {
          const t = this._lookupMap.get( e.command );
          if ( "undefined" !== typeof t )
            for ( let n = 0, i = t.length; n < i; n++ )
              if ( t[ n ] === e ) return void t.splice( n, 1 )
        }, e.whenIsEntirelyIncluded = ( e, t ) => {
          if ( !t ) return !0;
          if ( !e ) return !1;
          for ( let n = e instanceof i.a ? e.expr : [ e ], o = t instanceof i.a ? t.expr : [ t ], r = 0, s = 0; s < o.length; s++ ) {
            for ( var a = o[ s ], u = !1; !u && r < n.length; ) {
              n[ r ].equals( a ) && ( u = !0 ), r++
            }
            if ( !u ) return !1
          }
          return !0
        }, e.prototype.lookupPrimaryKeybinding = function ( e ) {
          const t = this._lookupMap.get( e );
          return "undefined" === typeof t || 0 === t.length ? null : t[ t.length - 1 ]
        }, e.prototype.resolve = function ( e, t, n ) {
          let i = null;
          if ( null !== t ) {
            if ( "undefined" === typeof ( a = this._map.get( t ) ) ) return null;
            i = [];
            for ( let o = 0, r = a.length; o < r; o++ ) {
              const s = a[ o ];
              s.keypressChordPart === n && i.push( s )
            }
          } else {
            var a;
            if ( "undefined" === typeof ( a = this._map.get( n ) ) ) return null;
            i = a
          }
          const u = this._findCommand( e, i );
          return u ? null === t && null !== u.keypressChordPart ? {
            enterChord: !0,
            commandId: null,
            commandArgs: null,
            bubble: !1
          } : {
            enterChord: !1,
            commandId: u.command,
            commandArgs: u.commandArgs,
            bubble: u.bubble
          } : null
        }, e.prototype._findCommand = ( t, n ) => {
          for ( let i = n.length - 1; i >= 0; i-- ) {
            const o = n[ i ];
            if ( e.contextMatchesRules( t, o.when ) ) return o
          }
          return null
        }, e.contextMatchesRules = ( e, t ) => {
          return !t || t.evaluate( e )
        }, e;
      } )();
    },
    Yr1X( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "MI8n" );
      var o = new( ( () => {
        function e() {
          this._zoomLevel = 0, this._onDidChangeZoomLevel = new i.a, this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event
        }
        return e.prototype.getZoomLevel = function () {
          return this._zoomLevel
        }, e.prototype.setZoomLevel = function ( e ) {
          e = Math.min( Math.max( -5, e ), 20 ), this._zoomLevel !== e && ( this._zoomLevel = e, this._onDidChangeZoomLevel.fire( this._zoomLevel ) )
        }, e
      } )() )();
    },
    ZCR3( e, t, n ) {
      "use strict";

      function i( e, t, n ) {
        let i = null,
          o = null;
        if ( "function" === typeof n.value ? ( i = "value", 0 !== ( o = n.value ).length && console.warn( "Memoize should only be used in functions with zero parameters" ) ) : "function" === typeof n.get && ( i = "get", o = n.get ), !o ) throw new Error( "not supported" );
        const r = "$memoize$" + t;
        n[ i ] = function () {
          for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
          return this.hasOwnProperty( r ) || Object.defineProperty( this, r, {
            configurable: !1,
            enumerable: !1,
            writable: !1,
            value: o.apply( this, e )
          } ), this[ r ]
        }
      }
      n.d( t, "a", ( () => {
        return i
      } ) )
    },
    ZIMw( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return d
      } ) ), n.d( t, "a", ( () => {
        return h
      } ) );
      const i = n( "bY76" ),
        o = n( "VMIq" ),
        r = n( "twdY" ),
        s = n( "X+cX" ),
        a = n( "sswD" ),
        u = n( "aokT" ),
        l = n( "/cxE" ),
        c = n( "G2kB" );

      function d( e, t ) {
        const n = [],
          i = r.d.ordered( e ).reverse().map( ( i => {
            return Promise.resolve( i.provideDocumentColors( e, t ) ).then( ( e => {
              if ( Array.isArray( e ) )
                for ( let t = 0, o = e; t < o.length; t++ ) {
                  const r = o[ t ];
                  n.push( {
                    colorInfo: r,
                    provider: i
                  } )
                }
            } ) );
          } ) );
        return Promise.all( i ).then( ( () => {
          return n
        } ) );
      }

      function h( e, t, n, i ) {
        return Promise.resolve( n.provideColorPresentations( e, t, i ) )
      }
      Object( a.j )( "_executeDocumentColorProvider", ( ( e, t ) => {
        const n = t.resource;
        if ( !( n instanceof i.a ) ) throw Object( l.b )();
        const a = e.get( c.a ).getModel( n );
        if ( !a ) throw Object( l.b )();
        const u = [],
          d = r.d.ordered( a ).reverse().map( ( e => {
            return Object( s.h )( ( t => {
              return e.provideDocumentColors( a, t )
            } ) ).then( ( e => {
              if ( Array.isArray( e ) )
                for ( let t = 0, n = e; t < n.length; t++ ) {
                  const i = n[ t ];
                  u.push( {
                    range: i.range,
                    color: [ i.color.red, i.color.green, i.color.blue, i.color.alpha ]
                  } )
                }
            } ) );
          } ) );
        return o.b.join( d ).then( ( () => {
          return u
        } ) );
      } ) ), Object( a.j )( "_executeColorPresentationProvider", ( ( e, t ) => {
        const n = t.resource,
          a = t.color,
          d = t.range;
        if ( !( n instanceof i.a ) || !Array.isArray( a ) || 4 !== a.length || !u.a.isIRange( d ) ) throw Object( l.b )();
        const h = a[ 0 ],
          p = a[ 1 ],
          f = a[ 2 ],
          g = a[ 3 ],
          m = e.get( c.a ).getModel( n );
        if ( !m ) throw Object( l.b )();
        const _ = {
            range: d,
            color: {
              red: h,
              green: p,
              blue: f,
              alpha: g
            }
          },
          v = [],
          y = r.d.ordered( m ).reverse().map( ( e => {
            return Object( s.h )( ( t => {
              return e.provideColorPresentations( m, _, t )
            } ) ).then( ( e => {
              Array.isArray( e ) && v.push.apply( v, e )
            } ) );
          } ) );
        return o.b.join( y ).then( ( () => {
          return v
        } ) );
      } ) )
    },
    "ZkA/": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "mips",
        extensions: [ ".s" ],
        aliases: [ "MIPS", "MIPS-V" ],
        mimetypes: [ "text/x-mips", "text/mips", "text/plaintext" ],
        loader() {
          return o.Promise.wrap( n.e( 278 ).then( n.bind( null, "DTUS" ) ) )
        }
      } )
    },
    ZlPH( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) );
      const i = n( "EffR" );
      var o = ( () => {
        function e( e ) {
          this.domNode = e, this._maxWidth = -1, this._width = -1, this._height = -1, this._top = -1, this._left = -1, this._bottom = -1, this._right = -1, this._fontFamily = "", this._fontWeight = "", this._fontSize = -1, this._lineHeight = -1, this._letterSpacing = -100, this._className = "", this._display = "", this._position = "", this._visibility = "", this._layerHint = !1
        }
        return e.prototype.setMaxWidth = function ( e ) {
          this._maxWidth !== e && ( this._maxWidth = e, this.domNode.style.maxWidth = this._maxWidth + "px" )
        }, e.prototype.setWidth = function ( e ) {
          this._width !== e && ( this._width = e, this.domNode.style.width = this._width + "px" )
        }, e.prototype.setHeight = function ( e ) {
          this._height !== e && ( this._height = e, this.domNode.style.height = this._height + "px" )
        }, e.prototype.setTop = function ( e ) {
          this._top !== e && ( this._top = e, this.domNode.style.top = this._top + "px" )
        }, e.prototype.unsetTop = function () {
          -1 !== this._top && ( this._top = -1, this.domNode.style.top = "" )
        }, e.prototype.setLeft = function ( e ) {
          this._left !== e && ( this._left = e, this.domNode.style.left = this._left + "px" )
        }, e.prototype.setBottom = function ( e ) {
          this._bottom !== e && ( this._bottom = e, this.domNode.style.bottom = this._bottom + "px" )
        }, e.prototype.setRight = function ( e ) {
          this._right !== e && ( this._right = e, this.domNode.style.right = this._right + "px" )
        }, e.prototype.setFontFamily = function ( e ) {
          this._fontFamily !== e && ( this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily )
        }, e.prototype.setFontWeight = function ( e ) {
          this._fontWeight !== e && ( this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight )
        }, e.prototype.setFontSize = function ( e ) {
          this._fontSize !== e && ( this._fontSize = e, this.domNode.style.fontSize = this._fontSize + "px" )
        }, e.prototype.setLineHeight = function ( e ) {
          this._lineHeight !== e && ( this._lineHeight = e, this.domNode.style.lineHeight = this._lineHeight + "px" )
        }, e.prototype.setLetterSpacing = function ( e ) {
          this._letterSpacing !== e && ( this._letterSpacing = e, this.domNode.style.letterSpacing = this._letterSpacing + "px" )
        }, e.prototype.setClassName = function ( e ) {
          this._className !== e && ( this._className = e, this.domNode.className = this._className )
        }, e.prototype.toggleClassName = function ( e, t ) {
          i.N( this.domNode, e, t ), this._className = this.domNode.className
        }, e.prototype.setDisplay = function ( e ) {
          this._display !== e && ( this._display = e, this.domNode.style.display = this._display )
        }, e.prototype.setPosition = function ( e ) {
          this._position !== e && ( this._position = e, this.domNode.style.position = this._position )
        }, e.prototype.setVisibility = function ( e ) {
          this._visibility !== e && ( this._visibility = e, this.domNode.style.visibility = this._visibility )
        }, e.prototype.setLayerHinting = function ( e ) {
          this._layerHint !== e && ( this._layerHint = e, this.domNode.style.willChange = this._layerHint ? "transform" : "auto" )
        }, e.prototype.setAttribute = function ( e, t ) {
          this.domNode.setAttribute( e, t )
        }, e.prototype.removeAttribute = function ( e ) {
          this.domNode.removeAttribute( e )
        }, e.prototype.appendChild = function ( e ) {
          this.domNode.appendChild( e.domNode )
        }, e.prototype.removeChild = function ( e ) {
          this.domNode.removeChild( e.domNode )
        }, e
      } )();

      function r( e ) {
        return new o( e )
      }
    },
    ZvGG( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "lua",
        extensions: [ ".lua" ],
        aliases: [ "Lua", "lua" ],
        loader() {
          return o.Promise.wrap( n.e( 276 ).then( n.bind( null, "yUwd" ) ) )
        }
      } )
    },
    ajgA( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "razor",
        extensions: [ ".cshtml" ],
        aliases: [ "Razor", "razor" ],
        mimetypes: [ "text/x-cshtml" ],
        loader() {
          return o.Promise.wrap( n.e( 294 ).then( n.bind( null, "Fzfo" ) ) )
        }
      } )
    },
    alCU( e, t, n ) {},
    aokT( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "cGHE" );

      var o = ( () => {
        function e( e, t, n, i ) {
          e > n || e === n && t > i ? ( this.startLineNumber = n, this.startColumn = i, this.endLineNumber = e, this.endColumn = t ) : ( this.startLineNumber = e, this.startColumn = t, this.endLineNumber = n, this.endColumn = i )
        }
        return e.prototype.isEmpty = function () {
          return e.isEmpty( this )
        }, e.isEmpty = e => {
          return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn
        }, e.prototype.containsPosition = function ( t ) {
          return e.containsPosition( this, t )
        }, e.containsPosition = ( e, t ) => {
          return !( t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber ) && ( !( t.lineNumber === e.startLineNumber && t.column < e.startColumn ) && !( t.lineNumber === e.endLineNumber && t.column > e.endColumn ) )
        }, e.prototype.containsRange = function ( t ) {
          return e.containsRange( this, t )
        }, e.containsRange = ( e, t ) => {
          return !( t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber ) && ( !( t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber ) && ( !( t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn ) && !( t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn ) ) )
        }, e.prototype.plusRange = function ( t ) {
          return e.plusRange( this, t )
        }, e.plusRange = ( t, n ) => {
          let i, o, r, s;
          return n.startLineNumber < t.startLineNumber ? ( i = n.startLineNumber, o = n.startColumn ) : n.startLineNumber === t.startLineNumber ? ( i = n.startLineNumber, o = Math.min( n.startColumn, t.startColumn ) ) : ( i = t.startLineNumber, o = t.startColumn ), n.endLineNumber > t.endLineNumber ? ( r = n.endLineNumber, s = n.endColumn ) : n.endLineNumber === t.endLineNumber ? ( r = n.endLineNumber, s = Math.max( n.endColumn, t.endColumn ) ) : ( r = t.endLineNumber, s = t.endColumn ), new e( i, o, r, s )
        }, e.prototype.intersectRanges = function ( t ) {
          return e.intersectRanges( this, t )
        }, e.intersectRanges = ( t, n ) => {
          let i = t.startLineNumber;
          let o = t.startColumn;
          let r = t.endLineNumber;
          let s = t.endColumn;
          const a = n.startLineNumber;
          const u = n.startColumn;
          const l = n.endLineNumber;
          const c = n.endColumn;
          return i < a ? ( i = a, o = u ) : i === a && ( o = Math.max( o, u ) ), r > l ? ( r = l, s = c ) : r === l && ( s = Math.min( s, c ) ), i > r ? null : i === r && o > s ? null : new e( i, o, r, s )
        }, e.prototype.equalsRange = function ( t ) {
          return e.equalsRange( this, t )
        }, e.equalsRange = ( e, t ) => {
          return !!e && !!t && e.startLineNumber === t.startLineNumber && e.startColumn === t.startColumn && e.endLineNumber === t.endLineNumber && e.endColumn === t.endColumn
        }, e.prototype.getEndPosition = function () {
          return new i.a( this.endLineNumber, this.endColumn )
        }, e.prototype.getStartPosition = function () {
          return new i.a( this.startLineNumber, this.startColumn )
        }, e.prototype.toString = function () {
          return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]"
        }, e.prototype.setEndPosition = function ( t, n ) {
          return new e( this.startLineNumber, this.startColumn, t, n )
        }, e.prototype.setStartPosition = function ( t, n ) {
          return new e( t, n, this.endLineNumber, this.endColumn )
        }, e.prototype.collapseToStart = function () {
          return e.collapseToStart( this )
        }, e.collapseToStart = t => {
          return new e( t.startLineNumber, t.startColumn, t.startLineNumber, t.startColumn )
        }, e.fromPositions = ( t, n ) => {
          return void 0 === n && ( n = t ), new e( t.lineNumber, t.column, n.lineNumber, n.column )
        }, e.lift = t => {
          return t ? new e( t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn ) : null
        }, e.isIRange = e => {
          return e && "number" === typeof e.startLineNumber && "number" === typeof e.startColumn && "number" === typeof e.endLineNumber && "number" === typeof e.endColumn
        }, e.areIntersectingOrTouching = ( e, t ) => {
          return !( e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn ) && !( t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn )
        }, e.areIntersecting = ( e, t ) => {
          return !( e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn ) && !( t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn )
        }, e.compareRangesUsingStarts = ( e, t ) => {
          const n = 0 | e.startLineNumber,
            i = 0 | t.startLineNumber;
          if ( n === i ) {
            const o = 0 | e.startColumn,
              r = 0 | t.startColumn;
            if ( o === r ) {
              const s = 0 | e.endLineNumber,
                a = 0 | t.endLineNumber;
              return s === a ? ( 0 | e.endColumn ) - ( 0 | t.endColumn ) : s - a
            }
            return o - r
          }
          return n - i
        }, e.compareRangesUsingEnds = ( e, t ) => {
          return e.endLineNumber === t.endLineNumber ? e.endColumn === t.endColumn ? e.startLineNumber === t.startLineNumber ? e.startColumn - t.startColumn : e.startLineNumber - t.startLineNumber : e.endColumn - t.endColumn : e.endLineNumber - t.endLineNumber
        }, e.spansMultipleLines = e => {
          return e.endLineNumber > e.startLineNumber
        }, e;
      } )();
    },
    bY76( e, t, n ) {
      "use strict";
      let i;
      const o = n( "MNsG" );
      const r = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const s = /^\w[\w\d+.-]*$/;
      const a = /^\//;
      const u = /^\/\//;
      const l = "",
        c = "/",
        d = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
        h = ( () => {
          function e( e, t, n, i, o ) {
            "object" === typeof e ? ( this.scheme = e.scheme || l, this.authority = e.authority || l, this.path = e.path || l, this.query = e.query || l, this.fragment = e.fragment || l ) : ( this.scheme = e || l, this.authority = t || l, this.path = ( ( e, t ) => {
              switch ( e ) {
                case "https":
                case "http":
                case "file":
                  t ? t[ 0 ] !== c && ( t = c + t ) : t = c
              }
              return t
            } )( this.scheme, n || l ), this.query = i || l, this.fragment = o || l, ( e => {
              if ( e.scheme && !s.test( e.scheme ) ) throw new Error( "[UriError]: Scheme contains illegal characters." );
              if ( e.path )
                if ( e.authority ) {
                  if ( !a.test( e.path ) ) throw new Error( '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character' )
                } else if ( u.test( e.path ) ) throw new Error( '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")' )
            } )( this ) )
          }
          return e.isUri = t => {
            return t instanceof e || !!t && ( "string" === typeof t.authority && "string" === typeof t.fragment && "string" === typeof t.path && "string" === typeof t.query && "string" === typeof t.scheme )
          }, Object.defineProperty( e.prototype, "fsPath", {
            get() {
              return _( this )
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.with = function ( e ) {
            if ( !e ) return this;
            let t = e.scheme,
              n = e.authority,
              i = e.path,
              o = e.query,
              r = e.fragment;
            return void 0 === t ? t = this.scheme : null === t && ( t = l ), void 0 === n ? n = this.authority : null === n && ( n = l ), void 0 === i ? i = this.path : null === i && ( i = l ), void 0 === o ? o = this.query : null === o && ( o = l ), void 0 === r ? r = this.fragment : null === r && ( r = l ), t === this.scheme && n === this.authority && i === this.path && o === this.query && r === this.fragment ? this : new p( t, n, i, o, r )
          }, e.parse = e => {
            const t = d.exec( e );
            return t ? new p( t[ 2 ] || l, decodeURIComponent( t[ 4 ] || l ), decodeURIComponent( t[ 5 ] || l ), decodeURIComponent( t[ 7 ] || l ), decodeURIComponent( t[ 9 ] || l ) ) : new p( l, l, l, l, l )
          }, e.file = e => {
            let t = l;
            if ( o.g && ( e = e.replace( /\\/g, c ) ), e[ 0 ] === c && e[ 1 ] === c ) {
              const n = e.indexOf( c, 2 ); - 1 === n ? ( t = e.substring( 2 ), e = c ) : ( t = e.substring( 2, n ), e = e.substring( n ) || c )
            }
            return new p( "file", t, e, l, l )
          }, e.from = e => {
            return new p( e.scheme, e.authority, e.path, e.query, e.fragment )
          }, e.prototype.toString = function ( e ) {
            return void 0 === e && ( e = !1 ), v( this, e )
          }, e.prototype.toJSON = function () {
            return this
          }, e.revive = t => {
            if ( t ) {
              if ( t instanceof e ) return t;
              const n = new p( t );
              return n._fsPath = t.fsPath, n._formatted = t.external, n
            }
            return t
          }, e;
        } )();
      t.a = h;
      var p = ( e => {
        function t() {
          const t = null !== e && e.apply( this, arguments ) || this;
          return t._formatted = null, t._fsPath = null, t
        }
        return r( t, e ), Object.defineProperty( t.prototype, "fsPath", {
          get() {
            return this._fsPath || ( this._fsPath = _( this ) ), this._fsPath
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.toString = function ( e ) {
          return void 0 === e && ( e = !1 ), e ? v( this, !0 ) : ( this._formatted || ( this._formatted = v( this, !1 ) ), this._formatted )
        }, t.prototype.toJSON = function () {
          const e = {
            $mid: 1
          };
          return this._fsPath && ( e.fsPath = this._fsPath ), this._formatted && ( e.external = this._formatted ), this.path && ( e.path = this.path ), this.scheme && ( e.scheme = this.scheme ), this.authority && ( e.authority = this.authority ), this.query && ( e.query = this.query ), this.fragment && ( e.fragment = this.fragment ), e
        }, t;
      } )( h );
      const f = ( ( i = {} )[ 58 ] = "%3A", i[ 47 ] = "%2F", i[ 63 ] = "%3F", i[ 35 ] = "%23", i[ 91 ] = "%5B", i[ 93 ] = "%5D", i[ 64 ] = "%40", i[ 33 ] = "%21", i[ 36 ] = "%24", i[ 38 ] = "%26", i[ 39 ] = "%27", i[ 40 ] = "%28", i[ 41 ] = "%29", i[ 42 ] = "%2A", i[ 43 ] = "%2B", i[ 44 ] = "%2C", i[ 59 ] = "%3B", i[ 61 ] = "%3D", i[ 32 ] = "%20", i );

      function g( e, t ) {
        for ( var n = void 0, i = -1, o = 0; o < e.length; o++ ) {
          const r = e.charCodeAt( o );
          if ( r >= 97 && r <= 122 || r >= 65 && r <= 90 || r >= 48 && r <= 57 || 45 === r || 46 === r || 95 === r || 126 === r || t && 47 === r ) - 1 !== i && ( n += encodeURIComponent( e.substring( i, o ) ), i = -1 ), void 0 !== n && ( n += e.charAt( o ) );
          else {
            void 0 === n && ( n = e.substr( 0, o ) );
            const s = f[ r ];
            void 0 !== s ? ( -1 !== i && ( n += encodeURIComponent( e.substring( i, o ) ), i = -1 ), n += s ) : -1 === i && ( i = o )
          }
        }
        return -1 !== i && ( n += encodeURIComponent( e.substring( i ) ) ), void 0 !== n ? n : e
      }

      function m( e ) {
        for ( var t = void 0, n = 0; n < e.length; n++ ) {
          const i = e.charCodeAt( n );
          35 === i || 63 === i ? ( void 0 === t && ( t = e.substr( 0, n ) ), t += f[ i ] ) : void 0 !== t && ( t += e[ n ] )
        }
        return void 0 !== t ? t : e
      }

      function _( e ) {
        let t;
        return t = e.authority && e.path.length > 1 && "file" === e.scheme ? "//" + e.authority + e.path : 47 === e.path.charCodeAt( 0 ) && ( e.path.charCodeAt( 1 ) >= 65 && e.path.charCodeAt( 1 ) <= 90 || e.path.charCodeAt( 1 ) >= 97 && e.path.charCodeAt( 1 ) <= 122 ) && 58 === e.path.charCodeAt( 2 ) ? e.path[ 1 ].toLowerCase() + e.path.substr( 2 ) : e.path, o.g && ( t = t.replace( /\//g, "\\" ) ), t
      }

      function v( e, t ) {
        const n = t ? m : g;
        let i = "";
        const o = e.scheme;
        let r = e.authority;
        let s = e.path;
        const a = e.query;
        const u = e.fragment;
        if ( o && ( i += o, i += ":" ), ( r || "file" === o ) && ( i += c, i += c ), r ) {
          let l = r.indexOf( "@" );
          if ( -1 !== l ) {
            const d = r.substr( 0, l );
            r = r.substr( l + 1 ), -1 === ( l = d.indexOf( ":" ) ) ? i += n( d, !1 ) : ( i += n( d.substr( 0, l ), !1 ), i += ":", i += n( d.substr( l + 1 ), !1 ) ), i += "@"
          } - 1 === ( l = ( r = r.toLowerCase() ).indexOf( ":" ) ) ? i += n( r, !1 ) : ( i += n( r.substr( 0, l ), !1 ), i += r.substr( l ) )
        }
        if ( s ) {
          if ( s.length >= 3 && 47 === s.charCodeAt( 0 ) && 58 === s.charCodeAt( 2 ) )( h = s.charCodeAt( 1 ) ) >= 65 && h <= 90 && ( s = "/" + String.fromCharCode( h + 32 ) + ":" + s.substr( 3 ) );
          else if ( s.length >= 2 && 58 === s.charCodeAt( 1 ) ) {
            var h;
            ( h = s.charCodeAt( 0 ) ) >= 65 && h <= 90 && ( s = String.fromCharCode( h + 32 ) + ":" + s.substr( 2 ) )
          }
          i += n( s, !0 )
        }
        return a && ( i += "?", i += n( a, !1 ) ), u && ( i += "#", i += t ? u : g( u, !1 ) ), i
      }
    },
    ba9Q( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "N0LK" ),
        r = n( "aokT" ),
        s = n( "cGHE" ),
        a = n( "wQH0" ),
        u = n( "sswD" ),
        l = n( "LCkn" ),
        c = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        d = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.transposeLetters",
              label: i.a( "transposeLetters.label", "Transpose Letters" ),
              alias: "Transpose Letters",
              precondition: a.a.writable,
              kbOpts: {
                kbExpr: a.a.textInputFocus,
                primary: 0,
                mac: {
                  primary: 306
                },
                weight: 100
              }
            } ) || this
          }
          return c( t, e ), t.prototype.positionLeftOf = ( e, t ) => {
            let n = e.column,
              i = e.lineNumber;
            return n > t.getLineMinColumn( i ) ? Object( o.isLowSurrogate )( t.getLineContent( i ).charCodeAt( n - 2 ) ) ? n -= 2 : n -= 1 : i > 1 && ( i -= 1, n = t.getLineMaxColumn( i ) ), new s.a( i, n )
          }, t.prototype.positionRightOf = ( e, t ) => {
            let n = e.column,
              i = e.lineNumber;
            return n < t.getLineMaxColumn( i ) ? Object( o.isHighSurrogate )( t.getLineContent( i ).charCodeAt( n - 1 ) ) ? n += 2 : n += 1 : i < t.getLineCount() && ( i += 1, n = 0 ), new s.a( i, n )
          }, t.prototype.run = function ( e, t ) {
            for ( var n = t.getModel(), i = [], o = 0, s = t.getSelections(); o < s.length; o++ ) {
              const a = s[ o ];
              if ( a.isEmpty() ) {
                const u = a.startLineNumber,
                  c = a.startColumn,
                  d = n.getLineMaxColumn( u );
                if ( 1 !== u || 1 !== c && ( 2 !== c || 2 !== d ) ) {
                  const h = c === d ? a.getPosition() : this.positionRightOf( a.getPosition(), n ),
                    p = this.positionLeftOf( h, n ),
                    f = this.positionLeftOf( p, n ),
                    g = n.getValueInRange( r.a.fromPositions( f, p ) ),
                    m = n.getValueInRange( r.a.fromPositions( p, h ) ),
                    _ = r.a.fromPositions( f, h );
                  i.push( new l.a( _, m + g ) )
                }
              }
            }
            i.length > 0 && ( t.pushUndoStop(), t.executeCommands( this.id, i ), t.pushUndoStop() )
          }, t;
        } )( u.b );
      Object( u.f )( d )
    },
    baJR( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) ), n.d( t, "c", ( () => {
        return c
      } ) ), n.d( t, "d", ( () => {
        return h
      } ) );
      const i = n( "dBaI" );
      const o = n( "N0LK" );
      const r = n( "erNZ" );
      const s = function ( e, t ) {
        this.endIndex = e, this.type = t
      };
      var a = ( () => {
        function e( e, t, n, i, o, r, s, a, u, l, c, d, h, p ) {
          this.useMonospaceOptimizations = e, this.lineContent = t, this.continuesWithWrappedLine = n, this.isBasicASCII = i, this.containsRTL = o, this.fauxIndentLength = r, this.lineTokens = s, this.lineDecorations = a, this.tabSize = u, this.spaceWidth = l, this.stopRenderingLineAfter = c, this.renderWhitespace = "all" === d ? 2 : "boundary" === d ? 1 : 0, this.renderControlCharacters = h, this.fontLigatures = p
        }
        return e.prototype.equals = function ( e ) {
          return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.spaceWidth === e.spaceWidth && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && i.a.equalsArr( this.lineDecorations, e.lineDecorations ) && this.lineTokens.equals( e.lineTokens )
        }, e
      } )();
      var u = ( () => {
        function e( e, t ) {
          this.length = e, this._data = new Uint32Array( this.length ), this._absoluteOffsets = new Uint32Array( this.length )
        }
        return e.getPartIndex = e => {
          return ( 4294901760 & e ) >>> 16
        }, e.getCharIndex = e => {
          return ( 65535 & e ) >>> 0
        }, e.prototype.setPartData = function ( e, t, n, i ) {
          const o = ( t << 16 | n << 0 ) >>> 0;
          this._data[ e ] = o, this._absoluteOffsets[ e ] = i + n
        }, e.prototype.getAbsoluteOffsets = function () {
          return this._absoluteOffsets
        }, e.prototype.charOffsetToPartData = function ( e ) {
          return 0 === this.length ? 0 : e < 0 ? this._data[ 0 ] : e >= this.length ? this._data[ this.length - 1 ] : this._data[ e ]
        }, e.prototype.partDataToCharOffset = function ( t, n, i ) {
          if ( 0 === this.length ) return 0;
          for ( var o = ( t << 16 | i << 0 ) >>> 0, r = 0, s = this.length - 1; r + 1 < s; ) {
            const a = r + s >>> 1,
              u = this._data[ a ];
            if ( u === o ) return a;
            u > o ? s = a : r = a
          }
          if ( r === s ) return r;
          const l = this._data[ r ],
            c = this._data[ s ];
          if ( l === o ) return r;
          if ( c === o ) return s;
          const d = e.getPartIndex( l );
          return i - e.getCharIndex( l ) <= ( d !== e.getPartIndex( c ) ? n : e.getCharIndex( c ) ) - i ? r : s
        }, e;
      } )();
      const l = function ( e, t, n ) {
        this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = n
      };

      function c( e, t ) {
        if ( 0 === e.lineContent.length ) {
          let n = 0,
            r = "<span><span>\xa0</span></span>";
          if ( e.lineDecorations.length > 0 ) {
            for ( var a = [], c = 0, d = e.lineDecorations.length; c < d; c++ ) {
              const h = e.lineDecorations[ c ];
              1 === h.type && ( a.push( e.lineDecorations[ c ].className ), n |= 1 ), 2 === h.type && ( a.push( e.lineDecorations[ c ].className ), n |= 2 )
            }
            0 !== n && ( r = '<span><span class="' + a.join( " " ) + '"></span></span>' )
          }
          return t.appendASCIIString( r ), new l( new u( 0, 0 ), !1, n )
        }
        return ( ( e, t ) => {
          const n = e.fontIsMonospace;
          const i = e.containsForeignElements;
          const r = e.lineContent;
          const s = e.len;
          const a = e.isOverflowing;
          const c = e.parts;
          const d = e.tabSize;
          const h = e.containsRTL;
          const p = e.spaceWidth;
          const f = e.renderWhitespace;
          const g = e.renderControlCharacters;
          const m = new u( s + 1, c.length );
          let _ = 0;
          let v = 0;
          let y = 0;
          let b = 0;
          let C = 0;
          t.appendASCIIString( "<span>" );
          for ( let w = 0, S = c.length; w < S; w++ ) {
            C += b;
            const O = c[ w ],
              L = O.endIndex,
              x = O.type,
              N = 0 !== f && x.indexOf( "vs-whitespace" ) >= 0;
            if ( y = 0, t.appendASCIIString( '<span class="' ), t.appendASCIIString( x ), t.appendASCII( 34 ), N ) {
              for ( var E = 0, k = _, I = v; k < L; k++ ) {
                if ( 9 === ( D = r.charCodeAt( k ) ) ) I += ( M = d - ( k + I ) % d ) - 1, E += M;
                else E++
              }
              if ( !n ) !( "vs-whitespace" === x ) && i || ( t.appendASCIIString( ' style="width:' ), t.appendASCIIString( String( p * E ) ), t.appendASCIIString( 'px"' ) );
              for ( t.appendASCII( 62 ); _ < L; _++ ) {
                if ( m.setPartData( _, w, y, C ), 9 === ( D = r.charCodeAt( _ ) ) )
                  for ( v += ( M = d - ( _ + v ) % d ) - 1, y += M - 1, M > 0 && ( M > 1 ? t.write1( 8594 ) : t.write1( 65515 ), M-- ); M > 0; ) t.write1( 160 ), M--;
                else t.write1( 183 );
                y++
              }
              b = E
            } else {
              E = 0;
              for ( h && t.appendASCIIString( ' dir="ltr"' ), t.appendASCII( 62 ); _ < L; _++ ) {
                var D;
                switch ( m.setPartData( _, w, y, C ), D = r.charCodeAt( _ ) ) {
                  case 9:
                    var M;
                    for ( v += ( M = d - ( _ + v ) % d ) - 1, y += M - 1; M > 0; ) t.write1( 160 ), E++, M--;
                    break;
                  case 32:
                    t.write1( 160 ), E++;
                    break;
                  case 60:
                    t.appendASCIIString( "&lt;" ), E++;
                    break;
                  case 62:
                    t.appendASCIIString( "&gt;" ), E++;
                    break;
                  case 38:
                    t.appendASCIIString( "&amp;" ), E++;
                    break;
                  case 0:
                    t.appendASCIIString( "&#00;" ), E++;
                    break;
                  case 65279:
                  case 8232:
                    t.write1( 65533 ), E++;
                    break;
                  default:
                    o.isFullWidthCharacter( D ) && v++, g && D < 32 ? ( t.write1( 9216 + D ), E++ ) : ( t.write1( D ), E++ )
                }
                y++
              }
              b = E
            }
            t.appendASCIIString( "</span>" )
          }
          m.setPartData( s, c.length - 1, y, C ), a && t.appendASCIIString( "<span>&hellip;</span>" );
          return t.appendASCIIString( "</span>" ), new l( m, h, i )
        } )(
          ( e => {
            let t;
            let n;
            const r = e.useMonospaceOptimizations;
            const a = e.lineContent; -
            1 !== e.stopRenderingLineAfter && e.stopRenderingLineAfter < a.length ? ( t = !0, n = e.stopRenderingLineAfter ) : ( t = !1, n = a.length );
            let u = ( ( e, t, n ) => {
              const i = [];
              let o = 0;
              t > 0 && ( i[ o++ ] = new s( t, "" ) );
              for ( let r = 0, a = e.getCount(); r < a; r++ ) {
                const u = e.getEndOffset( r );
                if ( !( u <= t ) ) {
                  const l = e.getClassName( r );
                  if ( u >= n ) {
                    i[ o++ ] = new s( n, l );
                    break
                  }
                  i[ o++ ] = new s( u, l )
                }
              }
              return i
            } )( e.lineTokens, e.fauxIndentLength, n );
            2 !== e.renderWhitespace && 1 !== e.renderWhitespace || ( u = ( ( e, t, n, i, r, a, u, l ) => {
              let c;
              const d = [];
              let h = 0;
              let p = 0;
              let f = i[ p ].type;
              let g = i[ p ].endIndex;
              let m = o.firstNonWhitespaceIndex( e ); -
              1 === m ? ( m = t, c = t ) : c = o.lastNonWhitespaceIndex( e );
              for ( var _ = 0, v = 0; v < r; v++ ) {
                9 === ( b = e.charCodeAt( v ) ) ? _ = a : o.isFullWidthCharacter( b ) ? _ += 2 : _++
              }
              _ %= a;
              let y = !1;
              for ( v = r; v < t; v++ ) {
                var b = e.charCodeAt( v );
                let C = void 0;
                if ( v < m || v > c ) C = !0;
                else if ( 9 === b ) C = !0;
                else if ( 32 === b )
                  if ( l )
                    if ( y ) C = !0;
                    else {
                      const w = v + 1 < t ? e.charCodeAt( v + 1 ) : 0;
                      C = 32 === w || 9 === w
                    }
                else C = !0;
                else C = !1;
                y ? ( !C || !u && _ >= a ) && ( d[ h++ ] = new s( v, "vs-whitespace" ), _ %= a ) : ( v === g || C && v > r ) && ( d[ h++ ] = new s( v, f ), _ %= a ), 9 === b ? _ = a : o.isFullWidthCharacter( b ) ? _ += 2 : _++, y = C, v === g && ( p++, f = i[ p ].type, g = i[ p ].endIndex )
              }
              let S = !1;
              if ( y )
                if ( n && l ) {
                  const O = t > 0 ? e.charCodeAt( t - 1 ) : 0,
                    L = t > 1 ? e.charCodeAt( t - 2 ) : 0;
                  32 === O && 32 !== L && 9 !== L || ( S = !0 )
                } else S = !0;
              return d[ h++ ] = new s( t, S ? "vs-whitespace" : f ), d
            } )(
              a,
              n,
              e.continuesWithWrappedLine,
              u,
              e.fauxIndentLength,
              e.tabSize,
              r,
              1 === e.renderWhitespace
            ) );
            let l = 0;
            if ( e.lineDecorations.length > 0 ) {
              for ( let c = 0, d = e.lineDecorations.length; c < d; c++ ) {
                const h = e.lineDecorations[ c ];
                3 === h.type ? l |= 1 : 1 === h.type ? l |= 1 : 2 === h.type && ( l |= 2 )
              }
              u = ( ( e, t, n, o ) => {
                o.sort( i.a.compare );
                for ( var r = i.b.normalize( e, o ), a = r.length, u = 0, l = [], c = 0, d = 0, h = 0, p = n.length; h < p; h++ ) {
                  for ( var f = n[ h ], g = f.endIndex, m = f.type; u < a && r[ u ].startOffset < g; ) {
                    const _ = r[ u ];
                    if ( _.startOffset > d && ( d = _.startOffset, l[ c++ ] = new s( d, m ) ), !( _.endOffset + 1 <= g ) ) {
                      d = g, l[ c++ ] = new s( d, m + " " + _.className );
                      break
                    }
                    d = _.endOffset + 1, l[ c++ ] = new s( d, m + " " + _.className ), u++
                  }
                  g > d && ( d = g, l[ c++ ] = new s( d, m ) )
                }
                const v = n[ n.length - 1 ].endIndex;
                if ( u < a && r[ u ].startOffset === v ) {
                  for ( var y = []; u < a && r[ u ].startOffset === v; ) y.push( r[ u ].className ), u++;
                  l[ c++ ] = new s( d, y.join( " " ) )
                }
                return l
              } )( a, 0, u, e.lineDecorations )
            }
            e.isBasicASCII && !e.fontLigatures && ( u = ( ( e, t ) => {
              for ( var n = 0, i = [], o = 0, r = 0, a = t.length; r < a; r++ ) {
                const u = t[ r ],
                  l = u.endIndex,
                  c = l - n;
                if ( c > 50 ) {
                  for ( var d = u.type, h = Math.ceil( c / 50 ), p = 1; p < h; p++ ) {
                    const f = n + 50 * p;
                    i[ o++ ] = new s( f, d )
                  }
                  i[ o++ ] = new s( l, d )
                } else i[ o++ ] = u;
                n = l
              }
              return i
            } )( 0, u ) );
            return new p( r, a, n, t, u, l, e.tabSize, e.containsRTL, e.spaceWidth, e.renderWhitespace, e.renderControlCharacters )
          } )( e ),
          t
        );
      }
      const d = function ( e, t, n, i ) {
        this.characterMapping = e, this.html = t, this.containsRTL = n, this.containsForeignElements = i
      };

      function h( e ) {
        const t = Object( r.a )( 1e4 ),
          n = c( e, t );
        return new d( n.characterMapping, t.build(), n.containsRTL, n.containsForeignElements )
      }
      var p = function ( e, t, n, i, o, r, s, a, u, l, c ) {
        this.fontIsMonospace = e, this.lineContent = t, this.len = n, this.isOverflowing = i, this.parts = o, this.containsForeignElements = r, this.tabSize = s, this.containsRTL = a, this.spaceWidth = u, this.renderWhitespace = l, this.renderControlCharacters = c
      }
    },
    bexQ( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return i
      } ) ), n.d( t, "a", ( () => {
        return r
      } ) );
      var i;
      const o = n( "Cg/j" );
      !( e => {
        e[ e.Default = 1 ] = "Default", e[ e.User = 2 ] = "User"
      } )( i || ( i = {} ) );
      var r = Object( o.c )( "keybindingService" )
    },
    bfR1( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "sswD" ),
        r = n( "Yr1X" ),
        s = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        a = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.fontZoomIn",
              label: i.a( "EditorFontZoomIn.label", "Editor Font Zoom In" ),
              alias: "Editor Font Zoom In",
              precondition: null
            } ) || this
          }
          return s( t, e ), t.prototype.run = ( e, t ) => {
            r.a.setZoomLevel( r.a.getZoomLevel() + 1 )
          }, t;
        } )( o.b ),
        u = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.fontZoomOut",
              label: i.a( "EditorFontZoomOut.label", "Editor Font Zoom Out" ),
              alias: "Editor Font Zoom Out",
              precondition: null
            } ) || this
          }
          return s( t, e ), t.prototype.run = ( e, t ) => {
            r.a.setZoomLevel( r.a.getZoomLevel() - 1 )
          }, t;
        } )( o.b ),
        l = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.fontZoomReset",
              label: i.a( "EditorFontZoomReset.label", "Editor Font Zoom Reset" ),
              alias: "Editor Font Zoom Reset",
              precondition: null
            } ) || this
          }
          return s( t, e ), t.prototype.run = ( e, t ) => {
            r.a.setZoomLevel( 0 )
          }, t;
        } )( o.b );
      Object( o.f )( a ), Object( o.f )( u ), Object( o.f )( l )
    },
    bk7F( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "BracketMatchingController", ( () => {
        return b
      } ) );
      n( "8ATB" );
      const i = n( "3/fG" );
      const o = n( "pmY6" );
      const r = n( "cGHE" );
      const s = n( "gCVg" );
      const a = n( "X+cX" );
      const u = n( "sswD" );
      const l = n( "wQH0" );
      const c = n( "t9D7" );
      const d = n( "kYye" );
      const h = n( "tX9W" );
      const p = n( "MD5Z" );
      const f = n( "M1Kb" );
      const g = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const m = Object( p.kb )( "editorOverviewRuler.bracketMatchForeground", {
        dark: "#A0A0A0",
        light: "#A0A0A0",
        hc: "#A0A0A0"
      }, i.a( "overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets." ) );
      const _ = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.jumpToBracket",
            label: i.a( "smartSelect.jumpBracket", "Go to Bracket" ),
            alias: "Go to Bracket",
            precondition: null,
            kbOpts: {
              kbExpr: l.a.editorTextFocus,
              primary: 3160,
              weight: 100
            }
          } ) || this
        }
        return g( t, e ), t.prototype.run = ( e, t ) => {
          const n = b.get( t );
          n && n.jumpToBracket()
        }, t;
      } )( u.b );
      const v = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.selectToBracket",
            label: i.a( "smartSelect.selectToBracket", "Select to Bracket" ),
            alias: "Select to Bracket",
            precondition: null
          } ) || this
        }
        return g( t, e ), t.prototype.run = ( e, t ) => {
          const n = b.get( t );
          n && n.selectToBracket()
        }, t;
      } )( u.b );
      const y = function ( e, t ) {
        this.position = e, this.brackets = t
      };

      var b = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n._editor = t, n._lastBracketsData = [], n._lastVersionId = 0, n._decorations = [], n._updateBracketsSoon = n._register( new a.c( ( () => {
            return n._updateBrackets()
          } ), 50 ) ), n._matchBrackets = n._editor.getConfiguration().contribInfo.matchBrackets, n._updateBracketsSoon.schedule(), n._register( t.onDidChangeCursorPosition( ( e => {
            n._matchBrackets && n._updateBracketsSoon.schedule()
          } ) ) ), n._register( t.onDidChangeModelContent( ( e => {
            n._updateBracketsSoon.schedule()
          } ) ) ), n._register( t.onDidChangeModel( ( e => {
            n._decorations = [], n._updateBracketsSoon.schedule()
          } ) ) ), n._register( t.onDidChangeModelLanguageConfiguration( ( e => {
            n._lastBracketsData = [], n._updateBracketsSoon.schedule()
          } ) ) ), n._register( t.onDidChangeConfiguration( ( e => {
            n._matchBrackets = n._editor.getConfiguration().contribInfo.matchBrackets, !n._matchBrackets && n._decorations.length > 0 && ( n._decorations = n._editor.deltaDecorations( n._decorations, [] ) ), n._updateBracketsSoon.schedule()
          } ) ) ), n;
        }
        return g( t, e ), t.get = e => {
          return e.getContribution( t.ID )
        }, t.prototype.getId = () => {
          return t.ID
        }, t.prototype.jumpToBracket = function () {
          const e = this._editor.getModel();
          if ( e ) {
            const t = this._editor.getSelections().map( ( t => {
              const n = t.getStartPosition();
              const i = e.matchBracket( n );
              let o = null;
              if ( i ) i[ 0 ].containsPosition( n ) ? o = i[ 1 ].getStartPosition() : i[ 1 ].containsPosition( n ) && ( o = i[ 0 ].getStartPosition() );
              else {
                const r = e.findNextBracket( n );
                r && r.range && ( o = r.range.getStartPosition() )
              }
              return o ? new s.a( o.lineNumber, o.column, o.lineNumber, o.column ) : new s.a( n.lineNumber, n.column, n.lineNumber, n.column )
            } ) );
            this._editor.setSelections( t ), this._editor.revealRange( t[ 0 ] )
          }
        }, t.prototype.selectToBracket = function () {
          const e = this._editor.getModel();
          if ( e ) {
            const t = [];
            this._editor.getSelections().forEach( ( n => {
              const i = n.getStartPosition();
              let o = e.matchBracket( i );
              let r = null;
              let a = null;
              if ( !o ) {
                const u = e.findNextBracket( i );
                u && u.range && ( o = e.matchBracket( u.range.getStartPosition() ) )
              }
              o && ( o[ 0 ].startLineNumber === o[ 1 ].startLineNumber ? ( r = o[ 1 ].startColumn < o[ 0 ].startColumn ? o[ 1 ].getStartPosition() : o[ 0 ].getStartPosition(), a = o[ 1 ].startColumn < o[ 0 ].startColumn ? o[ 0 ].getEndPosition() : o[ 1 ].getEndPosition() ) : ( r = o[ 1 ].startLineNumber < o[ 0 ].startLineNumber ? o[ 1 ].getStartPosition() : o[ 0 ].getStartPosition(), a = o[ 1 ].startLineNumber < o[ 0 ].startLineNumber ? o[ 0 ].getEndPosition() : o[ 1 ].getEndPosition() ) ), r && a && t.push( new s.a( r.lineNumber, r.column, a.lineNumber, a.column ) )
            } ) ), t.length > 0 && ( this._editor.setSelections( t ), this._editor.revealRange( t[ 0 ] ) )
          }
        }, t.prototype._updateBrackets = function () {
          if ( this._matchBrackets ) {
            this._recomputeBrackets();
            for ( var e = [], n = 0, i = 0, o = this._lastBracketsData.length; i < o; i++ ) {
              const r = this._lastBracketsData[ i ].brackets;
              r && ( e[ n++ ] = {
                range: r[ 0 ],
                options: t._DECORATION_OPTIONS
              }, e[ n++ ] = {
                range: r[ 1 ],
                options: t._DECORATION_OPTIONS
              } )
            }
            this._decorations = this._editor.deltaDecorations( this._decorations, e )
          }
        }, t.prototype._recomputeBrackets = function () {
          const e = this._editor.getModel();
          if ( !e ) return this._lastBracketsData = [], void( this._lastVersionId = 0 );
          const t = e.getVersionId();
          let n = [];
          this._lastVersionId === t && ( n = this._lastBracketsData );
          for ( var i = this._editor.getSelections(), o = [], s = 0, a = 0, u = i.length; a < u; a++ ) {
            const l = i[ a ];
            l.isEmpty() && ( o[ s++ ] = l.getStartPosition() )
          }
          o.length > 1 && o.sort( r.a.compare );
          const c = [];
          let d = 0;
          let h = 0;
          const p = n.length;
          for ( a = 0, u = o.length; a < u; a++ ) {
            for ( var f = o[ a ]; h < p && n[ h ].position.isBefore( f ); ) h++;
            if ( h < p && n[ h ].position.equals( f ) ) c[ d++ ] = n[ h ];
            else {
              const g = e.matchBracket( f );
              c[ d++ ] = new y( f, g )
            }
          }
          this._lastBracketsData = c, this._lastVersionId = t
        }, t.ID = "editor.contrib.bracketMatchingController", t._DECORATION_OPTIONS = h.a.register( {
          stickiness: f.h.NeverGrowsWhenTypingAtEdges,
          className: "bracket-match",
          overviewRuler: {
            color: Object( c.f )( m ),
            darkColor: Object( c.f )( m ),
            position: f.f.Center
          }
        } ), t;
      } )( o.a );

      Object( u.h )( b ), Object( u.f )( v ), Object( u.f )( _ ), Object( c.e )( ( ( e, t ) => {
        const n = e.getColor( d.c );
        n && t.addRule( ".monaco-editor .bracket-match { background-color: " + n + "; }" );
        const i = e.getColor( d.d );
        i && t.addRule( ".monaco-editor .bracket-match { border: 1px solid " + i + "; }" )
      } ) )
    },
    c2dO( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "LanguageServiceDefaultsImpl", ( () => {
        return o
      } ) );
      n( "M/lh" );
      const i = monaco.Emitter;
      var o = ( () => {
        function e( e, t ) {
          this._onDidChange = new i, this._languageId = e, this.setOptions( t )
        }
        return Object.defineProperty( e.prototype, "onDidChange", {
          get() {
            return this._onDidChange.event
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "languageId", {
          get() {
            return this._languageId
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "options", {
          get() {
            return this._options
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.setOptions = function ( e ) {
          this._options = e || Object.create( null ), this._onDidChange.fire( this )
        }, e;
      } )();
      const r = {
        tabSize: 4,
        insertSpaces: !1,
        wrapLineLength: 120,
        unformatted: 'default": "a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, select, small, span, strong, sub, sup, textarea, tt, var',
        contentUnformatted: "pre",
        indentInnerHtml: !1,
        preserveNewLines: !0,
        maxPreserveNewLines: null,
        indentHandlebars: !1,
        endWithNewline: !1,
        extraLiners: "head, body, /html",
        wrapAttributes: "auto"
      };
      const s = {
        format: r,
        suggest: {
          html5: !0
        }
      };
      const a = {
        format: r,
        suggest: {
          html5: !0,
          razor: !0
        }
      };
      const u = new o( "html", {
        format: r,
        suggest: {
          html5: !0,
          angular1: !0,
          ionic: !0
        }
      } );
      const l = new o( "handlebars", s );
      const c = new o( "razor", a );

      function d() {
        return monaco.Promise.wrap( n.e( 316 ).then( n.bind( null, "+lu7" ) ) )
      }
      monaco.languages.html = {
        htmlDefaults: u,
        razorDefaults: c,
        handlebarDefaults: l
      }, monaco.languages.onLanguage( "html", ( () => {
        d().then( ( e => {
          return e.setupMode( u )
        } ) )
      } ) ), monaco.languages.onLanguage( "handlebars", ( () => {
        d().then( ( e => {
          return e.setupMode( l )
        } ) )
      } ) ), monaco.languages.onLanguage( "razor", ( () => {
        d().then( ( e => {
          return e.setupMode( c )
        } ) )
      } ) )
    },
    c9ML( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "scss",
        extensions: [ ".scss" ],
        aliases: [ "Sass", "sass", "scss" ],
        mimetypes: [ "text/x-scss", "text/scss" ],
        loader() {
          return o.Promise.wrap( n.e( 303 ).then( n.bind( null, "QJnQ" ) ) )
        }
      } )
    },
    cGHE( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) );
      var i = ( () => {
        function e( e, t ) {
          this.lineNumber = e, this.column = t
        }
        return e.prototype.equals = function ( t ) {
          return e.equals( this, t )
        }, e.equals = ( e, t ) => {
          return !e && !t || !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column
        }, e.prototype.isBefore = function ( t ) {
          return e.isBefore( this, t )
        }, e.isBefore = ( e, t ) => {
          return e.lineNumber < t.lineNumber || !( t.lineNumber < e.lineNumber ) && e.column < t.column
        }, e.prototype.isBeforeOrEqual = function ( t ) {
          return e.isBeforeOrEqual( this, t )
        }, e.isBeforeOrEqual = ( e, t ) => {
          return e.lineNumber < t.lineNumber || !( t.lineNumber < e.lineNumber ) && e.column <= t.column
        }, e.compare = ( e, t ) => {
          const n = 0 | e.lineNumber,
            i = 0 | t.lineNumber;
          return n === i ? ( 0 | e.column ) - ( 0 | t.column ) : n - i
        }, e.prototype.clone = function () {
          return new e( this.lineNumber, this.column )
        }, e.prototype.toString = function () {
          return "(" + this.lineNumber + "," + this.column + ")"
        }, e.lift = t => {
          return new e( t.lineNumber, t.column )
        }, e.isIPosition = e => {
          return e && "number" === typeof e.lineNumber && "number" === typeof e.column
        }, e;
      } )()
    },
    cIJc( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "6OMU" ),
        r = n( "/kV6" ),
        s = n( "pmY6" ),
        a = n( "VMIq" ),
        u = n( "T8No" ),
        l = n( "sswD" ),
        c = n( "twdY" ),
        d = n( "/cxE" ),
        h = n( "bY76" ),
        p = n( "aokT" ),
        f = n( "G2kB" ),
        g = n( "X+cX" ),
        m = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        _ = ( e => {
          function t( n ) {
            const i = e.call( this ) || this;
            return i.name = t.Name, i.message = n, i
          }
          return m( t, e ), t.Name = "NOPRO", t
        } )( Error );

      function v( e, t, n ) {
        const i = c.i.ordered( e );
        return 0 === i.length ? a.b.wrapError( new _ ) : Object( g.j )( i.map( ( i => {
          return () => {
            return Object( g.h )( ( o => {
              return i.provideDocumentRangeFormattingEdits( e, t, n, o )
            } ) ).then( void 0, d.f );
          };
        } ) ), ( e => {
          return !Object( o.k )( e )
        } ) );
      }

      function y( e, t ) {
        const n = c.f.ordered( e );
        return 0 === n.length ? v( e, e.getFullModelRange(), t ) : Object( g.j )( n.map( ( n => {
          return () => {
            return Object( g.h )( ( i => {
              return n.provideDocumentFormattingEdits( e, t, i )
            } ) ).then( void 0, d.f );
          };
        } ) ), ( e => {
          return !Object( o.k )( e )
        } ) );
      }

      function b( e, t, n, i ) {
        const o = c.q.ordered( e )[ 0 ];
        return o ? o.autoFormatTriggerCharacters.indexOf( n ) < 0 ? a.b.as( void 0 ) : Object( g.h )( ( r => {
          return o.provideOnTypeFormattingEdits( e, t, n, i, r )
        } ) ).then( ( e => {
          return e
        } ), d.f ) : a.b.as( void 0 );
      }
      Object( l.j )( "_executeFormatRangeProvider", ( ( e, t ) => {
        const n = t.resource,
          i = t.range,
          o = t.options;
        if ( !( n instanceof h.a ) || !p.a.isIRange( i ) ) throw Object( d.b )();
        const r = e.get( f.a ).getModel( n );
        if ( !r ) throw Object( d.b )( "resource" );
        return v( r, p.a.lift( i ), o )
      } ) ), Object( l.j )( "_executeFormatDocumentProvider", ( ( e, t ) => {
        const n = t.resource,
          i = t.options;
        if ( !( n instanceof h.a ) ) throw Object( d.b )( "resource" );
        const o = e.get( f.a ).getModel( n );
        if ( !o ) throw Object( d.b )( "resource" );
        return y( o, i )
      } ) ), Object( l.e )( "_executeFormatOnTypeProvider", ( ( e, t, n ) => {
        const i = n.ch,
          o = n.options;
        if ( "string" !== typeof i ) throw Object( d.b )( "ch" );
        return b( e, t, i, o )
      } ) );
      const C = n( "0/Sa" ),
        w = ( () => {
          function e() {}
          return e._handleEolEdits = ( e, t ) => {
            for ( var n = void 0, i = [], o = 0, r = t; o < r.length; o++ ) {
              const s = r[ o ];
              "number" === typeof s.eol && ( n = s.eol ), s.range && "string" === typeof s.text && i.push( s )
            }
            return "number" === typeof n && e.getModel().pushEOL( n ), i
          }, e._isFullModelReplaceEdit = ( e, t ) => {
            const n = e.getModel(),
              i = n.validateRange( t.range );
            return n.getFullModelRange().equalsRange( i )
          }, e.execute = ( t, n ) => {
            t.pushUndoStop();
            const i = e._handleEolEdits( t, n );
            1 === i.length && e._isFullModelReplaceEdit( t, i[ 0 ] ) ? t.executeEdits( "formatEditsCommand", i.map( ( e => {
              return C.a.replace( p.a.lift( e.range ), e.text )
            } ) ) ) : t.executeEdits( "formatEditsCommand", i.map( ( e => {
              return C.a.replaceMove( p.a.lift( e.range ), e.text )
            } ) ) ), t.pushUndoStop()
          }, e;
        } )(),
        S = n( "nnTU" ),
        O = n( "Vxe3" ),
        L = n( "pAvP" ),
        x = n( "MXAL" ),
        N = n( "OBOq" ),
        E = n( "vATl" ),
        k = n( "wQH0" ),
        I = n( "sM1p" );
      n.d( t, "AbstractFormatAction", ( () => {
        return F
      } ) ), n.d( t, "FormatDocumentAction", ( () => {
        return W
      } ) ), n.d( t, "FormatSelectionAction", ( () => {
        return j
      } ) );
      const D = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        M = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        T = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        };

      function R( e ) {
        if ( ( e = e.filter( ( e => {
            return e.range
          } ) ) ).length ) {
          for ( var t = e[ 0 ].range, n = 1; n < e.length; n++ ) t = p.a.plusRange( t, e[ n ].range );
          const o = t.startLineNumber,
            r = t.endLineNumber;
          o === r ? 1 === e.length ? Object( N.a )( i.a( "hint11", "Made 1 formatting edit on line {0}", o ) ) : Object( N.a )( i.a( "hintn1", "Made {0} formatting edits on line {1}", e.length, o ) ) : 1 === e.length ? Object( N.a )( i.a( "hint1n", "Made 1 formatting edit between lines {0} and {1}", o, r ) ) : Object( N.a )( i.a( "hintnn", "Made {0} formatting edits between lines {1} and {2}", e.length, o, r ) )
        }
      }

      const P = ( () => {
        function e( e, t ) {
          const n = this;
          this.editor = e, this.workerService = t, this.callOnDispose = [], this.callOnModel = [], this.callOnDispose.push( e.onDidChangeConfiguration( ( () => {
            return n.update()
          } ) ) ), this.callOnDispose.push( e.onDidChangeModel( ( () => {
            return n.update()
          } ) ) ), this.callOnDispose.push( e.onDidChangeModelLanguage( ( () => {
            return n.update()
          } ) ) ), this.callOnDispose.push( c.q.onDidChange( this.update, this ) )
        }
        return e.prototype.update = function () {
          const e = this;
          if ( this.callOnModel = Object( s.d )( this.callOnModel ), this.editor.getConfiguration().contribInfo.formatOnType && this.editor.getModel() ) {
            const t = this.editor.getModel(),
              n = c.q.ordered( t )[ 0 ];
            if ( n && n.autoFormatTriggerCharacters ) {
              for ( var i = new x.b, o = 0, r = n.autoFormatTriggerCharacters; o < r.length; o++ ) {
                const a = r[ o ];
                i.add( a.charCodeAt( 0 ) )
              }
              this.callOnModel.push( this.editor.onDidType( ( t => {
                const n = t.charCodeAt( t.length - 1 );
                i.has( n ) && e.trigger( String.fromCharCode( n ) )
              } ) ) )
            }
          }
        }, e.prototype.trigger = function ( e ) {
          const t = this;
          if ( !( this.editor.getSelections().length > 1 ) ) {
            const n = this.editor.getModel();
            const i = this.editor.getPosition();
            let r = !1;
            const s = this.editor.onDidChangeModelContent( ( e => {
              if ( e.isFlush ) return r = !0, void s.dispose();
              for ( let t = 0, n = e.changes.length; t < n; t++ ) {
                if ( e.changes[ t ].range.endLineNumber <= i.lineNumber ) return r = !0, void s.dispose()
              }
            } ) );
            const a = n.getOptions();
            b( n, i, e, {
              tabSize: a.tabSize,
              insertSpaces: a.insertSpaces
            } ).then( ( e => {
              return t.workerService.computeMoreMinimalEdits( n.uri, e )
            } ) ).then( ( e => {
              s.dispose(), r || Object( o.k )( e ) || ( w.execute( t.editor, e ), R( e ) )
            } ), ( e => {
              throw ( s.dispose(), e )
            } ) )
          }
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.dispose = function () {
          this.callOnDispose = Object( s.d )( this.callOnDispose ), this.callOnModel = Object( s.d )( this.callOnModel )
        }, e.ID = "editor.contrib.autoFormat", e = M( [ T( 1, L.a ) ], e );
      } )();

      const A = ( () => {
        function e( e, t ) {
          const n = this;
          this.editor = e, this.workerService = t, this.callOnDispose = [], this.callOnModel = [], this.callOnDispose.push( e.onDidChangeConfiguration( ( () => {
            return n.update()
          } ) ) ), this.callOnDispose.push( e.onDidChangeModel( ( () => {
            return n.update()
          } ) ) ), this.callOnDispose.push( e.onDidChangeModelLanguage( ( () => {
            return n.update()
          } ) ) ), this.callOnDispose.push( c.i.onDidChange( this.update, this ) )
        }
        return e.prototype.update = function () {
          const e = this;
          if ( this.callOnModel = Object( s.d )( this.callOnModel ), this.editor.getConfiguration().contribInfo.formatOnPaste && this.editor.getModel() ) {
            const t = this.editor.getModel(),
              n = c.i.ordered( t )[ 0 ];
            n && n.provideDocumentRangeFormattingEdits && this.callOnModel.push( this.editor.onDidPaste( ( t => {
              e.trigger( t )
            } ) ) )
          }
        }, e.prototype.trigger = function ( e ) {
          const t = this;
          if ( !( this.editor.getSelections().length > 1 ) ) {
            const n = this.editor.getModel(),
              i = n.getOptions(),
              r = i.tabSize,
              s = i.insertSpaces,
              a = new E.a( this.editor, 5 );
            v( n, e, {
              tabSize: r,
              insertSpaces: s
            } ).then( ( e => {
              return t.workerService.computeMoreMinimalEdits( n.uri, e )
            } ) ).then( ( e => {
              a.validate( t.editor ) && !Object( o.k )( e ) && ( w.execute( t.editor, e ), R( e ) )
            } ) )
          }
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.dispose = function () {
          this.callOnDispose = Object( s.d )( this.callOnDispose ), this.callOnModel = Object( s.d )( this.callOnModel )
        }, e.ID = "editor.contrib.formatOnPaste", e = M( [ T( 1, L.a ) ], e );
      } )();
      var F = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return D( t, e ), t.prototype.run = function ( e, t ) {
          const n = this,
            i = e.get( L.a ),
            r = e.get( I.a ),
            s = this._getFormattingEdits( t );
          if ( !s ) return a.b.as( void 0 );
          const u = new E.a( t, 5 );
          return s.then( ( e => {
            return i.computeMoreMinimalEdits( t.getModel().uri, e )
          } ) ).then( ( e => {
            u.validate( t ) && !Object( o.k )( e ) && ( w.execute( t, e ), R( e ), t.focus() )
          } ), ( e => {
            if ( !( e instanceof Error && e.name === _.Name ) ) throw e;
            n._notifyNoProviderError( r, t.getModel().getLanguageIdentifier().language )
          } ) );
        }, t.prototype._notifyNoProviderError = ( e, t ) => {
          e.info( i.a( "no.provider", "There is no formatter for '{0}'-files installed.", t ) )
        }, t;
      } )( l.b );
      var W = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.formatDocument",
            label: i.a( "formatDocument.label", "Format Document" ),
            alias: "Format Document",
            precondition: k.a.writable,
            kbOpts: {
              kbExpr: k.a.editorTextFocus,
              primary: 1572,
              linux: {
                primary: 3111
              },
              weight: 100
            },
            menuOpts: {
              when: k.a.hasDocumentFormattingProvider,
              group: "1_modification",
              order: 1.3
            }
          } ) || this
        }
        return D( t, e ), t.prototype._getFormattingEdits = e => {
          const t = e.getModel(),
            n = t.getOptions();
          return y( t, {
            tabSize: n.tabSize,
            insertSpaces: n.insertSpaces
          } )
        }, t.prototype._notifyNoProviderError = ( e, t ) => {
          e.info( i.a( "no.documentprovider", "There is no document formatter for '{0}'-files installed.", t ) )
        }, t;
      } )( F );
      var j = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.formatSelection",
            label: i.a( "formatSelection.label", "Format Selection" ),
            alias: "Format Code",
            precondition: u.d.and( k.a.writable, k.a.hasNonEmptySelection ),
            kbOpts: {
              kbExpr: k.a.editorTextFocus,
              primary: Object( r.a )( 2089, 2084 ),
              weight: 100
            },
            menuOpts: {
              when: u.d.and( k.a.hasDocumentSelectionFormattingProvider, k.a.hasNonEmptySelection ),
              group: "1_modification",
              order: 1.31
            }
          } ) || this
        }
        return D( t, e ), t.prototype._getFormattingEdits = e => {
          const t = e.getModel(),
            n = t.getOptions(),
            i = n.tabSize,
            o = n.insertSpaces;
          return v( t, e.getSelection(), {
            tabSize: i,
            insertSpaces: o
          } )
        }, t.prototype._notifyNoProviderError = ( e, t ) => {
          e.info( i.a( "no.selectionprovider", "There is no selection formatter for '{0}'-files installed.", t ) )
        }, t;
      } )( F );
      Object( l.h )( P ), Object( l.h )( A ), Object( l.f )( W ), Object( l.f )( j ), S.a.registerCommand( "editor.action.format", ( e => {
        const t = e.get( O.a ).getFocusedCodeEditor();
        if ( t ) return ( new( ( e => {
          function t() {
            return e.call( this, {} ) || this
          }
          return D( t, e ), t.prototype._getFormattingEdits = e => {
            const t = e.getModel(),
              n = e.getSelection(),
              i = t.getOptions(),
              o = i.tabSize,
              r = i.insertSpaces;
            return n.isEmpty() ? y( t, {
              tabSize: o,
              insertSpaces: r
            } ) : v( t, n, {
              tabSize: o,
              insertSpaces: r
            } )
          }, t;
        } )( F ) )() ).run( e, t );
      } ) )
    },
    cMOf( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "c", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return g
      } ) );
      n( "undH" );
      var i;
      var o;
      const r = n( "pmY6" );
      const s = n( "D3Dy" );
      const a = n( "MNsG" );
      const u = n( "746U" );
      const l = n( "pg8w" );
      const c = n( "XSiN" );
      const d = n( "MI8n" );
      const h = n( "EffR" );
      const p = n( "4y0V" );
      const f = !1;
      !( e => {
        e[ e.VERTICAL = 0 ] = "VERTICAL", e[ e.HORIZONTAL = 1 ] = "HORIZONTAL"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.Disabled = 0 ] = "Disabled", e[ e.Minimum = 1 ] = "Minimum", e[ e.Maximum = 2 ] = "Maximum", e[ e.Enabled = 3 ] = "Enabled"
      } )( o || ( o = {} ) );
      var g = ( () => {
        function e( e, t, n ) {
          void 0 === n && ( n = {} ), this.disposables = [], this._state = o.Enabled, this._onDidEnablementChange = new d.a, this.onDidEnablementChange = this._onDidEnablementChange.event, this._onDidStart = new d.a, this.onDidStart = this._onDidStart.event, this._onDidChange = new d.a, this.onDidChange = this._onDidChange.event, this._onDidReset = new d.a, this.onDidReset = this._onDidReset.event, this._onDidEnd = new d.a, this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.orthogonalStartSashDisposables = [], this.orthogonalEndSashDisposables = [], this.el = Object( h.k )( e, Object( h.a )( ".monaco-sash" ) ), a.d && Object( h.f )( this.el, "mac" ), Object( p.a )( this.el, "mousedown" )( this.onMouseDown, this, this.disposables ), Object( p.a )( this.el, "dblclick" )( this.onMouseDoubleClick, this, this.disposables ), l.b.addTarget( this.el ), Object( p.a )( this.el, l.a.Start )( this.onTouchStart, this, this.disposables ), s.l && Object( h.f )( this.el, "touch" ), this.setOrientation( n.orientation || i.VERTICAL ), this.hidden = !1, this.layoutProvider = t, this.orthogonalStartSash = n.orthogonalStartSash, this.orthogonalEndSash = n.orthogonalEndSash, Object( h.N )( this.el, "debug", f )
        }
        return Object.defineProperty( e.prototype, "state", {
          get() {
            return this._state
          },
          set( e ) {
            this._state !== e && ( Object( h.N )( this.el, "disabled", e === o.Disabled ), Object( h.N )( this.el, "minimum", e === o.Minimum ), Object( h.N )( this.el, "maximum", e === o.Maximum ), this._state = e, this._onDidEnablementChange.fire( e ) )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "orthogonalStartSash", {
          get() {
            return this._orthogonalStartSash
          },
          set( e ) {
            this.orthogonalStartSashDisposables = Object( r.d )( this.orthogonalStartSashDisposables ), e ? ( e.onDidEnablementChange( this.onOrthogonalStartSashEnablementChange, this, this.orthogonalStartSashDisposables ), this.onOrthogonalStartSashEnablementChange( e.state ) ) : this.onOrthogonalStartSashEnablementChange( o.Disabled ), this._orthogonalStartSash = e
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "orthogonalEndSash", {
          get() {
            return this._orthogonalEndSash
          },
          set( e ) {
            this.orthogonalEndSashDisposables = Object( r.d )( this.orthogonalEndSashDisposables ), e ? ( e.onDidEnablementChange( this.onOrthogonalEndSashEnablementChange, this, this.orthogonalEndSashDisposables ), this.onOrthogonalEndSashEnablementChange( e.state ) ) : this.onOrthogonalEndSashEnablementChange( o.Disabled ), this._orthogonalEndSash = e
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.setOrientation = function ( e ) {
          this.orientation = e, this.orientation === i.HORIZONTAL ? ( Object( h.f )( this.el, "horizontal" ), Object( h.G )( this.el, "vertical" ) ) : ( Object( h.G )( this.el, "horizontal" ), Object( h.f )( this.el, "vertical" ) ), this.layoutProvider && this.layout()
        }, e.prototype.onMouseDown = function ( e ) {
          const t = this;
          h.c.stop( e, !1 );
          let n = !1;
          if ( this.linkedSash && !e.__linkedSashEvent && ( e.__linkedSashEvent = !0, this.linkedSash.onMouseDown( e ) ), !e.__orthogonalSashEvent ) {
            let s = void 0;
            this.orientation === i.VERTICAL ? e.offsetY <= 4 ? s = this.orthogonalStartSash : e.offsetY >= this.el.clientHeight - 4 && ( s = this.orthogonalEndSash ) : e.offsetX <= 4 ? s = this.orthogonalStartSash : e.offsetX >= this.el.clientWidth - 4 && ( s = this.orthogonalEndSash ), s && ( n = !0, e.__orthogonalSashEvent = !0, s.onMouseDown( e ) )
          }
          if ( this.state ) {
            for ( let u = 0, l = Object( h.v )( "iframe" ); u < l.length; u++ ) {
              l[ u ].style.pointerEvents = "none"
            }
            const d = new c.b( e ),
              f = d.posx,
              g = d.posy,
              m = d.altKey,
              _ = {
                startX: f,
                currentX: f,
                startY: g,
                currentY: g,
                altKey: m
              };
            Object( h.f )( this.el, "active" ), this._onDidStart.fire( _ );
            const v = Object( h.o )( this.el ),
              y = () => {
                let e = "";
                e = n ? "all-scroll" : t.orientation === i.HORIZONTAL ? t.state === o.Minimum ? "s-resize" : t.state === o.Maximum ? "n-resize" : a.d ? "row-resize" : "ns-resize" : t.state === o.Minimum ? "e-resize" : t.state === o.Maximum ? "w-resize" : a.d ? "col-resize" : "ew-resize", v.innerHTML = "* { cursor: " + e + " !important; }"
              },
              b = [];
            y(), n || this.onDidEnablementChange( y, null, b );
            Object( p.a )( window, "mousemove" )( ( e => {
              h.c.stop( e, !1 );
              const n = new c.b( e ),
                i = {
                  startX: f,
                  currentX: n.posx,
                  startY: g,
                  currentY: n.posy,
                  altKey: m
                };
              t._onDidChange.fire( i )
            } ), null, b ), Object( p.a )( window, "mouseup" )( ( e => {
              h.c.stop( e, !1 ), t.el.removeChild( v ), Object( h.G )( t.el, "active" ), t._onDidEnd.fire(), Object( r.d )( b );
              for ( let n = 0, i = Object( h.v )( "iframe" ); n < i.length; n++ ) {
                i[ n ].style.pointerEvents = "auto"
              }
            } ), null, b )
          }
        }, e.prototype.onMouseDoubleClick = function ( e ) {
          this._onDidReset.fire()
        }, e.prototype.onTouchStart = function ( e ) {
          const t = this;
          h.c.stop( e );
          const n = [],
            i = e.pageX,
            o = e.pageY,
            s = e.altKey;
          this._onDidStart.fire( {
            startX: i,
            currentX: i,
            startY: o,
            currentY: o,
            altKey: s
          } ), n.push( Object( h.g )( this.el, l.a.Change, ( e => {
            u.f( e.pageX ) && u.f( e.pageY ) && t._onDidChange.fire( {
              startX: i,
              currentX: e.pageX,
              startY: o,
              currentY: e.pageY,
              altKey: s
            } )
          } ) ) ), n.push( Object( h.g )( this.el, l.a.End, ( e => {
            t._onDidEnd.fire(), Object( r.d )( n )
          } ) ) )
        }, e.prototype.layout = function () {
          const e = s.l ? 20 : 4;
          if ( this.orientation === i.VERTICAL ) {
            const t = this.layoutProvider;
            this.el.style.left = t.getVerticalSashLeft( this ) - e / 2 + "px", t.getVerticalSashTop && ( this.el.style.top = t.getVerticalSashTop( this ) + "px" ), t.getVerticalSashHeight && ( this.el.style.height = t.getVerticalSashHeight( this ) + "px" )
          } else {
            const n = this.layoutProvider;
            this.el.style.top = n.getHorizontalSashTop( this ) - e / 2 + "px", n.getHorizontalSashLeft && ( this.el.style.left = n.getHorizontalSashLeft( this ) + "px" ), n.getHorizontalSashWidth && ( this.el.style.width = n.getHorizontalSashWidth( this ) + "px" )
          }
        }, e.prototype.hide = function () {
          this.hidden = !0, this.el.style.display = "none", this.el.setAttribute( "aria-hidden", "true" )
        }, e.prototype.onOrthogonalStartSashEnablementChange = function ( e ) {
          Object( h.N )( this.el, "orthogonal-start", e !== o.Disabled )
        }, e.prototype.onOrthogonalEndSashEnablementChange = function ( e ) {
          Object( h.N )( this.el, "orthogonal-end", e !== o.Disabled )
        }, e.prototype.dispose = function () {
          this.orthogonalStartSashDisposables = Object( r.d )( this.orthogonalStartSashDisposables ), this.orthogonalEndSashDisposables = Object( r.d )( this.orthogonalEndSashDisposables ), this.el && this.el.parentElement && this.el.parentElement.removeChild( this.el ), this.el = null, this.disposables = Object( r.d )( this.disposables )
        }, e;
      } )()
    },
    cMvZ( e, t, n ) {
      "use strict";
      const i = n( "KDc4" ),
        o = ( () => {
          function e( e ) {
            e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map( ( e => {
              return new i.b( e )
            } ) ) : e.brackets ? this._autoClosingPairs = e.brackets.map( ( e => {
              return new i.b( {
                open: e[ 0 ],
                close: e[ 1 ]
              } )
            } ) ) : this._autoClosingPairs = [], this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs
          }
          return e.prototype.getAutoClosingPairs = function () {
            return this._autoClosingPairs
          }, e.prototype.shouldAutoClosePair = function ( e, t, n ) {
            if ( 0 === t.getTokenCount() ) return !0;
            for ( let i = t.findTokenIndexAtOffset( n - 2 ), o = t.getStandardTokenType( i ), r = 0; r < this._autoClosingPairs.length; ++r ) {
              const s = this._autoClosingPairs[ r ];
              if ( s.open === e ) return s.isOK( o )
            }
            return !1
          }, e.prototype.getSurroundingPairs = function () {
            return this._surroundingPairs
          }, e;
        } )(),
        r = n( "BFtn" ),
        s = n( "EIAu" ),
        a = ( () => {
          function e( e, t, n ) {
            n = n || {}, this._richEditBrackets = e, this._complexAutoClosePairs = t.filter( ( e => {
              return e.open.length > 1 && !!e.close
            } ) ).map( ( e => {
              return new i.b( e )
            } ) ), n.docComment && this._complexAutoClosePairs.push( new i.b( {
              open: n.docComment.open,
              close: n.docComment.close
            } ) )
          }
          return e.prototype.getElectricCharacters = function () {
            let e = [];
            if ( this._richEditBrackets )
              for ( let t = 0, n = this._richEditBrackets.brackets.length; t < n; t++ ) {
                const i = this._richEditBrackets.brackets[ t ],
                  o = i.close.charAt( i.close.length - 1 );
                e.push( o )
              }
            for ( let r = 0, s = this._complexAutoClosePairs; r < s.length; r++ ) {
              const a = s[ r ];
              e.push( a.open.charAt( a.open.length - 1 ) )
            }
            return e = e.filter( ( ( e, t, n ) => {
              return n.indexOf( e ) === t
            } ) );
          }, e.prototype.onElectricCharacter = function ( e, t, n ) {
            return this._onElectricAutoClose( e, t, n ) || this._onElectricAutoIndent( e, t, n )
          }, e.prototype._onElectricAutoIndent = function ( e, t, n ) {
            if ( !this._richEditBrackets || 0 === this._richEditBrackets.brackets.length ) return null;
            const i = t.findTokenIndexAtOffset( n - 1 );
            if ( Object( r.b )( t.getStandardTokenType( i ) ) ) return null;
            const o = this._richEditBrackets.reversedRegex,
              a = t.getLineContent().substring( 0, n - 1 ) + e,
              u = s.a.findPrevBracketInToken( o, 1, a, 0, a.length );
            if ( !u ) return null;
            let l = a.substring( u.startColumn - 1, u.endColumn - 1 );
            if ( l = l.toLowerCase(), this._richEditBrackets.textIsOpenBracket[ l ] ) return null;
            const c = a.substring( 0, u.startColumn - 1 );
            return /^\s*$/.test( c ) ? {
              matchOpenBracket: l
            } : null
          }, e.prototype._onElectricAutoClose = function ( e, t, n ) {
            if ( !this._complexAutoClosePairs.length ) return null;
            for ( let i = t.getLineContent(), o = 0, r = this._complexAutoClosePairs.length; o < r; o++ ) {
              const s = this._complexAutoClosePairs[ o ];
              if ( e === s.open.charAt( s.open.length - 1 ) )
                if ( i.substring( i.length - s.open.length + 1 ) + e === s.open ) {
                  const a = t.findTokenIndexAtOffset( n - 1 ),
                    u = t.getStandardTokenType( a );
                  if ( s.isOK( u ) && !( i.indexOf( s.close, n - 1 ) >= 0 ) ) return {
                    appendText: s.close
                  }
                }
            }
            return null
          }, e;
        } )(),
        u = n( "/cxE" ),
        l = n( "N0LK" ),
        c = ( () => {
          function e( t ) {
            ( t = t || {} ).brackets = t.brackets || [
              [ "(", ")" ],
              [ "{", "}" ],
              [ "[", "]" ]
            ], this._brackets = t.brackets.map( ( t => {
              return {
                open: t[ 0 ],
                openRegExp: e._createOpenBracketRegExp( t[ 0 ] ),
                close: t[ 1 ],
                closeRegExp: e._createCloseBracketRegExp( t[ 1 ] )
              }
            } ) ), this._regExpRules = t.regExpRules || []
          }
          return e.prototype.onEnter = function ( e, t, n ) {
            for ( var o = 0, r = this._regExpRules.length; o < r; o++ ) {
              const s = this._regExpRules[ o ];
              if ( s.beforeText.test( t ) ) {
                if ( !s.afterText ) return s.action;
                if ( s.afterText.test( n ) ) return s.action
              }
            }
            if ( t.length > 0 && n.length > 0 )
              for ( o = 0, r = this._brackets.length; o < r; o++ ) {
                if ( ( a = this._brackets[ o ] ).openRegExp.test( t ) && a.closeRegExp.test( n ) ) return {
                  indentAction: i.a.IndentOutdent
                }
              }
            if ( t.length > 0 )
              for ( o = 0, r = this._brackets.length; o < r; o++ ) {
                var a;
                if ( ( a = this._brackets[ o ] ).openRegExp.test( t ) ) return {
                  indentAction: i.a.Indent
                }
              }
            return null
          }, e._createOpenBracketRegExp = t => {
            let n = l.escapeRegExpCharacters( t );
            return /\B/.test( n.charAt( 0 ) ) || ( n = "\\b" + n ), n += "\\s*$", e._safeRegExp( n )
          }, e._createCloseBracketRegExp = t => {
            let n = l.escapeRegExpCharacters( t );
            return /\B/.test( n.charAt( n.length - 1 ) ) || ( n += "\\b" ), n = "^\\s*" + n, e._safeRegExp( n )
          }, e._safeRegExp = e => {
            try {
              return new RegExp( e )
            } catch ( t ) {
              return Object( u.e )( t ), null
            }
          }, e;
        } )(),
        d = ( () => {
          function e( e ) {
            this._indentationRules = e
          }
          return e.prototype.shouldIncrease = function ( e ) {
            return !!( this._indentationRules && this._indentationRules.increaseIndentPattern && this._indentationRules.increaseIndentPattern.test( e ) )
          }, e.prototype.shouldDecrease = function ( e ) {
            return !!( this._indentationRules && this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test( e ) )
          }, e.prototype.shouldIndentNextLine = function ( e ) {
            return !!( this._indentationRules && this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test( e ) )
          }, e.prototype.shouldIgnore = function ( e ) {
            return !!( this._indentationRules && this._indentationRules.unIndentedLinePattern && this._indentationRules.unIndentedLinePattern.test( e ) )
          }, e.prototype.getIndentMetadata = function ( e ) {
            let t = 0;
            return this.shouldIncrease( e ) && ( t += 1 ), this.shouldDecrease( e ) && ( t += 2 ), this.shouldIndentNextLine( e ) && ( t += 4 ), this.shouldIgnore( e ) && ( t += 8 ), t
          }, e;
        } )(),
        h = n( "MI8n" ),
        p = n( "pmY6" ),
        f = n( "0JNc" ),
        g = n( "aokT" );
      n.d( t, "a", ( () => {
        return _
      } ) );

      const m = ( () => {
        function e( t, n, i ) {
          this._languageIdentifier = t, this._brackets = null, this._electricCharacter = null;
          let r = null;
          n && ( r = n._conf ), this._conf = e._mergeConf( r, i ), this.onEnter = e._handleOnEnter( this._conf ), this.comments = e._handleComments( this._conf ), this.characterPair = new o( this._conf ), this.wordDefinition = this._conf.wordPattern || f.a, this.indentationRules = this._conf.indentationRules, this._conf.indentationRules && ( this.indentRulesSupport = new d( this._conf.indentationRules ) ), this.foldingRules = this._conf.folding || {}
        }
        return Object.defineProperty( e.prototype, "brackets", {
          get() {
            return !this._brackets && this._conf.brackets && ( this._brackets = new s.b( this._languageIdentifier, this._conf.brackets ) ), this._brackets
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "electricCharacter", {
          get() {
            if ( !this._electricCharacter ) {
              let e = [];
              this._conf.autoClosingPairs ? e = this._conf.autoClosingPairs : this._conf.brackets && ( e = this._conf.brackets.map( ( e => {
                return {
                  open: e[ 0 ],
                  close: e[ 1 ]
                }
              } ) ) ), this._electricCharacter = new a( this.brackets, e, this._conf.__electricCharacterSupport )
            }
            return this._electricCharacter
          },
          enumerable: !0,
          configurable: !0
        } ), e._mergeConf = ( e, t ) => {
          return {
            comments: e ? t.comments || e.comments : t.comments,
            brackets: e ? t.brackets || e.brackets : t.brackets,
            wordPattern: e ? t.wordPattern || e.wordPattern : t.wordPattern,
            indentationRules: e ? t.indentationRules || e.indentationRules : t.indentationRules,
            onEnterRules: e ? t.onEnterRules || e.onEnterRules : t.onEnterRules,
            autoClosingPairs: e ? t.autoClosingPairs || e.autoClosingPairs : t.autoClosingPairs,
            surroundingPairs: e ? t.surroundingPairs || e.surroundingPairs : t.surroundingPairs,
            folding: e ? t.folding || e.folding : t.folding,
            __electricCharacterSupport: e ? t.__electricCharacterSupport || e.__electricCharacterSupport : t.__electricCharacterSupport
          }
        }, e._handleOnEnter = e => {
          const t = {};
          let n = !0;
          return e.brackets && ( n = !1, t.brackets = e.brackets ), e.indentationRules && ( n = !1 ), e.onEnterRules && ( n = !1, t.regExpRules = e.onEnterRules ), n ? null : new c( t )
        }, e._handleComments = e => {
          const t = e.comments;
          if ( !t ) return null;
          const n = {};
          if ( t.lineComment && ( n.lineCommentToken = t.lineComment ), t.blockComment ) {
            const i = t.blockComment,
              o = i[ 0 ],
              r = i[ 1 ];
            n.blockCommentStartToken = o, n.blockCommentEndToken = r
          }
          return n
        }, e;
      } )();

      var _ = new( ( () => {
        function e() {
          this._onDidChange = new h.a, this.onDidChange = this._onDidChange.event, this._entries = []
        }
        return e.prototype.register = function ( e, t ) {
          const n = this,
            i = this._getRichEditSupport( e.id ),
            o = new m( e, i, t );
          return this._entries[ e.id ] = o, this._onDidChange.fire( {
            languageIdentifier: e
          } ), Object( p.f )( ( () => {
            n._entries[ e.id ] === o && ( n._entries[ e.id ] = i, n._onDidChange.fire( {
              languageIdentifier: e
            } ) )
          } ) );
        }, e.prototype._getRichEditSupport = function ( e ) {
          return this._entries[ e ] || null
        }, e.prototype._getElectricCharacterSupport = function ( e ) {
          const t = this._getRichEditSupport( e );
          return t && t.electricCharacter || null
        }, e.prototype.getElectricCharacters = function ( e ) {
          const t = this._getElectricCharacterSupport( e );
          return t ? t.getElectricCharacters() : []
        }, e.prototype.onElectricCharacter = function ( e, t, n ) {
          const i = Object( r.a )( t, n - 1 ),
            o = this._getElectricCharacterSupport( i.languageId );
          return o ? o.onElectricCharacter( e, i, n - i.firstCharOffset ) : null
        }, e.prototype.getComments = function ( e ) {
          const t = this._getRichEditSupport( e );
          return t && t.comments || null
        }, e.prototype._getCharacterPairSupport = function ( e ) {
          const t = this._getRichEditSupport( e );
          return t && t.characterPair || null
        }, e.prototype.getAutoClosingPairs = function ( e ) {
          const t = this._getCharacterPairSupport( e );
          return t ? t.getAutoClosingPairs() : []
        }, e.prototype.getSurroundingPairs = function ( e ) {
          const t = this._getCharacterPairSupport( e );
          return t ? t.getSurroundingPairs() : []
        }, e.prototype.shouldAutoClosePair = function ( e, t, n ) {
          const i = Object( r.a )( t, n - 1 ),
            o = this._getCharacterPairSupport( i.languageId );
          return !!o && o.shouldAutoClosePair( e, i, n - i.firstCharOffset )
        }, e.prototype.getWordDefinition = function ( e ) {
          const t = this._getRichEditSupport( e );
          return t ? Object( f.c )( t.wordDefinition || null ) : Object( f.c )( null )
        }, e.prototype.getFoldingRules = function ( e ) {
          const t = this._getRichEditSupport( e );
          return t ? t.foldingRules : {}
        }, e.prototype.getIndentRulesSupport = function ( e ) {
          const t = this._getRichEditSupport( e );
          return t && t.indentRulesSupport || null
        }, e.prototype.getPrecedingValidLine = ( e, t, n ) => {
          const i = e.getLanguageIdAtPosition( t, 0 );
          if ( t > 1 ) {
            let o = t - 1,
              r = -1;
            for ( o = t - 1; o >= 1; o-- ) {
              if ( e.getLanguageIdAtPosition( o, 0 ) !== i ) return r;
              const s = e.getLineContent( o );
              if ( !n.shouldIgnore( s ) && !/^\s+$/.test( s ) && "" !== s ) return o;
              r = o
            }
          }
          return -1
        }, e.prototype.getInheritIndentForLine = function ( e, t, n ) {
          void 0 === n && ( n = !0 );
          const o = this.getIndentRulesSupport( e.getLanguageIdentifier().id );
          if ( !o ) return null;
          if ( t <= 1 ) return {
            indentation: "",
            action: null
          };
          const r = this.getPrecedingValidLine( e, t, o );
          if ( r < 0 ) return null;
          if ( r < 1 ) return {
            indentation: "",
            action: null
          };
          const s = e.getLineContent( r );
          if ( o.shouldIncrease( s ) || o.shouldIndentNextLine( s ) ) return {
            indentation: l.getLeadingWhitespace( s ),
            action: i.a.Indent,
            line: r
          };
          if ( o.shouldDecrease( s ) ) return {
            indentation: l.getLeadingWhitespace( s ),
            action: null,
            line: r
          };
          if ( 1 === r ) return {
            indentation: l.getLeadingWhitespace( e.getLineContent( r ) ),
            action: null,
            line: r
          };
          const a = r - 1,
            u = o.getIndentMetadata( e.getLineContent( a ) );
          if ( !( 3 & u ) && 4 & u ) {
            for ( var c = 0, d = a - 1; d > 0; d-- )
              if ( !o.shouldIndentNextLine( e.getLineContent( d ) ) ) {
                c = d;
                break
              } return {
              indentation: l.getLeadingWhitespace( e.getLineContent( c + 1 ) ),
              action: null,
              line: c + 1
            }
          }
          if ( n ) return {
            indentation: l.getLeadingWhitespace( e.getLineContent( r ) ),
            action: null,
            line: r
          };
          for ( d = r; d > 0; d-- ) {
            const h = e.getLineContent( d );
            if ( o.shouldIncrease( h ) ) return {
              indentation: l.getLeadingWhitespace( h ),
              action: i.a.Indent,
              line: d
            };
            if ( o.shouldIndentNextLine( h ) ) {
              c = 0;
              for ( let p = d - 1; p > 0; p-- )
                if ( !o.shouldIndentNextLine( e.getLineContent( d ) ) ) {
                  c = p;
                  break
                } return {
                indentation: l.getLeadingWhitespace( e.getLineContent( c + 1 ) ),
                action: null,
                line: c + 1
              }
            }
            if ( o.shouldDecrease( h ) ) return {
              indentation: l.getLeadingWhitespace( h ),
              action: null,
              line: d
            }
          }
          return {
            indentation: l.getLeadingWhitespace( e.getLineContent( 1 ) ),
            action: null,
            line: 1
          }
        }, e.prototype.getGoodIndentForLine = function ( e, t, n, o ) {
          const r = this.getIndentRulesSupport( t );
          if ( !r ) return null;
          const s = this.getInheritIndentForLine( e, n ),
            a = e.getLineContent( n );
          if ( s ) {
            const c = s.line;
            if ( void 0 !== c ) {
              const d = this._getOnEnterSupport( t );
              let h = null;
              try {
                h = d.onEnter( "", e.getLineContent( c ), "" )
              } catch ( f ) {
                Object( u.e )( f )
              }
              if ( h ) {
                let p = l.getLeadingWhitespace( e.getLineContent( c ) );
                return h.removeText && ( p = p.substring( 0, p.length - h.removeText ) ), h.indentAction === i.a.Indent || h.indentAction === i.a.IndentOutdent ? p = o.shiftIndent( p ) : h.indentAction === i.a.Outdent && ( p = o.unshiftIndent( p ) ), r.shouldDecrease( a ) && ( p = o.unshiftIndent( p ) ), h.appendText && ( p += h.appendText ), l.getLeadingWhitespace( p )
              }
            }
            return r.shouldDecrease( a ) ? s.action === i.a.Indent ? s.indentation : o.unshiftIndent( s.indentation ) : s.action === i.a.Indent ? o.shiftIndent( s.indentation ) : s.indentation
          }
          return null
        }, e.prototype.getIndentForEnter = function ( e, t, n, o ) {
          e.forceTokenization( t.startLineNumber );
          let s;
          let a;
          const u = e.getLineTokens( t.startLineNumber );
          const c = Object( r.a )( u, t.startColumn - 1 );
          const d = c.getLineContent();
          let h = !1;
          ( c.firstCharOffset > 0 && u.getLanguageId( 0 ) !== c.languageId ? ( h = !0, s = d.substr( 0, t.startColumn - 1 - c.firstCharOffset ) ) : s = u.getLineContent().substring( 0, t.startColumn - 1 ), t.isEmpty() ) ? a = d.substr( t.startColumn - 1 - c.firstCharOffset ): a = this.getScopedLineTokens( e, t.endLineNumber, t.endColumn ).getLineContent().substr( t.endColumn - 1 - c.firstCharOffset );
          const p = this.getIndentRulesSupport( c.languageId );
          if ( !p ) return null;
          let f = s,
            g = l.getLeadingWhitespace( s );
          if ( !o && !h ) {
            const m = this.getInheritIndentForLine( e, t.startLineNumber );
            p.shouldDecrease( s ) && m && ( g = m.indentation, m.action !== i.a.Indent && ( g = n.unshiftIndent( g ) ) ), f = g + l.ltrim( l.ltrim( s, " " ), "\t" )
          }
          const _ = {
              getLineTokens( t ) {
                return e.getLineTokens( t )
              },
              getLanguageIdentifier() {
                return e.getLanguageIdentifier()
              },
              getLanguageIdAtPosition( t, n ) {
                return e.getLanguageIdAtPosition( t, n )
              },
              getLineContent( n ) {
                return n === t.startLineNumber ? f : e.getLineContent( n )
              }
            },
            v = l.getLeadingWhitespace( u.getLineContent() ),
            y = this.getInheritIndentForLine( _, t.startLineNumber + 1 );
          if ( !y ) {
            const b = h ? v : g;
            return {
              beforeEnter: b,
              afterEnter: b
            }
          }
          let C = h ? v : y.indentation;
          return y.action === i.a.Indent && ( C = n.shiftIndent( C ) ), p.shouldDecrease( a ) && ( C = n.unshiftIndent( C ) ), {
            beforeEnter: h ? v : g,
            afterEnter: C
          }
        }, e.prototype.getIndentActionForType = function ( e, t, n, o ) {
          const r = this.getScopedLineTokens( e, t.startLineNumber, t.startColumn ),
            s = this.getIndentRulesSupport( r.languageId );
          if ( !s ) return null;
          let a;
          const u = r.getLineContent();
          const l = u.substr( 0, t.startColumn - 1 - r.firstCharOffset );
          t.isEmpty() ? a = u.substr( t.startColumn - 1 - r.firstCharOffset ) : a = this.getScopedLineTokens( e, t.endLineNumber, t.endColumn ).getLineContent().substr( t.endColumn - 1 - r.firstCharOffset );
          if ( !s.shouldDecrease( l + a ) && s.shouldDecrease( l + n + a ) ) {
            const c = this.getInheritIndentForLine( e, t.startLineNumber, !1 );
            if ( !c ) return null;
            let d = c.indentation;
            return c.action !== i.a.Indent && ( d = o.unshiftIndent( d ) ), d
          }
          return null
        }, e.prototype.getIndentMetadata = function ( e, t ) {
          const n = this.getIndentRulesSupport( e.getLanguageIdentifier().id );
          return n ? t < 1 || t > e.getLineCount() ? null : n.getIndentMetadata( e.getLineContent( t ) ) : null
        }, e.prototype._getOnEnterSupport = function ( e ) {
          const t = this._getRichEditSupport( e );
          return t && t.onEnter || null
        }, e.prototype.getRawEnterActionAtPosition = function ( e, t, n ) {
          const i = this.getEnterAction( e, new g.a( t, n, t, n ) );
          return i ? i.enterAction : null
        }, e.prototype.getEnterAction = function ( e, t ) {
          let n = this.getIndentationAtPosition( e, t.startLineNumber, t.startColumn );
          const o = this.getScopedLineTokens( e, t.startLineNumber, t.startColumn );
          const r = this._getOnEnterSupport( o.languageId );
          if ( !r ) return null;
          let s;
          const a = o.getLineContent();
          const l = a.substr( 0, t.startColumn - 1 - o.firstCharOffset );
          t.isEmpty() ? s = a.substr( t.startColumn - 1 - o.firstCharOffset ) : s = this.getScopedLineTokens( e, t.endLineNumber, t.endColumn ).getLineContent().substr( t.endColumn - 1 - o.firstCharOffset );
          const c = t.startLineNumber;
          let d = "";
          if ( c > 1 && 0 === o.firstCharOffset ) {
            const h = this.getScopedLineTokens( e, c - 1 );
            h.languageId === o.languageId && ( d = h.getLineContent() )
          }
          let p = null;
          try {
            p = r.onEnter( d, l, s )
          } catch ( f ) {
            Object( u.e )( f )
          }
          return p ? ( p.appendText || ( p.indentAction === i.a.Indent || p.indentAction === i.a.IndentOutdent ? p.appendText = "\t" : p.appendText = "" ), p.removeText && ( n = n.substring( 0, n.length - p.removeText ) ), {
            enterAction: p,
            indentation: n
          } ) : null
        }, e.prototype.getIndentationAtPosition = ( e, t, n ) => {
          const i = e.getLineContent( t );
          let o = l.getLeadingWhitespace( i );
          return o.length > n - 1 && ( o = o.substring( 0, n - 1 ) ), o
        }, e.prototype.getScopedLineTokens = ( e, t, n ) => {
          e.forceTokenization( t );
          const i = e.getLineTokens( t ),
            o = isNaN( n ) ? e.getLineMaxColumn( t ) - 1 : n - 1;
          return Object( r.a )( i, o )
        }, e.prototype.getBracketsSupport = function ( e ) {
          const t = this._getRichEditSupport( e );
          return t && t.brackets || null
        }, e;
      } )() )();
    },
    cSGN( e, t, n ) {
      "use strict";
      n( "M1kC" );
      const i = n( "3/fG" ),
        o = n( "/cxE" ),
        r = n( "MI8n" ),
        s = n( "pmY6" ),
        a = n( "tYmi" ),
        u = n( "N0LK" ),
        l = n( "VMIq" ),
        c = n( "zrhQ" ),
        d = n( "lCHf" ),
        h = n( "EffR" ),
        p = n( "cMOf" ),
        f = ( n( "VPJY" ), n( "qj0h" ) ),
        g = {
          badgeBackground: c.a.fromHex( "#4D4D4D" ),
          badgeForeground: c.a.fromHex( "#FFFFFF" )
        },
        m = ( () => {
          function e( e, t ) {
            this.options = t || Object.create( null ), Object( f.g )( this.options, g, !1 ), this.badgeBackground = this.options.badgeBackground, this.badgeForeground = this.options.badgeForeground, this.badgeBorder = this.options.badgeBorder, this.element = Object( h.k )( e, Object( h.a )( ".monaco-count-badge" ) ), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount( this.options.count || 0 )
          }
          return e.prototype.setCount = function ( e ) {
            this.count = e, this.render()
          }, e.prototype.setTitleFormat = function ( e ) {
            this.titleFormat = e, this.render()
          }, e.prototype.render = function () {
            this.element.textContent = Object( u.format )( this.countFormat, this.count ), this.element.title = Object( u.format )( this.titleFormat, this.count ), this.applyStyles()
          }, e.prototype.style = function ( e ) {
            this.badgeBackground = e.badgeBackground, this.badgeForeground = e.badgeForeground, this.badgeBorder = e.badgeBorder, this.applyStyles()
          }, e.prototype.applyStyles = function () {
            if ( this.element ) {
              const e = this.badgeBackground ? this.badgeBackground.toString() : null,
                t = this.badgeForeground ? this.badgeForeground.toString() : null,
                n = this.badgeBorder ? this.badgeBorder.toString() : null;
              this.element.style.backgroundColor = e, this.element.style.color = t, this.element.style.borderWidth = n ? "1px" : null, this.element.style.borderStyle = n ? "solid" : null, this.element.style.borderColor = n
            }
          }, e;
        } )(),
        _ = n( "xONI" ),
        v = n( "Cg/j" ),
        y = n( "EWX2" ),
        b = n( "aokT" ),
        C = n( "tX9W" ),
        w = n( "03kh" ),
        S = n( "5aqo" ),
        O = n( "OlfL" ),
        L = n( "t49l" ),
        x = n( "MD5Z" ),
        N = n( "t9D7" ),
        E = n( "ptcw" ),
        k = Object( v.c )( "environmentService" ),
        I = n( "bY76" ),
        D = n( "M1Kb" ),
        M = n( "k9mg" ),
        T = n( "T8No" ),
        R = n( "X8W9" ),
        P = n( "2jrX" ),
        A = n( "gslv" );
      n.d( t, "b", ( () => {
        return $
      } ) ), n.d( t, "a", ( () => {
        return Z
      } ) );
      const F = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const W = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const j = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      const V = ( e, t, n, i ) => {
        return new( n || ( n = Promise ) )( ( ( o, r ) => {
          function s( e ) {
            try {
              u( i.next( e ) )
            } catch ( t ) {
              r( t )
            }
          }

          function a( e ) {
            try {
              u( i.throw( e ) )
            } catch ( t ) {
              r( t )
            }
          }

          function u( e ) {
            e.done ? o( e.value ) : new n( ( t => {
              t( e.value )
            } ) ).then( s, a )
          }
          u( ( i = i.apply( e, t || [] ) ).next() )
        } ) );
      };
      const B = ( e, t ) => {
        let n, i, o, r, s = {
          label: 0,
          sent() {
            if ( 1 & o[ 0 ] ) throw o[ 1 ];
            return o[ 1 ]
          },
          trys: [],
          ops: []
        };
        return r = {
          next: a( 0 ),
          throw: a( 1 ),
          return: a( 2 )
        }, "function" === typeof Symbol && ( r[ Symbol.iterator ] = function () {
          return this
        } ), r;

        function a( r ) {
          return a => {
            return ( r => {
              if ( n ) throw new TypeError( "Generator is already executing." );
              for ( ; s; ) try {
                if ( n = 1, i && ( o = 2 & r[ 0 ] ? i.return : r[ 0 ] ? i.throw || ( ( o = i.return ) && o.call( i ), 0 ) : i.next ) && !( o = o.call( i, r[ 1 ] ) ).done ) return o;
                switch ( i = 0, o && ( r = [ 2 & r[ 0 ], o.value ] ), r[ 0 ] ) {
                  case 0:
                  case 1:
                    o = r;
                    break;
                  case 4:
                    return s.label++, {
                      value: r[ 1 ],
                      done: !1
                    };
                  case 5:
                    s.label++, i = r[ 1 ], r = [ 0 ];
                    continue;
                  case 7:
                    r = s.ops.pop(), s.trys.pop();
                    continue;
                  default:
                    if ( !( o = ( o = s.trys ).length > 0 && o[ o.length - 1 ] ) && ( 6 === r[ 0 ] || 2 === r[ 0 ] ) ) {
                      s = 0;
                      continue
                    }
                    if ( 3 === r[ 0 ] && ( !o || r[ 1 ] > o[ 0 ] && r[ 1 ] < o[ 3 ] ) ) {
                      s.label = r[ 1 ];
                      break
                    }
                    if ( 6 === r[ 0 ] && s.label < o[ 1 ] ) {
                      s.label = o[ 1 ], o = r;
                      break
                    }
                    if ( o && s.label < o[ 2 ] ) {
                      s.label = o[ 2 ], s.ops.push( r );
                      break
                    }
                    o[ 2 ] && s.ops.pop(), s.trys.pop();
                    continue
                }
                r = t.call( e, s )
              } catch ( a ) {
                r = [ 6, a ], i = 0
              } finally {
                n = o = 0
              }
              if ( 5 & r[ 0 ] ) throw r[ 1 ];
              return {
                value: r[ 0 ] ? r[ 1 ] : void 0,
                done: !0
              }
            } )( [ r, a ] );
          };
        }
      };
      const H = ( () => {
        function e( e, t ) {
          const n = this;
          this._editor = e, this._model = t, this._decorations = new Map, this._decorationIgnoreSet = new Set, this._callOnDispose = [], this._callOnModelChange = [], this._callOnDispose.push( this._editor.onDidChangeModel( ( () => {
            return n._onModelChanged()
          } ) ) ), this._onModelChanged()
        }
        return e.prototype.dispose = function () {
          this._callOnModelChange = Object( s.d )( this._callOnModelChange ), this._callOnDispose = Object( s.d )( this._callOnDispose ), this.removeDecorations()
        }, e.prototype._onModelChanged = function () {
          this._callOnModelChange = Object( s.d )( this._callOnModelChange );
          const e = this._editor.getModel();
          if ( e )
            for ( let t = 0, n = this._model.groups; t < n.length; t++ ) {
              const i = n[ t ];
              if ( i.uri.toString() === e.uri.toString() ) return void this._addDecorations( i )
            }
        }, e.prototype._addDecorations = function ( t ) {
          const n = this;
          this._callOnModelChange.push( this._editor.getModel().onDidChangeDecorations( ( e => {
            return n._onDecorationChanged()
          } ) ) );
          for ( var i = [], o = [], r = 0, s = t.children.length; r < s; r++ ) {
            const a = t.children[ r ];
            this._decorationIgnoreSet.has( a.id ) || ( i.push( {
              range: a.range,
              options: e.DecorationOptions
            } ), o.push( r ) )
          }
          const u = this._editor.deltaDecorations( [], i );
          for ( r = 0; r < u.length; r++ ) this._decorations.set( u[ r ], t.children[ o[ r ] ] )
        }, e.prototype._onDecorationChanged = function () {
          const e = this,
            t = [];
          this._decorations.forEach( ( ( n, i ) => {
            const o = e._editor.getModel().getDecorationRange( i );
            if ( o ) {
              let r = !1;
              if ( !b.a.equalsRange( o, n.range ) ) b.a.spansMultipleLines( o ) ? r = !0 : n.range.endColumn - n.range.startColumn !== o.endColumn - o.startColumn && ( r = !0 ), r ? ( e._decorationIgnoreSet.add( n.id ), t.push( i ) ) : n.range = o
            }
          } ) );
          for ( let n = 0, i = t.length; n < i; n++ ) this._decorations.delete( t[ n ] );
          this._editor.deltaDecorations( t, [] )
        }, e.prototype.removeDecorations = function () {
          const e = [];
          this._decorations.forEach( ( ( t, n ) => {
            e.push( n )
          } ) ), this._editor.deltaDecorations( e, [] ), this._decorations.clear()
        }, e.DecorationOptions = C.a.register( {
          stickiness: D.h.NeverGrowsWhenTypingAtEdges,
          className: "reference-decoration"
        } ), e;
      } )();
      const z = ( () => {
        function e( e ) {
          this._textModelResolverService = e
        }
        return e.prototype.getId = ( e, t ) => {
          return t instanceof O.c ? "root" : t instanceof O.a ? t.id : t instanceof O.b ? t.id : void 0
        }, e.prototype.hasChildren = ( e, t ) => {
          return t instanceof O.c || t instanceof O.a && !t.failure
        }, e.prototype.getChildren = function ( e, t ) {
          return t instanceof O.c ? l.b.as( t.groups ) : t instanceof O.a ? t.resolve( this._textModelResolverService ).then( ( n => {
            return t.failure ? e.refresh( t ).then( ( () => {
              return n.children
            } ) ) : n.children;
          } ) ) : l.b.as( [] );
        }, e.prototype.getParent = ( e, t ) => {
          let n = null;
          return t instanceof O.a ? n = t.parent : t instanceof O.b && ( n = t.parent ), l.b.as( n )
        }, e = W( [ j( 0, L.a ) ], e );
      } )();
      const U = ( e => {
        function t() {
          const t = null !== e && e.apply( this, arguments ) || this;
          return t._onDidFocus = new r.a, t.onDidFocus = t._onDidFocus.event, t._onDidSelect = new r.a, t.onDidSelect = t._onDidSelect.event, t._onDidOpenToSide = new r.a, t.onDidOpenToSide = t._onDidOpenToSide.event, t
        }
        return F( t, e ), t.prototype.onTap = function ( t, n, i ) {
          if ( n instanceof O.a ) return i.preventDefault(), i.stopPropagation(), this._expandCollapse( t, n );
          const o = e.prototype.onTap.call( this, t, n, i );
          return this._onDidFocus.fire( n ), o
        }, t.prototype.onMouseDown = function ( t, n, i ) {
          const o = 2 === i.detail;
          if ( i.leftButton ) {
            if ( n instanceof O.a && ( this.openOnSingleClick || o || this.isClickOnTwistie( i ) ) ) return i.preventDefault(), i.stopPropagation(), this._expandCollapse( t, n );
            const r = e.prototype.onClick.call( this, t, n, i );
            return ( i.ctrlKey || i.metaKey || i.altKey ) && ( o || this.openOnSingleClick ) ? this._onDidOpenToSide.fire( n ) : o ? this._onDidSelect.fire( n ) : this.openOnSingleClick && this._onDidFocus.fire( n ), r
          }
          return !1
        }, t.prototype.onClick = function ( t, n, i ) {
          return !i.leftButton && e.prototype.onClick.call( this, t, n, i )
        }, t.prototype._expandCollapse = ( e, t ) => {
          return e.isExpanded( t ) ? e.collapse( t ).done( null, o.e ) : e.expand( t ).done( null, o.e ), !0
        }, t.prototype.onEscape = ( e, t ) => {
          return !1
        }, t.prototype.dispose = function () {
          this._onDidFocus.dispose(), this._onDidSelect.dispose(), this._onDidOpenToSide.dispose()
        }, t;
      } )( M.d );
      const K = ( () => {
        function e( e, t, n, i ) {
          const o = this;
          this._contextService = t, this._environmentService = n;
          const r = document.createElement( "div" );
          h.f( r, "reference-file" ), e.appendChild( r ), this.file = new _.a( r, I.a.parse( "no:file" ), this._contextService, this._environmentService ), this.badge = new m( Object( d.a )( ".count" ).appendTo( r ).getHTMLElement() );
          const s = Object( E.a )( this.badge, i );
          this.dispose = () => {
            o.file.dispose(), s.dispose()
          }
        }
        return e.prototype.set = function ( e ) {
          this.file.setFile( e.uri, this._contextService, this._environmentService );
          const t = e.children.length;
          this.badge.setCount( t ), e.failure ? this.badge.setTitleFormat( i.a( "referencesFailre", "Failed to resolve file." ) ) : t > 1 ? this.badge.setTitleFormat( i.a( "referencesCount", "{0} references", t ) ) : this.badge.setTitleFormat( i.a( "referenceCount", "{0} reference", t ) )
        }, e = W( [ j( 1, y.a ), j( 2, Object( v.d )( k ) ), j( 3, N.c ) ], e );
      } )();
      const q = ( () => {
        function e( e ) {
          const t = document.createElement( "div" );
          this.before = document.createElement( "span" ), this.inside = document.createElement( "span" ), this.after = document.createElement( "span" ), h.f( this.inside, "referenceMatch" ), h.f( t, "reference" ), t.appendChild( this.before ), t.appendChild( this.inside ), t.appendChild( this.after ), e.appendChild( t )
        }
        return e.prototype.set = function ( e ) {
          const t = e.parent.preview.preview( e.range ),
            n = t.before,
            i = t.inside,
            o = t.after;
          this.before.innerHTML = u.escape( n ), this.inside.innerHTML = u.escape( i ), this.after.innerHTML = u.escape( o )
        }, e;
      } )();
      const G = ( () => {
        function e( e, t, n ) {
          this._contextService = e, this._themeService = t, this._environmentService = n
        }
        return e.prototype.getHeight = ( e, t ) => {
          return 23
        }, e.prototype.getTemplateId = ( t, n ) => {
          if ( n instanceof O.a ) return e._ids.FileReferences;
          if ( n instanceof O.b ) return e._ids.OneReference;
          throw n
        }, e.prototype.renderTemplate = function ( t, n, i ) {
          if ( n === e._ids.FileReferences ) return new K( i, this._contextService, this._environmentService, this._themeService );
          if ( n === e._ids.OneReference ) return new q( i );
          throw n
        }, e.prototype.renderElement = ( e, t, n, i ) => {
          if ( t instanceof O.a ) i.set( t );
          else {
            if ( !( t instanceof O.b ) ) throw n;
            i.set( t )
          }
        }, e.prototype.disposeTemplate = ( e, t, n ) => {
          n instanceof K && n.dispose()
        }, e._ids = {
          FileReferences: "FileReferences",
          OneReference: "OneReference"
        }, e = W( [ j( 0, y.a ), j( 1, N.c ), j( 2, Object( v.d )( k ) ) ], e );
      } )();
      const Y = ( () => {
        function e() {}
        return e.prototype.getAriaLabel = ( e, t ) => {
          return t instanceof O.a ? t.getAriaMessage() : t instanceof O.b ? t.getAriaMessage() : void 0
        }, e;
      } )();

      const X = ( () => {
        function e( e, t ) {
          let n;
          const i = this;
          this._disposables = [], this._onDidChangePercentages = new r.a, this._ratio = t, this._sash = new p.b( e, {
            getVerticalSashLeft() {
              return i._width * i._ratio
            },
            getVerticalSashHeight() {
              return i._height
            }
          } ), this._disposables.push( this._sash.onDidStart( ( e => {
            n = e.startX - i._width * i.ratio
          } ) ) ), this._disposables.push( this._sash.onDidChange( ( e => {
            const t = e.currentX - n;
            t > 20 && t + 20 < i._width && ( i._ratio = t / i._width, i._sash.layout(), i._onDidChangePercentages.fire( i ) )
          } ) ) )
        }
        return e.prototype.dispose = function () {
          this._sash.dispose(), this._onDidChangePercentages.dispose(), Object( s.d )( this._disposables )
        }, Object.defineProperty( e.prototype, "onDidChangePercentages", {
          get() {
            return this._onDidChangePercentages.event
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "width", {
          set( e ) {
            this._width = e, this._sash.layout()
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "height", {
          set( e ) {
            this._height = e, this._sash.layout()
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "percentages", {
          get() {
            const e = 100 * this._ratio;
            return [ e + "%", 100 - e + "%" ]
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "ratio", {
          get() {
            return this._ratio
          },
          enumerable: !0,
          configurable: !0
        } ), e;
      } )();

      var $ = new T.f( "referenceSearchTreeFocused", !0 );

      var Z = ( e => {
        function t( t, n, i, o, s, a, u ) {
          const l = e.call( this, t, {
            showFrame: !1,
            showArrow: !0,
            isResizeable: !0,
            isAccessible: !0
          } ) || this;
          return l._defaultTreeKeyboardSupport = n, l.layoutData = i, l._textModelResolverService = s, l._instantiationService = a, l._uriDisplay = u, l._disposeOnNewModel = [], l._callOnDispose = [], l._onDidSelectReference = new r.a, l._applyTheme( o.getTheme() ), l._callOnDispose.push( o.onThemeChange( l._applyTheme.bind( l ) ) ), l.create(), l
        }
        return F( t, e ), t.prototype._applyTheme = function ( e ) {
          const t = e.getColor( te ) || c.a.transparent;
          this.style( {
            arrowColor: t,
            frameColor: t,
            headerBackgroundColor: e.getColor( Q ) || c.a.transparent,
            primaryHeadingColor: e.getColor( J ),
            secondaryHeadingColor: e.getColor( ee )
          } )
        }, t.prototype.dispose = function () {
          this.setModel( null ), this._callOnDispose = Object( s.d )( this._callOnDispose ), Object( s.d )( this._preview, this._previewNotAvailableMessage, this._tree, this._sash, this._previewModelReference ), e.prototype.dispose.call( this )
        }, Object.defineProperty( t.prototype, "onDidSelectReference", {
          get() {
            return this._onDidSelectReference.event
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.show = function ( t ) {
          this.editor.revealRangeInCenterIfOutsideViewport( t, 0 ), e.prototype.show.call( this, t, this.layoutData.heightInLines || 18 )
        }, t.prototype.focus = function () {
          this._tree.domFocus()
        }, t.prototype._onTitleClick = function ( e ) {
          this._preview && this._preview.getModel() && this._onDidSelectReference.fire( {
            element: this._getFocusedReference(),
            kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
            source: "title"
          } )
        }, t.prototype._fillBody = function ( e ) {
          const t = this,
            n = Object( d.a )( e );
          this.setCssClass( "reference-zone-widget" ), n.div( {
            class: "messages"
          }, ( e => {
            t._messageContainer = e.hide()
          } ) ), n.div( {
            class: "preview inline"
          }, ( e => {
            t._preview = t._instantiationService.createInstance( w.a, e.getHTMLElement(), {
              scrollBeyondLastLine: !1,
              scrollbar: {
                verticalScrollbarSize: 14,
                horizontal: "auto",
                useShadows: !0,
                verticalHasArrows: !1,
                horizontalHasArrows: !1
              },
              overviewRulerLanes: 2,
              fixedOverflowWidgets: !0,
              minimap: {
                enabled: !1
              }
            }, t.editor ), t._previewContainer = e.hide(), t._previewNotAvailableMessage = C.b.createFromString( i.a( "missingPreviewMessage", "no preview available" ) )
          } ) ), this._sash = new X( e, this.layoutData.ratio || .8 ), this._sash.onDidChangePercentages( ( () => {
            const e = t._sash.percentages,
              n = e[ 0 ],
              i = e[ 1 ];
            t._previewContainer.style( {
              width: n
            } ), t._treeContainer.style( {
              width: i
            } ), t._preview.layout(), t._tree.layout(), t.layoutData.ratio = t._sash.ratio
          } ) ), n.div( {
            class: "ref-tree inline"
          }, ( e => {
            const n = t._instantiationService.createInstance( U, {
              keyboardSupport: t._defaultTreeKeyboardSupport,
              clickBehavior: R.a.ON_MOUSE_UP
            } );
            t._callOnDispose.push( n );
            const o = {
                dataSource: t._instantiationService.createInstance( z ),
                renderer: t._instantiationService.createInstance( G ),
                controller: n,
                accessibilityProvider: new Y
              },
              r = {
                twistiePixels: 20,
                ariaLabel: i.a( "treeAriaLabel", "References" )
              };
            t._tree = t._instantiationService.createInstance( M.c, e.getHTMLElement(), o, r ), $.bindTo( t._tree.contextKeyService );
            const s = ( e, n ) => {
              e instanceof O.b && ( "show" === n && t._revealReference( e, !1 ), t._onDidSelectReference.fire( {
                element: e,
                kind: n,
                source: "tree"
              } ) )
            };
            t._disposables.push( t._tree.onDidChangeFocus( ( e => {
              e && e.payload && "keyboard" === e.payload.origin && s( e.focus, "show" )
            } ) ) ), t._disposables.push( t._tree.onDidChangeSelection( ( e => {
              e && e.payload && "keyboard" === e.payload.origin && s( e.selection[ 0 ], "goto" )
            } ) ) ), t._disposables.push( n.onDidFocus( ( e => {
              return s( e, "show" )
            } ) ) ), t._disposables.push( n.onDidSelect( ( e => {
              return s( e, "goto" )
            } ) ) ), t._disposables.push( n.onDidOpenToSide( ( e => {
              return s( e, "side" )
            } ) ) ), t._treeContainer = e.hide()
          } ) )
        }, t.prototype._doLayoutBody = function ( t, n ) {
          e.prototype._doLayoutBody.call( this, t, n );
          const i = t + "px";
          this._sash.height = t, this._sash.width = n;
          const o = this._sash.percentages,
            r = o[ 0 ],
            s = o[ 1 ];
          this._previewContainer.style( {
            height: i,
            width: r
          } ), this._treeContainer.style( {
            height: i,
            width: s
          } ), this._tree.layout( t ), this._preview.layout(), this.layoutData = {
            heightInLines: this._viewZone.heightInLines,
            ratio: this._sash.ratio
          }
        }, t.prototype._onWidth = function ( e ) {
          this._sash.width = e, this._preview.layout()
        }, t.prototype.setSelection = function ( e ) {
          const t = this;
          return this._revealReference( e, !0 ).then( ( () => {
            t._tree.setSelection( [ e ] ), t._tree.setFocus( e )
          } ) );
        }, t.prototype.setModel = function ( e ) {
          if ( this._disposeOnNewModel = Object( s.d )( this._disposeOnNewModel ), this._model = e, this._model ) return this._onNewModel()
        }, t.prototype._onNewModel = function () {
          const e = this;
          if ( this._model.empty ) return this.setTitle( "" ), this._messageContainer.innerHtml( i.a( "noResults", "No results" ) ).show(), l.b.as( void 0 );
          this._messageContainer.hide(), this._decorationsManager = new H( this._preview, this._model ), this._disposeOnNewModel.push( this._decorationsManager ), this._disposeOnNewModel.push( this._model.onDidChangeReferenceRange( ( t => {
            return e._tree.refresh( t )
          } ) ) ), this._disposeOnNewModel.push( this._preview.onMouseDown( ( t => {
            const n = t.event,
              i = t.target;
            2 === n.detail && e._onDidSelectReference.fire( {
              element: {
                uri: e._getFocusedReference().uri,
                range: i.range
              },
              kind: n.ctrlKey || n.metaKey || n.altKey ? "side" : "open",
              source: "editor"
            } )
          } ) ) ), h.f( this.container, "results-loaded" ), this._treeContainer.show(), this._previewContainer.show(), this._preview.layout(), this._tree.layout(), this.focus();
          const t = 1 === this._model.groups.length ? this._model.groups[ 0 ] : this._model;
          return this._tree.setInput( t )
        }, t.prototype._getFocusedReference = function () {
          const e = this._tree.getFocus();
          return e instanceof O.b ? e : e instanceof O.a && e.children.length > 0 ? e.children[ 0 ] : void 0
        }, t.prototype._revealReference = function ( e, t ) {
          return V( this, void 0, void 0, ( function () {
            let n;
            const r = this;
            return B( this, ( function ( u ) {
              switch ( u.label ) {
                case 0:
                  return e.uri.scheme !== a.a.inMemory ? this.setTitle( Object( A.a )( e.uri ), this._uriDisplay.getLabel( Object( A.b )( e.uri ), !1 ) ) : this.setTitle( i.a( "peekView.alternateTitle", "References" ) ), n = this._textModelResolverService.createModelReference( e.uri ), t ? [ 4, this._tree.reveal( e.parent ) ] : [ 3, 2 ];
                case 1:
                  u.sent(), u.label = 2;
                case 2:
                  return [ 2, l.b.join( [ n, this._tree.reveal( e ) ] ).then( ( t => {
                    const n = t[ 0 ];
                    if ( r._model ) {
                      Object( s.d )( r._previewModelReference );
                      const i = n.object;
                      if ( i ) {
                        r._previewModelReference = n;
                        const o = r._preview.getModel() === i.textEditorModel;
                        r._preview.setModel( i.textEditorModel );
                        const a = b.a.lift( e.range ).collapseToStart();
                        r._preview.setSelection( a ), r._preview.revealRangeInCenter( a, o ? 0 : 1 )
                      } else r._preview.setModel( r._previewNotAvailableMessage ), n.dispose()
                    } else n.dispose()
                  } ), o.e ) ];
              }
            } ) );
          } ) );
        }, t = W( [ j( 3, N.c ), j( 4, L.a ), j( 5, v.a ), j( 6, P.a ) ], t );
      } )( S.b );

      const Q = Object( x.kb )( "peekViewTitle.background", {
        dark: "#1E1E1E",
        light: "#FFFFFF",
        hc: "#0C141F"
      }, i.a( "peekViewTitleBackground", "Background color of the peek view title area." ) );
      const J = Object( x.kb )( "peekViewTitleLabel.foreground", {
        dark: "#FFFFFF",
        light: "#333333",
        hc: "#FFFFFF"
      }, i.a( "peekViewTitleForeground", "Color of the peek view title." ) );
      const ee = Object( x.kb )( "peekViewTitleDescription.foreground", {
        dark: "#ccccccb3",
        light: "#6c6c6cb3",
        hc: "#FFFFFF99"
      }, i.a( "peekViewTitleInfoForeground", "Color of the peek view title info." ) );
      const te = Object( x.kb )( "peekView.border", {
        dark: "#007acc",
        light: "#007acc",
        hc: x.e
      }, i.a( "peekViewBorder", "Color of the peek view borders and arrow." ) );
      const ne = Object( x.kb )( "peekViewResult.background", {
        dark: "#252526",
        light: "#F3F3F3",
        hc: c.a.black
      }, i.a( "peekViewResultsBackground", "Background color of the peek view result list." ) );
      const ie = Object( x.kb )( "peekViewResult.lineForeground", {
        dark: "#bbbbbb",
        light: "#646465",
        hc: c.a.white
      }, i.a( "peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list." ) );
      const oe = Object( x.kb )( "peekViewResult.fileForeground", {
        dark: c.a.white,
        light: "#1E1E1E",
        hc: c.a.white
      }, i.a( "peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list." ) );
      const re = Object( x.kb )( "peekViewResult.selectionBackground", {
        dark: "#3399ff33",
        light: "#3399ff33",
        hc: null
      }, i.a( "peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list." ) );
      const se = Object( x.kb )( "peekViewResult.selectionForeground", {
        dark: c.a.white,
        light: "#6C6C6C",
        hc: c.a.white
      }, i.a( "peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list." ) );
      const ae = Object( x.kb )( "peekViewEditor.background", {
        dark: "#001F33",
        light: "#F2F8FC",
        hc: c.a.black
      }, i.a( "peekViewEditorBackground", "Background color of the peek view editor." ) );
      const ue = Object( x.kb )( "peekViewEditorGutter.background", {
        dark: ae,
        light: ae,
        hc: ae
      }, i.a( "peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor." ) );
      const le = Object( x.kb )( "peekViewResult.matchHighlightBackground", {
        dark: "#ea5c004d",
        light: "#ea5c004d",
        hc: null
      }, i.a( "peekViewResultsMatchHighlight", "Match highlight color in the peek view result list." ) );
      const ce = Object( x.kb )( "peekViewEditor.matchHighlightBackground", {
        dark: "#ff8f0099",
        light: "#f5d802de",
        hc: null
      }, i.a( "peekViewEditorMatchHighlight", "Match highlight color in the peek view editor." ) );
      const de = Object( x.kb )( "peekViewEditor.matchHighlightBorder", {
        dark: null,
        light: null,
        hc: x.b
      }, i.a( "peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor." ) );
      Object( N.e )( ( ( e, t ) => {
        const n = e.getColor( le );
        n && t.addRule( ".monaco-editor .reference-zone-widget .ref-tree .referenceMatch { background-color: " + n + "; }" );
        const i = e.getColor( ce );
        i && t.addRule( ".monaco-editor .reference-zone-widget .preview .reference-decoration { background-color: " + i + "; }" );
        const o = e.getColor( de );
        o && t.addRule( ".monaco-editor .reference-zone-widget .preview .reference-decoration { border: 2px solid " + o + "; box-sizing: border-box; }" );
        const r = e.getColor( x.b );
        r && t.addRule( ".monaco-editor .reference-zone-widget .ref-tree .referenceMatch { border: 1px dotted " + r + "; box-sizing: border-box; }" );
        const s = e.getColor( ne );
        s && t.addRule( ".monaco-editor .reference-zone-widget .ref-tree { background-color: " + s + "; }" );
        const a = e.getColor( ie );
        a && t.addRule( ".monaco-editor .reference-zone-widget .ref-tree { color: " + a + "; }" );
        const u = e.getColor( oe );
        u && t.addRule( ".monaco-editor .reference-zone-widget .ref-tree .reference-file { color: " + u + "; }" );
        const l = e.getColor( re );
        l && t.addRule( ".monaco-editor .reference-zone-widget .ref-tree .monaco-tree.focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { background-color: " + l + "; }" );
        const c = e.getColor( se );
        c && t.addRule( ".monaco-editor .reference-zone-widget .ref-tree .monaco-tree.focused .monaco-tree-rows > .monaco-tree-row.selected:not(.highlighted) { color: " + c + " !important; }" );
        const d = e.getColor( ae );
        d && t.addRule( ".monaco-editor .reference-zone-widget .preview .monaco-editor .monaco-editor-background,.monaco-editor .reference-zone-widget .preview .monaco-editor .inputarea.ime-input {\tbackground-color: " + d + ";}" );
        const h = e.getColor( ue );
        h && t.addRule( ".monaco-editor .reference-zone-widget .preview .monaco-editor .margin {\tbackground-color: " + h + ";}" )
      } ) )
    },
    "ci+S": function ( e, t, n ) {},
    cl4r( e, t, n ) {},
    cldp( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "javascript",
        extensions: [ ".js", ".es6", ".jsx", ".esm" ],
        firstLine: "^#!.*\\bnode",
        filenames: [ "jakefile" ],
        aliases: [ "JavaScript", "javascript", "js" ],
        mimetypes: [ "text/javascript" ],
        loader() {
          return o.Promise.wrap( Promise.all( [ n.e( 31 ), n.e( 272 ) ] ).then( n.bind( null, "7Xl7" ) ) )
        }
      } )
    },
    cnVm( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return _
      } ) );
      n( "uWgD" );
      const i = n( "pmY6" );
      const o = n( "qj0h" );
      const r = n( "EffR" );
      const s = n( "cMOf" );
      const a = n( "aokT" );
      const u = n( "zrhQ" );
      const l = n( "tX9W" );
      const c = n( "nD70" );
      const d = n( "M1Kb" );
      const h = new u.a( new u.c( 0, 122, 204 ) );
      const p = {
        showArrow: !0,
        showFrame: !0,
        className: "",
        frameColor: h,
        arrowColor: h,
        keepEditorSelection: !1
      };
      const f = ( () => {
        function e( e, t, n, i, o, r ) {
          this.domNode = e, this.afterLineNumber = t, this.afterColumn = n, this.heightInLines = i, this._onDomNodeTop = o, this._onComputedHeight = r
        }
        return e.prototype.onDomNodeTop = function ( e ) {
          this._onDomNodeTop( e )
        }, e.prototype.onComputedHeight = function ( e ) {
          this._onComputedHeight( e )
        }, e
      } )();
      const g = ( () => {
        function e( e, t ) {
          this._id = e, this._domNode = t
        }
        return e.prototype.getId = function () {
          return this._id
        }, e.prototype.getDomNode = function () {
          return this._domNode
        }, e.prototype.getPosition = () => {
          return null
        }, e;
      } )();
      const m = ( () => {
        function e( t ) {
          this._editor = t, this._ruleName = e._IdGenerator.nextId(), this._decorations = []
        }
        return e.prototype.dispose = function () {
          this.hide(), r.F( this._ruleName )
        }, Object.defineProperty( e.prototype, "color", {
          set( e ) {
            this._color !== e && ( this._color = e, this._updateStyle() )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "height", {
          set( e ) {
            this._height !== e && ( this._height = e, this._updateStyle() )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype._updateStyle = function () {
          r.F( this._ruleName ), r.n( ".monaco-editor " + this._ruleName, "border-style: solid; border-color: transparent; border-bottom-color: " + this._color + "; border-width: " + this._height + "px; bottom: -" + this._height + "px; margin-left: -" + this._height + "px; " )
        }, e.prototype.show = function ( e ) {
          this._decorations = this._editor.deltaDecorations( this._decorations, [ {
            range: a.a.fromPositions( e ),
            options: {
              className: this._ruleName,
              stickiness: d.h.NeverGrowsWhenTypingAtEdges
            }
          } ] )
        }, e.prototype.hide = function () {
          this._editor.deltaDecorations( this._decorations, [] )
        }, e._IdGenerator = new c.a( ".arrow-decoration-" ), e;
      } )();

      var _ = ( () => {
        function e( e, t ) {
          void 0 === t && ( t = {} );
          const n = this;
          this._positionMarkerId = [], this._disposables = [], this._isShowing = !1, this.editor = e, this.options = o.c( t ), o.g( this.options, p, !1 ), this.domNode = document.createElement( "div" ), this.options.isAccessible || ( this.domNode.setAttribute( "aria-hidden", "true" ), this.domNode.setAttribute( "role", "presentation" ) ), this._disposables.push( this.editor.onDidLayoutChange( ( e => {
            const t = n._getWidth( e );
            n.domNode.style.width = t + "px", n.domNode.style.left = n._getLeft( e ) + "px", n._onWidth( t )
          } ) ) )
        }
        return e.prototype.dispose = function () {
          const e = this;
          Object( i.d )( this._disposables ), this._overlayWidget && ( this.editor.removeOverlayWidget( this._overlayWidget ), this._overlayWidget = null ), this._viewZone && this.editor.changeViewZones( ( t => {
            t.removeZone( e._viewZone.id ), e._viewZone = null
          } ) ), this.editor.deltaDecorations( this._positionMarkerId, [] ), this._positionMarkerId = []
        }, e.prototype.create = function () {
          r.f( this.domNode, "zone-widget" ), r.f( this.domNode, this.options.className ), this.container = document.createElement( "div" ), r.f( this.container, "zone-widget-container" ), this.domNode.appendChild( this.container ), this.options.showArrow && ( this._arrow = new m( this.editor ), this._disposables.push( this._arrow ) ), this._fillContainer( this.container ), this._initSash(), this._applyStyles()
        }, e.prototype.style = function ( e ) {
          e.frameColor && ( this.options.frameColor = e.frameColor ), e.arrowColor && ( this.options.arrowColor = e.arrowColor ), this._applyStyles()
        }, e.prototype._applyStyles = function () {
          if ( this.container ) {
            const e = this.options.frameColor.toString();
            this.container.style.borderTopColor = e, this.container.style.borderBottomColor = e
          }
          if ( this._arrow ) {
            const t = this.options.arrowColor.toString();
            this._arrow.color = t
          }
        }, e.prototype._getWidth = e => {
          return e.width - e.minimapWidth - e.verticalScrollbarWidth
        }, e.prototype._getLeft = e => {
          return e.minimapWidth > 0 && 0 === e.minimapLeft ? e.minimapWidth : 0
        }, e.prototype._onViewZoneTop = function ( e ) {
          this.domNode.style.top = e + "px"
        }, e.prototype._onViewZoneHeight = function ( e ) {
          this.domNode.style.height = e + "px";
          const t = e - this._decoratingElementsHeight();
          this.container.style.height = t + "px";
          const n = this.editor.getLayoutInfo();
          this._doLayout( t, this._getWidth( n ) ), this._resizeSash.layout()
        }, Object.defineProperty( e.prototype, "position", {
          get() {
            const e = this._positionMarkerId[ 0 ];
            if ( e ) {
              const t = this.editor.getModel().getDecorationRange( e );
              if ( t ) return t.getStartPosition()
            }
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.show = function ( e, t ) {
          const n = a.a.isIRange( e ) ? e : new a.a( e.lineNumber, e.column, e.lineNumber, e.column );
          this._isShowing = !0, this._showImpl( n, t ), this._isShowing = !1, this._positionMarkerId = this.editor.deltaDecorations( this._positionMarkerId, [ {
            range: n,
            options: l.a.EMPTY
          } ] )
        }, e.prototype.hide = function () {
          const e = this;
          this._viewZone && ( this.editor.changeViewZones( ( t => {
            t.removeZone( e._viewZone.id )
          } ) ), this._viewZone = null ), this._overlayWidget && ( this.editor.removeOverlayWidget( this._overlayWidget ), this._overlayWidget = null ), this._arrow && this._arrow.hide()
        }, e.prototype._decoratingElementsHeight = function () {
          const e = this.editor.getConfiguration().lineHeight;
          let t = 0;
          this.options.showArrow && ( t += 2 * Math.round( e / 3 ) );
          this.options.showFrame && ( t += 2 * Math.round( e / 9 ) );
          return t
        }, e.prototype._showImpl = function ( e, t ) {
          const n = this,
            i = {
              lineNumber: e.startLineNumber,
              column: e.startColumn
            },
            o = this.editor.getLayoutInfo(),
            r = this._getWidth( o );
          this.domNode.style.width = r + "px", this.domNode.style.left = this._getLeft( o ) + "px";
          const s = document.createElement( "div" );
          s.style.overflow = "hidden";
          const a = this.editor.getConfiguration().lineHeight,
            u = this.editor.getLayoutInfo().height / a * .8;
          t >= u && ( t = u );
          let l = 0,
            c = 0;
          if ( this.options.showArrow && ( l = Math.round( a / 3 ), this._arrow.height = l, this._arrow.show( i ) ), this.options.showFrame && ( c = Math.round( a / 9 ) ), this.editor.changeViewZones( ( e => {
              n._viewZone && e.removeZone( n._viewZone.id ), n._overlayWidget && ( n.editor.removeOverlayWidget( n._overlayWidget ), n._overlayWidget = null ), n.domNode.style.top = "-1000px", n._viewZone = new f( s, i.lineNumber, i.column, t, ( e => {
                return n._onViewZoneTop( e )
              } ), ( e => {
                return n._onViewZoneHeight( e )
              } ) ), n._viewZone.id = e.addZone( n._viewZone ), n._overlayWidget = new g( "vs.editor.contrib.zoneWidget" + n._viewZone.id, n.domNode ), n.editor.addOverlayWidget( n._overlayWidget )
            } ) ), this.options.showFrame ) {
            const d = this.options.frameWidth ? this.options.frameWidth : c;
            this.container.style.borderTopWidth = d + "px", this.container.style.borderBottomWidth = d + "px"
          }
          const h = t * a - this._decoratingElementsHeight();
          this.container.style.top = l + "px", this.container.style.height = h + "px", this.container.style.overflow = "hidden", this._doLayout( h, r ), this.options.keepEditorSelection || this.editor.setSelection( e );
          const p = Math.min( this.editor.getModel().getLineCount(), Math.max( 1, e.endLineNumber + 1 ) );
          this.revealLine( p )
        }, e.prototype.revealLine = function ( e ) {
          this.editor.revealLine( e, 0 )
        }, e.prototype.setCssClass = function ( e, t ) {
          t && this.container.classList.remove( t ), r.f( this.container, e )
        }, e.prototype._onWidth = e => {}, e.prototype._doLayout = ( e, t ) => {}, e.prototype._relayout = function ( e ) {
          const t = this;
          this._viewZone.heightInLines !== e && this.editor.changeViewZones( ( n => {
            t._viewZone.heightInLines = e, n.layoutZone( t._viewZone.id )
          } ) )
        }, e.prototype._initSash = function () {
          let e;
          const t = this;
          this._resizeSash = new s.b( this.domNode, this, {
            orientation: s.a.HORIZONTAL
          } ), this.options.isResizeable || ( this._resizeSash.hide(), this._resizeSash.state = s.c.Disabled ), this._disposables.push( this._resizeSash.onDidStart( ( n => {
            t._viewZone && ( e = {
              startY: n.startY,
              heightInLines: t._viewZone.heightInLines
            } )
          } ) ) ), this._disposables.push( this._resizeSash.onDidEnd( ( () => {
            e = void 0
          } ) ) ), this._disposables.push( this._resizeSash.onDidChange( ( n => {
            if ( e ) {
              const i = ( n.currentY - e.startY ) / t.editor.getConfiguration().lineHeight,
                o = i < 0 ? Math.ceil( i ) : Math.floor( i ),
                r = e.heightInLines + o;
              r > 5 && r < 35 && t._relayout( r )
            }
          } ) ) )
        }, e.prototype.getHorizontalSashLeft = () => {
          return 0
        }, e.prototype.getHorizontalSashTop = function () {
          return parseInt( this.domNode.style.height ) - this._decoratingElementsHeight() / 2
        }, e.prototype.getHorizontalSashWidth = function () {
          const e = this.editor.getLayoutInfo();
          return e.width - e.minimapWidth
        }, e;
      } )();
    },
    d6R0( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "X+cX" ),
        o = n( "/cxE" ),
        r = n( "pmY6" ),
        s = n( "vATl" ),
        a = n( "sswD" ),
        u = n( "twdY" ),
        l = ( n( "RMfO" ), n( "N0LK" ) ),
        c = n( "EffR" ),
        d = n( "aokT" ),
        h = n( "sFUC" ),
        p = n( "tX9W" ),
        f = n( "kYye" ),
        g = n( "t9D7" ),
        m = n( "MD5Z" ),
        _ = ( () => {
          function e( e, t ) {
            this.afterLineNumber = e, this._onHeight = t, this.heightInLines = 1, this.suppressMouseDown = !0, this.domNode = document.createElement( "div" )
          }
          return e.prototype.onComputedHeight = function ( e ) {
            void 0 === this._lastHeight ? this._lastHeight = e : this._lastHeight !== e && ( this._lastHeight = e, this._onHeight() )
          }, e
        } )(),
        v = ( () => {
          function e( t, n, i, o ) {
            const r = this;
            this.allowEditorOverflow = !1, this.suppressMouseDown = !0, this._disposables = [], this._commands = Object.create( null ), this._id = "codeLensWidget" + ++e._idPool, this._editor = t, this.setSymbolRange( n ), this._domNode = document.createElement( "span" ), this._domNode.innerHTML = "&nbsp;", c.f( this._domNode, "codelens-decoration" ), c.f( this._domNode, "invisible-cl" ), this._updateHeight(), this._disposables.push( this._editor.onDidChangeConfiguration( ( e => {
              return e.fontInfo && r._updateHeight()
            } ) ) ), this._disposables.push( c.g( this._domNode, "click", ( function ( e ) {
              const n = e.target;
              if ( "A" === n.tagName && n.id ) {
                const s = r._commands[ n.id ];
                s && ( t.focus(), i.executeCommand.apply( i, [ s.id ].concat( s.arguments ) ).done( void 0, ( e => {
                  o.error( e )
                } ) ) )
              }
            } ) ) ), this.updateVisibility()
          }
          return e.prototype.dispose = function () {
            Object( r.d )( this._disposables )
          }, e.prototype._updateHeight = function () {
            const e = this._editor.getConfiguration(),
              t = e.fontInfo,
              n = e.lineHeight;
            this._domNode.style.height = Math.round( 1.1 * n ) + "px", this._domNode.style.lineHeight = n + "px", this._domNode.style.fontSize = Math.round( .9 * t.fontSize ) + "px", this._domNode.innerHTML = "&nbsp;"
          }, e.prototype.updateVisibility = function () {
            this.isVisible() && ( c.G( this._domNode, "invisible-cl" ), c.f( this._domNode, "fadein" ) )
          }, e.prototype.withCommands = function ( e ) {
            if ( this._commands = Object.create( null ), e && e.length ) {
              for ( var t = [], n = 0; n < e.length; n++ ) {
                const i = e[ n ].command;
                const o = Object( l.escape )( i.title );
                let r = void 0;
                i.id ? ( r = Object( l.format )( "<a id={0}>{1}</a>", n, o ), this._commands[ n ] = i ) : r = Object( l.format )( "<span>{0}</span>", o ), t.push( r )
              }
              this._domNode.innerHTML = t.join( "<span>&nbsp;|&nbsp;</span>" ), this._editor.layoutContentWidget( this )
            } else this._domNode.innerHTML = "no commands"
          }, e.prototype.getId = function () {
            return this._id
          }, e.prototype.getDomNode = function () {
            return this._domNode
          }, e.prototype.setSymbolRange = function ( e ) {
            const t = e.startLineNumber,
              n = this._editor.getModel().getLineFirstNonWhitespaceColumn( t );
            this._widgetPosition = {
              position: {
                lineNumber: t,
                column: n
              },
              preference: [ h.a.ABOVE ]
            }
          }, e.prototype.getPosition = function () {
            return this._widgetPosition
          }, e.prototype.isVisible = function () {
            return this._domNode.hasAttribute( "monaco-visible-content-widget" )
          }, e._idPool = 0, e;
        } )(),
        y = ( () => {
          function e() {
            this._removeDecorations = [], this._addDecorations = [], this._addDecorationsCallbacks = []
          }
          return e.prototype.addDecoration = function ( e, t ) {
            this._addDecorations.push( e ), this._addDecorationsCallbacks.push( t )
          }, e.prototype.removeDecoration = function ( e ) {
            this._removeDecorations.push( e )
          }, e.prototype.commit = function ( e ) {
            for ( let t = e.deltaDecorations( this._removeDecorations, this._addDecorations ), n = 0, i = t.length; n < i; n++ ) this._addDecorationsCallbacks[ n ]( t[ n ] )
          }, e;
        } )(),
        b = ( () => {
          function e( e, t, n, i, o, r, s ) {
            let a;
            const u = this;
            this._editor = t, this._data = e, this._decorationIds = new Array( this._data.length ), this._data.forEach( ( ( e, t ) => {
              n.addDecoration( {
                range: e.symbol.range,
                options: p.a.EMPTY
              }, ( e => {
                return u._decorationIds[ t ] = e
              } ) ), a = a ? d.a.plusRange( a, e.symbol.range ) : d.a.lift( e.symbol.range )
            } ) ), this._contentWidget = new v( t, a, o, r ), this._viewZone = new _( a.startLineNumber - 1, s ), this._viewZoneId = i.addZone( this._viewZone ), this._editor.addContentWidget( this._contentWidget )
          }
          return e.prototype.dispose = function ( e, t ) {
            for ( ; this._decorationIds.length; ) e.removeDecoration( this._decorationIds.pop() );
            t && t.removeZone( this._viewZoneId ), this._editor.removeContentWidget( this._contentWidget ), this._contentWidget.dispose()
          }, e.prototype.isValid = function () {
            const e = this;
            return this._decorationIds.some( ( ( t, n ) => {
              const i = e._editor.getModel().getDecorationRange( t ),
                o = e._data[ n ].symbol;
              return i && d.a.isEmpty( o.range ) === i.isEmpty()
            } ) );
          }, e.prototype.updateCodeLensSymbols = function ( e, t ) {
            for ( var n = this; this._decorationIds.length; ) t.removeDecoration( this._decorationIds.pop() );
            this._data = e, this._decorationIds = new Array( this._data.length ), this._data.forEach( ( ( e, i ) => {
              t.addDecoration( {
                range: e.symbol.range,
                options: p.a.EMPTY
              }, ( e => {
                return n._decorationIds[ i ] = e
              } ) )
            } ) )
          }, e.prototype.computeIfNecessary = function ( e ) {
            if ( this._contentWidget.updateVisibility(), !this._contentWidget.isVisible() ) return null;
            for ( let t = 0; t < this._decorationIds.length; t++ ) this._data[ t ].symbol.range = e.getDecorationRange( this._decorationIds[ t ] );
            return this._data
          }, e.prototype.updateCommands = function ( e ) {
            this._contentWidget.withCommands( e )
          }, e.prototype.getLineNumber = function () {
            const e = this._editor.getModel().getDecorationRange( this._decorationIds[ 0 ] );
            return e ? e.startLineNumber : -1
          }, e.prototype.update = function ( e ) {
            if ( this.isValid() ) {
              const t = this._editor.getModel().getDecorationRange( this._decorationIds[ 0 ] );
              this._viewZone.afterLineNumber = t.startLineNumber - 1, e.layoutZone( this._viewZoneId ), this._contentWidget.setSymbolRange( t ), this._editor.layoutContentWidget( this._contentWidget )
            }
          }, e;
        } )();
      Object( g.e )( ( ( e, t ) => {
        const n = e.getColor( f.e );
        n && t.addRule( ".monaco-editor .codelens-decoration { color: " + n + "; }" );
        const i = e.getColor( m.m );
        i && t.addRule( ".monaco-editor .codelens-decoration > a:hover { color: " + i + " !important; }" )
      } ) );
      const C = n( "nnTU" ),
        w = n( "sM1p" ),
        S = n( "6OMU" ),
        O = n( "bY76" ),
        L = n( "G2kB" ),
        x = n( "JQT/" );

      function N( e, t ) {
        const n = [],
          i = u.c.ordered( e ),
          r = i.map( ( i => {
            return Promise.resolve( i.provideCodeLenses( e, t ) ).then( ( e => {
              if ( Array.isArray( e ) )
                for ( let t = 0, o = e; t < o.length; t++ ) {
                  const r = o[ t ];
                  n.push( {
                    symbol: r,
                    provider: i
                  } )
                }
            } ) ).catch( o.f );
          } ) );
        return Promise.all( r ).then( ( () => {
          return Object( S.l )( n, ( ( e, t ) => {
            return e.symbol.range.startLineNumber < t.symbol.range.startLineNumber ? -1 : e.symbol.range.startLineNumber > t.symbol.range.startLineNumber ? 1 : i.indexOf( e.provider ) < i.indexOf( t.provider ) ? -1 : i.indexOf( e.provider ) > i.indexOf( t.provider ) ? 1 : e.symbol.range.startColumn < t.symbol.range.startColumn ? -1 : e.symbol.range.startColumn > t.symbol.range.startColumn ? 1 : 0
          } ) );
        } ) );
      }
      Object( a.j )( "_executeCodeLensProvider", ( ( e, t ) => {
        const n = t.resource;
        let i = t.itemResolveCount;
        if ( !( n instanceof O.a ) ) throw Object( o.b )();
        const r = e.get( L.a ).getModel( n );
        if ( !r ) throw Object( o.b )();
        const s = [];
        return N( r, x.a.None ).then( ( e => {
          for ( var t = [], n = 0, o = e; n < o.length; n++ ) {
            const a = o[ n ];
            "undefined" === typeof i || Boolean( a.symbol.command ) ? s.push( a.symbol ) : i-- > 0 && t.push( Promise.resolve( a.provider.resolveCodeLens( r, a.symbol, x.a.None ) ).then( ( e => {
              return s.push( e )
            } ) ) )
          }
          return Promise.all( t )
        } ) ).then( ( () => {
          return s
        } ) );
      } ) ), n.d( t, "CodeLensContribution", ( () => {
        return I
      } ) );

      const E = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const k = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };

      var I = ( () => {
        function e( e, t, n ) {
          const i = this;
          this._editor = e, this._commandService = t, this._notificationService = n, this._isEnabled = this._editor.getConfiguration().contribInfo.codeLens, this._globalToDispose = [], this._localToDispose = [], this._lenses = [], this._currentFindCodeLensSymbolsPromise = null, this._modelChangeCounter = 0, this._globalToDispose.push( this._editor.onDidChangeModel( ( () => {
            return i._onModelChange()
          } ) ) ), this._globalToDispose.push( this._editor.onDidChangeModelLanguage( ( () => {
            return i._onModelChange()
          } ) ) ), this._globalToDispose.push( this._editor.onDidChangeConfiguration( ( e => {
            const t = i._isEnabled;
            i._isEnabled = i._editor.getConfiguration().contribInfo.codeLens, t !== i._isEnabled && i._onModelChange()
          } ) ) ), this._globalToDispose.push( u.c.onDidChange( this._onModelChange, this ) ), this._onModelChange()
        }
        return e.prototype.dispose = function () {
          this._localDispose(), this._globalToDispose = Object( r.d )( this._globalToDispose )
        }, e.prototype._localDispose = function () {
          this._currentFindCodeLensSymbolsPromise && ( this._currentFindCodeLensSymbolsPromise.cancel(), this._currentFindCodeLensSymbolsPromise = null, this._modelChangeCounter++ ), this._currentResolveCodeLensSymbolsPromise && ( this._currentResolveCodeLensSymbolsPromise.cancel(), this._currentResolveCodeLensSymbolsPromise = null ), this._localToDispose = Object( r.d )( this._localToDispose )
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype._onModelChange = function () {
          const e = this;
          this._localDispose();
          const t = this._editor.getModel();
          if ( t && this._isEnabled && u.c.has( t ) ) {
            for ( let n = 0, a = u.c.all( t ); n < a.length; n++ ) {
              const l = a[ n ];
              if ( "function" === typeof l.onDidChange ) {
                const c = l.onDidChange( ( () => {
                  return d.schedule()
                } ) );
                this._localToDispose.push( c )
              }
            }
            this._detectVisibleLenses = new i.c( ( () => {
              e._onViewportChanged()
            } ), 500 );
            var d = new i.c( ( () => {
              const n = ++e._modelChangeCounter;
              e._currentFindCodeLensSymbolsPromise && e._currentFindCodeLensSymbolsPromise.cancel(), e._currentFindCodeLensSymbolsPromise = Object( i.i )( ( e => {
                return N( t, e )
              } ) ), e._currentFindCodeLensSymbolsPromise.then( ( t => {
                n === e._modelChangeCounter && ( e._renderCodeLensSymbols( t ), e._detectVisibleLenses.schedule() )
              } ), o.e )
            } ), 250 );
            this._localToDispose.push( d ), this._localToDispose.push( this._detectVisibleLenses ), this._localToDispose.push( this._editor.onDidChangeModelContent( ( t => {
              e._editor.changeDecorations( ( t => {
                e._editor.changeViewZones( ( n => {
                  const i = [];
                  let o = -1;
                  e._lenses.forEach( ( e => {
                    e.isValid() && o !== e.getLineNumber() ? ( e.update( n ), o = e.getLineNumber() ) : i.push( e )
                  } ) );
                  const r = new y;
                  i.forEach( ( t => {
                    t.dispose( r, n ), e._lenses.splice( e._lenses.indexOf( t ), 1 )
                  } ) ), r.commit( t )
                } ) )
              } ) ), e._detectVisibleLenses.schedule(), d.schedule()
            } ) ) ), this._localToDispose.push( this._editor.onDidScrollChange( ( t => {
              t.scrollTopChanged && e._lenses.length > 0 && e._detectVisibleLenses.schedule()
            } ) ) ), this._localToDispose.push( this._editor.onDidLayoutChange( ( t => {
              e._detectVisibleLenses.schedule()
            } ) ) ), this._localToDispose.push( Object( r.f )( ( () => {
              if ( e._editor.getModel() ) {
                const t = s.b.capture( e._editor );
                e._editor.changeDecorations( ( t => {
                  e._editor.changeViewZones( ( n => {
                    e._disposeAllLenses( t, n )
                  } ) )
                } ) ), t.restore( e._editor )
              } else e._disposeAllLenses( null, null )
            } ) ) ), d.schedule()
          }
        }, e.prototype._disposeAllLenses = function ( e, t ) {
          const n = new y;
          this._lenses.forEach( ( e => {
            return e.dispose( n, t )
          } ) ), e && n.commit( e ), this._lenses = []
        }, e.prototype._renderCodeLensSymbols = function ( e ) {
          const t = this;
          if ( this._editor.getModel() ) {
            for ( var n, i = this._editor.getModel().getLineCount(), o = [], r = 0, a = e; r < a.length; r++ ) {
              const u = a[ r ],
                l = u.symbol.range.startLineNumber;
              l < 1 || l > i || ( n && n[ n.length - 1 ].symbol.range.startLineNumber === l ? n.push( u ) : ( n = [ u ], o.push( n ) ) )
            }
            const c = s.b.capture( this._editor );
            this._editor.changeDecorations( ( e => {
              t._editor.changeViewZones( ( n => {
                for ( var i = 0, r = 0, s = new y; r < o.length && i < t._lenses.length; ) {
                  const a = o[ r ][ 0 ].symbol.range.startLineNumber,
                    u = t._lenses[ i ].getLineNumber();
                  u < a ? ( t._lenses[ i ].dispose( s, n ), t._lenses.splice( i, 1 ) ) : u === a ? ( t._lenses[ i ].updateCodeLensSymbols( o[ r ], s ), r++, i++ ) : ( t._lenses.splice( i, 0, new b( o[ r ], t._editor, s, n, t._commandService, t._notificationService, ( () => {
                    return t._detectVisibleLenses.schedule()
                  } ) ) ), i++, r++ )
                }
                for ( ; i < t._lenses.length; ) t._lenses[ i ].dispose( s, n ), t._lenses.splice( i, 1 );
                for ( ; r < o.length; ) t._lenses.push( new b( o[ r ], t._editor, s, n, t._commandService, t._notificationService, ( () => {
                  return t._detectVisibleLenses.schedule()
                } ) ) ), r++;
                s.commit( e )
              } ) )
            } ) ), c.restore( this._editor )
          }
        }, e.prototype._onViewportChanged = function () {
          const e = this;
          this._currentResolveCodeLensSymbolsPromise && ( this._currentResolveCodeLensSymbolsPromise.cancel(), this._currentResolveCodeLensSymbolsPromise = null );
          const t = this._editor.getModel();
          if ( t ) {
            const n = [],
              r = [];
            this._lenses.forEach( ( e => {
              const i = e.computeIfNecessary( t );
              i && ( n.push( i ), r.push( e ) )
            } ) ), 0 !== n.length && ( this._currentResolveCodeLensSymbolsPromise = Object( i.i )( ( e => {
              const i = n.map( ( ( n, i ) => {
                const o = new Array( n.length ),
                  s = n.map( ( ( n, i ) => {
                    return "function" === typeof n.provider.resolveCodeLens ? Promise.resolve( n.provider.resolveCodeLens( t, n.symbol, e ) ).then( ( e => {
                      o[ i ] = e
                    } ) ) : ( o[ i ] = n.symbol, Promise.resolve( void 0 ) );
                  } ) );
                return Promise.all( s ).then( ( () => {
                  r[ i ].updateCommands( o )
                } ) );
              } ) );
              return Promise.all( i )
            } ) ), this._currentResolveCodeLensSymbolsPromise.then( ( () => {
              e._currentResolveCodeLensSymbolsPromise = null
            } ) ).catch( ( t => {
              e._currentResolveCodeLensSymbolsPromise = null, Object( o.e )( t )
            } ) ) )
          }
        }, e.ID = "css.editor.codeLens", e = E( [ k( 1, C.b ), k( 2, w.a ) ], e );
      } )();

      Object( a.h )( I )
    },
    dBaI( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return a
      } ) );
      const i = n( "N0LK" );
      var o = ( () => {
        function e( e, t, n, i ) {
          this.startColumn = e, this.endColumn = t, this.className = n, this.type = i
        }
        return e._equals = ( e, t ) => {
          return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type
        }, e.equalsArr = ( t, n ) => {
          const i = t.length;
          if ( i !== n.length ) return !1;
          for ( let o = 0; o < i; o++ )
            if ( !e._equals( t[ o ], n[ o ] ) ) return !1;
          return !0
        }, e.filter = ( t, n, i, o ) => {
          if ( 0 === t.length ) return [];
          for ( var r = [], s = 0, a = 0, u = t.length; a < u; a++ ) {
            const l = t[ a ],
              c = l.range;
            if ( !( c.endLineNumber < n || c.startLineNumber > n ) && ( !c.isEmpty() || 0 !== l.type && 3 !== l.type ) ) {
              const d = c.startLineNumber === n ? c.startColumn : i,
                h = c.endLineNumber === n ? c.endColumn : o;
              r[ s++ ] = new e( d, h, l.inlineClassName, l.type )
            }
          }
          return r
        }, e.compare = ( e, t ) => {
          return e.startColumn === t.startColumn ? e.endColumn === t.endColumn ? e.className < t.className ? -1 : e.className > t.className ? 1 : 0 : e.endColumn - t.endColumn : e.startColumn - t.startColumn
        }, e;
      } )();
      const r = function ( e, t, n ) {
        this.startOffset = e, this.endOffset = t, this.className = n
      };
      const s = ( () => {
        function e() {
          this.stopOffsets = [], this.classNames = [], this.count = 0
        }
        return e.prototype.consumeLowerThan = function ( e, t, n ) {
          for ( ; this.count > 0 && this.stopOffsets[ 0 ] < e; ) {
            for ( var i = 0; i + 1 < this.count && this.stopOffsets[ i ] === this.stopOffsets[ i + 1 ]; ) i++;
            n.push( new r( t, this.stopOffsets[ i ], this.classNames.join( " " ) ) ), t = this.stopOffsets[ i ] + 1, this.stopOffsets.splice( 0, i + 1 ), this.classNames.splice( 0, i + 1 ), this.count -= i + 1
          }
          return this.count > 0 && t < e && ( n.push( new r( t, e - 1, this.classNames.join( " " ) ) ), t = e ), t
        }, e.prototype.insert = function ( e, t ) {
          if ( 0 === this.count || this.stopOffsets[ this.count - 1 ] <= e ) this.stopOffsets.push( e ), this.classNames.push( t );
          else
            for ( let n = 0; n < this.count; n++ )
              if ( this.stopOffsets[ n ] >= e ) {
                this.stopOffsets.splice( n, 0, e ), this.classNames.splice( n, 0, t );
                break
              } this.count++
        }, e;
      } )();

      var a = ( () => {
        function e() {}
        return e.normalize = ( e, t ) => {
          if ( 0 === t.length ) return [];
          for ( var n = [], o = new s, r = 0, a = 0, u = t.length; a < u; a++ ) {
            const l = t[ a ];
            let c = l.startColumn;
            let d = l.endColumn;
            const h = l.className;
            if ( c > 1 ) {
              var p = e.charCodeAt( c - 2 );
              i.isHighSurrogate( p ) && c--
            }
            if ( d > 1 ) {
              p = e.charCodeAt( d - 2 );
              i.isHighSurrogate( p ) && d--
            }
            const f = c - 1,
              g = d - 2;
            r = o.consumeLowerThan( f, r, n ), 0 === o.count && ( r = f ), o.insert( g, h )
          }
          return o.consumeLowerThan( 1073741824, r, n ), n
        }, e;
      } )();
    },
    dFcq( e, t, n ) {},
    "dH+W": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "/kV6" ),
        r = n( "0/Sa" ),
        s = n( "aokT" ),
        a = ( () => {
          function e( e, t ) {
            this.selection = e, this.descending = t
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            const n = ( ( e, t, n ) => {
              const i = u( e, t, n );
              if ( !i ) return null;
              return r.a.replace( new s.a( i.startLineNumber, 1, i.endLineNumber, e.getLineMaxColumn( i.endLineNumber ) ), i.after.join( "\n" ) )
            } )( e, this.selection, this.descending );
            n && t.addEditOperation( n.range, n.text ), this.selectionId = t.trackSelection( this.selection )
          }, e.prototype.computeCursorState = function ( e, t ) {
            return t.getTrackedSelection( this.selectionId )
          }, e.canRun = ( e, t, n ) => {
            const i = u( e, t, n );
            if ( !i ) return !1;
            for ( let o = 0, r = i.before.length; o < r; o++ )
              if ( i.before[ o ] !== i.after[ o ] ) return !0;
            return !1
          }, e;
        } )();

      function u( e, t, n ) {
        const i = t.startLineNumber;
        let o = t.endLineNumber;
        if ( 1 === t.endColumn && o--, i >= o ) return null;
        for ( var r = [], s = i; s <= o; s++ ) r.push( e.getLineContent( s ) );
        let a = r.slice( 0 );
        return a.sort( ( ( e, t ) => {
          return e.toLowerCase().localeCompare( t.toLowerCase() )
        } ) ), !0 === n && ( a = a.reverse() ), {
          startLineNumber: i,
          endLineNumber: o,
          before: r,
          after: a
        };
      }
      const l = n( "N0LK" ),
        c = ( () => {
          function e( e, t ) {
            this.selection = e, this.cursors = t
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            for ( let n = ( ( e, t ) => {
                  t.sort( ( ( e, t ) => {
                    return e.lineNumber === t.lineNumber ? e.column - t.column : e.lineNumber - t.lineNumber
                  } ) );
                  for ( let n = t.length - 2; n >= 0; n-- ) t[ n ].lineNumber === t[ n + 1 ].lineNumber && t.splice( n, 1 );
                  for ( var i = [], o = 0, a = 0, u = t.length, c = 1, d = e.getLineCount(); c <= d; c++ ) {
                    const h = e.getLineContent( c );
                    const p = h.length + 1;
                    let f = 0;
                    if ( !( a < u && t[ a ].lineNumber === c && ( f = t[ a ].column, a++, f === p ) ) && 0 !== h.length ) {
                      const g = l.lastNonWhitespaceIndex( h );
                      let m = 0;
                      if ( -1 === g ) m = 1;
                      else {
                        if ( g === h.length - 1 ) continue;
                        m = g + 2
                      }
                      m = Math.max( f, m ), i[ o++ ] = r.a.delete( new s.a( c, m, c, p ) )
                    }
                  }
                  return i
                } )( e, this.cursors ),
                i = 0,
                o = n.length; i < o; i++ ) {
              const a = n[ i ];
              t.addEditOperation( a.range, a.text )
            }
            this.selectionId = t.trackSelection( this.selection )
          }, e.prototype.computeCursorState = function ( e, t ) {
            return t.getTrackedSelection( this.selectionId )
          }, e;
        } )();
      const d = n( "wQH0" ),
        h = n( "LCkn" ),
        p = n( "gCVg" ),
        f = n( "cGHE" ),
        g = n( "sswD" ),
        m = ( () => {
          function e( e, t ) {
            this._selection = e, this._isCopyingDown = t
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            let n = this._selection;
            this._startLineNumberDelta = 0, this._endLineNumberDelta = 0, n.startLineNumber < n.endLineNumber && 1 === n.endColumn && ( this._endLineNumberDelta = 1, n = n.setEndPosition( n.endLineNumber - 1, e.getLineMaxColumn( n.endLineNumber - 1 ) ) );
            for ( var i = [], o = n.startLineNumber; o <= n.endLineNumber; o++ ) i.push( e.getLineContent( o ) );
            const r = i.join( "\n" );
            "" === r && this._isCopyingDown && ( this._startLineNumberDelta++, this._endLineNumberDelta++ ), this._isCopyingDown ? t.addEditOperation( new s.a( n.startLineNumber, 1, n.startLineNumber, 1 ), r + "\n" ) : t.addEditOperation( new s.a( n.endLineNumber, e.getLineMaxColumn( n.endLineNumber ), n.endLineNumber, e.getLineMaxColumn( n.endLineNumber ) ), "\n" + r ), this._selectionId = t.trackSelection( n ), this._selectionDirection = this._selection.getDirection()
          }, e.prototype.computeCursorState = function ( e, t ) {
            let n = t.getTrackedSelection( this._selectionId );
            if ( 0 !== this._startLineNumberDelta || 0 !== this._endLineNumberDelta ) {
              let i = n.startLineNumber,
                o = n.startColumn,
                r = n.endLineNumber,
                s = n.endColumn;
              0 !== this._startLineNumberDelta && ( i += this._startLineNumberDelta, o = 1 ), 0 !== this._endLineNumberDelta && ( r += this._endLineNumberDelta, s = 1 ), n = p.a.createWithDirection( i, o, r, s, this._selectionDirection )
            }
            return n
          }, e;
        } )(),
        _ = ( () => {
          function e( e, t, n ) {
            this.startLineNumber = e, this.endLineNumber = t, this.restoreCursorToColumn = n
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            if ( 1 !== e.getLineCount() || 1 !== e.getLineMaxColumn( 1 ) ) {
              let n = this.startLineNumber,
                i = this.endLineNumber,
                o = 1,
                r = e.getLineMaxColumn( i );
              i < e.getLineCount() ? ( i += 1, r = 1 ) : n > 1 && ( n -= 1, o = e.getLineMaxColumn( n ) ), t.addTrackedEditOperation( new s.a( n, o, i, r ), null )
            }
          }, e.prototype.computeCursorState = function ( e, t ) {
            const n = t.getInverseEditOperations()[ 0 ].range;
            return new p.a( n.endLineNumber, this.restoreCursorToColumn, n.endLineNumber, this.restoreCursorToColumn )
          }, e;
        } )(),
        v = n( "cMvZ" ),
        y = n( "zN7H" );

      function b( e, t ) {
        for ( var n = 0, i = 0; i < e.length; i++ ) "\t" === e.charAt( i ) ? n += t : n++;
        return n
      }

      function C( e, t, n ) {
        e = e < 0 ? 0 : e;
        let i = "";
        if ( !n ) {
          const o = Math.floor( e / t );
          e %= t;
          for ( var r = 0; r < o; r++ ) i += "\t"
        }
        for ( r = 0; r < e; r++ ) i += " ";
        return i
      }
      const w = n( "KDc4" ),
        S = ( () => {
          function e( e, t, n ) {
            this._selection = e, this._isMovingDown = t, this._autoIndent = n, this._moveEndLineSelectionShrink = !1
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            const n = e.getLineCount();
            if ( ( !this._isMovingDown || this._selection.endLineNumber !== n ) && ( this._isMovingDown || 1 !== this._selection.startLineNumber ) ) {
              this._moveEndPositionDown = !1;
              let i = this._selection;
              i.startLineNumber < i.endLineNumber && 1 === i.endColumn && ( this._moveEndPositionDown = !0, i = i.setEndPosition( i.endLineNumber - 1, e.getLineMaxColumn( i.endLineNumber - 1 ) ) );
              const o = e.getOptions().tabSize,
                r = e.getOptions().insertSpaces,
                a = this.buildIndentConverter( o ),
                u = {
                  getLineTokens( t ) {
                    return e.getLineTokens( t )
                  },
                  getLanguageIdentifier() {
                    return e.getLanguageIdentifier()
                  },
                  getLanguageIdAtPosition( t, n ) {
                    return e.getLanguageIdAtPosition( t, n )
                  },
                  getLineContent: null
                };
              if ( i.startLineNumber === i.endLineNumber && 1 === e.getLineMaxColumn( i.startLineNumber ) ) {
                const c = i.startLineNumber,
                  d = this._isMovingDown ? c + 1 : c - 1;
                1 === e.getLineMaxColumn( d ) ? t.addEditOperation( new s.a( 1, 1, 1, 1 ), null ) : ( t.addEditOperation( new s.a( c, 1, c, 1 ), e.getLineContent( d ) ), t.addEditOperation( new s.a( d, 1, d, e.getLineMaxColumn( d ) ), null ) ), i = new p.a( d, 1, d, 1 )
              } else {
                let h, f = void 0;
                if ( this._isMovingDown ) {
                  h = i.endLineNumber + 1, f = e.getLineContent( h ), t.addEditOperation( new s.a( h - 1, e.getLineMaxColumn( h - 1 ), h, e.getLineMaxColumn( h ) ), null );
                  let g = f;
                  if ( this.shouldAutoIndent( e, i ) ) {
                    const m = this.matchEnterRule( e, a, o, h, i.startLineNumber - 1 );
                    if ( null !== m ) {
                      var _ = C( N = m + b( w = l.getLeadingWhitespace( e.getLineContent( h ) ), o ), o, r );
                      g = _ + this.trimLeft( f )
                    } else {
                      u.getLineContent = t => {
                        return t === i.startLineNumber ? e.getLineContent( h ) : e.getLineContent( t )
                      };
                      const y = v.a.getGoodIndentForLine( u, e.getLanguageIdAtPosition( h, 1 ), i.startLineNumber, a );
                      if ( null !== y ) {
                        var w = l.getLeadingWhitespace( e.getLineContent( h ) );
                        if ( ( N = b( y, o ) ) !== ( E = b( w, o ) ) ) {
                          _ = C( N, o, r );
                          g = _ + this.trimLeft( f )
                        }
                      }
                    }
                    if ( t.addEditOperation( new s.a( i.startLineNumber, 1, i.startLineNumber, 1 ), g + "\n" ), null !== ( L = this.matchEnterRule( e, a, o, i.startLineNumber, i.startLineNumber, g ) ) ) 0 !== L && this.getIndentEditsOfMovingBlock( e, t, i, o, r, L );
                    else {
                      u.getLineContent = t => {
                        return t === i.startLineNumber ? g : t >= i.startLineNumber + 1 && t <= i.endLineNumber + 1 ? e.getLineContent( t - 1 ) : e.getLineContent( t )
                      };
                      const S = v.a.getGoodIndentForLine( u, e.getLanguageIdAtPosition( h, 1 ), i.startLineNumber + 1, a );
                      if ( null !== S ) {
                        w = l.getLeadingWhitespace( e.getLineContent( i.startLineNumber ) );
                        if ( ( N = b( S, o ) ) !== ( E = b( w, o ) ) ) {
                          var O = N - E;
                          this.getIndentEditsOfMovingBlock( e, t, i, o, r, O )
                        }
                      }
                    }
                  } else t.addEditOperation( new s.a( i.startLineNumber, 1, i.startLineNumber, 1 ), g + "\n" )
                } else {
                  var L;
                  if ( h = i.startLineNumber - 1, f = e.getLineContent( h ), t.addEditOperation( new s.a( h, 1, h + 1, 1 ), null ), t.addEditOperation( new s.a( i.endLineNumber, e.getLineMaxColumn( i.endLineNumber ), i.endLineNumber, e.getLineMaxColumn( i.endLineNumber ) ), "\n" + f ), this.shouldAutoIndent( e, i ) )
                    if ( u.getLineContent = t => {
                        return t === h ? e.getLineContent( i.startLineNumber ) : e.getLineContent( t )
                      }, null !== ( L = this.matchEnterRule( e, a, o, i.startLineNumber, i.startLineNumber - 2 ) ) ) 0 !== L && this.getIndentEditsOfMovingBlock( e, t, i, o, r, L );
                    else {
                      const x = v.a.getGoodIndentForLine( u, e.getLanguageIdAtPosition( i.startLineNumber, 1 ), h, a );
                      if ( null !== x ) {
                        var N;
                        var E;
                        const k = l.getLeadingWhitespace( e.getLineContent( i.startLineNumber ) );
                        if ( ( N = b( x, o ) ) !== ( E = b( k, o ) ) ) {
                          O = N - E;
                          this.getIndentEditsOfMovingBlock( e, t, i, o, r, O )
                        }
                      }
                    }
                }
              }
              this._selectionId = t.trackSelection( i )
            }
          }, e.prototype.buildIndentConverter = e => {
            return {
              shiftIndent( t ) {
                for ( var n = y.a.shiftIndentCount( t, t.length + 1, e ), i = "", o = 0; o < n; o++ ) i += "\t";
                return i
              },
              unshiftIndent( t ) {
                for ( var n = y.a.unshiftIndentCount( t, t.length + 1, e ), i = "", o = 0; o < n; o++ ) i += "\t";
                return i
              }
            };
          }, e.prototype.matchEnterRule = function ( e, t, n, i, o, r ) {
            for ( var a = o; a >= 1; ) {
              let u = void 0;
              if ( u = a === o && void 0 !== r ? r : e.getLineContent( a ), l.lastNonWhitespaceIndex( u ) >= 0 ) break;
              a--
            }
            if ( a < 1 || i > e.getLineCount() ) return null;
            const c = e.getLineMaxColumn( a ),
              d = v.a.getEnterAction( e, new s.a( a, c, a, c ) );
            if ( d ) {
              let h = d.indentation;
              const p = d.enterAction;
              p.indentAction === w.a.None ? h = d.indentation + p.appendText : p.indentAction === w.a.Indent ? h = d.indentation + p.appendText : p.indentAction === w.a.IndentOutdent ? h = d.indentation : p.indentAction === w.a.Outdent && ( h = t.unshiftIndent( d.indentation ) + p.appendText );
              const f = e.getLineContent( i );
              if ( this.trimLeft( f ).indexOf( this.trimLeft( h ) ) >= 0 ) {
                const g = l.getLeadingWhitespace( e.getLineContent( i ) );
                let m = l.getLeadingWhitespace( h );
                return 2 & v.a.getIndentMetadata( e, i ) && ( m = t.unshiftIndent( m ) ), b( m, n ) - b( g, n )
              }
            }
            return null
          }, e.prototype.trimLeft = e => {
            return e.replace( /^\s+/, "" )
          }, e.prototype.shouldAutoIndent = function ( e, t ) {
            if ( !this._autoIndent ) return !1;
            if ( !e.isCheapToTokenize( t.startLineNumber ) ) return !1;
            const n = e.getLanguageIdAtPosition( t.startLineNumber, 1 );
            return n === e.getLanguageIdAtPosition( t.endLineNumber, 1 ) && null !== v.a.getIndentRulesSupport( n )
          }, e.prototype.getIndentEditsOfMovingBlock = function ( e, t, n, i, o, r ) {
            for ( let a = n.startLineNumber; a <= n.endLineNumber; a++ ) {
              const u = e.getLineContent( a ),
                c = l.getLeadingWhitespace( u ),
                d = C( b( c, i ) + r, i, o );
              d !== c && ( t.addEditOperation( new s.a( a, 1, a, c.length + 1 ), d ), a === n.endLineNumber && n.endColumn <= c.length + 1 && "" === d && ( this._moveEndLineSelectionShrink = !0 ) )
            }
          }, e.prototype.computeCursorState = function ( e, t ) {
            let n = t.getTrackedSelection( this._selectionId );
            return this._moveEndPositionDown && ( n = n.setEndPosition( n.endLineNumber + 1, 1 ) ), this._moveEndLineSelectionShrink && n.startLineNumber < n.endLineNumber && ( n = n.setEndPosition( n.endLineNumber, 2 ) ), n
          }, e;
        } )(),
        O = n( "GR/f" ),
        L = n( "1YUG" ),
        x = n( "fjLI" );
      n.d( t, "AbstractSortLinesAction", ( () => {
        return R
      } ) ), n.d( t, "SortLinesAscendingAction", ( () => {
        return P
      } ) ), n.d( t, "SortLinesDescendingAction", ( () => {
        return A
      } ) ), n.d( t, "TrimTrailingWhitespaceAction", ( () => {
        return F
      } ) ), n.d( t, "IndentLinesAction", ( () => {
        return j
      } ) ), n.d( t, "InsertLineBeforeAction", ( () => {
        return B
      } ) ), n.d( t, "InsertLineAfterAction", ( () => {
        return H
      } ) ), n.d( t, "AbstractDeleteAllToBoundaryAction", ( () => {
        return z
      } ) ), n.d( t, "DeleteAllLeftAction", ( () => {
        return U
      } ) ), n.d( t, "DeleteAllRightAction", ( () => {
        return K
      } ) ), n.d( t, "JoinLinesAction", ( () => {
        return q
      } ) ), n.d( t, "TransposeAction", ( () => {
        return G
      } ) ), n.d( t, "AbstractCaseAction", ( () => {
        return Y
      } ) ), n.d( t, "UpperCaseAction", ( () => {
        return X
      } ) ), n.d( t, "LowerCaseAction", ( () => {
        return $
      } ) );
      const N = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const E = ( e => {
        function t( t, n ) {
          const i = e.call( this, n ) || this;
          return i.down = t, i
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          for ( var n = [], i = t.getSelections(), o = 0; o < i.length; o++ ) n.push( new m( i[ o ], this.down ) );
          t.pushUndoStop(), t.executeCommands( this.id, n ), t.pushUndoStop()
        }, t
      } )( g.b );
      const k = ( e => {
        function t() {
          return e.call( this, !1, {
            id: "editor.action.copyLinesUpAction",
            label: i.a( "lines.copyUp", "Copy Line Up" ),
            alias: "Copy Line Up",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: 1552,
              linux: {
                primary: 3600
              },
              weight: 100
            },
            menubarOpts: {
              menuId: x.b.MenubarSelectionMenu,
              group: "2_line",
              title: i.a( {
                key: "miCopyLinesUp",
                comment: [ "&& denotes a mnemonic" ]
              }, "&&Copy Line Up" ),
              order: 1
            }
          } ) || this
        }
        return N( t, e ), t
      } )( E );
      const I = ( e => {
        function t() {
          return e.call( this, !0, {
            id: "editor.action.copyLinesDownAction",
            label: i.a( "lines.copyDown", "Copy Line Down" ),
            alias: "Copy Line Down",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: 1554,
              linux: {
                primary: 3602
              },
              weight: 100
            },
            menubarOpts: {
              menuId: x.b.MenubarSelectionMenu,
              group: "2_line",
              title: i.a( {
                key: "miCopyLinesDown",
                comment: [ "&& denotes a mnemonic" ]
              }, "Co&&py Line Down" ),
              order: 2
            }
          } ) || this
        }
        return N( t, e ), t
      } )( E );
      const D = ( e => {
        function t( t, n ) {
          const i = e.call( this, n ) || this;
          return i.down = t, i
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          for ( var n = [], i = t.getSelections(), o = t.getConfiguration().autoIndent, r = 0; r < i.length; r++ ) n.push( new S( i[ r ], this.down, o ) );
          t.pushUndoStop(), t.executeCommands( this.id, n ), t.pushUndoStop()
        }, t
      } )( g.b );
      const M = ( e => {
        function t() {
          return e.call( this, !1, {
            id: "editor.action.moveLinesUpAction",
            label: i.a( "lines.moveUp", "Move Line Up" ),
            alias: "Move Line Up",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: 528,
              linux: {
                primary: 528
              },
              weight: 100
            },
            menubarOpts: {
              menuId: x.b.MenubarSelectionMenu,
              group: "2_line",
              title: i.a( {
                key: "miMoveLinesUp",
                comment: [ "&& denotes a mnemonic" ]
              }, "Mo&&ve Line Up" ),
              order: 3
            }
          } ) || this
        }
        return N( t, e ), t
      } )( D );
      const T = ( e => {
        function t() {
          return e.call( this, !0, {
            id: "editor.action.moveLinesDownAction",
            label: i.a( "lines.moveDown", "Move Line Down" ),
            alias: "Move Line Down",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: 530,
              linux: {
                primary: 530
              },
              weight: 100
            },
            menubarOpts: {
              menuId: x.b.MenubarSelectionMenu,
              group: "2_line",
              title: i.a( {
                key: "miMoveLinesDown",
                comment: [ "&& denotes a mnemonic" ]
              }, "Move &&Line Down" ),
              order: 4
            }
          } ) || this
        }
        return N( t, e ), t
      } )( D );
      var R = ( e => {
        function t( t, n ) {
          const i = e.call( this, n ) || this;
          return i.descending = t, i
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          for ( var n = t.getSelections(), i = 0, o = n.length; i < o; i++ ) {
            const r = n[ i ];
            if ( !a.canRun( t.getModel(), r, this.descending ) ) return
          }
          const s = [];
          for ( i = 0, o = n.length; i < o; i++ ) s[ i ] = new a( n[ i ], this.descending );
          t.pushUndoStop(), t.executeCommands( this.id, s ), t.pushUndoStop()
        }, t;
      } )( g.b );
      var P = ( e => {
        function t() {
          return e.call( this, !1, {
            id: "editor.action.sortLinesAscending",
            label: i.a( "lines.sortAscending", "Sort Lines Ascending" ),
            alias: "Sort Lines Ascending",
            precondition: d.a.writable
          } ) || this
        }
        return N( t, e ), t
      } )( R );
      var A = ( e => {
        function t() {
          return e.call( this, !0, {
            id: "editor.action.sortLinesDescending",
            label: i.a( "lines.sortDescending", "Sort Lines Descending" ),
            alias: "Sort Lines Descending",
            precondition: d.a.writable
          } ) || this
        }
        return N( t, e ), t
      } )( R );
      var F = ( e => {
        function t() {
          return e.call( this, {
            id: t.ID,
            label: i.a( "lines.trimTrailingWhitespace", "Trim Trailing Whitespace" ),
            alias: "Trim Trailing Whitespace",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: Object( o.a )( 2089, 2102 ),
              weight: 100
            }
          } ) || this
        }
        return N( t, e ), t.prototype.run = function ( e, t, n ) {
          let i = [];
          "auto-save" === n.reason && ( i = t.getSelections().map( ( e => {
            return new f.a( e.positionLineNumber, e.positionColumn )
          } ) ) );
          const o = new c( t.getSelection(), i );
          t.pushUndoStop(), t.executeCommands( this.id, [ o ] ), t.pushUndoStop()
        }, t.ID = "editor.action.trimTrailingWhitespace", t;
      } )( g.b );
      const W = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.deleteLines",
            label: i.a( "lines.delete", "Delete Line" ),
            alias: "Delete Line",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.textInputFocus,
              primary: 3113,
              weight: 100
            }
          } ) || this
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          const n = this._getLinesToRemove( t ).map( ( e => {
            return new _( e.startLineNumber, e.endLineNumber, e.positionColumn )
          } ) );
          t.pushUndoStop(), t.executeCommands( this.id, n ), t.pushUndoStop()
        }, t.prototype._getLinesToRemove = e => {
          const t = e.getSelections().map( ( e => {
            let t = e.endLineNumber;
            return e.startLineNumber < e.endLineNumber && 1 === e.endColumn && ( t -= 1 ), {
              startLineNumber: e.startLineNumber,
              endLineNumber: t,
              positionColumn: e.positionColumn
            }
          } ) );
          t.sort( ( ( e, t ) => {
            return e.startLineNumber - t.startLineNumber
          } ) );
          for ( var n = [], i = t[ 0 ], o = 1; o < t.length; o++ ) i.endLineNumber + 1 === t[ o ].startLineNumber ? i.endLineNumber = t[ o ].endLineNumber : ( n.push( i ), i = t[ o ] );
          return n.push( i ), n
        }, t;
      } )( g.b );
      var j = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.indentLines",
            label: i.a( "lines.indent", "Indent Line" ),
            alias: "Indent Line",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: 2137,
              weight: 100
            }
          } ) || this
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          t.pushUndoStop(), t.executeCommands( this.id, O.TypeOperations.indent( t._getCursorConfiguration(), t.getModel(), t.getSelections() ) ), t.pushUndoStop()
        }, t
      } )( g.b );
      const V = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.outdentLines",
            label: i.a( "lines.outdent", "Outdent Line" ),
            alias: "Outdent Line",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: 2135,
              weight: 100
            }
          } ) || this
        }
        return N( t, e ), t.prototype.run = ( e, t ) => {
          L.CoreEditingCommands.Outdent.runEditorCommand( null, t, null )
        }, t;
      } )( g.b );
      var B = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.insertLineBefore",
            label: i.a( "lines.insertBefore", "Insert Line Above" ),
            alias: "Insert Line Above",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: 3075,
              weight: 100
            }
          } ) || this
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          t.pushUndoStop(), t.executeCommands( this.id, O.TypeOperations.lineInsertBefore( t._getCursorConfiguration(), t.getModel(), t.getSelections() ) )
        }, t
      } )( g.b );
      var H = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.insertLineAfter",
            label: i.a( "lines.insertAfter", "Insert Line Below" ),
            alias: "Insert Line Below",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: 2051,
              weight: 100
            }
          } ) || this
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          t.pushUndoStop(), t.executeCommands( this.id, O.TypeOperations.lineInsertAfter( t._getCursorConfiguration(), t.getModel(), t.getSelections() ) )
        }, t
      } )( g.b );
      var z = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          for ( var n = t.getSelection(), i = this._getRangesToDelete( t ), o = [], a = 0, u = i.length - 1; a < u; a++ ) {
            const l = i[ a ],
              c = i[ a + 1 ];
            null === s.a.intersectRanges( l, c ) ? o.push( l ) : i[ a + 1 ] = s.a.plusRange( l, c )
          }
          o.push( i[ i.length - 1 ] );
          const d = this._getEndCursorState( n, o ),
            h = o.map( ( e => {
              return r.a.replace( e, "" )
            } ) );
          t.pushUndoStop(), t.executeEdits( this.id, h, d ), t.pushUndoStop()
        }, t;
      } )( g.b );

      var U = ( e => {
        function t() {
          return e.call( this, {
            id: "deleteAllLeft",
            label: i.a( "lines.deleteAllLeft", "Delete All Left" ),
            alias: "Delete All Left",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.textInputFocus,
              primary: null,
              mac: {
                primary: 2049
              },
              weight: 100
            }
          } ) || this
        }
        return N( t, e ), t.prototype._getEndCursorState = ( e, t ) => {
          let n;
          const i = [];
          let o = 0;
          return t.forEach( ( t => {
            let r;
            if ( 1 === t.endColumn && o > 0 ) {
              const s = t.startLineNumber - o;
              r = new p.a( s, t.startColumn, s, t.startColumn )
            } else r = new p.a( t.startLineNumber, t.startColumn, t.startLineNumber, t.startColumn );
            o += t.endLineNumber - t.startLineNumber, t.intersectRanges( e ) ? n = r : i.push( r )
          } ) ), n && i.unshift( n ), i;
        }, t.prototype._getRangesToDelete = e => {
          let t = e.getSelections();
          const n = e.getModel();
          return t.sort( s.a.compareRangesUsingStarts ), t = t.map( ( e => {
            if ( e.isEmpty() ) {
              if ( 1 === e.startColumn ) {
                const t = Math.max( 1, e.startLineNumber - 1 ),
                  i = 1 === e.startLineNumber ? 1 : n.getLineContent( t ).length + 1;
                return new s.a( t, i, e.startLineNumber, 1 )
              }
              return new s.a( e.startLineNumber, 1, e.startLineNumber, e.startColumn )
            }
            return e
          } ) );
        }, t;
      } )( z );

      var K = ( e => {
        function t() {
          return e.call( this, {
            id: "deleteAllRight",
            label: i.a( "lines.deleteAllRight", "Delete All Right" ),
            alias: "Delete All Right",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.textInputFocus,
              primary: null,
              mac: {
                primary: 297,
                secondary: [ 2068 ]
              },
              weight: 100
            }
          } ) || this
        }
        return N( t, e ), t.prototype._getEndCursorState = ( e, t ) => {
          for ( var n, i = [], o = 0, r = t.length; o < r; o++ ) {
            const s = t[ o ],
              a = new p.a( s.startLineNumber - 0, s.startColumn, s.startLineNumber - 0, s.startColumn );
            s.intersectRanges( e ) ? n = a : i.push( a )
          }
          return n && i.unshift( n ), i
        }, t.prototype._getRangesToDelete = e => {
          const t = e.getModel(),
            n = e.getSelections().map( ( e => {
              if ( e.isEmpty() ) {
                const n = t.getLineMaxColumn( e.startLineNumber );
                return e.startColumn === n ? new s.a( e.startLineNumber, e.startColumn, e.startLineNumber + 1, 1 ) : new s.a( e.startLineNumber, e.startColumn, e.startLineNumber, n )
              }
              return e
            } ) );
          return n.sort( s.a.compareRangesUsingStarts ), n
        }, t;
      } )( z );

      var q = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.joinLines",
            label: i.a( "lines.joinLines", "Join Lines" ),
            alias: "Join Lines",
            precondition: d.a.writable,
            kbOpts: {
              kbExpr: d.a.editorTextFocus,
              primary: 0,
              mac: {
                primary: 296
              },
              weight: 100
            }
          } ) || this
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          const n = t.getSelections();
          let i = t.getSelection();
          n.sort( s.a.compareRangesUsingStarts );
          const o = [],
            a = n.reduce( ( ( e, t ) => {
              return e.isEmpty() ? e.endLineNumber === t.startLineNumber ? ( i.equalsSelection( e ) && ( i = t ), t ) : t.startLineNumber > e.endLineNumber + 1 ? ( o.push( e ), t ) : new p.a( e.startLineNumber, e.startColumn, t.endLineNumber, t.endColumn ) : t.startLineNumber > e.endLineNumber ? ( o.push( e ), t ) : new p.a( e.startLineNumber, e.startColumn, t.endLineNumber, t.endColumn )
            } ) );
          o.push( a );
          for ( var u = t.getModel(), l = [], c = [], d = i, h = 0, f = 0, g = o.length; f < g; f++ ) {
            const m = o[ f ];
            const _ = m.startLineNumber;
            let v = 0;
            let y = void 0;
            let b = void 0;
            const C = u.getLineContent( m.endLineNumber ).length - m.endColumn;
            if ( m.isEmpty() || m.startLineNumber === m.endLineNumber ) {
              const w = m.getStartPosition();
              w.lineNumber < u.getLineCount() ? ( y = _ + 1, b = u.getLineMaxColumn( y ) ) : ( y = w.lineNumber, b = u.getLineMaxColumn( w.lineNumber ) )
            } else y = m.endLineNumber, b = u.getLineMaxColumn( y );
            for ( var S = u.getLineContent( _ ), O = _ + 1; O <= y; O++ ) {
              const L = u.getLineContent( O ),
                x = u.getLineFirstNonWhitespaceColumn( O );
              if ( x >= 1 ) {
                let N = !0;
                "" === S && ( N = !1 ), !N || " " !== S.charAt( S.length - 1 ) && "\t" !== S.charAt( S.length - 1 ) || ( N = !1, S = S.replace( /[\s\uFEFF\xA0]+$/g, " " ) );
                const E = L.substr( x - 1 );
                S += ( N ? " " : "" ) + E, v = N ? E.length + 1 : E.length
              } else v = 0
            }
            const k = new s.a( _, 1, y, b );
            if ( !k.isEmpty() ) {
              let I = void 0;
              m.isEmpty() ? ( l.push( r.a.replace( k, S ) ), I = new p.a( k.startLineNumber - h, S.length - v + 1, _ - h, S.length - v + 1 ) ) : m.startLineNumber === m.endLineNumber ? ( l.push( r.a.replace( k, S ) ), I = new p.a( m.startLineNumber - h, m.startColumn, m.endLineNumber - h, m.endColumn ) ) : ( l.push( r.a.replace( k, S ) ), I = new p.a( m.startLineNumber - h, m.startColumn, m.startLineNumber - h, S.length - C ) ), null !== s.a.intersectRanges( k, i ) ? d = I : c.push( I )
            }
            h += k.endLineNumber - k.startLineNumber
          }
          c.unshift( d ), t.pushUndoStop(), t.executeEdits( this.id, l, c ), t.pushUndoStop()
        }, t;
      } )( g.b );

      var G = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.transpose",
            label: i.a( "editor.transpose", "Transpose characters around the cursor" ),
            alias: "Transpose characters around the cursor",
            precondition: d.a.writable
          } ) || this
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          for ( var n = t.getSelections(), i = t.getModel(), o = [], r = 0, a = n.length; r < a; r++ ) {
            const u = n[ r ];
            if ( u.isEmpty() ) {
              const l = u.getStartPosition(),
                c = i.getLineMaxColumn( l.lineNumber );
              if ( l.column >= c ) {
                if ( l.lineNumber === i.getLineCount() ) continue;
                var d = new s.a( l.lineNumber, Math.max( 1, l.column - 1 ), l.lineNumber + 1, 1 ),
                  f = i.getValueInRange( d ).split( "" ).reverse().join( "" );
                o.push( new h.a( new p.a( l.lineNumber, Math.max( 1, l.column - 1 ), l.lineNumber + 1, 1 ), f ) )
              } else {
                d = new s.a( l.lineNumber, Math.max( 1, l.column - 1 ), l.lineNumber, l.column + 1 ), f = i.getValueInRange( d ).split( "" ).reverse().join( "" );
                o.push( new h.b( d, f, new p.a( l.lineNumber, l.column + 1, l.lineNumber, l.column + 1 ) ) )
              }
            }
          }
          t.pushUndoStop(), t.executeCommands( this.id, o ), t.pushUndoStop()
        }, t;
      } )( g.b );

      var Y = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return N( t, e ), t.prototype.run = function ( e, t ) {
          for ( var n = t.getSelections(), i = t.getModel(), o = [], r = 0, a = n.length; r < a; r++ ) {
            const u = n[ r ];
            if ( u.isEmpty() ) {
              const l = u.getStartPosition(),
                c = i.getWordAtPosition( l );
              if ( !c ) continue;
              const d = new s.a( l.lineNumber, c.startColumn, l.lineNumber, c.endColumn );
              var f = i.getValueInRange( d );
              o.push( new h.b( d, this._modifyText( f ), new p.a( l.lineNumber, l.column, l.lineNumber, l.column ) ) )
            } else {
              f = i.getValueInRange( u );
              o.push( new h.b( u, this._modifyText( f ), u ) )
            }
          }
          t.pushUndoStop(), t.executeCommands( this.id, o ), t.pushUndoStop()
        }, t;
      } )( g.b );

      var X = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.transformToUppercase",
            label: i.a( "editor.transformToUppercase", "Transform to Uppercase" ),
            alias: "Transform to Uppercase",
            precondition: d.a.writable
          } ) || this
        }
        return N( t, e ), t.prototype._modifyText = e => {
          return e.toLocaleUpperCase()
        }, t;
      } )( Y );
      var $ = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.transformToLowercase",
            label: i.a( "editor.transformToLowercase", "Transform to Lowercase" ),
            alias: "Transform to Lowercase",
            precondition: d.a.writable
          } ) || this
        }
        return N( t, e ), t.prototype._modifyText = e => {
          return e.toLocaleLowerCase()
        }, t;
      } )( Y );
      Object( g.f )( k ), Object( g.f )( I ), Object( g.f )( M ), Object( g.f )( T ), Object( g.f )( P ), Object( g.f )( A ), Object( g.f )( F ), Object( g.f )( W ), Object( g.f )( j ), Object( g.f )( V ), Object( g.f )( B ), Object( g.f )( H ), Object( g.f )( U ), Object( g.f )( K ), Object( g.f )( q ), Object( g.f )( G ), Object( g.f )( X ), Object( g.f )( $ )
    },
    dgXF( e, t, n ) {
      "use strict";
      n.r( t );
      n( "CjOT" );
      const i = n( "3/fG" ),
        o = n( "746U" ),
        r = n( "N0LK" ),
        s = n( "X+cX" ),
        a = n( "/kV6" ),
        u = n( "pmY6" ),
        l = n( "VMIq" ),
        c = n( "sswD" ),
        d = n( "sFUC" ),
        h = n( "MI8n" ),
        p = 65535,
        f = ( () => {
          function e( e, t, n ) {
            if ( e.length !== t.length || e.length > p ) throw new Error( "invalid startIndexes or endIndexes size" );
            this._startIndexes = e, this._endIndexes = t, this._collapseStates = new Uint32Array( Math.ceil( e.length / 32 ) ), this._types = n
          }
          return e.prototype.ensureParentIndices = function () {
            const e = this;
            if ( !this._parentsComputed ) {
              this._parentsComputed = !0;
              for ( let t = [], n = ( n, i ) => {
                  const o = t[ t.length - 1 ];
                  return e.getStartLineNumber( o ) <= n && e.getEndLineNumber( o ) >= i
                }, i = 0, o = this._startIndexes.length; i < o; i++ ) {
                const r = this._startIndexes[ i ],
                  s = this._endIndexes[ i ];
                if ( r > 16777215 || s > 16777215 ) throw new Error( "startLineNumber or endLineNumber must not exceed 16777215" );
                for ( ; t.length > 0 && !n( r, s ); ) t.pop();
                const a = t.length > 0 ? t[ t.length - 1 ] : -1;
                t.push( i ), this._startIndexes[ i ] = r + ( ( 255 & a ) << 24 ), this._endIndexes[ i ] = s + ( ( 65280 & a ) << 16 )
              }
            }
          }, Object.defineProperty( e.prototype, "length", {
            get() {
              return this._startIndexes.length
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.getStartLineNumber = function ( e ) {
            return 16777215 & this._startIndexes[ e ]
          }, e.prototype.getEndLineNumber = function ( e ) {
            return 16777215 & this._endIndexes[ e ]
          }, e.prototype.getType = function ( e ) {
            return this._types ? this._types[ e ] : void 0
          }, e.prototype.hasTypes = function () {
            return !!this._types
          }, e.prototype.isCollapsed = function ( e ) {
            const t = e / 32 | 0,
              n = e % 32;
            return 0 !== ( this._collapseStates[ t ] & 1 << n )
          }, e.prototype.setCollapsed = function ( e, t ) {
            const n = e / 32 | 0,
              i = e % 32,
              o = this._collapseStates[ n ];
            this._collapseStates[ n ] = t ? o | 1 << i : o & ~( 1 << i )
          }, e.prototype.toRegion = function ( e ) {
            return new g( this, e )
          }, e.prototype.getParentIndex = function ( e ) {
            this.ensureParentIndices();
            const t = ( ( 4278190080 & this._startIndexes[ e ] ) >>> 24 ) + ( ( 4278190080 & this._endIndexes[ e ] ) >>> 16 );
            return t === p ? -1 : t
          }, e.prototype.contains = function ( e, t ) {
            return this.getStartLineNumber( e ) <= t && this.getEndLineNumber( e ) >= t
          }, e.prototype.findIndex = function ( e ) {
            let t = 0,
              n = this._startIndexes.length;
            if ( 0 === n ) return -1;
            for ( ; t < n; ) {
              const i = Math.floor( ( t + n ) / 2 );
              e < this.getStartLineNumber( i ) ? n = i : t = i + 1
            }
            return t - 1
          }, e.prototype.findRange = function ( e ) {
            let t = this.findIndex( e );
            if ( t >= 0 ) {
              if ( this.getEndLineNumber( t ) >= e ) return t;
              for ( t = this.getParentIndex( t ); - 1 !== t; ) {
                if ( this.contains( t, e ) ) return t;
                t = this.getParentIndex( t )
              }
            }
            return -1
          }, e.prototype.toString = function () {
            for ( var e = [], t = 0; t < this.length; t++ ) e[ t ] = "[" + ( this.isCollapsed( t ) ? "+" : "-" ) + "] " + this.getStartLineNumber( t ) + "/" + this.getEndLineNumber( t );
            return e.join( ", " )
          }, e;
        } )(),
        g = ( () => {
          function e( e, t ) {
            this.ranges = e, this.index = t
          }
          return Object.defineProperty( e.prototype, "startLineNumber", {
            get() {
              return this.ranges.getStartLineNumber( this.index )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "endLineNumber", {
            get() {
              return this.ranges.getEndLineNumber( this.index )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "regionIndex", {
            get() {
              return this.index
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "parentIndex", {
            get() {
              return this.ranges.getParentIndex( this.index )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "isCollapsed", {
            get() {
              return this.ranges.isCollapsed( this.index )
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.containedBy = function ( e ) {
            return e.startLineNumber <= this.startLineNumber && e.endLineNumber >= this.endLineNumber
          }, e.prototype.containsLine = function ( e ) {
            return this.startLineNumber <= e && e <= this.endLineNumber
          }, e;
        } )(),
        m = ( () => {
          function e( e, t ) {
            this._updateEventEmitter = new h.a, this._textModel = e, this._decorationProvider = t, this._regions = new f( new Uint32Array( 0 ), new Uint32Array( 0 ) ), this._editorDecorationIds = [], this._isInitialized = !1
          }
          return Object.defineProperty( e.prototype, "regions", {
            get() {
              return this._regions
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onDidChange", {
            get() {
              return this._updateEventEmitter.event
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "textModel", {
            get() {
              return this._textModel
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "isInitialized", {
            get() {
              return this._isInitialized
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.toggleCollapseState = function ( e ) {
            const t = this;
            if ( e.length ) {
              const n = {};
              this._decorationProvider.changeDecorations( ( i => {
                for ( let o = 0, r = e; o < r.length; o++ ) {
                  const s = r[ o ].regionIndex,
                    a = t._editorDecorationIds[ s ];
                  if ( a && !n[ a ] ) {
                    n[ a ] = !0;
                    const u = !t._regions.isCollapsed( s );
                    t._regions.setCollapsed( s, u ), i.changeDecorationOptions( a, t._decorationProvider.getDecorationOption( u ) )
                  }
                }
              } ) ), this._updateEventEmitter.fire( {
                model: this,
                collapseStateChanged: e
              } )
            }
          }, e.prototype.update = function ( e, t ) {
            const n = this;
            void 0 === t && ( t = [] );
            for ( var i = [], o = ( o, r ) => {
                const s = e.getStartLineNumber( o );
                r && ( ( e, n ) => {
                  for ( let i = 0, o = t; i < o.length; i++ ) {
                    const r = o[ i ];
                    if ( e < r && r <= n ) return !0
                  }
                  return !1
                } )( s, e.getEndLineNumber( o ) ) && ( r = !1 ), e.setCollapsed( o, r );
                const a = n._textModel.getLineMaxColumn( s ),
                  u = {
                    startLineNumber: s,
                    startColumn: a,
                    endLineNumber: s,
                    endColumn: a
                  };
                i.push( {
                  range: u,
                  options: n._decorationProvider.getDecorationOption( r )
                } )
              }, r = 0, s = () => {
                for ( ; r < n._regions.length; ) {
                  const e = n._regions.isCollapsed( r );
                  if ( r++, e ) return r - 1
                }
                return -1
              }, a = 0, u = s(); - 1 !== u && a < e.length; ) {
              const l = this._textModel.getDecorationRange( this._editorDecorationIds[ u ] );
              if ( l ) {
                const c = l.startLineNumber;
                if ( this._textModel.getLineMaxColumn( c ) === l.startColumn )
                  for ( ; a < e.length; ) {
                    const d = e.getStartLineNumber( a );
                    if ( !( c >= d ) ) break;
                    o( a, c === d ), a++
                  }
              }
              u = s()
            }
            for ( ; a < e.length; ) o( a, !1 ), a++;
            this._editorDecorationIds = this._decorationProvider.deltaDecorations( this._editorDecorationIds, i ), this._regions = e, this._isInitialized = !0, this._updateEventEmitter.fire( {
              model: this
            } )
          }, e.prototype.getMemento = function () {
            for ( var e = [], t = 0; t < this._regions.length; t++ )
              if ( this._regions.isCollapsed( t ) ) {
                const n = this._textModel.getDecorationRange( this._editorDecorationIds[ t ] );
                if ( n ) {
                  const i = n.startLineNumber,
                    o = n.endLineNumber + this._regions.getEndLineNumber( t ) - this._regions.getStartLineNumber( t );
                  e.push( {
                    startLineNumber: i,
                    endLineNumber: o
                  } )
                }
              } return e.length > 0 ? e : null
          }, e.prototype.applyMemento = function ( e ) {
            if ( Array.isArray( e ) ) {
              for ( var t = [], n = 0, i = e; n < i.length; n++ ) {
                const o = i[ n ],
                  r = this.getRegionAtLine( o.startLineNumber );
                r && !r.isCollapsed && t.push( r )
              }
              this.toggleCollapseState( t )
            }
          }, e.prototype.dispose = function () {
            this._decorationProvider.deltaDecorations( this._editorDecorationIds, [] )
          }, e.prototype.getAllRegionsAtLine = function ( e, t ) {
            const n = [];
            if ( this._regions )
              for ( let i = this._regions.findRange( e ), o = 1; i >= 0; ) {
                const r = this._regions.toRegion( i );
                t && !t( r, o ) || n.push( r ), o++, i = r.parentIndex
              }
            return n
          }, e.prototype.getRegionAtLine = function ( e ) {
            if ( this._regions ) {
              const t = this._regions.findRange( e );
              if ( t >= 0 ) return this._regions.toRegion( t )
            }
            return null
          }, e.prototype.getRegionsInside = function ( e, t ) {
            for ( var n = [], i = t && 2 === t.length, o = i ? [] : null, r = e ? e.regionIndex + 1 : 0, s = e ? e.endLineNumber : Number.MAX_VALUE, a = r, u = this._regions.length; a < u; a++ ) {
              const l = this._regions.toRegion( a );
              if ( !( this._regions.getStartLineNumber( a ) < s ) ) break;
              if ( i ) {
                for ( ; o.length > 0 && !l.containedBy( o[ o.length - 1 ] ); ) o.pop();
                o.push( l ), t( l, o.length ) && n.push( l )
              } else t && !t( l ) || n.push( l )
            }
            return n
          }, e;
        } )();

      function _( e, t, n, i ) {
        void 0 === n && ( n = Number.MAX_VALUE );
        const o = [];
        if ( i && i.length > 0 )
          for ( let r = 0, s = i; r < s.length; r++ ) {
            const a = s[ r ],
              u = e.getRegionAtLine( a );
            if ( u && ( u.isCollapsed !== t && o.push( u ), n > 1 ) ) {
              var l = e.getRegionsInside( u, ( ( e, i ) => {
                return e.isCollapsed !== t && i < n
              } ) );
              o.push.apply( o, l )
            }
          } else {
            l = e.getRegionsInside( null, ( ( e, i ) => {
              return e.isCollapsed !== t && i < n
            } ) );
            o.push.apply( o, l )
          }
        e.toggleCollapseState( o )
      }

      function v( e, t, n, i ) {
        for ( var o = [], r = 0, s = i; r < s.length; r++ ) {
          const a = s[ r ],
            u = e.getAllRegionsAtLine( a, ( ( e, i ) => {
              return e.isCollapsed !== t && i <= n
            } ) );
          o.push.apply( o, u )
        }
        e.toggleCollapseState( o )
      }

      function y( e, t, n ) {
        for ( var i = e.textModel, o = e.regions, r = [], s = o.length - 1; s >= 0; s-- )
          if ( n !== o.isCollapsed( s ) ) {
            const a = o.getStartLineNumber( s );
            t.test( i.getLineContent( a ) ) && r.push( o.toRegion( s ) )
          } e.toggleCollapseState( r )
      }

      function b( e, t, n ) {
        for ( var i = e.regions, o = [], r = i.length - 1; r >= 0; r-- ) n !== i.isCollapsed( r ) && t === i.getType( r ) && o.push( i.toRegion( r ) );
        e.toggleCollapseState( o )
      }
      const C = n( "M1Kb" ),
        w = n( "tX9W" ),
        S = ( () => {
          function e( e ) {
            this.editor = e, this.autoHideFoldingControls = !0
          }
          return e.prototype.getDecorationOption = function ( t ) {
            return t ? e.COLLAPSED_VISUAL_DECORATION : this.autoHideFoldingControls ? e.EXPANDED_AUTO_HIDE_VISUAL_DECORATION : e.EXPANDED_VISUAL_DECORATION
          }, e.prototype.deltaDecorations = function ( e, t ) {
            return this.editor.deltaDecorations( e, t )
          }, e.prototype.changeDecorations = function ( e ) {
            return this.editor.changeDecorations( e )
          }, e.COLLAPSED_VISUAL_DECORATION = w.a.register( {
            stickiness: C.h.NeverGrowsWhenTypingAtEdges,
            afterContentClassName: "inline-folded",
            linesDecorationsClassName: "folding collapsed"
          } ), e.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = w.a.register( {
            stickiness: C.h.NeverGrowsWhenTypingAtEdges,
            linesDecorationsClassName: "folding"
          } ), e.EXPANDED_VISUAL_DECORATION = w.a.register( {
            stickiness: C.h.NeverGrowsWhenTypingAtEdges,
            linesDecorationsClassName: "folding alwaysShowFoldIcons"
          } ), e
        } )(),
        O = n( "wQH0" ),
        L = n( "aokT" ),
        x = n( "6OMU" ),
        N = ( () => {
          function e( e ) {
            const t = this;
            this._updateEventEmitter = new h.a, this._foldingModel = e, this._foldingModelListener = e.onDidChange( ( e => {
              return t.updateHiddenRanges()
            } ) ), this._hiddenRanges = [], e.regions.length && this.updateHiddenRanges()
          }
          return Object.defineProperty( e.prototype, "onDidChange", {
            get() {
              return this._updateEventEmitter.event
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "hiddenRanges", {
            get() {
              return this._hiddenRanges
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.updateHiddenRanges = function () {
            for ( var e = !1, t = [], n = 0, i = 0, o = Number.MAX_VALUE, r = -1, s = this._foldingModel.regions; n < s.length; n++ )
              if ( s.isCollapsed( n ) ) {
                const a = s.getStartLineNumber( n ) + 1,
                  u = s.getEndLineNumber( n );
                o <= a && u <= r || ( !e && i < this._hiddenRanges.length && this._hiddenRanges[ i ].startLineNumber === a && this._hiddenRanges[ i ].endLineNumber === u ? ( t.push( this._hiddenRanges[ i ] ), i++ ) : ( e = !0, t.push( new L.a( a, 1, u, 1 ) ) ), o = a, r = u )
              }( e || i < this._hiddenRanges.length ) && this.applyHiddenRanges( t )
          }, e.prototype.applyMemento = function ( e ) {
            if ( !Array.isArray( e ) || 0 === e.length ) return !1;
            for ( var t = [], n = 0, i = e; n < i.length; n++ ) {
              const o = i[ n ];
              if ( !o.startLineNumber || !o.endLineNumber ) return !1;
              t.push( new L.a( o.startLineNumber + 1, 1, o.endLineNumber, 1 ) )
            }
            return this.applyHiddenRanges( t ), !0
          }, e.prototype.getMemento = function () {
            return this._hiddenRanges.map( ( e => {
              return {
                startLineNumber: e.startLineNumber - 1,
                endLineNumber: e.endLineNumber
              }
            } ) );
          }, e.prototype.applyHiddenRanges = function ( e ) {
            this._hiddenRanges = e, this._updateEventEmitter.fire( e )
          }, e.prototype.hasRanges = function () {
            return this._hiddenRanges.length > 0
          }, e.prototype.isHidden = function ( e ) {
            return null !== E( this._hiddenRanges, e )
          }, e.prototype.adjustSelections = function ( e ) {
            for ( var t = this, n = !1, i = this._foldingModel.textModel, o = null, r = e => {
                return o && ( ( e, t ) => {
                  return e >= t.startLineNumber && e <= t.endLineNumber
                } )( e, o ) || ( o = E( t._hiddenRanges, e ) ), o ? o.startLineNumber - 1 : null;
              }, s = 0, a = e.length; s < a; s++ ) {
              let u = e[ s ];
              const l = r( u.startLineNumber );
              l && ( u = u.setStartPosition( l, i.getLineMaxColumn( l ) ), n = !0 );
              const c = r( u.endLineNumber );
              c && ( u = u.setEndPosition( c, i.getLineMaxColumn( c ) ), n = !0 ), e[ s ] = u
            }
            return n
          }, e.prototype.dispose = function () {
            this.hiddenRanges.length > 0 && ( this._hiddenRanges = [], this._updateEventEmitter.fire( this._hiddenRanges ) ), this._foldingModelListener && ( this._foldingModelListener.dispose(), this._foldingModelListener = null )
          }, e;
        } )();

      function E( e, t ) {
        const n = Object( x.f )( e, ( e => {
          return t < e.startLineNumber
        } ) ) - 1;
        return n >= 0 && e[ n ].endLineNumber >= t ? e[ n ] : null
      }
      const k = n( "cMvZ" ),
        I = 5e3,
        D = "indent",
        M = ( () => {
          function e( e ) {
            this.editorModel = e, this.id = D
          }
          return e.prototype.dispose = () => {}, e.prototype.compute = function ( e ) {
            const t = k.a.getFoldingRules( this.editorModel.getLanguageIdentifier().id ),
              n = t && t.offSide,
              i = t && t.markers;
            return l.b.as(
              ( ( e, t, n, i ) => {
                void 0 === i && ( i = I );
                const o = e.getOptions().tabSize;
                const r = new T( i );
                let s = void 0;
                n && ( s = new RegExp( "(" + n.start.source + ")|(?:" + n.end.source + ")" ) );
                const a = [];
                a.push( {
                  indent: -1,
                  line: e.getLineCount() + 1,
                  marker: !1
                } );
                for ( let u = e.getLineCount(); u > 0; u-- ) {
                  const l = e.getLineContent( u );
                  const c = w.b.computeIndentLevel( l, o );
                  let d = a[ a.length - 1 ];
                  if ( -1 !== c ) {
                    let h = void 0;
                    if ( s && ( h = l.match( s ) ) ) {
                      if ( !h[ 1 ] ) {
                        a.push( {
                          indent: -2,
                          line: u,
                          marker: !0
                        } );
                        continue
                      }
                      for ( var p = a.length - 1; p > 0 && !a[ p ].marker; ) p--;
                      if ( p > 0 ) {
                        a.length = p + 1, d = a[ p ], r.insertFirst( u, d.line, c ), d.marker = !1, d.indent = c, d.line = u;
                        continue
                      }
                    }
                    if ( d.indent > c ) {
                      do {
                        a.pop(), d = a[ a.length - 1 ]
                      } while ( d.indent > c );
                      const f = d.line - 1;
                      f - u >= 1 && r.insertFirst( u, f, c )
                    }
                    d.indent === c ? d.line = u : a.push( {
                      indent: c,
                      line: u,
                      marker: !1
                    } )
                  } else t && !d.marker && ( d.line = u )
                }
                return r.toIndentRanges( e )
              } )( this.editorModel, n, i )
            );
          }, e;
        } )(),
        T = ( () => {
          function e( e ) {
            this._startIndexes = [], this._endIndexes = [], this._indentOccurrences = [], this._length = 0, this._foldingRangesLimit = e
          }
          return e.prototype.insertFirst = function ( e, t, n ) {
            if ( !( e > 16777215 || t > 16777215 ) ) {
              const i = this._length;
              this._startIndexes[ i ] = e, this._endIndexes[ i ] = t, this._length++, n < 1e3 && ( this._indentOccurrences[ n ] = ( this._indentOccurrences[ n ] || 0 ) + 1 )
            }
          }, e.prototype.toIndentRanges = function ( e ) {
            if ( this._length <= this._foldingRangesLimit ) {
              for ( var t = new Uint32Array( this._length ), n = new Uint32Array( this._length ), i = this._length - 1, o = 0; i >= 0; i--, o++ ) t[ o ] = this._startIndexes[ i ], n[ o ] = this._endIndexes[ i ];
              return new f( t, n )
            }
            let r = 0,
              s = this._indentOccurrences.length;
            for ( i = 0; i < this._indentOccurrences.length; i++ ) {
              const a = this._indentOccurrences[ i ];
              if ( a ) {
                if ( a + r > this._foldingRangesLimit ) {
                  s = i;
                  break
                }
                r += a
              }
            }
            const u = e.getOptions().tabSize;
            for ( t = new Uint32Array( this._foldingRangesLimit ), n = new Uint32Array( this._foldingRangesLimit ), i = this._length - 1, o = 0; i >= 0; i-- ) {
              const l = this._startIndexes[ i ],
                c = e.getLineContent( l ),
                d = w.b.computeIndentLevel( c, u );
              ( d < s || d === s && r++ < this._foldingRangesLimit ) && ( t[ o ] = l, n[ o ] = this._endIndexes[ i ], o++ )
            }
            return new f( t, n )
          }, e;
        } )();
      const R = n( "twdY" ),
        P = n( "/cxE" ),
        A = 5e3,
        F = {},
        W = "syntax",
        j = ( () => {
          function e( e, t, n ) {
            void 0 === n && ( n = A ), this.editorModel = e, this.providers = t, this.limit = n, this.id = W
          }
          return e.prototype.compute = function ( e ) {
            const t = this;
            return ( ( e, t, n ) => {
              let i = null;
              const o = e.map( ( ( e, o ) => {
                return Object( s.n )( e.provideFoldingRanges( t, F, n ) ).then( ( e => {
                  if ( !n.isCancellationRequested && Array.isArray( e ) ) {
                    Array.isArray( i ) || ( i = [] );
                    for ( let r = t.getLineCount(), s = 0, a = e; s < a.length; s++ ) {
                      const u = a[ s ];
                      u.start > 0 && u.end > u.start && u.end <= r && i.push( {
                        start: u.start,
                        end: u.end,
                        rank: o,
                        kind: u.kind
                      } )
                    }
                  }
                } ), P.f );
              } ) );
              return l.b.join( o ).then( ( e => {
                return i
              } ) );
            } )( this.providers, this.editorModel, e ).then( ( e => {
              return e ? B( e, t.limit ) : null
            } ) );
          }, e.prototype.dispose = () => {}, e;
        } )();
      const V = ( () => {
        function e( e ) {
          this._startIndexes = [], this._endIndexes = [], this._nestingLevels = [], this._nestingLevelCounts = [], this._types = [], this._length = 0, this._foldingRangesLimit = e
        }
        return e.prototype.add = function ( e, t, n, i ) {
          if ( !( e > 16777215 || t > 16777215 ) ) {
            const o = this._length;
            this._startIndexes[ o ] = e, this._endIndexes[ o ] = t, this._nestingLevels[ o ] = i, this._types[ o ] = n, this._length++, i < 30 && ( this._nestingLevelCounts[ i ] = ( this._nestingLevelCounts[ i ] || 0 ) + 1 )
          }
        }, e.prototype.toIndentRanges = function () {
          if ( this._length <= this._foldingRangesLimit ) {
            for ( var e = new Uint32Array( this._length ), t = new Uint32Array( this._length ), n = 0; n < this._length; n++ ) e[ n ] = this._startIndexes[ n ], t[ n ] = this._endIndexes[ n ];
            return new f( e, t, this._types )
          }
          let i = 0,
            o = this._nestingLevelCounts.length;
          for ( n = 0; n < this._nestingLevelCounts.length; n++ ) {
            const r = this._nestingLevelCounts[ n ];
            if ( r ) {
              if ( r + i > this._foldingRangesLimit ) {
                o = n;
                break
              }
              i += r
            }
          }
          e = new Uint32Array( this._foldingRangesLimit ), t = new Uint32Array( this._foldingRangesLimit );
          for ( var s = [], a = ( n = 0, 0 ); n < this._length; n++ ) {
            const u = this._nestingLevels[ n ];
            ( u < o || u === o && i++ < this._foldingRangesLimit ) && ( e[ a ] = this._startIndexes[ n ], t[ a ] = this._endIndexes[ n ], s[ a ] = this._types[ n ], a++ )
          }
          return new f( e, t, s )
        }, e;
      } )();

      function B( e, t ) {
        for ( var n = e.sort( ( ( e, t ) => {
            let n = e.start - t.start;
            return 0 === n && ( n = e.rank - t.rank ), n
          } ) ), i = new V( t ), o = null, r = [], s = 0, a = n; s < a.length; s++ ) {
          const u = a[ s ];
          if ( o ) {
            if ( u.start > o.start )
              if ( u.end <= o.end ) r.push( o ), o = u, i.add( u.start, u.end, u.kind && u.kind.value, r.length );
              else {
                if ( u.start > o.end ) {
                  do {
                    o = r.pop()
                  } while ( o && u.start > o.end );
                  o && r.push( o ), o = u
                }
                i.add( u.start, u.end, u.kind && u.kind.value, r.length )
              }
          } else o = u, i.add( u.start, u.end, u.kind && u.kind.value, r.length )
        }
        return i.toIndentRanges()
      }
      const H = "init",
        z = ( () => {
          function e( e, t, n, i ) {
            if ( this.editorModel = e, this.id = H, t.length ) {
              this.decorationIds = e.deltaDecorations( [], t.map( ( t => {
                return {
                  range: {
                    startLineNumber: t.startLineNumber,
                    startColumn: 0,
                    endLineNumber: t.endLineNumber,
                    endColumn: e.getLineLength( t.endLineNumber )
                  },
                  options: {
                    stickiness: C.h.NeverGrowsWhenTypingAtEdges
                  }
                }
              } ) ) ), this.timeout = setTimeout( n, i )
            }
          }
          return e.prototype.dispose = function () {
            this.decorationIds && ( this.editorModel.deltaDecorations( this.decorationIds, [] ), this.decorationIds = void 0 ), "number" === typeof this.timeout && ( clearTimeout( this.timeout ), this.timeout = void 0 )
          }, e.prototype.compute = function ( e ) {
            const t = [];
            if ( this.decorationIds )
              for ( let n = 0, i = this.decorationIds; n < i.length; n++ ) {
                const o = i[ n ],
                  r = this.editorModel.getDecorationRange( o );
                r && t.push( {
                  start: r.startLineNumber,
                  end: r.endLineNumber,
                  rank: 1
                } )
              }
            return l.b.as( B( t, Number.MAX_VALUE ) )
          }, e;
        } )();
      n.d( t, "ID", ( () => {
        return K
      } ) ), n.d( t, "FoldingController", ( () => {
        return q
      } ) );
      const U = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var K = "editor.contrib.folding";
      var q = ( () => {
        function e( e ) {
          const t = this;
          this.editor = e, this._isEnabled = this.editor.getConfiguration().contribInfo.folding, this._autoHideFoldingControls = "mouseover" === this.editor.getConfiguration().contribInfo.showFoldingControls, this._useFoldingProviders = "indentation" !== this.editor.getConfiguration().contribInfo.foldingStrategy, this.globalToDispose = [], this.localToDispose = [], this.foldingDecorationProvider = new S( e ), this.foldingDecorationProvider.autoHideFoldingControls = this._autoHideFoldingControls, this.globalToDispose.push( this.editor.onDidChangeModel( ( () => {
            return t.onModelChanged()
          } ) ) ), this.globalToDispose.push( R.l.onDidChange( ( () => {
            return t.onFoldingStrategyChanged()
          } ) ) ), this.globalToDispose.push( this.editor.onDidChangeConfiguration( ( e => {
            if ( e.contribInfo ) {
              const n = t._isEnabled;
              t._isEnabled = t.editor.getConfiguration().contribInfo.folding, n !== t._isEnabled && t.onModelChanged();
              const i = t._autoHideFoldingControls;
              t._autoHideFoldingControls = "mouseover" === t.editor.getConfiguration().contribInfo.showFoldingControls, i !== t._autoHideFoldingControls && ( t.foldingDecorationProvider.autoHideFoldingControls = t._autoHideFoldingControls, t.onModelContentChanged() );
              const o = t._useFoldingProviders;
              t._useFoldingProviders = "indentation" !== t.editor.getConfiguration().contribInfo.foldingStrategy, o !== t._useFoldingProviders && t.onFoldingStrategyChanged()
            }
          } ) ) ), this.globalToDispose.push( {
            dispose() {
              return Object( u.d )( t.localToDispose )
            }
          } ), this.onModelChanged()
        }
        return e.get = e => {
          return e.getContribution( K )
        }, e.prototype.getId = () => {
          return K
        }, e.prototype.dispose = function () {
          this.globalToDispose = Object( u.d )( this.globalToDispose )
        }, e.prototype.saveViewState = function () {
          const e = this.editor.getModel();
          if ( !e || !this._isEnabled || e.isTooLargeForTokenization() ) return {};
          if ( this.foldingModel ) {
            const t = this.foldingModel.isInitialized ? this.foldingModel.getMemento() : this.hiddenRangeModel.getMemento(),
              n = this.rangeProvider ? this.rangeProvider.id : void 0;
            return {
              collapsedRegions: t,
              lineCount: e.getLineCount(),
              provider: n
            }
          }
        }, e.prototype.restoreViewState = function ( e ) {
          const t = this.editor.getModel();
          t && this._isEnabled && !t.isTooLargeForTokenization() && e && e.collapsedRegions && e.lineCount === t.getLineCount() && ( e.provider !== W && e.provider !== H || ( this.foldingStateMemento = e ), this.hiddenRangeModel.applyMemento( e.collapsedRegions ) && this.getFoldingModel().then( ( t => {
            t && t.applyMemento( e.collapsedRegions )
          } ) ).done( void 0, P.e ) )
        }, e.prototype.onModelChanged = function () {
          const e = this;
          this.localToDispose = Object( u.d )( this.localToDispose );
          const t = this.editor.getModel();
          this._isEnabled && t && !t.isTooLargeForTokenization() && ( this.foldingModel = new m( t, this.foldingDecorationProvider ), this.localToDispose.push( this.foldingModel ), this.hiddenRangeModel = new N( this.foldingModel ), this.localToDispose.push( this.hiddenRangeModel ), this.localToDispose.push( this.hiddenRangeModel.onDidChange( ( t => {
            return e.onHiddenRangesChanges( t )
          } ) ) ), this.updateScheduler = new s.a( 200 ), this.cursorChangedScheduler = new s.c( ( () => {
            return e.revealCursor()
          } ), 200 ), this.localToDispose.push( this.cursorChangedScheduler ), this.localToDispose.push( this.editor.onDidChangeModelLanguageConfiguration( ( t => {
            return e.onModelContentChanged()
          } ) ) ), this.localToDispose.push( this.editor.onDidChangeModelContent( ( t => {
            return e.onModelContentChanged()
          } ) ) ), this.localToDispose.push( this.editor.onDidChangeCursorPosition( ( t => {
            return e.onCursorPositionChanged()
          } ) ) ), this.localToDispose.push( this.editor.onMouseDown( ( t => {
            return e.onEditorMouseDown( t )
          } ) ) ), this.localToDispose.push( this.editor.onMouseUp( ( t => {
            return e.onEditorMouseUp( t )
          } ) ) ), this.localToDispose.push( {
            dispose() {
              e.foldingRegionPromise && ( e.foldingRegionPromise.cancel(), e.foldingRegionPromise = null ), e.updateScheduler.cancel(), e.updateScheduler = null, e.foldingModel = null, e.foldingModelPromise = null, e.hiddenRangeModel = null, e.cursorChangedScheduler = null, e.foldingStateMemento = null, e.rangeProvider && e.rangeProvider.dispose(), e.rangeProvider = null
            }
          } ), this.onModelContentChanged() )
        }, e.prototype.onFoldingStrategyChanged = function () {
          this.rangeProvider && this.rangeProvider.dispose(), this.rangeProvider = null, this.onModelContentChanged()
        }, e.prototype.getRangeProvider = function ( e ) {
          const t = this;
          if ( this.rangeProvider ) return this.rangeProvider;
          if ( this.rangeProvider = new M( e ), this._useFoldingProviders ) {
            const n = R.l.ordered( this.foldingModel.textModel );
            if ( 0 === n.length && this.foldingStateMemento ) return this.rangeProvider = new z( e, this.foldingStateMemento.collapsedRegions, ( () => {
              t.foldingStateMemento = null, t.onFoldingStrategyChanged()
            } ), 3e4 ), this.rangeProvider;
            n.length > 0 && ( this.rangeProvider = new j( e, n ) )
          }
          return this.foldingStateMemento = null, this.rangeProvider
        }, e.prototype.getFoldingModel = function () {
          return this.foldingModelPromise
        }, e.prototype.onModelContentChanged = function () {
          const e = this;
          this.updateScheduler && ( this.foldingRegionPromise && ( this.foldingRegionPromise.cancel(), this.foldingRegionPromise = null ), this.foldingModelPromise = this.updateScheduler.trigger( ( () => {
            if ( !e.foldingModel ) return null;
            const t = e.foldingRegionPromise = Object( s.i )( ( t => {
              return e.getRangeProvider( e.foldingModel.textModel ).compute( t )
            } ) );
            return l.b.wrap( t.then( ( n => {
              if ( n && t === e.foldingRegionPromise ) {
                const i = e.editor.getSelections(),
                  o = i ? i.map( ( e => {
                    return e.startLineNumber
                  } ) ) : [];
                e.foldingModel.update( n, o )
              }
              return e.foldingModel
            } ) ) );
          } ) ) )
        }, e.prototype.onHiddenRangesChanges = function ( e ) {
          if ( e.length ) {
            const t = this.editor.getSelections();
            t && this.hiddenRangeModel.adjustSelections( t ) && this.editor.setSelections( t )
          }
          this.editor.setHiddenAreas( e )
        }, e.prototype.onCursorPositionChanged = function () {
          this.hiddenRangeModel.hasRanges() && this.cursorChangedScheduler.schedule()
        }, e.prototype.revealCursor = function () {
          const e = this;
          this.getFoldingModel().then( ( t => {
            if ( t ) {
              const n = e.editor.getSelections();
              if ( n && n.length > 0 ) {
                for ( var i = [], o = n => {
                    const o = n.selectionStartLineNumber;
                    e.hiddenRangeModel.isHidden( o ) && i.push.apply( i, t.getAllRegionsAtLine( o, ( e => {
                      return e.isCollapsed && o > e.startLineNumber
                    } ) ) )
                  }, r = 0, s = n; r < s.length; r++ ) {
                  o( s[ r ] )
                }
                i.length && ( t.toggleCollapseState( i ), e.reveal( n[ 0 ].getPosition() ) )
              }
            }
          } ) ).done( void 0, P.e )
        }, e.prototype.onEditorMouseDown = function ( e ) {
          this.mouseDownInfo = null;
          const t = e.target.range;
          if ( this.hiddenRangeModel && t && ( e.event.leftButton || e.event.middleButton ) ) {
            let n = !1;
            switch ( e.target.type ) {
              case d.b.GUTTER_LINE_DECORATIONS:
                const i = e.target.detail;
                if ( i.offsetX - i.glyphMarginWidth - i.lineNumbersWidth - i.glyphMarginLeft <= 10 ) return;
                n = !0;
                break;
              case d.b.CONTENT_EMPTY:
                if ( this.hiddenRangeModel.hasRanges() )
                  if ( !e.target.detail.isAfterLines ) break;
                return;
              case d.b.CONTENT_TEXT:
                if ( this.hiddenRangeModel.hasRanges() ) {
                  const o = this.editor.getModel();
                  if ( o && t.startColumn === o.getLineMaxColumn( t.startLineNumber ) ) break
                }
                return;
              default:
                return
            }
            this.mouseDownInfo = {
              lineNumber: t.startLineNumber,
              iconClicked: n
            }
          }
        }, e.prototype.onEditorMouseUp = function ( e ) {
          const t = this;
          if ( this.mouseDownInfo ) {
            const n = this.mouseDownInfo.lineNumber,
              i = this.mouseDownInfo.iconClicked,
              o = e.target.range;
            if ( o && o.startLineNumber === n ) {
              if ( i ) {
                if ( e.target.type !== d.b.GUTTER_LINE_DECORATIONS ) return
              } else {
                const r = this.editor.getModel();
                if ( o.startColumn !== r.getLineMaxColumn( n ) ) return
              }
              this.getFoldingModel().then( ( o => {
                if ( o ) {
                  const r = o.getRegionAtLine( n );
                  if ( r && r.startLineNumber === n ) {
                    const s = r.isCollapsed;
                    if ( i || s ) {
                      const a = [ r ];
                      ( e.event.middleButton || e.event.shiftKey ) && a.push.apply( a, o.getRegionsInside( r, ( e => {
                        return e.isCollapsed === s
                      } ) ) ), o.toggleCollapseState( a ), t.reveal( {
                        lineNumber: n,
                        column: 1
                      } )
                    }
                  }
                }
              } ) ).done( void 0, P.e )
            }
          }
        }, e.prototype.reveal = function ( e ) {
          this.editor.revealPositionInCenterIfOutsideViewport( e, 0 )
        }, e;
      } )();
      const G = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return U( t, e ), t.prototype.runEditorCommand = function ( e, t, n ) {
          const i = this,
            o = q.get( t );
          if ( o ) {
            const r = o.getFoldingModel();
            return r ? ( this.reportTelemetry( e, t ), r.then( ( e => {
              e && ( i.invoke( o, e, t, n ), o.reveal( t.getSelection().getStartPosition() ) )
            } ) ) ) : void 0;
          }
        }, t.prototype.getSelectedLines = e => {
          const t = e.getSelections();
          return t ? t.map( ( e => {
            return e.startLineNumber
          } ) ) : [];
        }, t.prototype.getLineNumbers = function ( e, t ) {
          return e && e.selectionLines ? e.selectionLines.map( ( e => {
            return e + 1
          } ) ) : this.getSelectedLines( t );
        }, t.prototype.run = ( e, t ) => {}, t;
      } )( c.b );

      function Y( e ) {
        if ( !o.i( e ) ) {
          if ( !o.g( e ) ) return !1;
          const t = e;
          if ( !o.i( t.levels ) && !o.f( t.levels ) ) return !1;
          if ( !o.i( t.direction ) && !o.h( t.direction ) ) return !1;
          if ( !o.i( t.selectionLines ) && ( !o.b( t.selectionLines ) || !t.selectionLines.every( o.f ) ) ) return !1
        }
        return !0
      }
      const X = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.unfold",
              label: i.a( "unfoldAction.label", "Unfold" ),
              alias: "Unfold",
              precondition: null,
              kbOpts: {
                kbExpr: O.a.editorTextFocus,
                primary: 3161,
                mac: {
                  primary: 2649
                },
                weight: 100
              },
              description: {
                description: "Unfold the content in the editor",
                args: [ {
                  name: "Unfold editor argument",
                  description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t* 'levels': Number of levels to unfold. If not set, defaults to 1.\n\t\t\t\t\t\t* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.\n\t\t\t\t\t\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t",
                  constraint: Y
                } ]
              }
            } ) || this
          }
          return U( t, e ), t.prototype.invoke = function ( e, t, n, i ) {
            const o = i && i.levels || 1,
              r = this.getLineNumbers( i, n );
            i && "up" === i.direction ? v( t, !1, o, r ) : _( t, !1, o, r )
          }, t;
        } )( G ),
        $ = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.unfoldRecursively",
              label: i.a( "unFoldRecursivelyAction.label", "Unfold Recursively" ),
              alias: "Unfold Recursively",
              precondition: null,
              kbOpts: {
                kbExpr: O.a.editorTextFocus,
                primary: Object( a.a )( 2089, 2137 ),
                weight: 100
              }
            } ) || this
          }
          return U( t, e ), t.prototype.invoke = function ( e, t, n, i ) {
            _( t, !1, Number.MAX_VALUE, this.getSelectedLines( n ) )
          }, t
        } )( G ),
        Z = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.fold",
              label: i.a( "foldAction.label", "Fold" ),
              alias: "Fold",
              precondition: null,
              kbOpts: {
                kbExpr: O.a.editorTextFocus,
                primary: 3159,
                mac: {
                  primary: 2647
                },
                weight: 100
              },
              description: {
                description: "Fold the content in the editor",
                args: [ {
                  name: "Fold editor argument",
                  description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'levels': Number of levels to fold. Defaults to 1.\n\t\t\t\t\t\t\t* 'direction': If 'up', folds given number of levels up otherwise folds down.\n\t\t\t\t\t\t\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t",
                  constraint: Y
                } ]
              }
            } ) || this
          }
          return U( t, e ), t.prototype.invoke = function ( e, t, n, i ) {
            const o = i && i.levels || 1,
              r = this.getLineNumbers( i, n );
            i && "up" === i.direction ? v( t, !0, o, r ) : _( t, !0, o, r )
          }, t;
        } )( G ),
        Q = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.foldRecursively",
              label: i.a( "foldRecursivelyAction.label", "Fold Recursively" ),
              alias: "Fold Recursively",
              precondition: null,
              kbOpts: {
                kbExpr: O.a.editorTextFocus,
                primary: Object( a.a )( 2089, 2135 ),
                weight: 100
              }
            } ) || this
          }
          return U( t, e ), t.prototype.invoke = function ( e, t, n ) {
            const i = this.getSelectedLines( n );
            _( t, !0, Number.MAX_VALUE, i )
          }, t;
        } )( G ),
        J = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.foldAllBlockComments",
              label: i.a( "foldAllBlockComments.label", "Fold All Block Comments" ),
              alias: "Fold All Block Comments",
              precondition: null,
              kbOpts: {
                kbExpr: O.a.editorTextFocus,
                primary: Object( a.a )( 2089, 2133 ),
                weight: 100
              }
            } ) || this
          }
          return U( t, e ), t.prototype.invoke = ( e, t, n ) => {
            if ( t.regions.hasTypes() ) b( t, R.k.Comment.value, !0 );
            else {
              const i = k.a.getComments( n.getModel().getLanguageIdentifier().id );
              if ( i && i.blockCommentStartToken ) y( t, new RegExp( "^\\s*" + Object( r.escapeRegExpCharacters )( i.blockCommentStartToken ) ), !0 )
            }
          }, t;
        } )( G ),
        ee = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.foldAllMarkerRegions",
              label: i.a( "foldAllMarkerRegions.label", "Fold All Regions" ),
              alias: "Fold All Regions",
              precondition: null,
              kbOpts: {
                kbExpr: O.a.editorTextFocus,
                primary: Object( a.a )( 2089, 2077 ),
                weight: 100
              }
            } ) || this
          }
          return U( t, e ), t.prototype.invoke = ( e, t, n ) => {
            if ( t.regions.hasTypes() ) b( t, R.k.Region.value, !0 );
            else {
              const i = k.a.getFoldingRules( n.getModel().getLanguageIdentifier().id );
              if ( i && i.markers && i.markers.start ) y( t, new RegExp( i.markers.start ), !0 )
            }
          }, t;
        } )( G ),
        te = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.unfoldAllMarkerRegions",
              label: i.a( "unfoldAllMarkerRegions.label", "Unfold All Regions" ),
              alias: "Unfold All Regions",
              precondition: null,
              kbOpts: {
                kbExpr: O.a.editorTextFocus,
                primary: Object( a.a )( 2089, 2078 ),
                weight: 100
              }
            } ) || this
          }
          return U( t, e ), t.prototype.invoke = ( e, t, n ) => {
            if ( t.regions.hasTypes() ) b( t, R.k.Region.value, !1 );
            else {
              const i = k.a.getFoldingRules( n.getModel().getLanguageIdentifier().id );
              if ( i && i.markers && i.markers.start ) y( t, new RegExp( i.markers.start ), !1 )
            }
          }, t;
        } )( G ),
        ne = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.foldAll",
              label: i.a( "foldAllAction.label", "Fold All" ),
              alias: "Fold All",
              precondition: null,
              kbOpts: {
                kbExpr: O.a.editorTextFocus,
                primary: Object( a.a )( 2089, 2069 ),
                weight: 100
              }
            } ) || this
          }
          return U( t, e ), t.prototype.invoke = ( e, t, n ) => {
            _( t, !0 )
          }, t;
        } )( G ),
        ie = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.unfoldAll",
              label: i.a( "unfoldAllAction.label", "Unfold All" ),
              alias: "Unfold All",
              precondition: null,
              kbOpts: {
                kbExpr: O.a.editorTextFocus,
                primary: Object( a.a )( 2089, 2088 ),
                weight: 100
              }
            } ) || this
          }
          return U( t, e ), t.prototype.invoke = ( e, t, n ) => {
            _( t, !1 )
          }, t;
        } )( G ),
        oe = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return U( t, e ), t.prototype.getFoldingLevel = function () {
            return parseInt( this.id.substr( t.ID_PREFIX.length ) )
          }, t.prototype.invoke = function ( e, t, n ) {
            !( ( e, t, n, i ) => {
              const o = e.getRegionsInside( null, ( ( e, o ) => {
                return o === t && e.isCollapsed !== n && !i.some( ( t => {
                  return e.containsLine( t )
                } ) );
              } ) );
              e.toggleCollapseState( o )
            } )( t, this.getFoldingLevel(), !0, this.getSelectedLines( n ) )
          }, t.ID_PREFIX = "editor.foldLevel", t.ID = e => {
            return t.ID_PREFIX + e
          }, t;
        } )( G );
      Object( c.h )( q ), Object( c.f )( X ), Object( c.f )( $ ), Object( c.f )( Z ), Object( c.f )( Q ), Object( c.f )( ne ), Object( c.f )( ie ), Object( c.f )( J ), Object( c.f )( ee ), Object( c.f )( te );
      for ( let re = 1; re <= 7; re++ ) Object( c.i )( new oe( {
        id: oe.ID( re ),
        label: i.a( "foldLevelAction.label", "Fold Level {0}", re ),
        alias: "Fold Level " + re,
        precondition: null,
        kbOpts: {
          kbExpr: O.a.editorTextFocus,
          primary: Object( a.a )( 2089, 2048 | 21 + re ),
          weight: 100
        }
      } ) )
    },
    e39c( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "golang",
        extensions: [ ".go" ],
        aliases: [ "Go", "go", "golang" ],
        loader() {
          return o.Promise.wrap( n.e( 266 ).then( n.bind( null, "KeE3" ) ) )
        }
      } )
    },
    "eA/6": function ( e, t, n ) {
      "use strict";
      n( "1YUG" ), n( "nB0o" ), n( "SmQN" ), n( "0Lb2" ), n( "bk7F" ), n( "KTWA" ), n( "ba9Q" ), n( "w29/" ), n( "d6R0" ), n( "kqbb" ), n( "n01l" ), n( "fD5p" ), n( "5RaG" ), n( "/RFl" ), n( "oQaD" ), n( "dgXF" ), n( "bfR1" ), n( "cIJc" ), n( "n3JV" ), n( "gh2A" ), n( "lY/7" ), n( "rugR" ), n( "GvMn" ), n( "dH+W" ), n( "2ESN" ), n( "8XyJ" ), n( "WwIK" ), n( "CxEt" ), n( "TC2m" ), n( "Q631" ), n( "10Fh" ), n( "tXSY" ), n( "ep4t" ), n( "k7pc" ), n( "XtJs" ), n( "s7Km" ), n( "LUcL" )
    },
    eC1c( e, t, n ) {},
    eLzo( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) ), n.d( t, "c", ( () => {
        return a
      } ) ), n.d( t, "d", ( () => {
        return l
      } ) );
      const i = n( "6OMU" );
      var o = ( () => {
        function e( e ) {
          void 0 === e && ( e = "" ), this.value = e
        }
        return e.prototype.appendText = function ( e ) {
          return this.value += e.replace( /[\\`*_{}[\]()#+\-.!]/g, "\\$&" ), this
        }, e.prototype.appendMarkdown = function ( e ) {
          return this.value += e, this
        }, e.prototype.appendCodeblock = function ( e, t ) {
          return this.value += "\n```", this.value += e, this.value += "\n", this.value += t, this.value += "\n```\n", this
        }, e
      } )();

      function r( e ) {
        return s( e ) ? !e.value : !Array.isArray( e ) || e.every( r )
      }

      function s( e ) {
        return e instanceof o || !( !e || "object" !== typeof e ) && ( "string" === typeof e.value && ( "boolean" === typeof e.isTrusted || void 0 === e.isTrusted ) )
      }

      function a( e, t ) {
        return !e && !t || !( !e || !t ) && ( Array.isArray( e ) && Array.isArray( t ) ? Object( i.e )( e, t, u ) : !( !s( e ) || !s( t ) ) && u( e, t ) )
      }

      function u( e, t ) {
        return e === t || !( !e || !t ) && ( e.value === t.value && e.isTrusted === t.isTrusted )
      }

      function l( e ) {
        return e ? e.replace( /\\([\\`*_{}[\]()#+\-.!])/g, "$1" ) : e
      }
    },
    ehFp( e, t, n ) {},
    eizg( e, t, n ) {},
    ep4t( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "/cxE" ),
        r = n( "6OMU" ),
        s = n( "pmY6" ),
        a = n( "Cg/j" ),
        u = n( "T8No" ),
        l = n( "nnTU" ),
        c = n( "wQH0" ),
        d = n( "sswD" ),
        h = n( "OBOq" ),
        p = n( "0/Sa" ),
        f = n( "aokT" ),
        g = n( "uACm" ),
        m = n( "tXSY" ),
        _ = n( "QVNv" ),
        v = n( "X+cX" ),
        y = n( "MI8n" ),
        b = n( "QDVR" ),
        C = n( "uzpd" ),
        w = n( "gCVg" ),
        S = n( "twdY" ),
        O = n( "fpMC" ),
        L = n( "/UlZ" ),
        x = ( () => {
          function e( t, n, i, o ) {
            void 0 === o && ( o = L.a.contribInfo.suggest ), this._snippetCompareFn = e._compareCompletionItems, this._items = t, this._column = n, this._options = o, this._refilterKind = 1, this._lineContext = i, "top" === o.snippets ? this._snippetCompareFn = e._compareCompletionItemsSnippetsUp : "bottom" === o.snippets && ( this._snippetCompareFn = e._compareCompletionItemsSnippetsDown )
          }
          return e.prototype.dispose = function () {
            for ( let e = new Set, t = 0, n = this._items; t < n.length; t++ ) {
              const i = n[ t ].container;
              e.has( i ) || ( e.add( i ), Object( s.e )( i ) && i.dispose() )
            }
          }, Object.defineProperty( e.prototype, "lineContext", {
            get() {
              return this._lineContext
            },
            set( e ) {
              this._lineContext.leadingLineContent === e.leadingLineContent && this._lineContext.characterCountDelta === e.characterCountDelta || ( this._refilterKind = this._lineContext.characterCountDelta < e.characterCountDelta && this._filteredItems ? 2 : 1, this._lineContext = e )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "items", {
            get() {
              return this._ensureCachedState(), this._filteredItems
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "incomplete", {
            get() {
              return this._ensureCachedState(), this._isIncomplete
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.adopt = function ( e ) {
            for ( var t = new Array, n = 0; n < this._items.length; ) e.has( this._items[ n ].support ) ? n++ : ( t.push( this._items[ n ] ), this._items[ n ] = this._items[ this._items.length - 1 ], this._items.pop() );
            return this._refilterKind = 1, t
          }, Object.defineProperty( e.prototype, "stats", {
            get() {
              return this._ensureCachedState(), this._stats
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype._ensureCachedState = function () {
            0 !== this._refilterKind && this._createCachedState()
          }, e.prototype._createCachedState = function () {
            this._isIncomplete = new Set, this._stats = {
              suggestionCount: 0,
              snippetCount: 0,
              textCount: 0
            };
            for ( var e = this._lineContext, t = e.leadingLineContent, n = e.characterCountDelta, i = "", o = 1 === this._refilterKind ? this._items : this._filteredItems, r = [], s = !this._options.filterGraceful || o.length > 2e3 ? O.c : O.d, a = 0; a < o.length; a++ ) {
              const u = o[ a ],
                l = u.suggestion;
              u.container.incomplete && this._isIncomplete.add( u.support );
              const c = l.overwriteBefore + n - ( u.position.column - this._column );
              if ( i.length !== c && ( i = 0 === c ? "" : t.slice( -c ) ), u.word = i, 0 === c ) u.score = -100, u.matches = void 0;
              else if ( "string" === typeof l.filterText ) {
                if ( !( d = s( i, l.filterText, l.overwriteBefore ) ) ) continue;
                u.score = d[ 0 ], u.matches = ( Object( O.c )( i, l.label ) || Object( O.a )( i, l.label ) )[ 1 ]
              } else {
                var d;
                if ( !( d = s( i, l.label, l.overwriteBefore ) ) ) continue;
                u.score = d[ 0 ], u.matches = d[ 1 ]
              }
              switch ( u.idx = a, r.push( u ), this._stats.suggestionCount++, l.type ) {
                case "snippet":
                  this._stats.snippetCount++;
                  break;
                case "text":
                  this._stats.textCount++
              }
            }
            this._filteredItems = r.sort( this._snippetCompareFn ), this._refilterKind = 0
          }, e._compareCompletionItems = ( e, t ) => {
            return e.score > t.score ? -1 : e.score < t.score ? 1 : e.idx < t.idx ? -1 : e.idx > t.idx ? 1 : 0
          }, e._compareCompletionItemsSnippetsDown = ( t, n ) => {
            if ( t.suggestion.type !== n.suggestion.type ) {
              if ( "snippet" === t.suggestion.type ) return 1;
              if ( "snippet" === n.suggestion.type ) return -1
            }
            return e._compareCompletionItems( t, n )
          }, e._compareCompletionItemsSnippetsUp = ( t, n ) => {
            if ( t.suggestion.type !== n.suggestion.type ) {
              if ( "snippet" === t.suggestion.type ) return -1;
              if ( "snippet" === n.suggestion.type ) return 1
            }
            return e._compareCompletionItems( t, n )
          }, e;
        } )(),
        N = ( () => {
          function e( e, t, n ) {
            this.leadingLineContent = e.getLineContent( t.lineNumber ).substr( 0, t.column - 1 ), this.leadingWord = e.getWordUntilPosition( t ), this.lineNumber = t.lineNumber, this.column = t.column, this.auto = n
          }
          return e.shouldAutoTrigger = e => {
            const t = e.getModel();
            if ( !t ) return !1;
            const n = e.getPosition();
            t.tokenizeIfCheap( n.lineNumber );
            const i = t.getWordAtPosition( n );
            return !!i && ( i.endColumn === n.column && !!isNaN( Number( i.word ) ) )
          }, e;
        } )(),
        E = ( () => {
          function e( e ) {
            const t = this;
            this._toDispose = [], this._triggerQuickSuggest = new v.f, this._triggerRefilter = new v.f, this._onDidCancel = new y.a, this._onDidTrigger = new y.a, this._onDidSuggest = new y.a, this.onDidCancel = this._onDidCancel.event, this.onDidTrigger = this._onDidTrigger.event, this.onDidSuggest = this._onDidSuggest.event, this._editor = e, this._state = 0, this._requestPromise = null, this._completionModel = null, this._context = null, this._currentSelection = this._editor.getSelection() || new w.a( 1, 1, 1, 1 ), this._toDispose.push( this._editor.onDidChangeModel( ( () => {
              t._updateTriggerCharacters(), t.cancel()
            } ) ) ), this._toDispose.push( this._editor.onDidChangeModelLanguage( ( () => {
              t._updateTriggerCharacters(), t.cancel()
            } ) ) ), this._toDispose.push( this._editor.onDidChangeConfiguration( ( () => {
              t._updateTriggerCharacters(), t._updateQuickSuggest()
            } ) ) ), this._toDispose.push( S.u.onDidChange( ( () => {
              t._updateTriggerCharacters(), t._updateActiveSuggestSession()
            } ) ) ), this._toDispose.push( this._editor.onDidChangeCursorSelection( ( e => {
              t._onCursorChange( e )
            } ) ) ), this._toDispose.push( this._editor.onDidChangeModelContent( ( e => {
              t._refilterCompletionItems()
            } ) ) ), this._updateTriggerCharacters(), this._updateQuickSuggest()
          }
          return e.prototype.dispose = function () {
            Object( s.d )( [ this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerCharacterListener, this._triggerQuickSuggest, this._triggerRefilter ] ), this._toDispose = Object( s.d )( this._toDispose ), Object( s.d )( this._completionModel ), this.cancel()
          }, e.prototype._updateQuickSuggest = function () {
            this._quickSuggestDelay = this._editor.getConfiguration().contribInfo.quickSuggestionsDelay, ( isNaN( this._quickSuggestDelay ) || !this._quickSuggestDelay && 0 !== this._quickSuggestDelay || this._quickSuggestDelay < 0 ) && ( this._quickSuggestDelay = 10 )
          }, e.prototype._updateTriggerCharacters = function () {
            const e = this;
            if ( Object( s.d )( this._triggerCharacterListener ), !this._editor.getConfiguration().readOnly && this._editor.getModel() && this._editor.getConfiguration().contribInfo.suggestOnTriggerCharacters ) {
              for ( var t = Object.create( null ), n = 0, i = S.u.all( this._editor.getModel() ); n < i.length; n++ ) {
                const o = i[ n ];
                if ( !Object( r.k )( o.triggerCharacters ) )
                  for ( let a = 0, u = o.triggerCharacters; a < u.length; a++ ) {
                    const l = u[ a ];
                    let c = t[ l ];
                    c || ( c = t[ l ] = new Set ).add( Object( _.b )() ), c.add( o )
                  }
              }
              this._triggerCharacterListener = this._editor.onDidType( ( n => {
                const i = n.charAt( n.length - 1 ),
                  o = t[ i ];
                if ( o ) {
                  const r = e._completionModel ? e._completionModel.adopt( o ) : void 0;
                  e.trigger( {
                    auto: !0,
                    triggerCharacter: i
                  }, Boolean( e._completionModel ), Object( b.d )( o ), r )
                }
              } ) )
            }
          }, Object.defineProperty( e.prototype, "state", {
            get() {
              return this._state
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.cancel = function ( e ) {
            void 0 === e && ( e = !1 ), this._triggerRefilter.cancel(), this._triggerQuickSuggest && this._triggerQuickSuggest.cancel(), this._requestPromise && ( this._requestPromise.cancel(), this._requestPromise = null ), this._state = 0, Object( s.d )( this._completionModel ), this._completionModel = null, this._context = null, this._onDidCancel.fire( {
              retrigger: e
            } )
          }, e.prototype._updateActiveSuggestSession = function () {
            0 !== this._state && ( S.u.has( this._editor.getModel() ) ? this.trigger( {
              auto: 2 === this._state
            }, !0 ) : this.cancel() )
          }, e.prototype._onCursorChange = function ( e ) {
            const t = this,
              n = this._currentSelection;
            if ( this._currentSelection = this._editor.getSelection(), !e.selection.isEmpty() || e.reason !== C.a.NotSet || "keyboard" !== e.source && "deleteLeft" !== e.source ) 0 !== this._state && this.cancel();
            else if ( S.u.has( this._editor.getModel() ) && this._editor.getModel() && 0 === this._state ) {
              if ( !1 === this._editor.getConfiguration().contribInfo.quickSuggestions ) return;
              if ( !n.containsRange( this._currentSelection ) && !n.getEndPosition().isBeforeOrEqual( this._currentSelection.getPosition() ) ) return;
              if ( this._editor.getConfiguration().contribInfo.suggest.snippetsPreventQuickSuggestions && m.SnippetController2.get( this._editor ).isInSnippet() ) return;
              this.cancel(), this._triggerQuickSuggest.cancelAndSet( ( () => {
                if ( N.shouldAutoTrigger( t._editor ) ) {
                  const e = t._editor.getModel(),
                    n = t._editor.getPosition();
                  if ( e ) {
                    const i = t._editor.getConfiguration().contribInfo.quickSuggestions;
                    if ( !1 !== i ) {
                      if ( !0 === i );
                      else {
                        e.tokenizeIfCheap( n.lineNumber );
                        const o = e.getLineTokens( n.lineNumber ),
                          r = o.getStandardTokenType( o.findTokenIndexAtOffset( Math.max( n.column - 1 - 1, 0 ) ) );
                        if ( !( i.other && 0 === r || i.comments && 1 === r || i.strings && 2 === r ) ) return
                      }
                      t.trigger( {
                        auto: !0
                      } )
                    }
                  }
                }
              } ), this._quickSuggestDelay )
            }
          }, e.prototype._refilterCompletionItems = function () {
            const e = this;
            if ( 0 !== this._state ) {
              const t = this._editor.getModel();
              t && this._triggerRefilter.cancelAndSet( ( () => {
                const n = e._editor.getPosition(),
                  i = new N( t, n, 2 === e._state );
                e._onNewContext( i )
              } ), 25 )
            }
          }, e.prototype.trigger = function ( e, t, n, i ) {
            const a = this;
            void 0 === t && ( t = !1 );
            const u = this._editor.getModel();
            if ( u ) {
              let l;
              const c = e.auto;
              const d = new N( u, this._editor.getPosition(), c );
              this.cancel( t ), this._state = c ? 2 : 1, this._onDidTrigger.fire( {
                auto: c
              } ), this._context = d, l = e.triggerCharacter ? {
                triggerKind: S.v.TriggerCharacter,
                triggerCharacter: e.triggerCharacter
              } : n && n.length ? {
                triggerKind: S.v.TriggerForIncompleteCompletions
              } : {
                triggerKind: S.v.Invoke
              }, this._requestPromise = Object( v.i )( ( e => {
                return Object( _.d )( u, a._editor.getPosition(), a._editor.getConfiguration().contribInfo.suggest.snippets, n, l, e )
              } ) ), this._requestPromise.then( ( e => {
                if ( a._requestPromise = null, 0 !== a._state ) {
                  const t = a._editor.getModel();
                  if ( t ) {
                    if ( !Object( r.k )( i ) ) {
                      const n = Object( _.c )( a._editor.getConfiguration().contribInfo.suggest.snippets );
                      e = e.concat( i ).sort( n )
                    }
                    const o = new N( t, a._editor.getPosition(), c );
                    Object( s.d )( a._completionModel ), a._completionModel = new x( e, a._context.column, {
                      leadingLineContent: o.leadingLineContent,
                      characterCountDelta: a._context ? o.column - a._context.column : 0
                    }, a._editor.getConfiguration().contribInfo.suggest ), a._onNewContext( o )
                  }
                }
              } ) ).catch( o.e )
            }
          }, e.prototype._onNewContext = function ( e ) {
            if ( this._context )
              if ( e.lineNumber === this._context.lineNumber ) {
                if ( e.leadingWord.startColumn < this._context.leadingWord.startColumn ) this.cancel();
                else if ( e.column < this._context.column ) e.leadingWord.word ? this.trigger( {
                  auto: this._context.auto
                }, !0 ) : this.cancel();
                else if ( this._completionModel )
                  if ( e.column > this._context.column && this._completionModel.incomplete.size > 0 && 0 !== e.leadingWord.word.length ) {
                    const t = this._completionModel.incomplete,
                      n = this._completionModel.adopt( t );
                    this.trigger( {
                      auto: 2 === this._state
                    }, !0, Object( b.d )( t ), n )
                  } else {
                    const i = this._completionModel.lineContext;
                    let o = !1;
                    if ( this._completionModel.lineContext = {
                        leadingLineContent: e.leadingLineContent,
                        characterCountDelta: e.column - this._context.column
                      }, 0 === this._completionModel.items.length ) {
                      if ( N.shouldAutoTrigger( this._editor ) && this._context.leadingWord.endColumn < e.leadingWord.startColumn ) return void this.trigger( {
                        auto: this._context.auto
                      }, !0 );
                      if ( this._context.auto ) return void this.cancel();
                      if ( this._completionModel.lineContext = i, ( o = this._completionModel.items.length > 0 ) && 0 === e.leadingWord.word.length ) return void this.cancel()
                    }
                    this._onDidSuggest.fire( {
                      completionModel: this._completionModel,
                      auto: this._context.auto,
                      isFrozen: o
                    } )
                  }
              } else this.cancel()
          }, e;
        } )(),
        k = ( n( "CClx" ), n( "N0LK" ) ),
        I = n( "EffR" ),
        D = n( "7lZ/" ),
        M = ( n( "4rho" ), n( "746U" ) ),
        T = n( "ZCR3" ),
        R = n( "MNsG" ),
        P = n( "pg8w" ),
        A = n( "uDWl" ),
        F = n( "4y0V" ),
        W = n( "qj0h" ),
        j = n( "GJhM" ),
        V = n( "QuOb" );

      function B( e, t ) {
        if ( e.start >= t.end || t.start >= e.end ) return {
          start: 0,
          end: 0
        };
        const n = Math.max( e.start, t.start ),
          i = Math.min( e.end, t.end );
        return i - n <= 0 ? {
          start: 0,
          end: 0
        } : {
          start: n,
          end: i
        }
      }

      function H( e ) {
        return e.end - e.start <= 0
      }

      function z( e, t ) {
        const n = [],
          i = {
            start: e.start,
            end: Math.min( t.start, e.end )
          },
          o = {
            start: Math.max( t.end, e.start ),
            end: e.end
          };
        return H( i ) || n.push( i ), H( o ) || n.push( o ), n
      }

      function U( e, t ) {
        for ( var n = [], i = 0, o = t; i < o.length; i++ ) {
          const r = o[ i ];
          if ( !( e.start >= r.range.end ) ) {
            if ( e.end < r.range.start ) break;
            const s = B( e, r.range );
            H( s ) || n.push( {
              range: s,
              size: r.size
            } )
          }
        }
        return n
      }

      function K( e, t ) {
        return {
          start: e.start + t,
          end: e.end + t
        }
      }

      function q() {
        for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
        return ( e => {
          for ( var t = [], n = null, i = 0, o = e; i < o.length; i++ ) {
            const r = o[ i ],
              s = r.range.start,
              a = r.range.end,
              u = r.size;
            n && u === n.size ? n.range.end = a : ( n = {
              range: {
                start: s,
                end: a
              },
              size: u
            }, t.push( n ) )
          }
          return t
        } )( e.reduce( ( ( e, t ) => {
          return e.concat( t )
        } ), [] ) );
      }
      const G = ( () => {
        function e() {
          this.groups = [], this._size = 0
        }
        return e.prototype.splice = function ( e, t ) {
          for ( var n = [], i = 2; i < arguments.length; i++ ) n[ i - 2 ] = arguments[ i ];
          const o = n.length - t,
            r = U( {
              start: 0,
              end: e
            }, this.groups ),
            s = U( {
              start: e + t,
              end: Number.POSITIVE_INFINITY
            }, this.groups ).map( ( e => {
              return {
                range: K( e.range, o ),
                size: e.size
              }
            } ) ),
            a = n.map( ( ( t, n ) => {
              return {
                range: {
                  start: e + n,
                  end: e + n + 1
                },
                size: t.size
              }
            } ) );
          this.groups = q( r, a, s ), this._size = this.groups.reduce( ( ( e, t ) => {
            return e + t.size * ( t.range.end - t.range.start )
          } ), 0 )
        }, Object.defineProperty( e.prototype, "count", {
          get() {
            const e = this.groups.length;
            return e ? this.groups[ e - 1 ].range.end : 0
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "size", {
          get() {
            return this._size
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.indexAt = function ( e ) {
          if ( e < 0 ) return -1;
          for ( var t = 0, n = 0, i = 0, o = this.groups; i < o.length; i++ ) {
            const r = o[ i ],
              s = r.range.end - r.range.start,
              a = n + s * r.size;
            if ( e < a ) return t + Math.floor( ( e - n ) / r.size );
            t += s, n = a
          }
          return t
        }, e.prototype.indexAfter = function ( e ) {
          return Math.min( this.indexAt( e ) + 1, this.count )
        }, e.prototype.positionAt = function ( e ) {
          if ( e < 0 ) return -1;
          for ( let t = 0, n = 0, i = 0, o = this.groups; i < o.length; i++ ) {
            const r = o[ i ],
              s = r.range.end - r.range.start,
              a = n + s;
            if ( e < a ) return t + ( e - n ) * r.size;
            t += s * r.size, n = a
          }
          return -1
        }, e.prototype.dispose = function () {
          this.groups = null
        }, e;
      } )();
      const Y = ( () => {
          function e( e ) {
            this.renderers = e, this.cache = new Map
          }
          return e.prototype.alloc = function ( e ) {
            let t = this.getTemplateCache( e ).pop();
            if ( !t ) {
              const n = Object( I.a )( ".monaco-list-row" );
              t = {
                domNode: n,
                templateId: e,
                templateData: this.renderers.get( e ).renderTemplate( n )
              }
            }
            return t
          }, e.prototype.release = function ( e ) {
            e && this.releaseRow( e )
          }, e.prototype.releaseRow = function ( e ) {
            const t = e.domNode,
              n = e.templateId;
            Object( I.G )( t, "scrolling" ), ( e => {
              try {
                e.parentElement.removeChild( e )
              } catch ( t ) {}
            } )( t ), this.getTemplateCache( n ).push( e )
          }, e.prototype.getTemplateCache = function ( e ) {
            let t = this.cache.get( e );
            return t || ( t = [], this.cache.set( e, t ) ), t
          }, e.prototype.garbageCollect = function () {
            const e = this;
            this.renderers && ( this.cache.forEach( ( ( t, n ) => {
              for ( let i = 0, o = t; i < o.length; i++ ) {
                const r = o[ i ];
                e.renderers.get( n ).disposeTemplate( r.templateData ), r.domNode = null, r.templateData = null
              }
            } ) ), this.cache.clear() )
          }, e.prototype.dispose = function () {
            this.garbageCollect(), this.cache.clear(), this.renderers = null
          }, e;
        } )(),
        X = n( "D3Dy" ),
        $ = n( "XSiN" ),
        Z = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        };
      const Q = {
          useShadows: !0,
          verticalScrollMode: V.b.Auto
        },
        J = ( () => {
          function e( e, t, n, i ) {
            void 0 === i && ( i = Q ), this.virtualDelegate = t, this.renderers = new Map, this.splicing = !1, this.items = [], this.itemId = 0, this.rangeMap = new G;
            for ( let o = 0, r = n; o < r.length; o++ ) {
              const s = r[ o ];
              this.renderers.set( s.templateId, s )
            }
            this.cache = new Y( this.renderers ), this.lastRenderTop = 0, this.lastRenderHeight = 0, this._domNode = document.createElement( "div" ), this._domNode.className = "monaco-list", this.rowsContainer = document.createElement( "div" ), this.rowsContainer.className = "monaco-list-rows", P.b.addTarget( this.rowsContainer ), this.scrollableElement = new j.b( this.rowsContainer, {
              alwaysConsumeMouseWheel: !0,
              horizontal: V.b.Hidden,
              vertical: Object( W.f )( i, ( e => {
                return e.verticalScrollMode
              } ), Q.verticalScrollMode ),
              useShadows: Object( W.f )( i, ( e => {
                return e.useShadows
              } ), Q.useShadows )
            } ), this._domNode.appendChild( this.scrollableElement.getDomNode() ), e.appendChild( this._domNode ), this.disposables = [ this.rangeMap, this.gesture, this.scrollableElement, this.cache ], this.scrollableElement.onScroll( this.onScroll, this, this.disposables ), Object( F.a )( this.rowsContainer, P.a.Change )( this.onTouchChange, this, this.disposables ), Object( F.a )( this.scrollableElement.getDomNode(), "scroll" )( ( e => {
              return e.target.scrollTop = 0
            } ), null, this.disposables ), Object( y.j )( Object( F.a )( this.rowsContainer, "dragover" ), ( e => {
              return new $.a( e )
            } ) )( this.onDragOver, this, this.disposables ), this.layout()
          }
          return Object.defineProperty( e.prototype, "domNode", {
            get() {
              return this._domNode
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.splice = function ( e, t, n ) {
            if ( void 0 === n && ( n = [] ), this.splicing ) throw new Error( "Can't run recursive splices." );
            this.splicing = !0;
            try {
              return this._splice( e, t, n )
            } finally {
              this.splicing = !1
            }
          }, e.prototype._splice = function ( e, t, n ) {
            let i;
            let o;
            const r = this;
            void 0 === n && ( n = [] );
            for ( var s = this.getRenderRange( this.lastRenderTop, this.lastRenderHeight ), a = B( s, {
                start: e,
                end: e + t
              } ), u = a.start; u < a.end; u++ ) this.removeItemFromDOM( u );
            const l = {
                start: e + t,
                end: this.items.length
              },
              c = B( l, s ),
              d = z( l, s ),
              h = n.map( ( e => {
                return {
                  id: String( r.itemId++ ),
                  element: e,
                  size: r.virtualDelegate.getHeight( e ),
                  templateId: r.virtualDelegate.getTemplateId( e ),
                  row: null
                }
              } ) );
            ( i = this.rangeMap ).splice.apply( i, [ e, t ].concat( h ) );
            const p = ( o = this.items ).splice.apply( o, [ e, t ].concat( h ) ),
              f = n.length - t,
              g = this.getRenderRange( this.lastRenderTop, this.lastRenderHeight ),
              m = K( c, f ),
              _ = B( g, m );
            for ( u = _.start; u < _.end; u++ ) this.updateItemInDOM( this.items[ u ], u );
            for ( var v = z( m, g ), y = 0; y < v.length; y++ ) {
              const b = v[ y ];
              for ( u = b.start; u < b.end; u++ ) this.removeItemFromDOM( u )
            }
            const C = d.map( ( e => {
                return K( e, f )
              } ) ),
              w = [ {
                start: e,
                end: e + n.length
              } ].concat( C ).map( ( e => {
                return B( g, e )
              } ) ),
              S = this.getNextToLastElement( w );
            for ( y = 0; y < w.length; y++ ) {
              const O = w[ y ];
              for ( u = O.start; u < O.end; u++ ) this.insertItemInDOM( u, S )
            }
            const L = this.getContentHeight();
            return this.rowsContainer.style.height = L + "px", this.scrollableElement.setScrollDimensions( {
              scrollHeight: L
            } ), p.map( ( e => {
              return e.element
            } ) );
          }, Object.defineProperty( e.prototype, "length", {
            get() {
              return this.items.length
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "renderHeight", {
            get() {
              return this.scrollableElement.getScrollDimensions().height
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.element = function ( e ) {
            return this.items[ e ].element
          }, e.prototype.domElement = function ( e ) {
            const t = this.items[ e ].row;
            return t && t.domNode
          }, e.prototype.elementHeight = function ( e ) {
            return this.items[ e ].size
          }, e.prototype.elementTop = function ( e ) {
            return this.rangeMap.positionAt( e )
          }, e.prototype.indexAt = function ( e ) {
            return this.rangeMap.indexAt( e )
          }, e.prototype.indexAfter = function ( e ) {
            return this.rangeMap.indexAfter( e )
          }, e.prototype.layout = function ( e ) {
            this.scrollableElement.setScrollDimensions( {
              height: e || I.s( this._domNode )
            } )
          }, e.prototype.render = function ( e, t ) {
            for ( var n = this.getRenderRange( this.lastRenderTop, this.lastRenderHeight ), i = this.getRenderRange( e, t ), o = z( i, n ), r = z( n, i ), s = this.getNextToLastElement( o ), a = 0, u = o; a < u.length; a++ )
              for ( var l = ( h = u[ a ] ).start; l < h.end; l++ ) this.insertItemInDOM( l, s );
            for ( let c = 0, d = r; c < d.length; c++ ) {
              var h;
              for ( l = ( h = d[ c ] ).start; l < h.end; l++ ) this.removeItemFromDOM( l )
            }
            if ( X.j || 0 !== X.d() || R.g ) this.rowsContainer.style.top = "-" + e + "px";
            else {
              const p = "translate3d(0px, -" + e + "px, 0px)";
              this.rowsContainer.style.transform = p, this.rowsContainer.style.webkitTransform = p
            }
            this.lastRenderTop = e, this.lastRenderHeight = t
          }, e.prototype.insertItemInDOM = function ( e, t ) {
            const n = this.items[ e ];
            n.row || ( n.row = this.cache.alloc( n.templateId ) ), n.row.domNode.parentElement || ( t ? this.rowsContainer.insertBefore( n.row.domNode, t ) : this.rowsContainer.appendChild( n.row.domNode ) ), n.row.domNode.style.height = n.size + "px", this.updateItemInDOM( n, e ), this.renderers.get( n.templateId ).renderElement( n.element, e, n.row.templateData )
          }, e.prototype.updateItemInDOM = function ( e, t ) {
            e.row.domNode.style.top = this.elementTop( t ) + "px", e.row.domNode.setAttribute( "data-index", "" + t ), e.row.domNode.setAttribute( "data-last-element", t === this.length - 1 ? "true" : "false" ), e.row.domNode.setAttribute( "aria-setsize", "" + this.length ), e.row.domNode.setAttribute( "aria-posinset", "" + ( t + 1 ) )
          }, e.prototype.removeItemFromDOM = function ( e ) {
            const t = this.items[ e ],
              n = this.renderers.get( t.templateId );
            n.disposeElement && n.disposeElement( t.element, e, t.row.templateData ), this.cache.release( t.row ), t.row = null
          }, e.prototype.getContentHeight = function () {
            return this.rangeMap.size
          }, e.prototype.getScrollTop = function () {
            return this.scrollableElement.getScrollPosition().scrollTop
          }, e.prototype.setScrollTop = function ( e ) {
            this.scrollableElement.setScrollPosition( {
              scrollTop: e
            } )
          }, Object.defineProperty( e.prototype, "scrollTop", {
            get() {
              return this.getScrollTop()
            },
            set( e ) {
              this.setScrollTop( e )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onMouseClick", {
            get() {
              const e = this;
              return Object( y.i )( Object( y.j )( Object( F.a )( this.domNode, "click" ), ( t => {
                return e.toMouseEvent( t )
              } ) ), ( e => {
                return e.index >= 0
              } ) );
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onMouseDblClick", {
            get() {
              const e = this;
              return Object( y.i )( Object( y.j )( Object( F.a )( this.domNode, "dblclick" ), ( t => {
                return e.toMouseEvent( t )
              } ) ), ( e => {
                return e.index >= 0
              } ) );
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onMouseDown", {
            get() {
              const e = this;
              return Object( y.i )( Object( y.j )( Object( F.a )( this.domNode, "mousedown" ), ( t => {
                return e.toMouseEvent( t )
              } ) ), ( e => {
                return e.index >= 0
              } ) );
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onContextMenu", {
            get() {
              const e = this;
              return Object( y.i )( Object( y.j )( Object( F.a )( this.domNode, "contextmenu" ), ( t => {
                return e.toMouseEvent( t )
              } ) ), ( e => {
                return e.index >= 0
              } ) );
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onTouchStart", {
            get() {
              const e = this;
              return Object( y.i )( Object( y.j )( Object( F.a )( this.domNode, "touchstart" ), ( t => {
                return e.toTouchEvent( t )
              } ) ), ( e => {
                return e.index >= 0
              } ) );
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onTap", {
            get() {
              const e = this;
              return Object( y.i )( Object( y.j )( Object( F.a )( this.rowsContainer, P.a.Tap ), ( t => {
                return e.toGestureEvent( t )
              } ) ), ( e => {
                return e.index >= 0
              } ) );
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.toMouseEvent = function ( e ) {
            const t = this.getItemIndexFromEventTarget( e.target ),
              n = t < 0 ? void 0 : this.items[ t ];
            return {
              browserEvent: e,
              index: t,
              element: n && n.element
            }
          }, e.prototype.toTouchEvent = function ( e ) {
            const t = this.getItemIndexFromEventTarget( e.target ),
              n = t < 0 ? void 0 : this.items[ t ];
            return {
              browserEvent: e,
              index: t,
              element: n && n.element
            }
          }, e.prototype.toGestureEvent = function ( e ) {
            const t = this.getItemIndexFromEventTarget( e.initialTarget ),
              n = t < 0 ? void 0 : this.items[ t ];
            return {
              browserEvent: e,
              index: t,
              element: n && n.element
            }
          }, e.prototype.onScroll = function ( e ) {
            try {
              this.render( e.scrollTop, e.height )
            } catch ( t ) {
              throw ( console.log( "Got bad scroll event:", e ), t )
            }
          }, e.prototype.onTouchChange = function ( e ) {
            e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY
          }, e.prototype.onDragOver = function ( e ) {
            this.setupDragAndDropScrollInterval(), this.dragAndDropMouseY = e.posy
          }, e.prototype.setupDragAndDropScrollInterval = function () {
            const e = this,
              t = I.w( this._domNode ).top;
            this.dragAndDropScrollInterval || ( this.dragAndDropScrollInterval = window.setInterval( ( () => {
              if ( void 0 !== e.dragAndDropMouseY ) {
                const n = e.dragAndDropMouseY - t;
                let i = 0;
                const o = e.renderHeight - 35;
                n < 35 ? i = Math.max( -14, .2 * ( n - 35 ) ) : n > o && ( i = Math.min( 14, .2 * ( n - o ) ) ), e.scrollTop += i
              }
            } ), 10 ), this.cancelDragAndDropScrollTimeout(), this.dragAndDropScrollTimeout = window.setTimeout( ( () => {
              e.cancelDragAndDropScrollInterval(), e.dragAndDropScrollTimeout = null
            } ), 1e3 ) )
          }, e.prototype.cancelDragAndDropScrollInterval = function () {
            this.dragAndDropScrollInterval && ( window.clearInterval( this.dragAndDropScrollInterval ), this.dragAndDropScrollInterval = null ), this.cancelDragAndDropScrollTimeout()
          }, e.prototype.cancelDragAndDropScrollTimeout = function () {
            this.dragAndDropScrollTimeout && ( window.clearTimeout( this.dragAndDropScrollTimeout ), this.dragAndDropScrollTimeout = null )
          }, e.prototype.getItemIndexFromEventTarget = function ( e ) {
            for ( ; e instanceof HTMLElement && e !== this.rowsContainer; ) {
              const t = e,
                n = t.getAttribute( "data-index" );
              if ( n ) {
                const i = Number( n );
                if ( !isNaN( i ) ) return i
              }
              e = t.parentElement
            }
            return -1
          }, e.prototype.getRenderRange = function ( e, t ) {
            return {
              start: this.rangeMap.indexAt( e ),
              end: this.rangeMap.indexAfter( e + t - 1 )
            }
          }, e.prototype.getNextToLastElement = function ( e ) {
            const t = e[ e.length - 1 ];
            if ( !t ) return null;
            const n = this.items[ t.end ];
            return n && n.row ? n.row.domNode : null
          }, e.prototype.dispose = function () {
            if ( this.items ) {
              for ( let e = 0, t = this.items; e < t.length; e++ ) {
                const n = t[ e ];
                if ( n.row ) this.renderers.get( n.row.templateId ).disposeTemplate( n.row.templateData ), n.row = null
              }
              this.items = null
            }
            this._domNode && this._domNode.parentElement && ( this._domNode.parentNode.removeChild( this._domNode ), this._domNode = null ), this.disposables = Object( s.d )( this.disposables )
          }, Z( [ T.a ], e.prototype, "onMouseClick", null ), Z( [ T.a ], e.prototype, "onMouseDblClick", null ), Z( [ T.a ], e.prototype, "onMouseDown", null ), Z( [ T.a ], e.prototype, "onContextMenu", null ), Z( [ T.a ], e.prototype, "onTouchStart", null ), Z( [ T.a ], e.prototype, "onTap", null ), e;
        } )(),
        ee = n( "zrhQ" ),
        te = ( () => {
          function e( e ) {
            this.spliceables = e
          }
          return e.prototype.splice = function ( e, t, n ) {
            this.spliceables.forEach( ( i => {
              return i.splice( e, t, n )
            } ) )
          }, e;
        } )();
      const ne = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        ie = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        oe = ( () => {
          function e( e ) {
            this.trait = e, this.renderedElements = []
          }
          return Object.defineProperty( e.prototype, "templateId", {
            get() {
              return "template:" + this.trait.trait
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.renderTemplate = e => {
            return e
          }, e.prototype.renderElement = function ( e, t, n ) {
            const i = Object( r.h )( this.renderedElements, ( e => {
              return e.templateData === n
            } ) );
            if ( i >= 0 ) {
              var o = this.renderedElements[ i ];
              this.trait.unrender( n ), o.index = t
            } else {
              o = {
                index: t,
                templateData: n
              };
              this.renderedElements.push( o )
            }
            this.trait.renderIndex( t, n )
          }, e.prototype.disposeElement = () => {}, e.prototype.splice = function ( e, t, n ) {
            for ( var i = [], o = 0; o < this.renderedElements.length; o++ ) {
              const r = this.renderedElements[ o ];
              r.index < e ? i.push( r ) : r.index >= e + t && i.push( {
                index: r.index + n - t,
                templateData: r.templateData
              } )
            }
            this.renderedElements = i
          }, e.prototype.renderIndexes = function ( e ) {
            for ( let t = 0, n = this.renderedElements; t < n.length; t++ ) {
              const i = n[ t ],
                o = i.index,
                r = i.templateData;
              e.indexOf( o ) > -1 && this.trait.renderIndex( o, r )
            }
          }, e.prototype.disposeTemplate = function ( e ) {
            const t = Object( r.h )( this.renderedElements, ( t => {
              return t.templateData === e
            } ) );
            t < 0 || this.renderedElements.splice( t, 1 )
          }, e;
        } )(),
        re = ( () => {
          function e( e ) {
            this._trait = e, this._onChange = new y.a, this.indexes = []
          }
          return Object.defineProperty( e.prototype, "onChange", {
            get() {
              return this._onChange.event
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "trait", {
            get() {
              return this._trait
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "renderer", {
            get() {
              return new oe( this )
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.splice = function ( e, t, n ) {
            const i = n.length - t,
              o = e + t,
              r = this.indexes.filter( ( t => {
                return t < e
              } ) ).concat( n.map( ( ( t, n ) => {
                return t ? n + e : -1
              } ) ).filter( ( e => {
                return -1 !== e
              } ) ), this.indexes.filter( ( e => {
                return e >= o
              } ) ).map( ( e => {
                return e + i
              } ) ) );
            this.renderer.splice( e, t, n.length ), this.set( r )
          }, e.prototype.renderIndex = function ( e, t ) {
            I.N( t, this._trait, this.contains( e ) )
          }, e.prototype.unrender = function ( e ) {
            I.G( e, this._trait )
          }, e.prototype.set = function ( e ) {
            const t = this.indexes;
            this.indexes = e;
            const n = ve( t, e );
            return this.renderer.renderIndexes( n ), this._onChange.fire( {
              indexes: e
            } ), t
          }, e.prototype.get = function () {
            return this.indexes
          }, e.prototype.contains = function ( e ) {
            return this.indexes.some( ( t => {
              return t === e
            } ) );
          }, e.prototype.dispose = function () {
            this.indexes = null, this._onChange = Object( s.d )( this._onChange )
          }, ie( [ T.a ], e.prototype, "renderer", null ), e;
        } )(),
        se = ( e => {
          function t( t ) {
            const n = e.call( this, "focused" ) || this;
            return n.getDomId = t, n
          }
          return ne( t, e ), t.prototype.renderIndex = function ( t, n ) {
            e.prototype.renderIndex.call( this, t, n ), n.setAttribute( "role", "treeitem" ), n.setAttribute( "id", this.getDomId( t ) )
          }, t
        } )( re ),
        ae = ( () => {
          function e( e, t, n ) {
            this.trait = e, this.view = t, this.getId = n
          }
          return e.prototype.splice = function ( e, t, n ) {
            const i = this;
            if ( !this.getId ) return this.trait.splice( e, t, n.map( ( e => {
              return !1
            } ) ) );
            const o = this.trait.get().map( ( e => {
                return i.getId( i.view.element( e ) )
              } ) ),
              r = n.map( ( e => {
                return o.indexOf( i.getId( e ) ) > -1
              } ) );
            this.trait.splice( e, t, r )
          }, e;
        } )();

      function ue( e ) {
        return "INPUT" === e.tagName || "TEXTAREA" === e.tagName
      }
      const le = ( () => {
          function e( e, t, n ) {
            this.list = e, this.view = t;
            const i = !( !1 === n.multipleSelectionSupport );
            this.disposables = [], this.openController = n.openController || pe;
            const o = Object( y.g )( Object( F.a )( t.domNode, "keydown" ) ).filter( ( e => {
              return !ue( e.target )
            } ) ).map( ( e => {
              return new A.a( e )
            } ) );
            o.filter( ( e => {
              return 3 === e.keyCode
            } ) ).on( this.onEnter, this, this.disposables ), o.filter( ( e => {
              return 16 === e.keyCode
            } ) ).on( this.onUpArrow, this, this.disposables ), o.filter( ( e => {
              return 18 === e.keyCode
            } ) ).on( this.onDownArrow, this, this.disposables ), o.filter( ( e => {
              return 11 === e.keyCode
            } ) ).on( this.onPageUpArrow, this, this.disposables ), o.filter( ( e => {
              return 12 === e.keyCode
            } ) ).on( this.onPageDownArrow, this, this.disposables ), o.filter( ( e => {
              return 9 === e.keyCode
            } ) ).on( this.onEscape, this, this.disposables ), i && o.filter( ( e => {
              return ( R.d ? e.metaKey : e.ctrlKey ) && 31 === e.keyCode
            } ) ).on( this.onCtrlA, this, this.disposables )
          }
          return e.prototype.onEnter = function ( e ) {
            e.preventDefault(), e.stopPropagation(), this.list.setSelection( this.list.getFocus() ), this.openController.shouldOpen( e.browserEvent ) && this.list.open( this.list.getFocus(), e.browserEvent )
          }, e.prototype.onUpArrow = function ( e ) {
            e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(), this.list.reveal( this.list.getFocus()[ 0 ] ), this.view.domNode.focus()
          }, e.prototype.onDownArrow = function ( e ) {
            e.preventDefault(), e.stopPropagation(), this.list.focusNext(), this.list.reveal( this.list.getFocus()[ 0 ] ), this.view.domNode.focus()
          }, e.prototype.onPageUpArrow = function ( e ) {
            e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(), this.list.reveal( this.list.getFocus()[ 0 ] ), this.view.domNode.focus()
          }, e.prototype.onPageDownArrow = function ( e ) {
            e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(), this.list.reveal( this.list.getFocus()[ 0 ] ), this.view.domNode.focus()
          }, e.prototype.onCtrlA = function ( e ) {
            e.preventDefault(), e.stopPropagation(), this.list.setSelection( Object( r.m )( this.list.length ) ), this.view.domNode.focus()
          }, e.prototype.onEscape = function ( e ) {
            e.preventDefault(), e.stopPropagation(), this.list.setSelection( [] ), this.view.domNode.focus()
          }, e.prototype.dispose = function () {
            this.disposables = Object( s.d )( this.disposables )
          }, e
        } )(),
        ce = ( () => {
          function e( e, t ) {
            this.list = e, this.view = t, this.disposables = [], this.disposables = [], Object( y.g )( Object( F.a )( t.domNode, "keydown" ) ).filter( ( e => {
              return !ue( e.target )
            } ) ).map( ( e => {
              return new A.a( e )
            } ) ).filter( ( e => {
              return 2 === e.keyCode && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey
            } ) ).on( this.onTab, this, this.disposables )
          }
          return e.prototype.onTab = function ( e ) {
            if ( e.target === this.view.domNode ) {
              const t = this.list.getFocus();
              if ( 0 !== t.length ) {
                const n = this.view.domElement( t[ 0 ] ).querySelector( "[tabIndex]" );
                if ( n && n instanceof HTMLElement ) {
                  const i = window.getComputedStyle( n );
                  "hidden" !== i.visibility && "none" !== i.display && ( e.preventDefault(), e.stopPropagation(), n.focus() )
                }
              }
            }
          }, e.prototype.dispose = function () {
            this.disposables = Object( s.d )( this.disposables )
          }, e;
        } )();

      function de( e ) {
        return e instanceof MouseEvent && 2 === e.button
      }
      const he = {
        isSelectionSingleChangeEvent( e ) {
          return R.d ? e.browserEvent.metaKey : e.browserEvent.ctrlKey
        },
        isSelectionRangeChangeEvent( e ) {
          return e.browserEvent.shiftKey
        }
      };
      var pe = {
        shouldOpen( e ) {
          return !( e instanceof MouseEvent ) || !de( e )
        }
      };

      const fe = ( () => {
        function e( e, t, n ) {
          void 0 === n && ( n = {} ), this.list = e, this.view = t, this.options = n, this.didJustPressContextMenuKey = !1, this.disposables = [], this.multipleSelectionSupport = !( !1 === n.multipleSelectionSupport ), this.multipleSelectionSupport && ( this.multipleSelectionController = n.multipleSelectionController || he ), this.openController = n.openController || pe, t.onMouseDown( this.onMouseDown, this, this.disposables ), t.onMouseClick( this.onPointer, this, this.disposables ), t.onMouseDblClick( this.onDoubleClick, this, this.disposables ), t.onTouchStart( this.onMouseDown, this, this.disposables ), t.onTap( this.onPointer, this, this.disposables ), P.b.addTarget( t.domNode )
        }
        return Object.defineProperty( e.prototype, "onContextMenu", {
          get() {
            const e = this,
              t = Object( y.g )( Object( F.a )( this.view.domNode, "keydown" ) ).map( ( e => {
                return new A.a( e )
              } ) ).filter( ( t => {
                return e.didJustPressContextMenuKey = 58 === t.keyCode || t.shiftKey && 68 === t.keyCode
              } ) ).filter( ( e => {
                return e.preventDefault(), e.stopPropagation(), !1
              } ) ).event,
              n = Object( y.g )( Object( F.a )( this.view.domNode, "keyup" ) ).filter( ( () => {
                const t = e.didJustPressContextMenuKey;
                return e.didJustPressContextMenuKey = !1, t
              } ) ).filter( ( () => {
                return e.list.getFocus().length > 0
              } ) ).map( ( () => {
                const t = e.list.getFocus()[ 0 ];
                return {
                  index: t,
                  element: e.view.element( t ),
                  anchor: e.view.domElement( t )
                }
              } ) ).filter( ( e => {
                return !!e.anchor
              } ) ).event,
              i = Object( y.g )( this.view.onContextMenu ).filter( ( () => {
                return !e.didJustPressContextMenuKey
              } ) ).map( ( e => {
                const t = e.element,
                  n = e.index,
                  i = e.browserEvent;
                return {
                  element: t,
                  index: n,
                  anchor: {
                    x: i.clientX + 1,
                    y: i.clientY
                  }
                }
              } ) ).event;
            return Object( y.f )( t, n, i )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.isSelectionSingleChangeEvent = function ( e ) {
          return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent( e ) : R.d ? e.browserEvent.metaKey : e.browserEvent.ctrlKey
        }, e.prototype.isSelectionRangeChangeEvent = function ( e ) {
          return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent( e ) : e.browserEvent.shiftKey
        }, e.prototype.isSelectionChangeEvent = function ( e ) {
          return this.isSelectionSingleChangeEvent( e ) || this.isSelectionRangeChangeEvent( e )
        }, e.prototype.onMouseDown = function ( e ) {
          !1 === this.options.focusOnMouseDown ? ( e.browserEvent.preventDefault(), e.browserEvent.stopPropagation() ) : document.activeElement !== e.browserEvent.target && this.view.domNode.focus();
          let t = this.list.getFocus()[ 0 ];
          const n = this.list.getSelection();
          if ( t = void 0 === t ? n[ 0 ] : t, this.multipleSelectionSupport && this.isSelectionRangeChangeEvent( e ) ) return this.changeSelection( e, t );
          const i = e.index;
          if ( n.every( ( e => {
              return e !== i
            } ) ) && this.list.setFocus( [ i ] ), this.multipleSelectionSupport && this.isSelectionChangeEvent( e ) ) return this.changeSelection( e, t );
          this.options.selectOnMouseDown && !de( e.browserEvent ) && ( this.list.setSelection( [ i ] ), this.openController.shouldOpen( e.browserEvent ) && this.list.open( [ i ], e.browserEvent ) )
        }, e.prototype.onPointer = function ( e ) {
          if ( ( !this.multipleSelectionSupport || !this.isSelectionChangeEvent( e ) ) && !this.options.selectOnMouseDown ) {
            const t = this.list.getFocus();
            this.list.setSelection( t ), this.openController.shouldOpen( e.browserEvent ) && this.list.open( t, e.browserEvent )
          }
        }, e.prototype.onDoubleClick = function ( e ) {
          if ( !this.multipleSelectionSupport || !this.isSelectionChangeEvent( e ) ) {
            const t = this.list.getFocus();
            this.list.setSelection( t ), this.list.pin( t )
          }
        }, e.prototype.changeSelection = function ( e, t ) {
          const n = e.index;
          if ( this.isSelectionRangeChangeEvent( e ) && void 0 !== t ) {
            const i = Math.min( t, n ),
              o = Math.max( t, n ),
              s = Object( r.m )( i, o + 1 ),
              a = ( ( e, t ) => {
                const n = e.indexOf( t );
                if ( -1 === n ) return [];
                const i = [];
                let o = n - 1;
                for ( ; o >= 0 && e[ o ] === t - ( n - o ); ) i.push( e[ o-- ] );
                i.reverse(), o = n;
                for ( ; o < e.length && e[ o ] === t + ( o - n ); ) i.push( e[ o++ ] );
                return i
              } )( ve( l = this.list.getSelection(), [ t ] ), t );
            if ( 0 === a.length ) return;
            var u = ve(
              s,
              ( ( e, t ) => {
                const n = [];
                let i = 0;
                let o = 0;
                for ( ; i < e.length || o < t.length; )
                  if ( i >= e.length ) n.push( t[ o++ ] );
                  else if ( o >= t.length ) n.push( e[ i++ ] );
                else {
                  if ( e[ i ] === t[ o ] ) {
                    i++, o++;
                    continue
                  }
                  e[ i ] < t[ o ] ? n.push( e[ i++ ] ) : o++
                }
                return n
              } )( l, a )
            );
            this.list.setSelection( u )
          } else if ( this.isSelectionSingleChangeEvent( e ) ) {
            var l;
            u = ( l = this.list.getSelection() ).filter( ( e => {
              return e !== n
            } ) );
            l.length === u.length ? this.list.setSelection( u.concat( [ n ] ) ) : this.list.setSelection( u )
          }
        }, e.prototype.dispose = function () {
          this.disposables = Object( s.d )( this.disposables )
        }, ie( [ T.a ], e.prototype, "onContextMenu", null ), e;
      } )();

      const ge = ( () => {
        function e( e, t ) {
          this.styleElement = e, this.selectorSuffix = t
        }
        return e.prototype.style = function ( e ) {
          const t = this.selectorSuffix ? "." + this.selectorSuffix : "",
            n = [];
          e.listFocusBackground && ( n.push( ".monaco-list" + t + ":focus .monaco-list-row.focused { background-color: " + e.listFocusBackground + "; }" ), n.push( ".monaco-list" + t + ":focus .monaco-list-row.focused:hover { background-color: " + e.listFocusBackground + "; }" ) ), e.listFocusForeground && n.push( ".monaco-list" + t + ":focus .monaco-list-row.focused { color: " + e.listFocusForeground + "; }" ), e.listActiveSelectionBackground && ( n.push( ".monaco-list" + t + ":focus .monaco-list-row.selected { background-color: " + e.listActiveSelectionBackground + "; }" ), n.push( ".monaco-list" + t + ":focus .monaco-list-row.selected:hover { background-color: " + e.listActiveSelectionBackground + "; }" ) ), e.listActiveSelectionForeground && n.push( ".monaco-list" + t + ":focus .monaco-list-row.selected { color: " + e.listActiveSelectionForeground + "; }" ), e.listFocusAndSelectionBackground && n.push( ".monaco-list" + t + ":focus .monaco-list-row.selected.focused { background-color: " + e.listFocusAndSelectionBackground + "; }" ), e.listFocusAndSelectionForeground && n.push( ".monaco-list" + t + ":focus .monaco-list-row.selected.focused { color: " + e.listFocusAndSelectionForeground + "; }" ), e.listInactiveFocusBackground && ( n.push( ".monaco-list" + t + " .monaco-list-row.focused { background-color:  " + e.listInactiveFocusBackground + "; }" ), n.push( ".monaco-list" + t + " .monaco-list-row.focused:hover { background-color:  " + e.listInactiveFocusBackground + "; }" ) ), e.listInactiveSelectionBackground && ( n.push( ".monaco-list" + t + " .monaco-list-row.selected { background-color:  " + e.listInactiveSelectionBackground + "; }" ), n.push( ".monaco-list" + t + " .monaco-list-row.selected:hover { background-color:  " + e.listInactiveSelectionBackground + "; }" ) ), e.listInactiveSelectionForeground && n.push( ".monaco-list" + t + " .monaco-list-row.selected { color: " + e.listInactiveSelectionForeground + "; }" ), e.listHoverBackground && n.push( ".monaco-list" + t + " .monaco-list-row:hover { background-color:  " + e.listHoverBackground + "; }" ), e.listHoverForeground && n.push( ".monaco-list" + t + " .monaco-list-row:hover { color:  " + e.listHoverForeground + "; }" ), e.listSelectionOutline && n.push( ".monaco-list" + t + " .monaco-list-row.selected { outline: 1px dotted " + e.listSelectionOutline + "; outline-offset: -1px; }" ), e.listFocusOutline && n.push( ".monaco-list" + t + ":focus .monaco-list-row.focused { outline: 1px solid " + e.listFocusOutline + "; outline-offset: -1px; }" ), e.listInactiveFocusOutline && n.push( ".monaco-list" + t + " .monaco-list-row.focused { outline: 1px dotted " + e.listInactiveFocusOutline + "; outline-offset: -1px; }" ), e.listHoverOutline && n.push( ".monaco-list" + t + " .monaco-list-row:hover { outline: 1px dashed " + e.listHoverOutline + "; outline-offset: -1px; }" );
          const i = n.join( "\n" );
          i !== this.styleElement.innerHTML && ( this.styleElement.innerHTML = i )
        }, e;
      } )();
      const me = {
        listFocusBackground: ee.a.fromHex( "#073655" ),
        listActiveSelectionBackground: ee.a.fromHex( "#0E639C" ),
        listActiveSelectionForeground: ee.a.fromHex( "#FFFFFF" ),
        listFocusAndSelectionBackground: ee.a.fromHex( "#094771" ),
        listFocusAndSelectionForeground: ee.a.fromHex( "#FFFFFF" ),
        listInactiveSelectionBackground: ee.a.fromHex( "#3F3F46" ),
        listHoverBackground: ee.a.fromHex( "#2A2D2E" ),
        listDropBackground: ee.a.fromHex( "#383B3D" )
      };
      const _e = {
        keyboardSupport: !0,
        mouseSupport: !0,
        multipleSelectionSupport: !0
      };

      function ve( e, t ) {
        for ( var n = [], i = 0, o = 0; i < e.length || o < t.length; )
          if ( i >= e.length ) n.push( t[ o++ ] );
          else if ( o >= t.length ) n.push( e[ i++ ] );
        else {
          if ( e[ i ] === t[ o ] ) {
            n.push( e[ i ] ), i++, o++;
            continue
          }
          e[ i ] < t[ o ] ? n.push( e[ i++ ] ) : n.push( t[ o++ ] )
        }
        return n
      }
      const ye = ( e, t ) => {
          return e - t
        },
        be = ( () => {
          function e( e, t ) {
            this._templateId = e, this.renderers = t
          }
          return Object.defineProperty( e.prototype, "templateId", {
            get() {
              return this._templateId
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.renderTemplate = function ( e ) {
            return this.renderers.map( ( t => {
              return t.renderTemplate( e )
            } ) );
          }, e.prototype.renderElement = function ( e, t, n ) {
            for ( let i = 0, o = 0, r = this.renderers; o < r.length; o++ ) {
              r[ o ].renderElement( e, t, n[ i++ ] )
            }
          }, e.prototype.disposeElement = function ( e, t, n ) {
            for ( let i = 0, o = 0, r = this.renderers; o < r.length; o++ ) {
              r[ o ].disposeElement( e, t, n[ i++ ] )
            }
          }, e.prototype.disposeTemplate = function ( e ) {
            for ( let t = 0, n = 0, i = this.renderers; n < i.length; n++ ) {
              i[ n ].disposeTemplate( e[ t++ ] )
            }
          }, e;
        } )(),
        Ce = ( () => {
          function e( t, n, o, r ) {
            void 0 === r && ( r = _e );
            const s = this;
            if ( this.idPrefix = "list_id_" + ++e.InstanceCount, this.eventBufferer = new y.c, this.onContextMenu = y.b.None, this._onOpen = new y.a, this._onPin = new y.a, this._onDidDispose = new y.a, this.focus = new se( ( e => {
                return s.getElementDomId( e )
              } ) ), this.selection = new re( "selected" ), Object( W.g )( r, me, !1 ), o = o.map( ( e => {
                return new be( e.templateId, [ s.focus.renderer, s.selection.renderer, e ] )
              } ) ), this.view = new J( t, n, o, r ), this.view.domNode.setAttribute( "role", "tree" ), I.f( this.view.domNode, this.idPrefix ), this.view.domNode.tabIndex = 0, this.styleElement = I.o( this.view.domNode ), this.styleController = r.styleController, this.styleController || ( this.styleController = new ge( this.styleElement, this.idPrefix ) ), this.spliceable = new te( [ new ae( this.focus, this.view, r.identityProvider ), new ae( this.selection, this.view, r.identityProvider ), this.view ] ), this.disposables = [ this.focus, this.selection, this.view, this._onDidDispose ], this.onDidFocus = Object( y.j )( Object( F.a )( this.view.domNode, "focus", !0 ), ( () => {
                return null
              } ) ), this.onDidBlur = Object( y.j )( Object( F.a )( this.view.domNode, "blur", !0 ), ( () => {
                return null
              } ) ), this.disposables.push( new ce( this, this.view ) ), "boolean" !== typeof r.keyboardSupport || r.keyboardSupport ) {
              const a = new le( this, this.view, r );
              this.disposables.push( a )
            }( "boolean" !== typeof r.mouseSupport || r.mouseSupport ) && ( this.mouseController = new fe( this, this.view, r ), this.disposables.push( this.mouseController ), this.onContextMenu = this.mouseController.onContextMenu ), this.onFocusChange( this._onFocusChange, this, this.disposables ), this.onSelectionChange( this._onSelectionChange, this, this.disposables ), r.ariaLabel && this.view.domNode.setAttribute( "aria-label", Object( i.a )( "aria list", "{0}. Use the navigation keys to navigate.", r.ariaLabel ) ), this.style( r )
          }
          return Object.defineProperty( e.prototype, "onFocusChange", {
            get() {
              const e = this;
              return Object( y.j )( this.eventBufferer.wrapEvent( this.focus.onChange ), ( t => {
                return e.toListEvent( t )
              } ) );
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onSelectionChange", {
            get() {
              const e = this;
              return Object( y.j )( this.eventBufferer.wrapEvent( this.selection.onChange ), ( t => {
                return e.toListEvent( t )
              } ) );
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onDidDispose", {
            get() {
              return this._onDidDispose.event
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.splice = function ( e, t, n ) {
            const i = this;
            if ( void 0 === n && ( n = [] ), e < 0 || e > this.view.length ) throw new Error( "Invalid start index: " + e );
            if ( t < 0 ) throw new Error( "Invalid delete count: " + t );
            0 === t && 0 === n.length || this.eventBufferer.bufferEvents( ( () => {
              return i.spliceable.splice( e, t, n )
            } ) )
          }, Object.defineProperty( e.prototype, "length", {
            get() {
              return this.view.length
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "contentHeight", {
            get() {
              return this.view.getContentHeight()
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.layout = function ( e ) {
            this.view.layout( e )
          }, e.prototype.setSelection = function ( e ) {
            for ( let t = 0, n = e; t < n.length; t++ ) {
              const i = n[ t ];
              if ( i < 0 || i >= this.length ) throw new Error( "Invalid index " + i )
            }
            e = e.sort( ye ), this.selection.set( e )
          }, e.prototype.getSelection = function () {
            return this.selection.get()
          }, e.prototype.setFocus = function ( e ) {
            for ( let t = 0, n = e; t < n.length; t++ ) {
              const i = n[ t ];
              if ( i < 0 || i >= this.length ) throw new Error( "Invalid index " + i )
            }
            e = e.sort( ye ), this.focus.set( e )
          }, e.prototype.focusNext = function ( e, t ) {
            if ( void 0 === e && ( e = 1 ), void 0 === t && ( t = !1 ), 0 !== this.length ) {
              const n = this.focus.get(),
                i = n.length > 0 ? n[ 0 ] + e : 0;
              this.setFocus( t ? [ i % this.length ] : [ Math.min( i, this.length - 1 ) ] )
            }
          }, e.prototype.focusPrevious = function ( e, t ) {
            if ( void 0 === e && ( e = 1 ), void 0 === t && ( t = !1 ), 0 !== this.length ) {
              const n = this.focus.get();
              let i = n.length > 0 ? n[ 0 ] - e : 0;
              t && i < 0 && ( i = ( this.length + i % this.length ) % this.length ), this.setFocus( [ Math.max( i, 0 ) ] )
            }
          }, e.prototype.focusNextPage = function () {
            const e = this;
            let t = this.view.indexAt( this.view.getScrollTop() + this.view.renderHeight );
            t = 0 === t ? 0 : t - 1;
            const n = this.view.element( t );
            if ( this.getFocusedElements()[ 0 ] !== n ) this.setFocus( [ t ] );
            else {
              const i = this.view.getScrollTop();
              this.view.setScrollTop( i + this.view.renderHeight - this.view.elementHeight( t ) ), this.view.getScrollTop() !== i && setTimeout( ( () => {
                return e.focusNextPage()
              } ), 0 )
            }
          }, e.prototype.focusPreviousPage = function () {
            let e;
            const t = this;
            const n = this.view.getScrollTop();
            e = 0 === n ? this.view.indexAt( n ) : this.view.indexAfter( n - 1 );
            const i = this.view.element( e );
            if ( this.getFocusedElements()[ 0 ] !== i ) this.setFocus( [ e ] );
            else {
              const o = n;
              this.view.setScrollTop( n - this.view.renderHeight ), this.view.getScrollTop() !== o && setTimeout( ( () => {
                return t.focusPreviousPage()
              } ), 0 )
            }
          }, e.prototype.focusLast = function () {
            0 !== this.length && this.setFocus( [ this.length - 1 ] )
          }, e.prototype.focusFirst = function () {
            0 !== this.length && this.setFocus( [ 0 ] )
          }, e.prototype.getFocus = function () {
            return this.focus.get()
          }, e.prototype.getFocusedElements = function () {
            const e = this;
            return this.getFocus().map( ( t => {
              return e.view.element( t )
            } ) );
          }, e.prototype.reveal = function ( e, t ) {
            if ( e < 0 || e >= this.length ) throw new Error( "Invalid index " + e );
            let n;
            let i;
            let o;
            const r = this.view.getScrollTop();
            const s = this.view.elementTop( e );
            const a = this.view.elementHeight( e );
            if ( Object( M.f )( t ) ) {
              const u = a - this.view.renderHeight;
              this.view.setScrollTop( u * ( n = t, i = 0, o = 1, Math.min( Math.max( n, i ), o ) ) + s )
            } else {
              const l = s + a,
                c = r + this.view.renderHeight;
              s < r ? this.view.setScrollTop( s ) : l >= c && this.view.setScrollTop( l - this.view.renderHeight )
            }
          }, e.prototype.getElementDomId = function ( e ) {
            return this.idPrefix + "_" + e
          }, e.prototype.isDOMFocused = function () {
            return this.view.domNode === document.activeElement
          }, e.prototype.getHTMLElement = function () {
            return this.view.domNode
          }, e.prototype.open = function ( e, t ) {
            for ( var n = this, i = 0, o = e; i < o.length; i++ ) {
              const r = o[ i ];
              if ( r < 0 || r >= this.length ) throw new Error( "Invalid index " + r )
            }
            this._onOpen.fire( {
              indexes: e,
              elements: e.map( ( e => {
                return n.view.element( e )
              } ) ),
              browserEvent: t
            } )
          }, e.prototype.pin = function ( e ) {
            for ( let t = 0, n = e; t < n.length; t++ ) {
              const i = n[ t ];
              if ( i < 0 || i >= this.length ) throw new Error( "Invalid index " + i )
            }
            this._onPin.fire( e )
          }, e.prototype.style = function ( e ) {
            this.styleController.style( e )
          }, e.prototype.toListEvent = function ( e ) {
            const t = this,
              n = e.indexes;
            return {
              indexes: n,
              elements: n.map( ( e => {
                return t.view.element( e )
              } ) )
            };
          }, e.prototype._onFocusChange = function () {
            const e = this.focus.get();
            e.length > 0 ? this.view.domNode.setAttribute( "aria-activedescendant", this.getElementDomId( e[ 0 ] ) ) : this.view.domNode.removeAttribute( "aria-activedescendant" ), this.view.domNode.setAttribute( "role", "tree" ), I.N( this.view.domNode, "element-focused", e.length > 0 )
          }, e.prototype._onSelectionChange = function () {
            const e = this.selection.get();
            I.N( this.view.domNode, "selection-none", 0 === e.length ), I.N( this.view.domNode, "selection-single", 1 === e.length ), I.N( this.view.domNode, "selection-multiple", e.length > 1 )
          }, e.prototype.dispose = function () {
            this._onDidDispose.fire(), this.disposables = Object( s.d )( this.disposables )
          }, e.InstanceCount = 0, ie( [ T.a ], e.prototype, "onFocusChange", null ), ie( [ T.a ], e.prototype, "onSelectionChange", null ), e;
        } )(),
        we = n( "bexQ" ),
        Se = n( "sFUC" ),
        Oe = n( "XXUj" ),
        Le = n( "ptcw" ),
        xe = n( "t9D7" ),
        Ne = n( "MD5Z" ),
        Ee = n( "A+jI" ),
        ke = n( "3qCu" ),
        Ie = n( "WBhO" ),
        De = n( "W9cx" ),
        Me = n( "JQT/" ),
        Te = Object.assign || function ( e ) {
          for ( let t, n = 1, i = arguments.length; n < i; n++ )
            for ( const o in t = arguments[ n ] ) Object.prototype.hasOwnProperty.call( t, o ) && ( e[ o ] = t[ o ] );
          return e
        },
        Re = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        Pe = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        Ae = !1,
        Fe = Object( Ne.kb )( "editorSuggestWidget.background", {
          dark: Ne.D,
          light: Ne.D,
          hc: Ne.D
        }, i.a( "editorSuggestWidgetBackground", "Background color of the suggest widget." ) ),
        We = Object( Ne.kb )( "editorSuggestWidget.border", {
          dark: Ne.E,
          light: Ne.E,
          hc: Ne.E
        }, i.a( "editorSuggestWidgetBorder", "Border color of the suggest widget." ) ),
        je = Object( Ne.kb )( "editorSuggestWidget.foreground", {
          dark: Ne.u,
          light: Ne.u,
          hc: Ne.u
        }, i.a( "editorSuggestWidgetForeground", "Foreground color of the suggest widget." ) ),
        Ve = Object( Ne.kb )( "editorSuggestWidget.selectedBackground", {
          dark: Ne.W,
          light: Ne.W,
          hc: Ne.W
        }, i.a( "editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget." ) ),
        Be = Object( Ne.kb )( "editorSuggestWidget.highlightForeground", {
          dark: Ne.Y,
          light: Ne.Y,
          hc: Ne.Y
        }, i.a( "editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget." ) ),
        He = /^(#([\da-f]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))$/i;

      function ze( e ) {
        return e && e.match( He ) ? e : null
      }

      function Ue( e ) {
        if ( !e ) return !1;
        const t = e.suggestion;
        return !!t.documentation || t.detail && t.detail !== t.label
      }
      const Ke = ( () => {
          function e( e, t, n ) {
            this.widget = e, this.editor = t, this.triggerKeybindingLabel = n
          }
          return Object.defineProperty( e.prototype, "templateId", {
            get() {
              return "suggestion"
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.renderTemplate = function ( e ) {
            const t = this,
              n = Object.create( null );
            n.disposables = [], n.root = e, n.icon = Object( I.k )( e, Object( I.a )( ".icon" ) ), n.colorspan = Object( I.k )( n.icon, Object( I.a )( "span.colorspan" ) );
            const o = Object( I.k )( e, Object( I.a )( ".contents" ) ),
              r = Object( I.k )( o, Object( I.a )( ".main" ) );
            n.highlightedLabel = new D.a( r ), n.disposables.push( n.highlightedLabel ), n.typeLabel = Object( I.k )( r, Object( I.a )( "span.type-label" ) ), n.readMore = Object( I.k )( r, Object( I.a )( "span.readMore" ) ), n.readMore.title = i.a( "readMore", "Read More...{0}", this.triggerKeybindingLabel );
            const s = () => {
              const e = t.editor.getConfiguration(),
                i = e.fontInfo.fontFamily,
                o = ( e.contribInfo.suggestFontSize || e.fontInfo.fontSize ) + "px",
                s = ( e.contribInfo.suggestLineHeight || e.fontInfo.lineHeight ) + "px";
              n.root.style.fontSize = o, r.style.fontFamily = i, r.style.lineHeight = s, n.icon.style.height = s, n.icon.style.width = s, n.readMore.style.height = s, n.readMore.style.width = s
            };
            return s(), Object( y.g )( this.editor.onDidChangeConfiguration.bind( this.editor ) ).filter( ( e => {
              return e.fontInfo || e.contribInfo
            } ) ).on( s, null, n.disposables ), n;
          }, e.prototype.renderElement = function ( e, t, n ) {
            const o = this,
              r = n,
              s = e.suggestion;
            if ( Ue( e ) ? r.root.setAttribute( "aria-label", i.a( "suggestionWithDetailsAriaLabel", "{0}, suggestion, has details", s.label ) ) : r.root.setAttribute( "aria-label", i.a( "suggestionAriaLabel", "{0}, suggestion", s.label ) ), r.icon.className = "icon " + s.type, r.colorspan.style.backgroundColor = "", "color" === s.type ) {
              const a = ze( s.label ) || "string" === typeof s.documentation && ze( s.documentation );
              a && ( r.icon.className = "icon customcolor", r.colorspan.style.backgroundColor = a )
            }
            r.highlightedLabel.set( s.label, Object( O.b )( e.matches ), "", !0 ), r.typeLabel.textContent = ( s.detail || "" ).replace( /\n.*$/m, "" ), Ue( e ) ? ( Object( I.M )( r.readMore ), r.readMore.onmousedown = e => {
              e.stopPropagation(), e.preventDefault()
            }, r.readMore.onclick = e => {
              e.stopPropagation(), e.preventDefault(), o.widget.toggleDetails()
            } ) : ( Object( I.A )( r.readMore ), r.readMore.onmousedown = null, r.readMore.onclick = null )
          }, e.prototype.disposeElement = () => {}, e.prototype.disposeTemplate = e => {
            e.disposables = Object( s.d )( e.disposables )
          }, e;
        } )(),
        qe = ( () => {
          function e( e, t, n, o, r ) {
            const a = this;
            this.widget = t, this.editor = n, this.markdownRenderer = o, this.triggerKeybindingLabel = r, this.borderWidth = 1, this.disposables = [], this.el = Object( I.k )( e, Object( I.a )( ".details" ) ), this.disposables.push( Object( s.f )( ( () => {
              return e.removeChild( a.el )
            } ) ) ), this.body = Object( I.a )( ".body" ), this.scrollbar = new j.a( this.body, {} ), Object( I.k )( this.el, this.scrollbar.getDomNode() ), this.disposables.push( this.scrollbar ), this.header = Object( I.k )( this.body, Object( I.a )( ".header" ) ), this.close = Object( I.k )( this.header, Object( I.a )( "span.close" ) ), this.close.title = i.a( "readLess", "Read less...{0}", this.triggerKeybindingLabel ), this.type = Object( I.k )( this.header, Object( I.a )( "p.type" ) ), this.docs = Object( I.k )( this.body, Object( I.a )( "p.docs" ) ), this.ariaLabel = null, this.configureFont(), Object( y.g )( this.editor.onDidChangeConfiguration.bind( this.editor ) ).filter( ( e => {
              return e.fontInfo
            } ) ).on( this.configureFont, this, this.disposables ), o.onDidRenderCodeBlock( ( () => {
              return a.scrollbar.scanDomNode()
            } ), this, this.disposables )
          }
          return Object.defineProperty( e.prototype, "element", {
            get() {
              return this.el
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.render = function ( e ) {
            const t = this;
            if ( this.renderDisposeable = Object( s.d )( this.renderDisposeable ), !e || !Ue( e ) ) return this.type.textContent = "", this.docs.textContent = "", Object( I.f )( this.el, "no-docs" ), void( this.ariaLabel = null );
            if ( Object( I.G )( this.el, "no-docs" ), "string" === typeof e.suggestion.documentation ) Object( I.G )( this.docs, "markdown-docs" ), this.docs.textContent = e.suggestion.documentation;
            else {
              Object( I.f )( this.docs, "markdown-docs" ), this.docs.innerHTML = "";
              const n = this.markdownRenderer.render( e.suggestion.documentation );
              this.renderDisposeable = n, this.docs.appendChild( n.element )
            }
            e.suggestion.detail ? ( this.type.innerText = e.suggestion.detail, Object( I.M )( this.type ) ) : ( this.type.innerText = "", Object( I.A )( this.type ) ), this.el.style.height = this.header.offsetHeight + this.docs.offsetHeight + 2 * this.borderWidth + "px", this.close.onmousedown = e => {
              e.preventDefault(), e.stopPropagation()
            }, this.close.onclick = e => {
              e.preventDefault(), e.stopPropagation(), t.widget.toggleDetails()
            }, this.body.scrollTop = 0, this.scrollbar.scanDomNode(), this.ariaLabel = k.format( "{0}\n{1}\n{2}", e.suggestion.label || "", e.suggestion.detail || "", e.suggestion.documentation || "" )
          }, e.prototype.getAriaLabel = function () {
            return this.ariaLabel
          }, e.prototype.scrollDown = function ( e ) {
            void 0 === e && ( e = 8 ), this.body.scrollTop += e
          }, e.prototype.scrollUp = function ( e ) {
            void 0 === e && ( e = 8 ), this.body.scrollTop -= e
          }, e.prototype.scrollTop = function () {
            this.body.scrollTop = 0
          }, e.prototype.scrollBottom = function () {
            this.body.scrollTop = this.body.scrollHeight
          }, e.prototype.pageDown = function () {
            this.scrollDown( 80 )
          }, e.prototype.pageUp = function () {
            this.scrollUp( 80 )
          }, e.prototype.setBorderWidth = function ( e ) {
            this.borderWidth = e
          }, e.prototype.configureFont = function () {
            const e = this.editor.getConfiguration(),
              t = e.fontInfo.fontFamily,
              n = ( e.contribInfo.suggestFontSize || e.fontInfo.fontSize ) + "px",
              i = ( e.contribInfo.suggestLineHeight || e.fontInfo.lineHeight ) + "px";
            this.el.style.fontSize = n, this.type.style.fontFamily = t, this.close.style.height = i, this.close.style.width = i
          }, e.prototype.dispose = function () {
            this.disposables = Object( s.d )( this.disposables ), this.renderDisposeable = Object( s.d )( this.renderDisposeable )
          }, e;
        } )(),
        Ge = ( () => {
          function e( e, t, n, i, o, r, s, a ) {
            const u = this;
            this.editor = e, this.telemetryService = t, this.allowEditorOverflow = !0, this.ignoreFocusEvents = !1, this.editorBlurTimeout = new v.f, this.showTimeout = new v.f, this.onDidSelectEmitter = new y.a, this.onDidFocusEmitter = new y.a, this.onDidHideEmitter = new y.a, this.onDidShowEmitter = new y.a, this.onDidSelect = this.onDidSelectEmitter.event, this.onDidFocus = this.onDidFocusEmitter.event, this.onDidHide = this.onDidHideEmitter.event, this.onDidShow = this.onDidShowEmitter.event, this.maxWidgetWidth = 660, this.listWidth = 330, this.storageServiceAvailable = !0, this.expandSuggestionDocs = !1, this.firstFocusInCurrentList = !1;
            const l = r.lookupKeybinding( "editor.action.triggerSuggest" ),
              c = l ? " (" + l.getLabel() + ")" : "",
              d = new ke.a( e, s, a );
            this.isAuto = !1, this.focusedItem = null, this.storageService = o, void 0 === this.expandDocsSettingFromStorage() && ( this.storageService.store( "expandSuggestionDocs", Ae, Ee.c.GLOBAL ), void 0 === this.expandDocsSettingFromStorage() && ( this.storageServiceAvailable = !1 ) ), this.element = Object( I.a )( ".editor-widget.suggest-widget" ), this.editor.getConfiguration().contribInfo.iconsInSuggestions || Object( I.f )( this.element, "no-icons" ), this.messageElement = Object( I.k )( this.element, Object( I.a )( ".message" ) ), this.listElement = Object( I.k )( this.element, Object( I.a )( ".tree" ) ), this.details = new qe( this.element, this, this.editor, d, c );
            const h = new Ke( this, this.editor, c );
            this.list = new Ce( this.listElement, this, [ h ], {
              useShadows: !1,
              selectOnMouseDown: !0,
              focusOnMouseDown: !1,
              openController: {
                shouldOpen() {
                  return !1
                }
              }
            } ), this.toDispose = [ Object( Le.b )( this.list, i, {
              listInactiveFocusBackground: Ve,
              listInactiveFocusOutline: Ne.b
            } ), i.onThemeChange( ( e => {
              return u.onThemeChange( e )
            } ) ), e.onDidBlurEditorText( ( () => {
              return u.onEditorBlur()
            } ) ), e.onDidLayoutChange( ( () => {
              return u.onEditorLayoutChange()
            } ) ), this.list.onSelectionChange( ( e => {
              return u.onListSelection( e )
            } ) ), this.list.onFocusChange( ( e => {
              return u.onListFocus( e )
            } ) ), this.editor.onDidChangeCursorSelection( ( () => {
              return u.onCursorSelectionChanged()
            } ) ) ], this.suggestWidgetVisible = _.a.Visible.bindTo( n ), this.suggestWidgetMultipleSuggestions = _.a.MultipleSuggestions.bindTo( n ), this.suggestionSupportsAutoAccept = _.a.AcceptOnKey.bindTo( n ), this.editor.addContentWidget( this ), this.setState( 0 ), this.onThemeChange( i.getTheme() )
          }
          return e.prototype.onCursorSelectionChanged = function () {
            0 !== this.state && this.editor.layoutContentWidget( this )
          }, e.prototype.onEditorBlur = function () {
            const e = this;
            this.editorBlurTimeout.cancelAndSet( ( () => {
              e.editor.hasTextFocus() || e.setState( 0 )
            } ), 150 )
          }, e.prototype.onEditorLayoutChange = function () {
            3 !== this.state && 5 !== this.state || !this.expandDocsSettingFromStorage() || this.expandSideOrBelow()
          }, e.prototype.onListSelection = function ( e ) {
            const t = this;
            if ( e.elements.length ) {
              const n = e.elements[ 0 ],
                o = e.indexes[ 0 ];
              n.resolve( Me.a.None ).then( ( () => {
                t.onDidSelectEmitter.fire( {
                  item: n,
                  index: o,
                  model: t.completionModel
                } ), Object( h.a )( i.a( "suggestionAriaAccepted", "{0}, accepted", n.suggestion.label ) ), t.editor.focus()
              } ) )
            }
          }, e.prototype._getSuggestionAriaAlertLabel = e => {
            return Ue( e ) ? i.a( "ariaCurrentSuggestionWithDetails", "{0}, suggestion, has details", e.suggestion.label ) : i.a( "ariaCurrentSuggestion", "{0}, suggestion", e.suggestion.label )
          }, e.prototype._ariaAlert = function ( e ) {
            this._lastAriaAlertLabel !== e && ( this._lastAriaAlertLabel = e, this._lastAriaAlertLabel && Object( h.a )( this._lastAriaAlertLabel ) )
          }, e.prototype.onThemeChange = function ( e ) {
            const t = e.getColor( Fe );
            t && ( this.listElement.style.backgroundColor = t.toString(), this.details.element.style.backgroundColor = t.toString(), this.messageElement.style.backgroundColor = t.toString() );
            const n = e.getColor( We );
            n && ( this.listElement.style.borderColor = n.toString(), this.details.element.style.borderColor = n.toString(), this.messageElement.style.borderColor = n.toString(), this.detailsBorderColor = n.toString() );
            const i = e.getColor( Ne.H );
            i && ( this.detailsFocusBorderColor = i.toString() ), this.details.setBorderWidth( "hc" === e.type ? 2 : 1 )
          }, e.prototype.onListFocus = function ( e ) {
            const t = this;
            if ( !this.ignoreFocusEvents ) {
              if ( !e.elements.length ) return this.currentSuggestionDetails && ( this.currentSuggestionDetails.cancel(), this.currentSuggestionDetails = null, this.focusedItem = null ), void this._ariaAlert( null );
              const n = e.elements[ 0 ];
              if ( this._ariaAlert( this._getSuggestionAriaAlertLabel( n ) ), this.firstFocusInCurrentList = !this.focusedItem, n !== this.focusedItem ) {
                this.currentSuggestionDetails && ( this.currentSuggestionDetails.cancel(), this.currentSuggestionDetails = null );
                const i = e.indexes[ 0 ];
                this.suggestionSupportsAutoAccept.set( !n.suggestion.noAutoAccept ), this.focusedItem = n, this.list.reveal( i ), this.currentSuggestionDetails = Object( v.i )( ( e => {
                  return n.resolve( e )
                } ) ), this.currentSuggestionDetails.then( ( () => {
                  t.ignoreFocusEvents = !0, t.list.splice( i, 1, [ n ] ), t.list.setFocus( [ i ] ), t.ignoreFocusEvents = !1, t.expandDocsSettingFromStorage() ? t.showDetails() : Object( I.G )( t.element, "docs-side" )
                } ) ).catch( o.e ).then( ( () => {
                  t.focusedItem === n && ( t.currentSuggestionDetails = null )
                } ) ), this.onDidFocusEmitter.fire( {
                  item: n,
                  index: i,
                  model: this.completionModel
                } )
              }
            }
          }, e.prototype.setState = function ( t ) {
            if ( this.element ) {
              const n = this.state !== t;
              switch ( this.state = t, Object( I.N )( this.element, "frozen", 4 === t ), t ) {
                case 0:
                  Object( I.A )( this.messageElement, this.details.element, this.listElement ), this.hide(), this.listHeight = 0, n && this.list.splice( 0, this.list.length ), this.focusedItem = null;
                  break;
                case 1:
                  this.messageElement.textContent = e.LOADING_MESSAGE, Object( I.A )( this.listElement, this.details.element ), Object( I.M )( this.messageElement ), Object( I.G )( this.element, "docs-side" ), this.show(), this.focusedItem = null;
                  break;
                case 2:
                  this.messageElement.textContent = e.NO_SUGGESTIONS_MESSAGE, Object( I.A )( this.listElement, this.details.element ), Object( I.M )( this.messageElement ), Object( I.G )( this.element, "docs-side" ), this.show(), this.focusedItem = null;
                  break;
                case 3:
                case 4:
                  Object( I.A )( this.messageElement ), Object( I.M )( this.listElement ), this.show();
                  break;
                case 5:
                  Object( I.A )( this.messageElement ), Object( I.M )( this.details.element, this.listElement ), this.show(), this._ariaAlert( this.details.getAriaLabel() )
              }
            }
          }, e.prototype.showTriggered = function ( e ) {
            const t = this;
            0 === this.state && ( this.isAuto = !!e, this.isAuto || ( this.loadingTimeout = setTimeout( ( () => {
              t.loadingTimeout = null, t.setState( 1 )
            } ), 50 ) ) )
          }, e.prototype.showSuggestions = function ( e, t, n, i ) {
            if ( this.loadingTimeout && ( clearTimeout( this.loadingTimeout ), this.loadingTimeout = null ), this.completionModel !== e && ( this.completionModel = e ), n && 2 !== this.state && 0 !== this.state ) this.setState( 4 );
            else {
              const o = this.completionModel.items.length,
                r = 0 === o;
              if ( this.suggestWidgetMultipleSuggestions.set( o > 1 ), r ) i ? this.setState( 0 ) : this.setState( 2 ), this.completionModel = null;
              else {
                const s = this.completionModel.stats;
                s.wasAutomaticallyTriggered = !!i, this.telemetryService.publicLog( "suggestWidget", Te( {}, s, this.editor.getTelemetryData() ) ), this.list.splice( 0, this.list.length, this.completionModel.items ), n ? this.setState( 4 ) : this.setState( 3 ), this.list.reveal( t, t ), this.list.setFocus( [ t ] ), this.detailsBorderColor && ( this.details.element.style.borderColor = this.detailsBorderColor )
              }
            }
          }, e.prototype.selectNextPage = function () {
            switch ( this.state ) {
              case 0:
                return !1;
              case 5:
                return this.details.pageDown(), !0;
              case 1:
                return !this.isAuto;
              default:
                return this.list.focusNextPage(), !0
            }
          }, e.prototype.selectNext = function () {
            switch ( this.state ) {
              case 0:
                return !1;
              case 1:
                return !this.isAuto;
              default:
                return this.list.focusNext( 1, !0 ), !0
            }
          }, e.prototype.selectLast = function () {
            switch ( this.state ) {
              case 0:
                return !1;
              case 5:
                return this.details.scrollBottom(), !0;
              case 1:
                return !this.isAuto;
              default:
                return this.list.focusLast(), !0
            }
          }, e.prototype.selectPreviousPage = function () {
            switch ( this.state ) {
              case 0:
                return !1;
              case 5:
                return this.details.pageUp(), !0;
              case 1:
                return !this.isAuto;
              default:
                return this.list.focusPreviousPage(), !0
            }
          }, e.prototype.selectPrevious = function () {
            switch ( this.state ) {
              case 0:
                return !1;
              case 1:
                return !this.isAuto;
              default:
                return this.list.focusPrevious( 1, !0 ), !1
            }
          }, e.prototype.selectFirst = function () {
            switch ( this.state ) {
              case 0:
                return !1;
              case 5:
                return this.details.scrollTop(), !0;
              case 1:
                return !this.isAuto;
              default:
                return this.list.focusFirst(), !0
            }
          }, e.prototype.getFocusedItem = function () {
            if ( 0 !== this.state && 2 !== this.state && 1 !== this.state ) return {
              item: this.list.getFocusedElements()[ 0 ],
              index: this.list.getFocus()[ 0 ],
              model: this.completionModel
            }
          }, e.prototype.toggleDetailsFocus = function () {
            5 === this.state ? ( this.setState( 3 ), this.detailsBorderColor && ( this.details.element.style.borderColor = this.detailsBorderColor ) ) : 3 === this.state && this.expandDocsSettingFromStorage() && ( this.setState( 5 ), this.detailsFocusBorderColor && ( this.details.element.style.borderColor = this.detailsFocusBorderColor ) ), this.telemetryService.publicLog( "suggestWidget:toggleDetailsFocus", this.editor.getTelemetryData() )
          }, e.prototype.toggleDetails = function () {
            if ( Ue( this.list.getFocusedElements()[ 0 ] ) )
              if ( this.expandDocsSettingFromStorage() ) this.updateExpandDocsSetting( !1 ), Object( I.A )( this.details.element ), Object( I.G )( this.element, "docs-side" ), Object( I.G )( this.element, "docs-below" ), this.editor.layoutContentWidget( this ), this.telemetryService.publicLog( "suggestWidget:collapseDetails", this.editor.getTelemetryData() );
              else {
                if ( 3 !== this.state && 5 !== this.state && 4 !== this.state ) return;
                this.updateExpandDocsSetting( !0 ), this.showDetails(), this.telemetryService.publicLog( "suggestWidget:expandDetails", this.editor.getTelemetryData() )
              }
          }, e.prototype.showDetails = function () {
            this.expandSideOrBelow(), Object( I.M )( this.details.element ), this.details.render( this.list.getFocusedElements()[ 0 ] ), this.details.element.style.maxHeight = this.maxWidgetHeight + "px", this.listElement.style.marginTop = "0px", this.editor.layoutContentWidget( this ), this.adjustDocsPosition(), this.editor.focus(), this._ariaAlert( this.details.getAriaLabel() )
          }, e.prototype.show = function () {
            const e = this,
              t = this.updateListHeight();
            t !== this.listHeight && ( this.editor.layoutContentWidget( this ), this.listHeight = t ), this.suggestWidgetVisible.set( !0 ), this.showTimeout.cancelAndSet( ( () => {
              Object( I.f )( e.element, "visible" ), e.onDidShowEmitter.fire( e )
            } ), 100 )
          }, e.prototype.hide = function () {
            this.suggestWidgetVisible.reset(), this.suggestWidgetMultipleSuggestions.reset(), Object( I.G )( this.element, "visible" )
          }, e.prototype.hideWidget = function () {
            clearTimeout( this.loadingTimeout ), this.setState( 0 ), this.onDidHideEmitter.fire( this )
          }, e.prototype.getPosition = function () {
            return 0 === this.state ? null : {
              position: this.editor.getPosition(),
              preference: [ Se.a.BELOW, Se.a.ABOVE ]
            }
          }, e.prototype.getDomNode = function () {
            return this.element
          }, e.prototype.getId = () => {
            return e.ID
          }, e.prototype.updateListHeight = function () {
            let e = 0;
            if ( 2 === this.state || 1 === this.state ) e = this.unfocusedHeight;
            else {
              const t = this.list.contentHeight / this.unfocusedHeight;
              e = Math.min( t, 12 ) * this.unfocusedHeight
            }
            return this.element.style.lineHeight = this.unfocusedHeight + "px", this.listElement.style.height = e + "px", this.list.layout( e ), e
          }, e.prototype.adjustDocsPosition = function () {
            const e = this.editor.getConfiguration().fontInfo.lineHeight,
              t = this.editor.getScrolledVisiblePosition( this.editor.getPosition() ),
              n = Object( I.u )( this.editor.getDomNode() ),
              i = n.left + t.left,
              o = n.top + t.top + t.height,
              r = Object( I.u )( this.element ),
              s = r.left,
              a = r.top;
            s < i - this.listWidth ? Object( I.f )( this.element, "list-right" ) : Object( I.G )( this.element, "list-right" ), Object( I.z )( this.element, "docs-side" ) && o - e > a && this.details.element.offsetHeight > this.listElement.offsetHeight && ( this.listElement.style.marginTop = this.details.element.offsetHeight - this.listElement.offsetHeight + "px" )
          }, e.prototype.expandSideOrBelow = function () {
            if ( !Ue( this.focusedItem ) && this.firstFocusInCurrentList ) return Object( I.G )( this.element, "docs-side" ), void Object( I.G )( this.element, "docs-below" );
            const e = this.element.style.maxWidth.match( /(\d+)px/ );
            !e || Number( e[ 1 ] ) < this.maxWidgetWidth ? ( Object( I.f )( this.element, "docs-below" ), Object( I.G )( this.element, "docs-side" ) ) : Ue( this.focusedItem ) && ( Object( I.f )( this.element, "docs-side" ), Object( I.G )( this.element, "docs-below" ) )
          }, Object.defineProperty( e.prototype, "maxWidgetHeight", {
            get() {
              return 12 * this.unfocusedHeight
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "unfocusedHeight", {
            get() {
              const e = this.editor.getConfiguration();
              return e.contribInfo.suggestLineHeight || e.fontInfo.lineHeight
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.getHeight = function ( e ) {
            return this.unfocusedHeight
          }, e.prototype.getTemplateId = e => {
            return "suggestion"
          }, e.prototype.expandDocsSettingFromStorage = function () {
            return this.storageServiceAvailable ? this.storageService.getBoolean( "expandSuggestionDocs", Ee.c.GLOBAL ) : this.expandSuggestionDocs
          }, e.prototype.updateExpandDocsSetting = function ( e ) {
            this.storageServiceAvailable ? this.storageService.store( "expandSuggestionDocs", e, Ee.c.GLOBAL ) : this.expandSuggestionDocs = e
          }, e.prototype.dispose = function () {
            this.state = null, this.suggestionSupportsAutoAccept = null, this.currentSuggestionDetails = null, this.focusedItem = null, this.element = null, this.messageElement = null, this.listElement = null, this.details.dispose(), this.details = null, this.list.dispose(), this.list = null, this.toDispose = Object( s.d )( this.toDispose ), this.loadingTimeout && ( clearTimeout( this.loadingTimeout ), this.loadingTimeout = null ), this.editorBlurTimeout.dispose(), this.showTimeout.dispose()
          }, e.ID = "editor.widget.suggestWidget", e.LOADING_MESSAGE = i.a( "suggestWidget.loading", "Loading..." ), e.NO_SUGGESTIONS_MESSAGE = i.a( "suggestWidget.noSuggestions", "No suggestions." ), e = Re( [ Pe( 1, Oe.a ), Pe( 2, u.e ), Pe( 3, xe.c ), Pe( 4, Ee.a ), Pe( 5, we.a ), Pe( 6, Ie.a ), Pe( 7, De.a ) ], e );
        } )();
      Object( xe.e )( ( ( e, t ) => {
        const n = e.getColor( Be );
        n && t.addRule( ".monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-highlighted-label .highlight { color: " + n + "; }" );
        const i = e.getColor( je );
        i && t.addRule( ".monaco-editor .suggest-widget { color: " + i + "; }" );
        const o = e.getColor( Ne.qb );
        o && t.addRule( ".monaco-editor .suggest-widget a { color: " + o + "; }" );
        const r = e.getColor( Ne.pb );
        r && t.addRule( ".monaco-editor .suggest-widget code { background-color: " + r + "; }" )
      } ) );
      const Ye = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Xe = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        $e = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        Ze = ( () => {
          function e() {}
          return e.prototype.select = ( e, t, n ) => {
            if ( 0 === n.length ) return 0;
            for ( let i = n[ 0 ].score, o = 1; o < n.length; o++ ) {
              const r = n[ o ],
                s = r.score,
                a = r.suggestion;
              if ( s !== i ) break;
              if ( a.preselect ) return o
            }
            return 0
          }, e;
        } )(),
        Qe = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return Ye( t, e ), t.prototype.memorize = ( e, t, n ) => {}, t.prototype.toJSON = () => {}, t.prototype.fromJSON = () => {}, t;
        } )( Ze ),
        Je = ( e => {
          function t() {
            const t = null !== e && e.apply( this, arguments ) || this;
            return t._cache = new b.a( 300, .66 ), t._seq = 0, t
          }
          return Ye( t, e ), t.prototype.memorize = function ( e, t, n ) {
            const i = n.suggestion.label,
              o = e.getLanguageIdentifier().language + "/" + i;
            this._cache.set( o, {
              touch: this._seq++,
              type: n.suggestion.type,
              insertText: n.suggestion.insertText
            } )
          }, t.prototype.select = function ( t, n, i ) {
            if ( 0 !== t.getWordUntilPosition( n ).word.length ) return e.prototype.select.call( this, t, n, i );
            const o = t.getLineContent( n.lineNumber ).substr( n.column - 10, n.column - 1 );
            if ( /\s$/.test( o ) ) return e.prototype.select.call( this, t, n, i );
            for ( var r = -1, s = -1, a = 0; a < i.length; a++ ) {
              const u = i[ a ].suggestion,
                l = t.getLanguageIdentifier().language + "/" + u.label,
                c = this._cache.get( l );
              c && c.touch > s && c.type === u.type && c.insertText === u.insertText && ( s = c.touch, r = a )
            }
            return -1 === r ? e.prototype.select.call( this, t, n, i ) : r
          }, t.prototype.toJSON = function () {
            const e = [];
            return this._cache.forEach( ( ( t, n ) => {
              e.push( [ n, t ] )
            } ) ), e;
          }, t.prototype.fromJSON = function ( e ) {
            this._cache.clear();
            for ( let t = 0, n = e; t < n.length; t++ ) {
              const i = n[ t ],
                o = i[ 0 ],
                r = i[ 1 ];
              r.touch = 0, this._cache.set( o, r )
            }
            this._seq = this._cache.size
          }, t;
        } )( Ze ),
        et = ( e => {
          function t() {
            const t = null !== e && e.apply( this, arguments ) || this;
            return t._trie = b.c.forStrings(), t._seq = 0, t
          }
          return Ye( t, e ), t.prototype.memorize = function ( e, t, n ) {
            const i = e.getWordUntilPosition( t ).word,
              o = e.getLanguageIdentifier().language + "/" + i;
            this._trie.set( o, {
              type: n.suggestion.type,
              insertText: n.suggestion.insertText,
              touch: this._seq++
            } )
          }, t.prototype.select = function ( t, n, i ) {
            const o = t.getWordUntilPosition( n ).word;
            if ( !o ) return e.prototype.select.call( this, t, n, i );
            const r = t.getLanguageIdentifier().language + "/" + o;
            let s = this._trie.get( r );
            if ( s || ( s = this._trie.findSubstr( r ) ), s )
              for ( let a = 0; a < i.length; a++ ) {
                const u = i[ a ].suggestion,
                  l = u.type,
                  c = u.insertText;
                if ( l === s.type && c === s.insertText ) return a
              }
            return e.prototype.select.call( this, t, n, i )
          }, t.prototype.toJSON = function () {
            const e = [];
            return this._trie.forEach( ( ( t, n ) => {
              return e.push( [ n, t ] )
            } ) ), e.sort( ( ( e, t ) => {
              return -( e[ 1 ].touch - t[ 1 ].touch )
            } ) ).forEach( ( ( e, t ) => {
              return e[ 1 ].touch = t
            } ) ), e.slice( 0, 200 );
          }, t.prototype.fromJSON = function ( e ) {
            if ( this._trie.clear(), e.length > 0 ) {
              this._seq = e[ 0 ][ 1 ].touch + 1;
              for ( let t = 0, n = e; t < n.length; t++ ) {
                const i = n[ t ],
                  o = i[ 0 ],
                  r = i[ 1 ];
                this._trie.set( o, r )
              }
            }
          }, t;
        } )( Ze ),
        tt = ( () => {
          function e( e, t ) {
            const n = this;
            this._storageService = t, this._storagePrefix = "suggest/memories", this._persistSoon = new v.c( ( () => {
              return n._flush()
            } ), 3e3 ), this.setMode( e )
          }
          return e.prototype.setMode = function ( e ) {
            if ( this._mode !== e ) {
              this._mode = e, this._strategy = "recentlyUsedByPrefix" === e ? new et : "recentlyUsed" === e ? new Je : new Qe;
              try {
                const t = this._storageService.get( this._storagePrefix + "/" + this._mode, Ee.c.WORKSPACE );
                t && this._strategy.fromJSON( JSON.parse( t ) )
              } catch ( n ) {}
            }
          }, e.prototype.memorize = function ( e, t, n ) {
            this._strategy.memorize( e, t, n ), this._persistSoon.schedule()
          }, e.prototype.select = function ( e, t, n ) {
            return this._strategy.select( e, t, n )
          }, e.prototype._flush = function () {
            const e = JSON.stringify( this._strategy );
            this._storageService.store( this._storagePrefix + "/" + this._mode, e, Ee.c.WORKSPACE )
          }, e = Xe( [ $e( 1, Ee.a ) ], e );
        } )();
      n.d( t, "SuggestController", ( () => {
        return st
      } ) ), n.d( t, "TriggerSuggestAction", ( () => {
        return at
      } ) );
      const nt = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const it = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const ot = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      const rt = ( () => {
        function e( e, t, n ) {
          const i = this;
          this._disposables = [], this._activeAcceptCharacters = new Set, this._disposables.push( t.onDidShow( ( () => {
            return i._onItem( t.getFocusedItem() )
          } ) ) ), this._disposables.push( t.onDidFocus( this._onItem, this ) ), this._disposables.push( t.onDidHide( this.reset, this ) ), this._disposables.push( e.onWillType( ( t => {
            if ( i._activeItem ) {
              const o = t[ t.length - 1 ];
              i._activeAcceptCharacters.has( o ) && e.getConfiguration().contribInfo.acceptSuggestionOnCommitCharacter && n( i._activeItem )
            }
          } ) ) )
        }
        return e.prototype._onItem = function ( e ) {
          if ( e && !Object( r.k )( e.item.suggestion.commitCharacters ) ) {
            this._activeItem = e, this._activeAcceptCharacters.clear();
            for ( let t = 0, n = e.item.suggestion.commitCharacters; t < n.length; t++ ) {
              const i = n[ t ];
              i.length > 0 && this._activeAcceptCharacters.add( i[ 0 ] )
            }
          } else this.reset()
        }, e.prototype.reset = function () {
          this._activeItem = void 0
        }, e.prototype.dispose = function () {
          Object( s.d )( this._disposables )
        }, e;
      } )();

      var st = ( () => {
        function e( e, t, n, i ) {
          const o = this;
          this._editor = e, this._commandService = t, this._contextKeyService = n, this._instantiationService = i, this._toDispose = [], this._model = new E( this._editor ), this._memory = i.createInstance( tt, this._editor.getConfiguration().contribInfo.suggestSelection ), this._toDispose.push( this._model.onDidTrigger( ( e => {
            o._widget || o._createSuggestWidget(), o._widget.showTriggered( e.auto )
          } ) ) ), this._toDispose.push( this._model.onDidSuggest( ( e => {
            const t = o._memory.select( o._editor.getModel(), o._editor.getPosition(), e.completionModel.items );
            o._widget.showSuggestions( e.completionModel, t, e.isFrozen, e.auto )
          } ) ) ), this._toDispose.push( this._model.onDidCancel( ( e => {
            o._widget && !e.retrigger && o._widget.hideWidget()
          } ) ) );
          const r = _.a.AcceptSuggestionsOnEnter.bindTo( n ),
            s = () => {
              const e = o._editor.getConfiguration().contribInfo,
                t = e.acceptSuggestionOnEnter,
                n = e.suggestSelection;
              r.set( "on" === t || "smart" === t ), o._memory.setMode( n )
            };
          this._toDispose.push( this._editor.onDidChangeConfiguration( ( e => {
            return s()
          } ) ) ), s()
        }
        return e.get = t => {
          return t.getContribution( e.ID )
        }, e.prototype._createSuggestWidget = function () {
          const e = this;
          this._widget = this._instantiationService.createInstance( Ge, this._editor ), this._toDispose.push( this._widget.onDidSelect( this._onDidSelectItem, this ) );
          const t = new rt( this._editor, this._widget, ( t => {
            return e._onDidSelectItem( t )
          } ) );
          this._toDispose.push( t, this._model.onDidSuggest( ( e => {
            0 === e.completionModel.items.length && t.reset()
          } ) ) );
          const n = _.a.MakesTextEdit.bindTo( this._contextKeyService );
          this._toDispose.push( this._widget.onDidFocus( ( t => {
            const i = t.item;
            const o = e._editor.getPosition();
            const r = i.position.column - i.suggestion.overwriteBefore;
            const s = o.column;
            let a = !0;
            "smart" !== e._editor.getConfiguration().contribInfo.acceptSuggestionOnEnter || 2 !== e._model.state || i.suggestion.command || i.suggestion.additionalTextEdits || "textmate" === i.suggestion.snippetType || s - r !== i.suggestion.insertText.length || ( a = e._editor.getModel().getValueInRange( {
              startLineNumber: o.lineNumber,
              startColumn: r,
              endLineNumber: o.lineNumber,
              endColumn: s
            } ) !== i.suggestion.insertText );
            n.set( a )
          } ) ) ), this._toDispose.push( {
            dispose() {
              n.reset()
            }
          } )
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.dispose = function () {
          this._toDispose = Object( s.d )( this._toDispose ), this._widget && ( this._widget.dispose(), this._widget = null ), this._model && ( this._model.dispose(), this._model = null )
        }, e.prototype._onDidSelectItem = function ( e ) {
          let t;
          if ( e && e.item ) {
            const n = e.item,
              i = n.suggestion,
              r = n.position,
              s = this._editor.getPosition().column - r.column;
            this._editor.pushUndoStop(), Array.isArray( i.additionalTextEdits ) && this._editor.executeEdits( "suggestController.additionalTextEdits", i.additionalTextEdits.map( ( e => {
              return p.a.replace( f.a.lift( e.range ), e.text )
            } ) ) ), this._memory.memorize( this._editor.getModel(), this._editor.getPosition(), e.item );
            let a = i.insertText;
            "textmate" !== i.snippetType && ( a = g.c.escape( a ) ), m.SnippetController2.get( this._editor ).insert( a, i.overwriteBefore + s, i.overwriteAfter, !1, !1 ), this._editor.pushUndoStop(), i.command ? i.command.id === at.id ? this._model.trigger( {
              auto: !0
            }, !0 ) : ( ( t = this._commandService ).executeCommand.apply( t, [ i.command.id ].concat( i.command.arguments ) ).done( void 0, o.e ), this._model.cancel() ) : this._model.cancel(), this._alertCompletionItem( e.item )
          } else this._model.cancel()
        }, e.prototype._alertCompletionItem = e => {
          const t = e.suggestion,
            n = i.a( "arai.alert.snippet", "Accepting '{0}' did insert the following text: {1}", t.label, t.insertText );
          Object( h.a )( n )
        }, e.prototype.triggerSuggest = function ( e ) {
          this._model.trigger( {
            auto: !1
          }, !1, e ), this._editor.revealLine( this._editor.getPosition().lineNumber, 0 ), this._editor.focus()
        }, e.prototype.acceptSelectedSuggestion = function () {
          if ( this._widget ) {
            const e = this._widget.getFocusedItem();
            this._onDidSelectItem( e )
          }
        }, e.prototype.cancelSuggestWidget = function () {
          this._widget && ( this._model.cancel(), this._widget.hideWidget() )
        }, e.prototype.selectNextSuggestion = function () {
          this._widget && this._widget.selectNext()
        }, e.prototype.selectNextPageSuggestion = function () {
          this._widget && this._widget.selectNextPage()
        }, e.prototype.selectLastSuggestion = function () {
          this._widget && this._widget.selectLast()
        }, e.prototype.selectPrevSuggestion = function () {
          this._widget && this._widget.selectPrevious()
        }, e.prototype.selectPrevPageSuggestion = function () {
          this._widget && this._widget.selectPreviousPage()
        }, e.prototype.selectFirstSuggestion = function () {
          this._widget && this._widget.selectFirst()
        }, e.prototype.toggleSuggestionDetails = function () {
          this._widget && this._widget.toggleDetails()
        }, e.prototype.toggleSuggestionFocus = function () {
          this._widget && this._widget.toggleDetailsFocus()
        }, e.ID = "editor.contrib.suggestController", e = it( [ ot( 1, l.b ), ot( 2, u.e ), ot( 3, a.a ) ], e );
      } )();

      var at = ( e => {
        function t() {
          return e.call( this, {
            id: t.id,
            label: i.a( "suggest.trigger.label", "Trigger Suggest" ),
            alias: "Trigger Suggest",
            precondition: u.d.and( c.a.writable, c.a.hasCompletionItemProvider ),
            kbOpts: {
              kbExpr: c.a.textInputFocus,
              primary: 2058,
              mac: {
                primary: 266
              },
              weight: 100
            }
          } ) || this
        }
        return nt( t, e ), t.prototype.run = ( e, t ) => {
          const n = st.get( t );
          n && n.triggerSuggest()
        }, t.id = "editor.action.triggerSuggest", t;
      } )( d.b );
      Object( d.h )( st ), Object( d.f )( at );
      const ut = d.c.bindToContribution( st.get );
      Object( d.g )( new ut( {
        id: "acceptSelectedSuggestion",
        precondition: _.a.Visible,
        handler( e ) {
          return e.acceptSelectedSuggestion()
        },
        kbOpts: {
          weight: 190,
          kbExpr: c.a.textInputFocus,
          primary: 2
        }
      } ) ), Object( d.g )( new ut( {
        id: "acceptSelectedSuggestionOnEnter",
        precondition: _.a.Visible,
        handler( e ) {
          return e.acceptSelectedSuggestion()
        },
        kbOpts: {
          weight: 190,
          kbExpr: u.d.and( c.a.textInputFocus, _.a.AcceptSuggestionsOnEnter, _.a.MakesTextEdit ),
          primary: 3
        }
      } ) ), Object( d.g )( new ut( {
        id: "hideSuggestWidget",
        precondition: _.a.Visible,
        handler( e ) {
          return e.cancelSuggestWidget()
        },
        kbOpts: {
          weight: 190,
          kbExpr: c.a.textInputFocus,
          primary: 9,
          secondary: [ 1033 ]
        }
      } ) ), Object( d.g )( new ut( {
        id: "selectNextSuggestion",
        precondition: u.d.and( _.a.Visible, _.a.MultipleSuggestions ),
        handler( e ) {
          return e.selectNextSuggestion()
        },
        kbOpts: {
          weight: 190,
          kbExpr: c.a.textInputFocus,
          primary: 18,
          secondary: [ 2066 ],
          mac: {
            primary: 18,
            secondary: [ 2066, 300 ]
          }
        }
      } ) ), Object( d.g )( new ut( {
        id: "selectNextPageSuggestion",
        precondition: u.d.and( _.a.Visible, _.a.MultipleSuggestions ),
        handler( e ) {
          return e.selectNextPageSuggestion()
        },
        kbOpts: {
          weight: 190,
          kbExpr: c.a.textInputFocus,
          primary: 12,
          secondary: [ 2060 ]
        }
      } ) ), Object( d.g )( new ut( {
        id: "selectLastSuggestion",
        precondition: u.d.and( _.a.Visible, _.a.MultipleSuggestions ),
        handler( e ) {
          return e.selectLastSuggestion()
        }
      } ) ), Object( d.g )( new ut( {
        id: "selectPrevSuggestion",
        precondition: u.d.and( _.a.Visible, _.a.MultipleSuggestions ),
        handler( e ) {
          return e.selectPrevSuggestion()
        },
        kbOpts: {
          weight: 190,
          kbExpr: c.a.textInputFocus,
          primary: 16,
          secondary: [ 2064 ],
          mac: {
            primary: 16,
            secondary: [ 2064, 302 ]
          }
        }
      } ) ), Object( d.g )( new ut( {
        id: "selectPrevPageSuggestion",
        precondition: u.d.and( _.a.Visible, _.a.MultipleSuggestions ),
        handler( e ) {
          return e.selectPrevPageSuggestion()
        },
        kbOpts: {
          weight: 190,
          kbExpr: c.a.textInputFocus,
          primary: 11,
          secondary: [ 2059 ]
        }
      } ) ), Object( d.g )( new ut( {
        id: "selectFirstSuggestion",
        precondition: u.d.and( _.a.Visible, _.a.MultipleSuggestions ),
        handler( e ) {
          return e.selectFirstSuggestion()
        }
      } ) ), Object( d.g )( new ut( {
        id: "toggleSuggestionDetails",
        precondition: _.a.Visible,
        handler( e ) {
          return e.toggleSuggestionDetails()
        },
        kbOpts: {
          weight: 190,
          kbExpr: c.a.textInputFocus,
          primary: 2058,
          mac: {
            primary: 266
          }
        }
      } ) ), Object( d.g )( new ut( {
        id: "toggleSuggestionFocus",
        precondition: _.a.Visible,
        handler( e ) {
          return e.toggleSuggestionFocus()
        },
        kbOpts: {
          weight: 190,
          kbExpr: c.a.textInputFocus,
          primary: 2570,
          mac: {
            primary: 778
          }
        }
      } ) )
    },
    eq1K( e, t, n ) {},
    erNZ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) );
      var i;
      const o = n( "N0LK" );
      i = "undefined" !== typeof TextDecoder ? e => {
        return new r( e )
      } : e => {
        return new s
      };
      var r = ( () => {
          function e( e ) {
            this._decoder = new TextDecoder( "UTF-16LE" ), this._capacity = 0 | e, this._buffer = new Uint16Array( this._capacity ), this._completedStrings = null, this._bufferLength = 0
          }
          return e.prototype.reset = function () {
            this._completedStrings = null, this._bufferLength = 0
          }, e.prototype.build = function () {
            return null !== this._completedStrings ? ( this._flushBuffer(), this._completedStrings.join( "" ) ) : this._buildBuffer()
          }, e.prototype._buildBuffer = function () {
            if ( 0 === this._bufferLength ) return "";
            const e = new Uint16Array( this._buffer.buffer, 0, this._bufferLength );
            return this._decoder.decode( e )
          }, e.prototype._flushBuffer = function () {
            const e = this._buildBuffer();
            this._bufferLength = 0, null === this._completedStrings ? this._completedStrings = [ e ] : this._completedStrings[ this._completedStrings.length ] = e
          }, e.prototype.write1 = function ( e ) {
            const t = this._capacity - this._bufferLength;
            t <= 1 && ( 0 === t || o.isHighSurrogate( e ) ) && this._flushBuffer(), this._buffer[ this._bufferLength++ ] = e
          }, e.prototype.appendASCII = function ( e ) {
            this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[ this._bufferLength++ ] = e
          }, e.prototype.appendASCIIString = function ( e ) {
            const t = e.length;
            if ( this._bufferLength + t >= this._capacity ) return this._flushBuffer(), void( this._completedStrings[ this._completedStrings.length ] = e );
            for ( let n = 0; n < t; n++ ) this._buffer[ this._bufferLength++ ] = e.charCodeAt( n )
          }, e;
        } )(),
        s = ( () => {
          function e() {
            this._pieces = [], this._piecesLen = 0
          }
          return e.prototype.reset = function () {
            this._pieces = [], this._piecesLen = 0
          }, e.prototype.build = function () {
            return this._pieces.join( "" )
          }, e.prototype.write1 = function ( e ) {
            this._pieces[ this._piecesLen++ ] = String.fromCharCode( e )
          }, e.prototype.appendASCII = function ( e ) {
            this._pieces[ this._piecesLen++ ] = String.fromCharCode( e )
          }, e.prototype.appendASCIIString = function ( e ) {
            this._pieces[ this._piecesLen++ ] = e
          }, e
        } )()
    },
    fD5p( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "ContextMenuController", ( () => {
        return v
      } ) );
      const i = n( "3/fG" );
      const o = n( "pmY6" );
      const r = n( "VMIq" );
      const s = n( "EffR" );
      const a = n( "WqXY" );
      const u = n( "Uzvx" );
      const l = n( "bexQ" );
      const c = n( "T8No" );
      const d = n( "fjLI" );
      const h = n( "wQH0" );
      const p = n( "sswD" );
      const f = n( "sFUC" );
      const g = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const m = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const _ = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      var v = ( () => {
        function e( e, t, n, i, o, r ) {
          const s = this;
          this._contextMenuService = t, this._contextViewService = n, this._contextKeyService = i, this._keybindingService = o, this._menuService = r, this._toDispose = [], this._contextMenuIsBeingShownCount = 0, this._editor = e, this._toDispose.push( this._editor.onContextMenu( ( e => {
            return s._onContextMenu( e )
          } ) ) ), this._toDispose.push( this._editor.onDidScrollChange( ( e => {
            s._contextMenuIsBeingShownCount > 0 && s._contextViewService.hideContextView()
          } ) ) ), this._toDispose.push( this._editor.onKeyDown( ( e => {
            58 === e.keyCode && ( e.preventDefault(), e.stopPropagation(), s.showContextMenu() )
          } ) ) )
        }
        return e.get = t => {
          return t.getContribution( e.ID )
        }, e.prototype._onContextMenu = function ( e ) {
          if ( !this._editor.getConfiguration().contribInfo.contextmenu ) return this._editor.focus(), void( e.target.position && !this._editor.getSelection().containsPosition( e.target.position ) && this._editor.setPosition( e.target.position ) );
          let t;
          e.target.type !== f.b.OVERLAY_WIDGET && ( e.event.preventDefault(), ( e.target.type === f.b.CONTENT_TEXT || e.target.type === f.b.CONTENT_EMPTY || e.target.type === f.b.TEXTAREA ) && ( this._editor.focus(), e.target.position && !this._editor.getSelection().containsPosition( e.target.position ) && this._editor.setPosition( e.target.position ), e.target.type !== f.b.TEXTAREA && ( t = {
            x: e.event.posx,
            y: e.event.posy + 1
          } ), this.showContextMenu( t ) ) )
        }, e.prototype.showContextMenu = function ( e ) {
          if ( this._editor.getConfiguration().contribInfo.contextmenu )
            if ( this._contextMenuService ) {
              const t = this._getMenuActions();
              t.length > 0 && this._doShowContextMenu( t, e )
            } else this._editor.focus()
        }, e.prototype._getMenuActions = function () {
          const e = [],
            t = this._menuService.createMenu( d.b.EditorContext, this._contextKeyService ),
            n = t.getActions( {
              arg: this._editor.getModel().uri
            } );
          t.dispose();
          for ( let i = 0, o = n; i < o.length; i++ ) {
            const r = o[ i ][ 1 ];
            e.push.apply( e, r ), e.push( new a.e )
          }
          return e.pop(), e
        }, e.prototype._doShowContextMenu = function ( e, t ) {
          const n = this;
          void 0 === t && ( t = null );
          const i = this._editor.getConfiguration().contribInfo.hover;
          this._editor.updateOptions( {
            hover: {
              enabled: !1
            }
          } );
          let o = t;
          if ( !o ) {
            this._editor.revealPosition( this._editor.getPosition(), 1 ), this._editor.render();
            const u = this._editor.getScrolledVisiblePosition( this._editor.getPosition() ),
              l = s.u( this._editor.getDomNode() ),
              c = l.left + u.left,
              d = l.top + u.top + u.height;
            o = {
              x: c,
              y: d
            }
          }
          this._contextMenuIsBeingShownCount++, this._contextMenuService.showContextMenu( {
            getAnchor() {
              return o
            },
            getActions() {
              return r.b.as( e )
            },
            getActionItem( e ) {
              const t = n._keybindingFor( e );
              if ( t ) return new a.b( e, e, {
                label: !0,
                keybinding: t.getLabel(),
                isMenu: !0
              } );
              const i = e;
              return "function" === typeof i.getActionItem ? i.getActionItem() : new a.b( e, e, {
                icon: !0,
                label: !0,
                isMenu: !0
              } )
            },
            getKeyBinding( e ) {
              return n._keybindingFor( e )
            },
            onHide( e ) {
              n._contextMenuIsBeingShownCount--, n._editor.focus(), n._editor.updateOptions( {
                hover: i
              } )
            }
          } )
        }, e.prototype._keybindingFor = function ( e ) {
          return this._keybindingService.lookupKeybinding( e.id )
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.dispose = function () {
          this._contextMenuIsBeingShownCount > 0 && this._contextViewService.hideContextView(), this._toDispose = Object( o.d )( this._toDispose )
        }, e.ID = "editor.contrib.contextmenu", e = m( [ _( 1, u.a ), _( 2, u.b ), _( 3, c.e ), _( 4, l.a ), _( 5, d.a ) ], e );
      } )();
      const y = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.showContextMenu",
            label: i.a( "action.showContextMenu.label", "Show Editor Context Menu" ),
            alias: "Show Editor Context Menu",
            precondition: null,
            kbOpts: {
              kbExpr: h.a.textInputFocus,
              primary: 1092,
              weight: 100
            }
          } ) || this
        }
        return g( t, e ), t.prototype.run = ( e, t ) => {
          v.get( t ).showContextMenu()
        }, t;
      } )( p.b );
      Object( p.h )( v ), Object( p.f )( y )
    },
    fjLI( e, t, n ) {
      "use strict";
      n.d( t, "f", ( () => {
        return c
      } ) ), n.d( t, "b", ( () => {
        return d
      } ) ), n.d( t, "a", ( () => {
        return h
      } ) ), n.d( t, "d", ( () => {
        return p
      } ) ), n.d( t, "e", ( () => {
        return g
      } ) ), n.d( t, "c", ( () => {
        return m
      } ) );
      const i = n( "8HAY" ),
        o = n( "Cg/j" ),
        r = n( "T8No" ),
        s = n( "nnTU" ),
        a = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        u = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        l = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        };

      function c( e ) {
        return void 0 !== e.command
      }
      var d = ( () => {
        function e() {
          this.id = String( e.ID++ )
        }
        return e.ID = 1, e.EditorContext = new e, e.CommandPalette = new e, e.MenubarEditMenu = new e, e.MenubarSelectionMenu = new e, e
      } )();
      var h = Object( o.c )( "menuService" );

      var p = new( ( () => {
        function e() {
          this._commands = Object.create( null ), this._menuItems = Object.create( null )
        }
        return e.prototype.addCommand = function ( e ) {
          const t = this._commands[ e.id ];
          return this._commands[ e.id ] = e, void 0 !== t
        }, e.prototype.getCommand = function ( e ) {
          return this._commands[ e ]
        }, e.prototype.appendMenuItem = function ( e, t ) {
          const n = e.id;
          let i = this._menuItems[ n ];
          return i ? i.push( t ) : this._menuItems[ n ] = i = [ t ], {
            dispose() {
              const e = i.indexOf( t );
              e >= 0 && i.splice( e, 1 )
            }
          };
        }, e.prototype.getMenuItems = function ( e ) {
          const t = e.id,
            n = this._menuItems[ t ] || [];
          return t === d.CommandPalette.id && this._appendImplicitItems( n ), n
        }, e.prototype._appendImplicitItems = function ( e ) {
          for ( var t = new Set, n = 0, i = e.filter( ( e => {
              return c( e )
            } ) ); n < i.length; n++ ) {
            const o = i[ n ],
              r = o.command,
              s = o.alt;
            t.add( r.id ), s && t.add( s.id )
          }
          for ( const a in this._commands ) t.has( a ) || e.push( {
            command: this._commands[ a ]
          } )
        }, e;
      } )() )();

      const f = ( e => {
        function t( t, n, i ) {
          const o = e.call( this, t, n ) || this;
          return o._commandService = i, o
        }
        return a( t, e ), t.prototype.run = function () {
          for ( var e, t = [], n = 0; n < arguments.length; n++ ) t[ n ] = arguments[ n ];
          return ( e = this._commandService ).executeCommand.apply( e, [ this.id ].concat( t ) )
        }, t = u( [ l( 2, s.b ) ], t )
      } )( i.a );
      var g = ( e => {
        function t( t ) {
          let n = this;
          return ( n = "string" === typeof t.title ? e.call( this, "", t.title, "submenu" ) || this : e.call( this, "", t.title.value, "submenu" ) || this ).item = t, n
        }
        return a( t, e ), t
      } )( i.a );
      var m = ( e => {
        function t( n, i, o, r, s ) {
          let a = this;
          return ( a = "string" === typeof n.title ? e.call( this, n.id, n.title, s ) || this : e.call( this, n.id, n.title.value, s ) || this )._cssClass = void 0, a._enabled = !n.precondition || r.contextMatchesRules( n.precondition ), a._options = o || {}, a.item = n, a.alt = i ? new t( i, void 0, a._options, r, s ) : void 0, a
        }
        return a( t, e ), t.prototype.run = function () {
          for ( var t = [], n = 0; n < arguments.length; n++ ) t[ n ] = arguments[ n ];
          let i = [];
          return this._options.arg && ( i = i.concat( [ this._options.arg ] ) ), this._options.shouldForwardArgs && ( i = i.concat( t ) ), e.prototype.run.apply( this, i )
        }, t = u( [ l( 3, r.e ), l( 4, s.b ) ], t );
      } )( f );
    },
    fpMC( e, t, n ) {
      "use strict";
      n.d( t, "e", ( () => {
        return y
      } ) ), n.d( t, "a", ( () => {
        return b
      } ) ), n.d( t, "b", ( () => {
        return C
      } ) ), n.d( t, "c", ( () => {
        return I
      } ) ), n.d( t, "d", ( () => {
        return F
      } ) );
      const i = n( "N0LK" ),
        o = n( "QDVR" );

      function r() {
        for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
        return ( t, n ) => {
          for ( let i = 0, o = e.length; i < o; i++ ) {
            const r = e[ i ]( t, n );
            if ( r ) return r
          }
          return null
        };
      }
      const s = ( ( e, t, n ) => {
        if ( !n || n.length < t.length ) return null;
        let o;
        o = e ? i.startsWithIgnoreCase( n, t ) : 0 === n.indexOf( t );
        if ( !o ) return null;
        return t.length > 0 ? [ {
          start: 0,
          end: t.length
        } ] : []
      } ).bind( void 0, !0 );

      function a( e ) {
        return 97 <= e && e <= 122
      }

      function u( e ) {
        return 65 <= e && e <= 90
      }

      function l( e ) {
        return 48 <= e && e <= 57
      }

      function c( e ) {
        return 32 === e || 9 === e || 10 === e || 13 === e
      }

      function d( e ) {
        return a( e ) || u( e ) || l( e )
      }

      function h( e, t ) {
        return 0 === t.length ? t = [ e ] : e.end === t[ 0 ].start ? t[ 0 ].start = e.start : t.unshift( e ), t
      }

      function p( e, t ) {
        for ( let n = t; n < e.length; n++ ) {
          const i = e.charCodeAt( n );
          if ( u( i ) || l( i ) || n > 0 && !d( e.charCodeAt( n - 1 ) ) ) return n
        }
        return e.length
      }

      function f( e, t, n, i ) {
        if ( n === e.length ) return [];
        if ( i === t.length ) return null;
        if ( e[ n ] !== t[ i ].toLowerCase() ) return null;
        let o = null,
          r = i + 1;
        for ( o = f( e, t, n + 1, i + 1 ); !o && ( r = p( t, r ) ) < t.length; ) o = f( e, t, n + 1, r ), r++;
        return null === o ? null : h( {
          start: i,
          end: i + 1
        }, o )
      }

      function g( e, t ) {
        if ( !t ) return null;
        if ( 0 === ( t = t.trim() ).length ) return null;
        if ( !( e => {
            for ( var t = 0, n = 0, i = 0, o = 0, r = 0; r < e.length; r++ ) u( i = e.charCodeAt( r ) ) && t++, a( i ) && n++, c( i ) && o++;
            return 0 !== t && 0 !== n || 0 !== o ? t <= 5 : e.length <= 30
          } )( e ) ) return null;
        if ( t.length > 60 ) return null;
        const n = ( e => {
          for ( var t = 0, n = 0, i = 0, o = 0, r = 0, s = 0; s < e.length; s++ ) u( r = e.charCodeAt( s ) ) && t++, a( r ) && n++, d( r ) && i++, l( r ) && o++;
          return {
            upperPercent: t / e.length,
            lowerPercent: n / e.length,
            alphaPercent: i / e.length,
            numericPercent: o / e.length
          }
        } )( t );
        if ( !( e => {
            const t = e.upperPercent,
              n = e.lowerPercent,
              i = e.alphaPercent,
              o = e.numericPercent;
            return n > .2 && t < .8 && i > .6 && o < .2
          } )( n ) ) {
          if ( !( e => {
              const t = e.upperPercent;
              return 0 === e.lowerPercent && t > .6
            } )( n ) ) return null;
          t = t.toLowerCase()
        }
        let i = null,
          o = 0;
        for ( e = e.toLowerCase(); o < t.length && null === ( i = f( e, t, 0, o ) ); ) o = p( t, o + 1 );
        return i
      }
      const m = r( s, g, ( ( e, t ) => {
          const n = t.toLowerCase().indexOf( e.toLowerCase() );
          return -1 === n ? null : [ {
            start: n,
            end: n + e.length
          } ]
        } ) ),
        _ = r( s, g, ( ( e, t ) => {
          return function e( t, n, i, o ) {
            if ( i === t.length ) return [];
            if ( o === n.length ) return null;
            if ( t[ i ] === n[ o ] ) {
              let r;
              return ( r = e( t, n, i + 1, o + 1 ) ) ? h( {
                start: o,
                end: o + 1
              }, r ) : null
            }
            return e( t, n, i, o + 1 )
          }( e.toLowerCase(), t.toLowerCase(), 0, 0 );
        } ) ),
        v = new o.a( 1e4 );

      function y( e, t, n ) {
        if ( void 0 === n && ( n = !1 ), "string" !== typeof e || "string" !== typeof t ) return null;
        let o = v.get( e );
        o || ( o = new RegExp( i.convertSimple2RegExpPattern( e ), "i" ), v.set( e, o ) );
        const r = o.exec( t );
        return r ? [ {
          start: r.index,
          end: r.index + r[ 0 ].length
        } ] : n ? _( e, t ) : m( e, t )
      }

      function b( e, t, n ) {
        e = e.toLowerCase(), t = t.toLowerCase();
        for ( var i = [], o = 0, r = 0; r < e.length; ++r ) {
          const s = t.indexOf( e.charAt( r ), o );
          s >= 0 && ( i.push( s ), o = s + 1 )
        }
        return [ i.length, i ]
      }

      function C( e ) {
        let t;
        const n = [];
        if ( !e ) return n;
        for ( let i = 0, o = e; i < o.length; i++ ) {
          const r = o[ i ];
          t && t.end === r ? t.end += 1 : ( t = {
            start: r,
            end: r + 1
          }, n.push( t ) )
        }
        return n
      }

      function w() {
        for ( var e = [], t = [ 0 ], n = 1; n <= 100; n++ ) t.push( -n );
        for ( n = 0; n <= 100; n++ ) {
          const i = t.slice( 0 );
          i[ 0 ] = -n, e.push( i )
        }
        return e
      }
      const S = w(),
        O = w(),
        L = w(),
        x = !1;

      function N( e, t, n, i, o ) {
        function r( e, t, n ) {
          for ( void 0 === n && ( n = " " ); e.length < t; ) e = n + e;
          return e
        }
        for ( var s = " |   |" + i.split( "" ).map( ( e => {
            return r( e, 3 )
          } ) ).join( "|" ) + "\n", a = 0; a <= n; a++ ) s += 0 === a ? " |" : t[ a - 1 ] + "|", s += e[ a ].slice( 0, o + 1 ).map( ( e => {
          return r( e.toString(), 3 )
        } ) ).join( "|" ) + "\n";
        return s
      }

      function E( e, t ) {
        if ( t < 0 || t >= e.length ) return !1;
        switch ( e.charCodeAt( t ) ) {
          case 95:
          case 45:
          case 46:
          case 32:
          case 47:
          case 92:
          case 39:
          case 34:
          case 58:
            return !0;
          default:
            return !1
        }
      }

      function k( e, t ) {
        if ( t < 0 || t >= e.length ) return !1;
        switch ( e.charCodeAt( t ) ) {
          case 32:
          case 9:
            return !0;
          default:
            return !1
        }
      }

      function I( e, t, n, i ) {
        const o = e.length > 100 ? 100 : e.length;
        const r = t.length > 100 ? 100 : t.length;
        let s = 0;
        for ( void 0 === n && ( n = o ); s < n && k( e, s ); ) s += 1;
        if ( s === o ) return [ -100, [] ];
        if ( !( o > r ) ) {
          for ( var a = e.toLowerCase(), u = t.toLowerCase(), l = s, c = 0; l < o && c < r; ) a[ l ] === u[ c ] && ( l += 1 ), c += 1;
          if ( l === o ) {
            for ( l = s + 1; l <= o; l++ )
              for ( c = 1; c <= r; c++ ) {
                let d = -1;
                const h = u[ c - 1 ];
                a[ l - 1 ] === h && ( d = c === l - s ? e[ l - 1 ] === t[ c - 1 ] ? 7 : 5 : h === t[ c - 1 ] || 1 !== c && u[ c - 2 ] !== t[ c - 2 ] ? E( u, c - 2 ) || k( u, c - 2 ) ? 5 : 1 : e[ l - 1 ] === t[ c - 1 ] ? 7 : 5 ), O[ l ][ c ] = d;
                const p = S[ l - 1 ][ c - 1 ] + ( d > 1 ? 1 : d ),
                  f = S[ l - 1 ][ c ] + -1,
                  g = S[ l ][ c - 1 ] + -1;
                g >= f ? g > p ? ( S[ l ][ c ] = g, L[ l ][ c ] = 4 ) : g === p ? ( S[ l ][ c ] = g, L[ l ][ c ] = 6 ) : ( S[ l ][ c ] = p, L[ l ][ c ] = 2 ) : f > p ? ( S[ l ][ c ] = f, L[ l ][ c ] = 1 ) : f === p ? ( S[ l ][ c ] = f, L[ l ][ c ] = 3 ) : ( S[ l ][ c ] = p, L[ l ][ c ] = 2 )
              }
            if ( x && ( console.log( N( S, e, o, t, r ) ), console.log( N( L, e, o, t, r ) ), console.log( N( O, e, o, t, r ) ) ), M = 0, T = -100, R = s, P = i, function e( t, n, i, o, r ) {
                if ( M >= 10 || i < -25 ) return;
                let s = 0;
                for ( ; t > R && n > 0; ) {
                  const a = O[ t ][ n ],
                    u = L[ t ][ n ];
                  if ( 4 === u ) n -= 1, r ? i -= 5 : o.isEmpty() || ( i -= 1 ), r = !1, s = 0;
                  else {
                    if ( !( 2 & u ) ) return;
                    if ( 4 & u && e( t, n - 1, o.isEmpty() ? i : i - 1, o.slice(), r ), i += a, t -= 1, n -= 1, o.unshift( n ), r = !0, 1 === a ) {
                      if ( s += 1, t === R && !P ) return
                    } else i += 1 + s * ( a - 1 ), s = 0
                  }
                }
                M += 1, ( i -= n >= 3 ? 9 : 3 * n ) > T && ( T = i, D = o )
              }( o, r, o === r ? 1 : 0, new A, !1 ), 0 !== M ) return [ T, D.toArray() ]
          }
        }
      }
      var D, M = 0,
        T = 0,
        R = 0,
        P = !1;
      var A = ( () => {
        function e() {}
        return e.prototype.isEmpty = function () {
          return !this._data && ( !this._parent || this._parent.isEmpty() )
        }, e.prototype.unshift = function ( e ) {
          this._data ? this._data.unshift( e ) : this._data = [ e ]
        }, e.prototype.slice = function () {
          const t = new e;
          return t._parent = this, t._parentLen = this._data ? this._data.length : 0, t
        }, e.prototype.toArray = function () {
          if ( !this._data ) return this._parent.toArray();
          for ( var e = [], t = this; t; ) t._parent && t._parent._data && e.push( t._parent._data.slice( t._parent._data.length - t._parentLen ) ), t = t._parent;
          return Array.prototype.concat.apply( this._data, e )
        }, e;
      } )();

      function F( e, t, n ) {
        return ( ( e, t, n, i ) => {
          let o = I( e, t, i );
          if ( o && !n ) return o;
          if ( e.length >= 3 )
            for ( let r = Math.min( 7, e.length - 1 ), s = 1; s < r; s++ ) {
              const a = W( e, s );
              if ( a ) {
                const u = I( a, t, i );
                u && ( u[ 0 ] -= 3, ( !o || u[ 0 ] > o[ 0 ] ) && ( o = u ) )
              }
            }
          return o
        } )( e, t, !0, n );
      }

      function W( e, t ) {
        if ( !( t + 1 >= e.length ) ) {
          const n = e[ t ],
            i = e[ t + 1 ];
          if ( n !== i ) return e.slice( 0, t ) + i + n + e.slice( t + 2 )
        }
      }
    },
    gCVg( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return i
      } ) ), n.d( t, "a", ( () => {
        return a
      } ) );
      var i;
      const o = n( "aokT" );
      const r = n( "cGHE" );
      const s = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      !( e => {
        e[ e.LTR = 0 ] = "LTR", e[ e.RTL = 1 ] = "RTL"
      } )( i || ( i = {} ) );
      var a = ( e => {
        function t( t, n, i, o ) {
          const r = e.call( this, t, n, i, o ) || this;
          return r.selectionStartLineNumber = t, r.selectionStartColumn = n, r.positionLineNumber = i, r.positionColumn = o, r
        }
        return s( t, e ), t.prototype.clone = function () {
          return new t( this.selectionStartLineNumber, this.selectionStartColumn, this.positionLineNumber, this.positionColumn )
        }, t.prototype.toString = function () {
          return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]"
        }, t.prototype.equalsSelection = function ( e ) {
          return t.selectionsEqual( this, e )
        }, t.selectionsEqual = ( e, t ) => {
          return e.selectionStartLineNumber === t.selectionStartLineNumber && e.selectionStartColumn === t.selectionStartColumn && e.positionLineNumber === t.positionLineNumber && e.positionColumn === t.positionColumn
        }, t.prototype.getDirection = function () {
          return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? i.LTR : i.RTL
        }, t.prototype.setEndPosition = function ( e, n ) {
          return this.getDirection() === i.LTR ? new t( this.startLineNumber, this.startColumn, e, n ) : new t( e, n, this.startLineNumber, this.startColumn )
        }, t.prototype.getPosition = function () {
          return new r.a( this.positionLineNumber, this.positionColumn )
        }, t.prototype.setStartPosition = function ( e, n ) {
          return this.getDirection() === i.LTR ? new t( e, n, this.endLineNumber, this.endColumn ) : new t( this.endLineNumber, this.endColumn, e, n )
        }, t.fromPositions = ( e, n ) => {
          return void 0 === n && ( n = e ), new t( e.lineNumber, e.column, n.lineNumber, n.column )
        }, t.liftSelection = e => {
          return new t( e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn )
        }, t.selectionsArrEqual = function ( e, t ) {
          if ( e && !t || !e && t ) return !1;
          if ( !e && !t ) return !0;
          if ( e.length !== t.length ) return !1;
          for ( let n = 0, i = e.length; n < i; n++ )
            if ( !this.selectionsEqual( e[ n ], t[ n ] ) ) return !1;
          return !0
        }, t.isISelection = e => {
          return e && "number" === typeof e.selectionStartLineNumber && "number" === typeof e.selectionStartColumn && "number" === typeof e.positionLineNumber && "number" === typeof e.positionColumn
        }, t.createWithDirection = ( e, n, o, r, s ) => {
          return s === i.LTR ? new t( e, n, o, r ) : new t( o, r, e, n )
        }, t;
      } )( o.a )
    },
    gJAb( e, t, n ) {
      "use strict";
      n.r( t );
      n( "EzsQ" );
      const i = n( "3/fG" ),
        o = n( "pmY6" ),
        r = n( "N0LK" ),
        s = n( "sswD" ),
        a = n( "sFUC" ),
        u = n( "WBhO" ),
        l = n( "twdY" ),
        c = n( "scqD" ),
        d = n( "i/Ef" ),
        h = n( "zrhQ" ),
        p = n( "t9D7" ),
        f = n( "MD5Z" ),
        g = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        m = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        _ = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        v = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            return o._editor = t, o._standaloneThemeService = n, o._modeService = i, o._widget = null, o._register( o._editor.onDidChangeModel( ( e => {
              return o.stop()
            } ) ) ), o._register( o._editor.onDidChangeModelLanguage( ( e => {
              return o.stop()
            } ) ) ), o._register( l.y.onDidChange( ( e => {
              return o.stop()
            } ) ) ), o;
          }
          return g( t, e ), t.get = e => {
            return e.getContribution( t.ID )
          }, t.prototype.getId = () => {
            return t.ID
          }, t.prototype.dispose = function () {
            this.stop(), e.prototype.dispose.call( this )
          }, t.prototype.launch = function () {
            this._widget || this._editor.getModel() && ( this._widget = new b( this._editor, this._standaloneThemeService, this._modeService ) )
          }, t.prototype.stop = function () {
            this._widget && ( this._widget.dispose(), this._widget = null )
          }, t.ID = "editor.contrib.inspectTokens", t = m( [ _( 1, c.a ), _( 2, u.a ) ], t );
        } )( o.a ),
        y = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.inspectTokens",
              label: i.a( "inspectTokens", "Developer: Inspect Tokens" ),
              alias: "Developer: Inspect Tokens",
              precondition: null
            } ) || this
          }
          return g( t, e ), t.prototype.run = ( e, t ) => {
            const n = v.get( t );
            n && n.launch()
          }, t;
        } )( s.b );
      var b = ( e => {
        function t( t, n, i ) {
          const o = e.call( this ) || this;
          return o.allowEditorOverflow = !0, o._editor = t, o._modeService = i, o._model = o._editor.getModel(), o._domNode = document.createElement( "div" ), o._domNode.className = "tokens-inspect-widget", o._tokenizationSupport = ( e => {
            const t = l.y.get( e.language );
            return t || {
              getInitialState() {
                return d.c
              },
              tokenize( t, n, i ) {
                return Object( d.d )( e.language, t, n, i )
              },
              tokenize2( t, n, i ) {
                return Object( d.e )( e.id, t, n, i )
              }
            };
          } )( o._model.getLanguageIdentifier() ), o._compute( o._editor.getPosition() ), o._register( o._editor.onDidChangeCursorPosition( ( e => {
            return o._compute( o._editor.getPosition() )
          } ) ) ), o._editor.addContentWidget( o ), o;
        }
        return g( t, e ), t.prototype.dispose = function () {
          this._editor.removeContentWidget( this ), e.prototype.dispose.call( this )
        }, t.prototype.getId = () => {
          return t._ID
        }, t.prototype._compute = function ( e ) {
          for ( var t = this._getTokensAtLine( e.lineNumber ), n = 0, i = t.tokens1.length - 1; i >= 0; i-- ) {
            const o = t.tokens1[ i ];
            if ( e.column - 1 >= o.offset ) {
              n = i;
              break
            }
          }
          let s = 0;
          for ( i = t.tokens2.length >>> 1; i >= 0; i-- )
            if ( e.column - 1 >= t.tokens2[ i << 1 ] ) {
              s = i;
              break
            }
          let a = "";
          const u = this._model.getLineContent( e.lineNumber );
          let l = "";
          if ( n < t.tokens1.length ) {
            const c = t.tokens1[ n ].offset,
              d = n + 1 < t.tokens1.length ? t.tokens1[ n + 1 ].offset : u.length;
            l = u.substring( c, d )
          }
          a += '<h2 class="tm-token">' + ( e => {
            for ( var t = "", n = 0, i = e.length; n < i; n++ ) {
              const o = e.charCodeAt( n );
              switch ( o ) {
                case 9:
                  t += "&rarr;";
                  break;
                case 32:
                  t += "&middot;";
                  break;
                case 60:
                  t += "&lt;";
                  break;
                case 62:
                  t += "&gt;";
                  break;
                case 38:
                  t += "&amp;";
                  break;
                default:
                  t += String.fromCharCode( o )
              }
            }
            return t
          } )( l ) + '<span class="tm-token-length">(' + l.length + " " + ( 1 === l.length ? "char" : "chars" ) + ")</span></h2>", a += '<hr class="tokens-inspect-separator" style="clear:both"/>';
          const p = this._decodeMetadata( t.tokens2[ 1 + ( s << 1 ) ] );
          a += '<table class="tm-metadata-table"><tbody>', a += '<tr><td class="tm-metadata-key">language</td><td class="tm-metadata-value">' + Object( r.escape )( p.languageIdentifier.language ) + "</td>", a += '<tr><td class="tm-metadata-key">token type</td><td class="tm-metadata-value">' + this._tokenTypeToString( p.tokenType ) + "</td>", a += '<tr><td class="tm-metadata-key">font style</td><td class="tm-metadata-value">' + this._fontStyleToString( p.fontStyle ) + "</td>", a += '<tr><td class="tm-metadata-key">foreground</td><td class="tm-metadata-value">' + h.a.Format.CSS.formatHex( p.foreground ) + "</td>", a += '<tr><td class="tm-metadata-key">background</td><td class="tm-metadata-value">' + h.a.Format.CSS.formatHex( p.background ) + "</td>", a += "</tbody></table>", a += '<hr class="tokens-inspect-separator"/>', n < t.tokens1.length && ( a += '<span class="tm-token-type">' + Object( r.escape )( t.tokens1[ n ].type ) + "</span>" ), this._domNode.innerHTML = a, this._editor.layoutContentWidget( this )
        }, t.prototype._decodeMetadata = function ( e ) {
          const t = l.y.getColorMap(),
            n = l.x.getLanguageId( e ),
            i = l.x.getTokenType( e ),
            o = l.x.getFontStyle( e ),
            r = l.x.getForeground( e ),
            s = l.x.getBackground( e );
          return {
            languageIdentifier: this._modeService.getLanguageIdentifier( n ),
            tokenType: i,
            fontStyle: o,
            foreground: t[ r ],
            background: t[ s ]
          }
        }, t.prototype._tokenTypeToString = e => {
          switch ( e ) {
            case 0:
              return "Other";
            case 1:
              return "Comment";
            case 2:
              return "String";
            case 4:
              return "RegEx"
          }
          return "??"
        }, t.prototype._fontStyleToString = e => {
          let t = "";
          return 1 & e && ( t += "italic " ), 2 & e && ( t += "bold " ), 4 & e && ( t += "underline " ), 0 === t.length && ( t = "---" ), t
        }, t.prototype._getTokensAtLine = function ( e ) {
          const t = this._getStateBeforeLine( e ),
            n = this._tokenizationSupport.tokenize( this._model.getLineContent( e ), t, 0 ),
            i = this._tokenizationSupport.tokenize2( this._model.getLineContent( e ), t, 0 );
          return {
            startState: t,
            tokens1: n.tokens,
            tokens2: i.tokens,
            endState: n.endState
          }
        }, t.prototype._getStateBeforeLine = function ( e ) {
          for ( var t = this._tokenizationSupport.getInitialState(), n = 1; n < e; n++ ) {
            t = this._tokenizationSupport.tokenize( this._model.getLineContent( n ), t, 0 ).endState
          }
          return t
        }, t.prototype.getDomNode = function () {
          return this._domNode
        }, t.prototype.getPosition = function () {
          return {
            position: this._editor.getPosition(),
            preference: [ a.a.BELOW, a.a.ABOVE ]
          }
        }, t._ID = "editor.contrib.inspectTokensWidget", t;
      } )( o.a );
      Object( s.h )( v ), Object( s.f )( y ), Object( p.e )( ( ( e, t ) => {
        const n = e.getColor( f.w );
        if ( n ) {
          const i = e.type === p.b ? 2 : 1;
          t.addRule( ".monaco-editor .tokens-inspect-widget { border: " + i + "px solid " + n + "; }" ), t.addRule( ".monaco-editor .tokens-inspect-widget .tokens-inspect-separator { background-color: " + n + "; }" )
        }
        const o = e.getColor( f.v );
        o && t.addRule( ".monaco-editor .tokens-inspect-widget { background-color: " + o + "; }" )
      } ) )
    },
    gh2A( e, t, n ) {
      "use strict";
      n.r( t );
      n( "xNeX" );
      const i = n( "3/fG" ),
        o = n( "X+cX" ),
        r = n( "/cxE" ),
        s = n( "eLzo" ),
        a = n( "VMIq" ),
        u = n( "WBhO" ),
        l = n( "aokT" ),
        c = n( "twdY" ),
        d = n( "sFUC" ),
        h = n( "sswD" ),
        p = n( "UH51" ),
        f = n( "pmY6" ),
        g = n( "t49l" ),
        m = n( "t9D7" ),
        _ = n( "MD5Z" ),
        v = n( "vATl" ),
        y = n( "n3JV" ),
        b = n( "BBpZ" ),
        C = n( "cGHE" ),
        w = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        S = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        O = ( () => {
          function e( e, t, n ) {
            const i = this;
            this.textModelResolverService = t, this.modeService = n, this.toUnhook = [], this.decorations = [], this.editor = e, this.throttler = new o.e;
            const s = new b.a( e );
            this.toUnhook.push( s ), this.toUnhook.push( s.onMouseMoveOrRelevantKeyDown( ( e => {
              const t = e[ 0 ],
                n = e[ 1 ];
              i.startFindDefinition( t, n )
            } ) ) ), this.toUnhook.push( s.onExecute( ( e => {
              i.isEnabled( e ) && i.gotoDefinition( e.target, e.hasSideBySideModifier ).done( ( () => {
                i.removeDecorations()
              } ), ( e => {
                i.removeDecorations(), Object( r.e )( e )
              } ) )
            } ) ) ), this.toUnhook.push( s.onCancel( ( () => {
              i.removeDecorations(), i.currentWordUnderMouse = null
            } ) ) )
          }
          return e.prototype.startFindDefinition = function ( e, t ) {
            const n = this;
            if ( !this.isEnabled( e, t ) ) return this.currentWordUnderMouse = null, void this.removeDecorations();
            const o = e.target.position,
              u = o ? this.editor.getModel().getWordAtPosition( o ) : null;
            if ( !u ) return this.currentWordUnderMouse = null, void this.removeDecorations();
            if ( !this.currentWordUnderMouse || this.currentWordUnderMouse.startColumn !== u.startColumn || this.currentWordUnderMouse.endColumn !== u.endColumn || this.currentWordUnderMouse.word !== u.word ) {
              this.currentWordUnderMouse = u;
              const c = new v.a( this.editor, 15 );
              this.throttler.queue( ( () => {
                return c.validate( n.editor ) ? n.findDefinition( e.target ) : a.b.wrap( null )
              } ) ).then( ( e => {
                if ( e && e.length && c.validate( n.editor ) )
                  if ( e.length > 1 ) n.addDecoration( new l.a( o.lineNumber, u.startColumn, o.lineNumber, u.endColumn ), ( new s.a ).appendText( i.a( "multipleResults", "Click to show {0} definitions.", e.length ) ) );
                  else {
                    const t = e[ 0 ];
                    if ( !t.uri ) return;
                    n.textModelResolverService.createModelReference( t.uri ).then( ( e => {
                      if ( e.object && e.object.textEditorModel ) {
                        const i = e.object.textEditorModel,
                          r = t.range.startLineNumber;
                        if ( 0 !== i.getLineMaxColumn( r ) ) {
                          let a;
                          const c = n.getPreviewValue( i, r );
                          a = t.origin ? l.a.lift( t.origin ) : new l.a( o.lineNumber, u.startColumn, o.lineNumber, u.endColumn ), n.addDecoration( a, ( new s.a ).appendCodeblock( n.modeService.getModeIdByFilenameOrFirstLine( i.uri.fsPath ), c ) ), e.dispose()
                        } else e.dispose()
                      } else e.dispose()
                    } ) )
                  }
                else n.removeDecorations()
              } ) ).done( void 0, r.e )
            }
          }, e.prototype.getPreviewValue = function ( t, n ) {
            let i = this.getPreviewRangeBasedOnBrackets( t, n );
            return i.endLineNumber - i.startLineNumber >= e.MAX_SOURCE_PREVIEW_LINES && ( i = this.getPreviewRangeBasedOnIndentation( t, n ) ), this.stripIndentationFromPreviewRange( t, n, i )
          }, e.prototype.stripIndentationFromPreviewRange = ( e, t, n ) => {
            for ( var i = e.getLineFirstNonWhitespaceColumn( t ), o = t + 1; o < n.endLineNumber; o++ ) {
              const r = e.getLineFirstNonWhitespaceColumn( o );
              i = Math.min( i, r )
            }
            return e.getValueInRange( n ).replace( new RegExp( "^\\s{" + ( i - 1 ) + "}", "gm" ), "" ).trim()
          }, e.prototype.getPreviewRangeBasedOnIndentation = ( t, n ) => {
            for ( var i = t.getLineFirstNonWhitespaceColumn( n ), o = Math.min( t.getLineCount(), n + e.MAX_SOURCE_PREVIEW_LINES ), r = n + 1; r < o; r++ ) {
              if ( i === t.getLineFirstNonWhitespaceColumn( r ) ) break
            }
            return new l.a( n, 1, r + 1, 1 )
          }, e.prototype.getPreviewRangeBasedOnBrackets = ( t, n ) => {
            for ( var i = Math.min( t.getLineCount(), n + e.MAX_SOURCE_PREVIEW_LINES ), o = [], r = !0, s = t.findNextBracket( new C.a( n, 1 ) ); null !== s; ) {
              if ( 0 === o.length ) o.push( s );
              else {
                const a = o[ o.length - 1 ];
                if ( a.open === s.open && a.isOpen && !s.isOpen ? o.pop() : o.push( s ), 0 === o.length ) {
                  if ( !r ) return new l.a( n, 1, s.range.endLineNumber + 1, 1 );
                  r = !1
                }
              }
              const u = t.getLineMaxColumn( n );
              let c = s.range.endLineNumber;
              let d = s.range.endColumn;
              if ( u === s.range.endColumn && ( c++, d = 1 ), c > i ) return new l.a( n, 1, i + 1, 1 );
              s = t.findNextBracket( new C.a( c, d ) )
            }
            return new l.a( n, 1, i + 1, 1 )
          }, e.prototype.addDecoration = function ( e, t ) {
            const n = {
              range: e,
              options: {
                inlineClassName: "goto-definition-link",
                hoverMessage: t
              }
            };
            this.decorations = this.editor.deltaDecorations( this.decorations, [ n ] )
          }, e.prototype.removeDecorations = function () {
            this.decorations.length > 0 && ( this.decorations = this.editor.deltaDecorations( this.decorations, [] ) )
          }, e.prototype.isEnabled = function ( e, t ) {
            return this.editor.getModel() && e.isNoneOrSingleMouseDown && e.target.type === d.b.CONTENT_TEXT && ( e.hasTriggerModifier || t && t.keyCodeIsTriggerKey ) && c.e.has( this.editor.getModel() )
          }, e.prototype.findDefinition = function ( e ) {
            const t = this.editor.getModel();
            return t ? Object( p.a )( t, e.position ) : a.b.as( null )
          }, e.prototype.gotoDefinition = function ( e, t ) {
            const n = this;
            this.editor.setPosition( e.position );
            const i = new y.DefinitionAction( new y.DefinitionActionConfig( t, !1, !0, !1 ), {
              alias: void 0,
              label: void 0,
              id: void 0,
              precondition: void 0
            } );
            return this.editor.invokeWithinContext( ( e => {
              return i.run( e, n.editor )
            } ) );
          }, e.prototype.getId = () => {
            return e.ID
          }, e.prototype.dispose = function () {
            this.toUnhook = Object( f.d )( this.toUnhook )
          }, e.ID = "editor.contrib.gotodefinitionwithmouse", e.MAX_SOURCE_PREVIEW_LINES = 8, e = w( [ S( 1, g.a ), S( 2, u.a ) ], e );
        } )();
      Object( h.h )( O ), Object( m.e )( ( ( e, t ) => {
        const n = e.getColor( _.m );
        n && t.addRule( ".monaco-editor .goto-definition-link { color: " + n + " !important; }" )
      } ) )
    },
    gqHg( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "c",
        extensions: [ ".c", ".h" ],
        aliases: [ "C", "c" ],
        loader() {
          return o.Promise.wrap( n.e( 63 ).then( n.bind( null, "fhwZ" ) ) )
        }
      } ), Object( i.a )( {
        id: "cpp",
        extensions: [ ".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx" ],
        aliases: [ "C++", "Cpp", "cpp" ],
        loader() {
          return o.Promise.wrap( n.e( 63 ).then( n.bind( null, "fhwZ" ) ) )
        }
      } )
    },
    gslv( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return r
      } ) ), n.d( t, "c", ( () => {
        return s
      } ) ), n.d( t, "b", ( () => {
        return a
      } ) );
      const i = n( "4J+e" ),
        o = n( "N0LK" );

      function r( e ) {
        return i.a( e.path ) || e.authority
      }

      function s( e, t, n ) {
        return !( e !== t ) || !( !e || !t ) && ( n ? Object( o.equalsIgnoreCase )( e.toString(), t.toString() ) : e.toString() === t.toString() )
      }

      function a( e ) {
        const t = i.b( e.path );
        return e.authority && t && !i.d( t ) ? null : e.with( {
          path: t
        } )
      }
    },
    hFdI( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "html",
        extensions: [ ".html", ".htm", ".shtml", ".xhtml", ".mdoc", ".jsp", ".asp", ".aspx", ".jshtm" ],
        aliases: [ "HTML", "htm", "html", "xhtml" ],
        mimetypes: [ "text/html", "text/x-jshtm", "text/template", "text/ng-template" ],
        loader() {
          return o.Promise.wrap( n.e( 269 ).then( n.bind( null, "tpLM" ) ) )
        }
      } )
    },
    hHjc( e, t, n ) {},
    "i/Ef": function ( e, t, n ) {
      "use strict";
      n.d( t, "c", ( () => {
        return r
      } ) ), n.d( t, "b", ( () => {
        return s
      } ) ), n.d( t, "a", ( () => {
        return a
      } ) ), n.d( t, "d", ( () => {
        return u
      } ) ), n.d( t, "e", ( () => {
        return l
      } ) );
      const i = n( "twdY" );
      const o = n( "Tcc1" );
      var r = new( ( () => {
        function e() {}
        return e.prototype.clone = function () {
          return this
        }, e.prototype.equals = function ( e ) {
          return this === e
        }, e
      } )() )();
      var s = "vs.editor.nullMode";
      var a = new i.o( s, 0 );

      function u( e, t, n, i ) {
        return new o.b( [ new o.a( i, "", e ) ], n )
      }

      function l( e, t, n, i ) {
        const r = new Uint32Array( 2 );
        return r[ 0 ] = i, r[ 1 ] = ( 16384 | e << 0 | 2 << 23 ) >>> 0, new o.c( r, n )
      }
    },
    "i/Rh": function ( e, t, n ) {},
    i04g( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return r
      } ) ), n.d( t, "a", ( () => {
        return s
      } ) );
      const i = n( "3/fG" );
      const o = ( () => {
        function e( e, t, n ) {
          void 0 === n && ( n = t ), this.modifierLabels = [ null ], this.modifierLabels[ 2 ] = e, this.modifierLabels[ 1 ] = t, this.modifierLabels[ 3 ] = n
        }
        return e.prototype.toLabel = function ( e, t, n, i, o ) {
          return null === t && null === i ? null : ( ( e, t, n, i, o ) => {
            let r = a( e, t, o );
            null !== i && ( r += " ", r += a( n, i, o ) );
            return r
          } )( e, t, n, i, this.modifierLabels[ o ] );
        }, e;
      } )();
      var r = new o( {
        ctrlKey: "\u2303",
        shiftKey: "\u21e7",
        altKey: "\u2325",
        metaKey: "\u2318",
        separator: ""
      }, {
        ctrlKey: i.a( {
          key: "ctrlKey",
          comment: [ "This is the short form for the Control key on the keyboard" ]
        }, "Ctrl" ),
        shiftKey: i.a( {
          key: "shiftKey",
          comment: [ "This is the short form for the Shift key on the keyboard" ]
        }, "Shift" ),
        altKey: i.a( {
          key: "altKey",
          comment: [ "This is the short form for the Alt key on the keyboard" ]
        }, "Alt" ),
        metaKey: i.a( {
          key: "windowsKey",
          comment: [ "This is the short form for the Windows key on the keyboard" ]
        }, "Windows" ),
        separator: "+"
      }, {
        ctrlKey: i.a( {
          key: "ctrlKey",
          comment: [ "This is the short form for the Control key on the keyboard" ]
        }, "Ctrl" ),
        shiftKey: i.a( {
          key: "shiftKey",
          comment: [ "This is the short form for the Shift key on the keyboard" ]
        }, "Shift" ),
        altKey: i.a( {
          key: "altKey",
          comment: [ "This is the short form for the Alt key on the keyboard" ]
        }, "Alt" ),
        metaKey: i.a( {
          key: "superKey",
          comment: [ "This is the short form for the Super key on the keyboard" ]
        }, "Super" ),
        separator: "+"
      } );
      var s = new o( {
        ctrlKey: i.a( {
          key: "ctrlKey.long",
          comment: [ "This is the long form for the Control key on the keyboard" ]
        }, "Control" ),
        shiftKey: i.a( {
          key: "shiftKey.long",
          comment: [ "This is the long form for the Shift key on the keyboard" ]
        }, "Shift" ),
        altKey: i.a( {
          key: "altKey.long",
          comment: [ "This is the long form for the Alt key on the keyboard" ]
        }, "Alt" ),
        metaKey: i.a( {
          key: "cmdKey.long",
          comment: [ "This is the long form for the Command key on the keyboard" ]
        }, "Command" ),
        separator: "+"
      }, {
        ctrlKey: i.a( {
          key: "ctrlKey.long",
          comment: [ "This is the long form for the Control key on the keyboard" ]
        }, "Control" ),
        shiftKey: i.a( {
          key: "shiftKey.long",
          comment: [ "This is the long form for the Shift key on the keyboard" ]
        }, "Shift" ),
        altKey: i.a( {
          key: "altKey.long",
          comment: [ "This is the long form for the Alt key on the keyboard" ]
        }, "Alt" ),
        metaKey: i.a( {
          key: "windowsKey.long",
          comment: [ "This is the long form for the Windows key on the keyboard" ]
        }, "Windows" ),
        separator: "+"
      }, {
        ctrlKey: i.a( {
          key: "ctrlKey.long",
          comment: [ "This is the long form for the Control key on the keyboard" ]
        }, "Control" ),
        shiftKey: i.a( {
          key: "shiftKey.long",
          comment: [ "This is the long form for the Shift key on the keyboard" ]
        }, "Shift" ),
        altKey: i.a( {
          key: "altKey.long",
          comment: [ "This is the long form for the Alt key on the keyboard" ]
        }, "Alt" ),
        metaKey: i.a( {
          key: "superKey.long",
          comment: [ "This is the long form for the Super key on the keyboard" ]
        }, "Super" ),
        separator: "+"
      } );

      function a( e, t, n ) {
        if ( null === t ) return "";
        const i = [];
        return e.ctrlKey && i.push( n.ctrlKey ), e.shiftKey && i.push( n.shiftKey ), e.altKey && i.push( n.altKey ), e.metaKey && i.push( n.metaKey ), i.push( t ), i.join( n.separator )
      }
    },
    iDAx( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return _
      } ) ), n.d( t, "a", ( () => {
        return y
      } ) ), n.d( t, "d", ( () => {
        return O
      } ) ), n.d( t, "c", ( () => {
        return L
      } ) );
      const i = n( "3/fG" );
      const o = n( "MI8n" );
      const r = n( "pmY6" );
      const s = n( "qj0h" );
      const a = n( "MNsG" );
      const u = n( "CRAX" );
      const l = n( "ic2d" );
      const c = n( "+3Gp" );
      const d = n( "Yr1X" );
      const h = n( "/UlZ" );
      const p = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const f = h.a;
      const g = h.b;
      const m = h.c;
      var _ = new( ( () => {
        function e() {
          this._tabFocus = !1, this._onDidChangeTabFocus = new o.a, this.onDidChangeTabFocus = this._onDidChangeTabFocus.event
        }
        return e.prototype.getTabFocusMode = function () {
          return this._tabFocus
        }, e.prototype.setTabFocusMode = function ( e ) {
          this._tabFocus !== e && ( this._tabFocus = e, this._onDidChangeTabFocus.fire( this._tabFocus ) )
        }, e
      } )() )();
      const v = Object.hasOwnProperty;
      var y = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n._onDidChange = n._register( new o.a ), n.onDidChange = n._onDidChange.event, n._rawOptions = s.g( {}, t || {} ), n._rawOptions.scrollbar = s.g( {}, n._rawOptions.scrollbar || {} ), n._rawOptions.minimap = s.g( {}, n._rawOptions.minimap || {} ), n._rawOptions.find = s.g( {}, n._rawOptions.find || {} ), n._rawOptions.hover = s.g( {}, n._rawOptions.hover || {} ), n._validatedOptions = h.d.validate( n._rawOptions, f ), n.editor = null, n._isDominatedByLongLines = !1, n._lineNumbersDigitCount = 1, n._register( d.a.onDidChangeZoomLevel( ( e => {
            return n._recomputeOptions()
          } ) ) ), n._register( _.onDidChangeTabFocus( ( e => {
            return n._recomputeOptions()
          } ) ) ), n;
        }
        return p( t, e ), t.prototype.observeReferenceElement = e => {}, t.prototype.dispose = function () {
          e.prototype.dispose.call( this )
        }, t.prototype._recomputeOptions = function () {
          const e = this.editor,
            t = this._computeInternalOptions();
          e && e.equals( t ) || ( this.editor = t, e && this._onDidChange.fire( e.createChangeEvent( t ) ) )
        }, t.prototype.getRawOptions = function () {
          return this._rawOptions
        }, t.prototype._computeInternalOptions = function () {
          const e = this._validatedOptions,
            t = this._getEnvConfiguration(),
            n = c.a.createFromRawSettings( this._rawOptions, t.zoomLevel ),
            i = {
              outerWidth: t.outerWidth,
              outerHeight: t.outerHeight,
              fontInfo: this.readConfiguration( n ),
              extraEditorClassName: t.extraEditorClassName,
              isDominatedByLongLines: this._isDominatedByLongLines,
              lineNumbersDigitCount: this._lineNumbersDigitCount,
              emptySelectionClipboard: t.emptySelectionClipboard,
              pixelRatio: t.pixelRatio,
              tabFocusMode: _.getTabFocusMode(),
              accessibilitySupport: t.accessibilitySupport
            };
          return h.f.createInternalEditorOptions( i, e )
        }, t._primitiveArrayEquals = ( e, t ) => {
          if ( e.length !== t.length ) return !1;
          for ( let n = 0; n < e.length; n++ )
            if ( e[ n ] !== t[ n ] ) return !1;
          return !0
        }, t._subsetEquals = function ( e, t ) {
          for ( const n in t )
            if ( v.call( t, n ) ) {
              const i = t[ n ],
                o = e[ n ];
              if ( o === i ) continue;
              if ( Array.isArray( o ) && Array.isArray( i ) ) {
                if ( !this._primitiveArrayEquals( o, i ) ) return !1;
                continue
              }
              if ( "object" === typeof o && "object" === typeof i ) {
                if ( !this._subsetEquals( o, i ) ) return !1;
                continue
              }
              return !1
            } return !0
        }, t.prototype.updateOptions = function ( e ) {
          "undefined" !== typeof e && ( t._subsetEquals( this._rawOptions, e ) || ( this._rawOptions = s.g( this._rawOptions, e || {} ), this._validatedOptions = h.d.validate( this._rawOptions, f ), this._recomputeOptions() ) )
        }, t.prototype.setIsDominatedByLongLines = function ( e ) {
          this._isDominatedByLongLines = e, this._recomputeOptions()
        }, t.prototype.setMaxLineNumber = function ( e ) {
          const n = t._digitCount( e );
          this._lineNumbersDigitCount !== n && ( this._lineNumbersDigitCount = n, this._recomputeOptions() )
        }, t._digitCount = e => {
          for ( var t = 0; e; ) e = Math.floor( e / 10 ), t++;
          return t || 1
        }, t;
      } )( r.a );
      const b = l.a.as( u.b.Configuration );
      const C = {
        id: "editor",
        order: 5,
        type: "object",
        title: i.a( "editorConfigurationTitle", "Editor" ),
        overridable: !0,
        scope: u.a.RESOURCE,
        properties: {
          "editor.fontFamily": {
            type: "string",
            default: g.fontFamily,
            description: i.a( "fontFamily", "Controls the font family." )
          },
          "editor.fontWeight": {
            type: "string",
            enum: [ "normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900" ],
            default: g.fontWeight,
            description: i.a( "fontWeight", "Controls the font weight." )
          },
          "editor.fontSize": {
            type: "number",
            default: g.fontSize,
            description: i.a( "fontSize", "Controls the font size in pixels." )
          },
          "editor.lineHeight": {
            type: "number",
            default: g.lineHeight,
            description: i.a( "lineHeight", "Controls the line height. Use 0 to compute the line height from the font size." )
          },
          "editor.letterSpacing": {
            type: "number",
            default: g.letterSpacing,
            description: i.a( "letterSpacing", "Controls the letter spacing in pixels." )
          },
          "editor.lineNumbers": {
            type: "string",
            enum: [ "off", "on", "relative", "interval" ],
            enumDescriptions: [ i.a( "lineNumbers.off", "Line numbers are not rendered." ), i.a( "lineNumbers.on", "Line numbers are rendered as absolute number." ), i.a( "lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position." ), i.a( "lineNumbers.interval", "Line numbers are rendered every 10 lines." ) ],
            default: "on",
            description: i.a( "lineNumbers", "Controls the display of line numbers." )
          },
          "editor.rulers": {
            type: "array",
            items: {
              type: "number"
            },
            default: f.viewInfo.rulers,
            description: i.a( "rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty." )
          },
          "editor.wordSeparators": {
            type: "string",
            default: f.wordSeparators,
            description: i.a( "wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations." )
          },
          "editor.tabSize": {
            type: "number",
            default: m.tabSize,
            minimum: 1,
            description: i.a( "tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on." ),
            errorMessage: i.a( "tabSize.errorMessage", "Expected 'number'. Note that the value \"auto\" has been replaced by the `editor.detectIndentation` setting." )
          },
          "editor.insertSpaces": {
            type: "boolean",
            default: m.insertSpaces,
            description: i.a( "insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on." ),
            errorMessage: i.a( "insertSpaces.errorMessage", "Expected 'boolean'. Note that the value \"auto\" has been replaced by the `editor.detectIndentation` setting." )
          },
          "editor.detectIndentation": {
            type: "boolean",
            default: m.detectIndentation,
            description: i.a( "detectIndentation", "Controls whether `#editor.tabSize#` and `#editor.insertSpaces#` will be automatically detected when a file is opened based on the file contents." )
          },
          "editor.roundedSelection": {
            type: "boolean",
            default: f.viewInfo.roundedSelection,
            description: i.a( "roundedSelection", "Controls whether selections should have rounded corners." )
          },
          "editor.scrollBeyondLastLine": {
            type: "boolean",
            default: f.viewInfo.scrollBeyondLastLine,
            description: i.a( "scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line." )
          },
          "editor.scrollBeyondLastColumn": {
            type: "number",
            default: f.viewInfo.scrollBeyondLastColumn,
            description: i.a( "scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally." )
          },
          "editor.smoothScrolling": {
            type: "boolean",
            default: f.viewInfo.smoothScrolling,
            description: i.a( "smoothScrolling", "Controls whether the editor will scroll using an animation." )
          },
          "editor.minimap.enabled": {
            type: "boolean",
            default: f.viewInfo.minimap.enabled,
            description: i.a( "minimap.enabled", "Controls whether the minimap is shown." )
          },
          "editor.minimap.side": {
            type: "string",
            enum: [ "left", "right" ],
            default: f.viewInfo.minimap.side,
            description: i.a( "minimap.side", "Controls the side where to render the minimap." )
          },
          "editor.minimap.showSlider": {
            type: "string",
            enum: [ "always", "mouseover" ],
            default: f.viewInfo.minimap.showSlider,
            description: i.a( "minimap.showSlider", "Controls whether the minimap slider is automatically hidden." )
          },
          "editor.minimap.renderCharacters": {
            type: "boolean",
            default: f.viewInfo.minimap.renderCharacters,
            description: i.a( "minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks." )
          },
          "editor.minimap.maxColumn": {
            type: "number",
            default: f.viewInfo.minimap.maxColumn,
            description: i.a( "minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns." )
          },
          "editor.hover.enabled": {
            type: "boolean",
            default: f.contribInfo.hover.enabled,
            description: i.a( "hover.enabled", "Controls whether the hover is shown." )
          },
          "editor.hover.delay": {
            type: "number",
            default: f.contribInfo.hover.delay,
            description: i.a( "hover.delay", "Time delay in milliseconds after which to the hover is shown." )
          },
          "editor.hover.sticky": {
            type: "boolean",
            default: f.contribInfo.hover.sticky,
            description: i.a( "hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it." )
          },
          "editor.find.seedSearchStringFromSelection": {
            type: "boolean",
            default: f.contribInfo.find.seedSearchStringFromSelection,
            description: i.a( "find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection." )
          },
          "editor.find.autoFindInSelection": {
            type: "boolean",
            default: f.contribInfo.find.autoFindInSelection,
            description: i.a( "find.autoFindInSelection", "Controls whether the find operation is carried on selected text or the entire file in the editor." )
          },
          "editor.find.globalFindClipboard": {
            type: "boolean",
            default: f.contribInfo.find.globalFindClipboard,
            description: i.a( "find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS." ),
            included: a.d
          },
          "editor.wordWrap": {
            type: "string",
            enum: [ "off", "on", "wordWrapColumn", "bounded" ],
            enumDescriptions: [ i.a( "wordWrap.off", "Lines will never wrap." ), i.a( "wordWrap.on", "Lines will wrap at the viewport width." ), i.a( {
              key: "wordWrap.wordWrapColumn",
              comment: [ "- `editor.wordWrapColumn` refers to a different setting and should not be localized." ]
            }, "Lines will wrap at `#editor.wordWrapColumn#`." ), i.a( {
              key: "wordWrap.bounded",
              comment: [ "- viewport means the edge of the visible window size.", "- `editor.wordWrapColumn` refers to a different setting and should not be localized." ]
            }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`." ) ],
            default: f.wordWrap,
            description: i.a( {
              key: "wordWrap",
              comment: [ "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.", "- `editor.wordWrapColumn` refers to a different setting and should not be localized." ]
            }, "Controls how lines should wrap." )
          },
          "editor.wordWrapColumn": {
            type: "integer",
            default: f.wordWrapColumn,
            minimum: 1,
            description: i.a( {
              key: "wordWrapColumn",
              comment: [ "- `editor.wordWrap` refers to a different setting and should not be localized.", "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized." ]
            }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`." )
          },
          "editor.wrappingIndent": {
            type: "string",
            enum: [ "none", "same", "indent", "deepIndent" ],
            enumDescriptions: [ i.a( "wrappingIndent.none", "No indentation. Wrapped lines begin at column 1." ), i.a( "wrappingIndent.same", "Wrapped lines get the same indentation as the parent." ), i.a( "wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent." ), i.a( "wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent." ) ],
            default: "same",
            description: i.a( "wrappingIndent", "Controls the indentation of wrapped lines." )
          },
          "editor.mouseWheelScrollSensitivity": {
            type: "number",
            default: f.viewInfo.scrollbar.mouseWheelScrollSensitivity,
            description: i.a( "mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events." )
          },
          "editor.multiCursorModifier": {
            type: "string",
            enum: [ "ctrlCmd", "alt" ],
            enumDescriptions: [ i.a( "multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS." ), i.a( "multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS." ) ],
            default: "alt",
            description: i.a( {
              key: "multiCursorModifier",
              comment: [ "- `ctrlCmd` refers to a value the setting can take and should not be localized.", "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized." ]
            }, "The modifier to be used to add multiple cursors with the mouse. The Go To Definition and Open Link mouse gestures will adapt such that they do not conflict with the multicursor modifier. [Read more](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier)." )
          },
          "editor.multiCursorMergeOverlapping": {
            type: "boolean",
            default: f.multiCursorMergeOverlapping,
            description: i.a( "multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping." )
          },
          "editor.quickSuggestions": {
            anyOf: [ {
              type: "boolean"
            }, {
              type: "object",
              properties: {
                strings: {
                  type: "boolean",
                  default: !1,
                  description: i.a( "quickSuggestions.strings", "Enable quick suggestions inside strings." )
                },
                comments: {
                  type: "boolean",
                  default: !1,
                  description: i.a( "quickSuggestions.comments", "Enable quick suggestions inside comments." )
                },
                other: {
                  type: "boolean",
                  default: !0,
                  description: i.a( "quickSuggestions.other", "Enable quick suggestions outside of strings and comments." )
                }
              }
            } ],
            default: f.contribInfo.quickSuggestions,
            description: i.a( "quickSuggestions", "Controls whether suggestions should automatically show up while typing." )
          },
          "editor.quickSuggestionsDelay": {
            type: "integer",
            default: f.contribInfo.quickSuggestionsDelay,
            minimum: 0,
            description: i.a( "quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up." )
          },
          "editor.parameterHints": {
            type: "boolean",
            default: f.contribInfo.parameterHints,
            description: i.a( "parameterHints", "Enables a pop-up that shows parameter documentation and type information as you type." )
          },
          "editor.autoClosingBrackets": {
            type: "boolean",
            default: f.autoClosingBrackets,
            description: i.a( "autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket." )
          },
          "editor.formatOnType": {
            type: "boolean",
            default: f.contribInfo.formatOnType,
            description: i.a( "formatOnType", "Controls whether the editor should automatically format the line after typing." )
          },
          "editor.formatOnPaste": {
            type: "boolean",
            default: f.contribInfo.formatOnPaste,
            description: i.a( "formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document." )
          },
          "editor.autoIndent": {
            type: "boolean",
            default: f.autoIndent,
            description: i.a( "autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste or move lines. Extensions with indentation rules of the language must be available." )
          },
          "editor.suggestOnTriggerCharacters": {
            type: "boolean",
            default: f.contribInfo.suggestOnTriggerCharacters,
            description: i.a( "suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters." )
          },
          "editor.acceptSuggestionOnEnter": {
            type: "string",
            enum: [ "on", "smart", "off" ],
            default: f.contribInfo.acceptSuggestionOnEnter,
            enumDescriptions: [ "", i.a( "acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change." ), "" ],
            description: i.a( "acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions." )
          },
          "editor.acceptSuggestionOnCommitCharacter": {
            type: "boolean",
            default: f.contribInfo.acceptSuggestionOnCommitCharacter,
            description: i.a( "acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character." )
          },
          "editor.snippetSuggestions": {
            type: "string",
            enum: [ "top", "bottom", "inline", "none" ],
            enumDescriptions: [ i.a( "snippetSuggestions.top", "Show snippet suggestions on top of other suggestions." ), i.a( "snippetSuggestions.bottom", "Show snippet suggestions below other suggestions." ), i.a( "snippetSuggestions.inline", "Show snippets suggestions with other suggestions." ), i.a( "snippetSuggestions.none", "Do not show snippet suggestions." ) ],
            default: f.contribInfo.suggest.snippets,
            description: i.a( "snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted." )
          },
          "editor.emptySelectionClipboard": {
            type: "boolean",
            default: f.emptySelectionClipboard,
            description: i.a( "emptySelectionClipboard", "Controls whether copying without a selection copies the current line." )
          },
          "editor.wordBasedSuggestions": {
            type: "boolean",
            default: f.contribInfo.wordBasedSuggestions,
            description: i.a( "wordBasedSuggestions", "Controls whether completions should be computed based on words in the document." )
          },
          "editor.suggestSelection": {
            type: "string",
            enum: [ "first", "recentlyUsed", "recentlyUsedByPrefix" ],
            enumDescriptions: [ i.a( "suggestSelection.first", "Always select the first suggestion." ), i.a( "suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently." ), i.a( "suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`." ) ],
            default: "recentlyUsed",
            description: i.a( "suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list." )
          },
          "editor.suggestFontSize": {
            type: "integer",
            default: 0,
            minimum: 0,
            description: i.a( "suggestFontSize", "Font size for the suggest widget." )
          },
          "editor.suggestLineHeight": {
            type: "integer",
            default: 0,
            minimum: 0,
            description: i.a( "suggestLineHeight", "Line height for the suggest widget." )
          },
          "editor.suggest.filterGraceful": {
            type: "boolean",
            default: !0,
            description: i.a( "suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos." )
          },
          "editor.suggest.snippetsPreventQuickSuggestions": {
            type: "boolean",
            default: !0,
            description: i.a( "suggest.snippetsPreventQuickSuggestions", "Control whether an active snippet prevents quick suggestions." )
          },
          "editor.selectionHighlight": {
            type: "boolean",
            default: f.contribInfo.selectionHighlight,
            description: i.a( "selectionHighlight", "Controls whether the editor should highlight matches similar to the selection" )
          },
          "editor.occurrencesHighlight": {
            type: "boolean",
            default: f.contribInfo.occurrencesHighlight,
            description: i.a( "occurrencesHighlight", "Controls whether the editor should highlight semantic symbol occurrences." )
          },
          "editor.overviewRulerLanes": {
            type: "integer",
            default: 3,
            description: i.a( "overviewRulerLanes", "Controls the number of decorations that can show up at the same position in the overview ruler." )
          },
          "editor.overviewRulerBorder": {
            type: "boolean",
            default: f.viewInfo.overviewRulerBorder,
            description: i.a( "overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler." )
          },
          "editor.cursorBlinking": {
            type: "string",
            enum: [ "blink", "smooth", "phase", "expand", "solid" ],
            default: h.k( f.viewInfo.cursorBlinking ),
            description: i.a( "cursorBlinking", "Control the cursor animation style." )
          },
          "editor.mouseWheelZoom": {
            type: "boolean",
            default: f.viewInfo.mouseWheelZoom,
            description: i.a( "mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`." )
          },
          "editor.cursorStyle": {
            type: "string",
            enum: [ "block", "block-outline", "line", "line-thin", "underline", "underline-thin" ],
            default: h.l( f.viewInfo.cursorStyle ),
            description: i.a( "cursorStyle", "Controls the cursor style." )
          },
          "editor.cursorWidth": {
            type: "integer",
            default: f.viewInfo.cursorWidth,
            description: i.a( "cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`." )
          },
          "editor.fontLigatures": {
            type: "boolean",
            default: f.viewInfo.fontLigatures,
            description: i.a( "fontLigatures", "Enables/Disables font ligatures." )
          },
          "editor.hideCursorInOverviewRuler": {
            type: "boolean",
            default: f.viewInfo.hideCursorInOverviewRuler,
            description: i.a( "hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler." )
          },
          "editor.renderWhitespace": {
            type: "string",
            enum: [ "none", "boundary", "all" ],
            enumDescriptions: [ "", i.a( "renderWhiteSpace.boundary", "Render whitespace characters except for single spaces between words." ), "" ],
            default: f.viewInfo.renderWhitespace,
            description: i.a( "renderWhitespace", "Controls how the editor should render whitespace characters." )
          },
          "editor.renderControlCharacters": {
            type: "boolean",
            default: f.viewInfo.renderControlCharacters,
            description: i.a( "renderControlCharacters", "Controls whether the editor should render control characters." )
          },
          "editor.renderIndentGuides": {
            type: "boolean",
            default: f.viewInfo.renderIndentGuides,
            description: i.a( "renderIndentGuides", "Controls whether the editor should render indent guides." )
          },
          "editor.highlightActiveIndentGuide": {
            type: "boolean",
            default: f.viewInfo.highlightActiveIndentGuide,
            description: i.a( "highlightActiveIndentGuide", "Controls whether the editor should highlight the active indent guide." )
          },
          "editor.renderLineHighlight": {
            type: "string",
            enum: [ "none", "gutter", "line", "all" ],
            enumDescriptions: [ "", "", "", i.a( "renderLineHighlight.all", "Highlights both the gutter and the current line." ) ],
            default: f.viewInfo.renderLineHighlight,
            description: i.a( "renderLineHighlight", "Controls how the editor should render the current line highlight." )
          },
          "editor.codeLens": {
            type: "boolean",
            default: f.contribInfo.codeLens,
            description: i.a( "codeLens", "Controls whether the editor shows CodeLens" )
          },
          "editor.folding": {
            type: "boolean",
            default: f.contribInfo.folding,
            description: i.a( "folding", "Controls whether the editor has code folding enabled" )
          },
          "editor.foldingStrategy": {
            type: "string",
            enum: [ "auto", "indentation" ],
            default: f.contribInfo.foldingStrategy,
            description: i.a( "foldingStrategy", "Controls the strategy for computing folding ranges. `auto` uses a language specific folding strategy, if available. `indentation` uses the indentation based folding strategy." )
          },
          "editor.showFoldingControls": {
            type: "string",
            enum: [ "always", "mouseover" ],
            default: f.contribInfo.showFoldingControls,
            description: i.a( "showFoldingControls", "Controls whether the fold controls on the gutter are automatically hidden." )
          },
          "editor.matchBrackets": {
            type: "boolean",
            default: f.contribInfo.matchBrackets,
            description: i.a( "matchBrackets", "Highlight matching brackets when one of them is selected." )
          },
          "editor.glyphMargin": {
            type: "boolean",
            default: f.viewInfo.glyphMargin,
            description: i.a( "glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging." )
          },
          "editor.useTabStops": {
            type: "boolean",
            default: f.useTabStops,
            description: i.a( "useTabStops", "Inserting and deleting whitespace follows tab stops." )
          },
          "editor.trimAutoWhitespace": {
            type: "boolean",
            default: m.trimAutoWhitespace,
            description: i.a( "trimAutoWhitespace", "Remove trailing auto inserted whitespace." )
          },
          "editor.stablePeek": {
            type: "boolean",
            default: !1,
            description: i.a( "stablePeek", "Keep peek editors open even when double clicking their content or when hitting `Escape`." )
          },
          "editor.dragAndDrop": {
            type: "boolean",
            default: f.dragAndDrop,
            description: i.a( "dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop." )
          },
          "editor.accessibilitySupport": {
            type: "string",
            enum: [ "auto", "on", "off" ],
            enumDescriptions: [ i.a( "accessibilitySupport.auto", "The editor will use platform APIs to detect when a Screen Reader is attached." ), i.a( "accessibilitySupport.on", "The editor will be permanently optimized for usage with a Screen Reader." ), i.a( "accessibilitySupport.off", "The editor will never be optimized for usage with a Screen Reader." ) ],
            default: f.accessibilitySupport,
            description: i.a( "accessibilitySupport", "Controls whether the editor should run in a mode where it is optimized for screen readers." )
          },
          "editor.showUnused": {
            type: "boolean",
            default: f.showUnused,
            description: i.a( "showUnused", "Controls fading out of unused code." )
          },
          "editor.links": {
            type: "boolean",
            default: f.contribInfo.links,
            description: i.a( "links", "Controls whether the editor should detect links and make them clickable." )
          },
          "editor.colorDecorators": {
            type: "boolean",
            default: f.contribInfo.colorDecorators,
            description: i.a( "colorDecorators", "Controls whether the editor should render the inline color decorators and color picker." )
          },
          "editor.lightbulb.enabled": {
            type: "boolean",
            default: f.contribInfo.lightbulbEnabled,
            description: i.a( "codeActions", "Enables the code action lightbulb in the editor." )
          },
          "editor.codeActionsOnSave": {
            type: "object",
            properties: {
              "source.organizeImports": {
                type: "boolean",
                description: i.a( "codeActionsOnSave.organizeImports", "Controls whether organize imports action should be run on file save." )
              }
            },
            additionalProperties: {
              type: "boolean"
            },
            default: f.contribInfo.codeActionsOnSave,
            description: i.a( "codeActionsOnSave", "Code action kinds to be run on save." )
          },
          "editor.codeActionsOnSaveTimeout": {
            type: "number",
            default: f.contribInfo.codeActionsOnSaveTimeout,
            description: i.a( "codeActionsOnSaveTimeout", "Timeout in milliseconds after which the code actions that are run on save are cancelled." )
          },
          "editor.selectionClipboard": {
            type: "boolean",
            default: f.contribInfo.selectionClipboard,
            description: i.a( "selectionClipboard", "Controls whether the Linux primary clipboard should be supported." ),
            included: a.c
          },
          "diffEditor.renderSideBySide": {
            type: "boolean",
            default: !0,
            description: i.a( "sideBySide", "Controls whether the diff editor shows the diff side by side or inline." )
          },
          "diffEditor.ignoreTrimWhitespace": {
            type: "boolean",
            default: !0,
            description: i.a( "ignoreTrimWhitespace", "Controls whether the diff editor shows changes in leading or trailing whitespace as diffs." )
          },
          "editor.largeFileOptimizations": {
            type: "boolean",
            default: m.largeFileOptimizations,
            description: i.a( "largeFileOptimizations", "Special handling for large files to disable certain memory intensive features." )
          },
          "diffEditor.renderIndicators": {
            type: "boolean",
            default: !0,
            description: i.a( "renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes." )
          }
        }
      };
      let w = null;

      function S() {
        return null === w && ( w = Object.create( null ), Object.keys( C.properties ).forEach( ( e => {
          w[ e ] = !0
        } ) ) ), w;
      }

      function O( e ) {
        return S()[ "editor." + e ] || !1
      }

      function L( e ) {
        return S()[ "diffEditor." + e ] || !1
      }
      b.registerConfiguration( C )
    },
    iJk1( e, t, n ) {},
    iLY9( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "python",
        extensions: [ ".py", ".rpy", ".pyw", ".cpy", ".gyp", ".gypi" ],
        aliases: [ "Python", "py" ],
        firstLine: "^#!/.*\\bpython[0-9.-]*\\b",
        loader() {
          return o.Promise.wrap( n.e( 291 ).then( n.bind( null, "8ahN" ) ) )
        }
      } )
    },
    ic2d( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return r
      } ) );
      const i = n( "746U" );
      const o = n( "FWmy" );
      var r = new( ( () => {
        function e() {
          this.data = {}
        }
        return e.prototype.add = function ( e, t ) {
          o.a( i.h( e ) ), o.a( i.g( t ) ), o.a( !this.data.hasOwnProperty( e ), "There is already an extension with this id" ), this.data[ e ] = t
        }, e.prototype.as = function ( e ) {
          return this.data[ e ] || null
        }, e
      } )() )();
    },
    "ij/i": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "ruby",
        extensions: [ ".rb", ".rbx", ".rjs", ".gemspec" ],
        filenames: [ "rakefile" ],
        aliases: [ "Ruby", "rb" ],
        loader() {
          return o.Promise.wrap( n.e( 298 ).then( n.bind( null, "3MdH" ) ) )
        }
      } )
    },
    iuje( e, t, n ) {
      "use strict";

      function i( e ) {
        return e && "string" === typeof e.id
      }
      n.d( t, "c", ( () => {
        return i
      } ) ), n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) );
      var o = {
          ICodeEditor: "vs.editor.ICodeEditor",
          IDiffEditor: "vs.editor.IDiffEditor"
        },
        r = {
          ExecuteCommand: "executeCommand",
          ExecuteCommands: "executeCommands",
          Type: "type",
          ReplacePreviousChar: "replacePreviousChar",
          CompositionStart: "compositionStart",
          CompositionEnd: "compositionEnd",
          Paste: "paste",
          Cut: "cut",
          Undo: "undo",
          Redo: "redo"
        }
    },
    j2o1( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "powershell",
        extensions: [ ".ps1", ".psm1", ".psd1" ],
        aliases: [ "PowerShell", "powershell", "ps", "ps1" ],
        loader() {
          return o.Promise.wrap( n.e( 289 ).then( n.bind( null, "ppMK" ) ) )
        }
      } )
    },
    "jAJ/": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return u
      } ) ), n.d( t, "d", ( () => {
        return c
      } ) ), n.d( t, "c", ( () => {
        return h
      } ) ), n.d( t, "e", ( () => {
        return p
      } ) ), n.d( t, "b", ( () => {
        return f
      } ) );
      const i = n( "N0LK" );
      const o = n( "cGHE" );
      const r = n( "aokT" );
      const s = n( "M1Kb" );
      const a = n( "5v8Y" );
      var u = ( () => {
        function e( e, t, n, i ) {
          this.searchString = e, this.isRegex = t, this.matchCase = n, this.wordSeparators = i
        }
        return e._isMultilineRegexSource = e => {
          if ( !e || 0 === e.length ) return !1;
          for ( let t = 0, n = e.length; t < n; t++ ) {
            if ( 92 === e.charCodeAt( t ) ) {
              if ( ++t >= n ) break;
              const i = e.charCodeAt( t );
              if ( 110 === i || 114 === i ) return !0
            }
          }
          return !1
        }, e.prototype.parseSearchRequest = function () {
          if ( "" === this.searchString ) return null;
          let t;
          t = this.isRegex ? e._isMultilineRegexSource( this.searchString ) : this.searchString.indexOf( "\n" ) >= 0;
          let n = null;
          try {
            n = i.createRegExp( this.searchString, this.isRegex, {
              matchCase: this.matchCase,
              wholeWord: !1,
              multiline: t,
              global: !0
            } )
          } catch ( r ) {
            return null
          }
          if ( !n ) return null;
          let o = !this.isRegex && !t;
          return o && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && ( o = this.matchCase ), new l( n, this.wordSeparators ? Object( a.a )( this.wordSeparators ) : null, o ? this.searchString : null )
        }, e;
      } )();
      const l = function ( e, t, n ) {
        this.regex = e, this.wordSeparators = t, this.simpleSearch = n
      };

      function c( e, t, n ) {
        if ( !n ) return new s.e( e, null );
        for ( var i = [], o = 0, r = t.length; o < r; o++ ) i[ o ] = t[ o ];
        return new s.e( e, i )
      }

      const d = ( () => {
        function e( e ) {
          for ( var t = [], n = 0, i = 0, o = e.length; i < o; i++ ) 10 === e.charCodeAt( i ) && ( t[ n++ ] = i );
          this._lineFeedsOffsets = t
        }
        return e.prototype.findLineFeedCountBeforeOffset = function ( e ) {
          const t = this._lineFeedsOffsets;
          let n = 0;
          let i = t.length - 1;
          if ( -1 === i ) return 0;
          if ( e <= t[ 0 ] ) return 0;
          for ( ; n < i; ) {
            const o = n + ( ( i - n ) / 2 >> 0 );
            t[ o ] >= e ? i = o - 1 : t[ o + 1 ] >= e ? ( n = o, i = o ) : n = o + 1
          }
          return n + 1
        }, e;
      } )();

      var h = ( () => {
        function e() {}
        return e.findMatches = function ( e, t, n, i, o ) {
          const r = t.parseSearchRequest();
          return r ? r.regex.multiline ? this._doFindMatchesMultiline( e, n, new f( r.wordSeparators, r.regex ), i, o ) : this._doFindMatchesLineByLine( e, n, r, i, o ) : []
        }, e._getMultilineMatchRange = ( e, t, n, i, o, s ) => {
          let a, u, l = 0;
          if ( a = "\r\n" === e.getEOL() ? t + o + ( l = i.findLineFeedCountBeforeOffset( o ) ) : t + o, "\r\n" === e.getEOL() ) {
            const c = i.findLineFeedCountBeforeOffset( o + s.length ) - l;
            u = a + s.length + c
          } else u = a + s.length;
          const d = e.getPositionAt( a ),
            h = e.getPositionAt( u );
          return new r.a( d.lineNumber, d.column, h.lineNumber, h.column )
        }, e._doFindMatchesMultiline = function ( e, t, n, i, o ) {
          let r;
          const a = e.getOffsetAt( t.getStartPosition() );
          const u = e.getValueInRange( t, s.c.LF );
          const l = "\r\n" === e.getEOL() ? new d( u ) : null;
          const h = [];
          let p = 0;
          for ( n.reset( 0 ); r = n.next( u ); )
            if ( h[ p++ ] = c( this._getMultilineMatchRange( e, a, u, l, r.index, r[ 0 ] ), r, i ), p >= o ) return h;
          return h
        }, e._doFindMatchesLineByLine = function ( e, t, n, i, o ) {
          const r = [];
          let s = 0;
          if ( t.startLineNumber === t.endLineNumber ) {
            const a = e.getLineContent( t.startLineNumber ).substring( t.startColumn - 1, t.endColumn - 1 );
            return s = this._findMatchesInLine( n, a, t.startLineNumber, t.startColumn - 1, s, r, i, o ), r
          }
          const u = e.getLineContent( t.startLineNumber ).substring( t.startColumn - 1 );
          s = this._findMatchesInLine( n, u, t.startLineNumber, t.startColumn - 1, s, r, i, o );
          for ( let l = t.startLineNumber + 1; l < t.endLineNumber && s < o; l++ ) s = this._findMatchesInLine( n, e.getLineContent( l ), l, 0, s, r, i, o );
          if ( s < o ) {
            const c = e.getLineContent( t.endLineNumber ).substring( 0, t.endColumn - 1 );
            s = this._findMatchesInLine( n, c, t.endLineNumber, 0, s, r, i, o )
          }
          return r
        }, e._findMatchesInLine = ( e, t, n, i, o, a, u, l ) => {
          const d = e.wordSeparators;
          if ( !u && e.simpleSearch ) {
            for ( let h = e.simpleSearch, g = h.length, m = t.length, _ = -g; - 1 !== ( _ = t.indexOf( h, _ + g ) ); )
              if ( ( !d || p( d, t, m, _, g ) ) && ( a[ o++ ] = new s.e( new r.a( n, _ + 1 + i, n, _ + 1 + g + i ), null ), o >= l ) ) return o;
            return o
          }
          let v;
          const y = new f( e.wordSeparators, e.regex );
          y.reset( 0 );
          do {
            if ( ( v = y.next( t ) ) && ( a[ o++ ] = c( new r.a( n, v.index + 1 + i, n, v.index + 1 + v[ 0 ].length + i ), v, u ), o >= l ) ) return o
          } while ( v );
          return o
        }, e.findNextMatch = function ( e, t, n, i ) {
          const o = t.parseSearchRequest();
          if ( !o ) return null;
          const r = new f( o.wordSeparators, o.regex );
          return o.regex.multiline ? this._doFindNextMatchMultiline( e, n, r, i ) : this._doFindNextMatchLineByLine( e, n, r, i )
        }, e._doFindNextMatchMultiline = function ( e, t, n, i ) {
          const a = new o.a( t.lineNumber, 1 ),
            u = e.getOffsetAt( a ),
            l = e.getLineCount(),
            h = e.getValueInRange( new r.a( a.lineNumber, a.column, l, e.getLineMaxColumn( l ) ), s.c.LF ),
            p = "\r\n" === e.getEOL() ? new d( h ) : null;
          n.reset( t.column - 1 );
          const f = n.next( h );
          return f ? c( this._getMultilineMatchRange( e, u, h, p, f.index, f[ 0 ] ), f, i ) : 1 !== t.lineNumber || 1 !== t.column ? this._doFindNextMatchMultiline( e, new o.a( 1, 1 ), n, i ) : null
        }, e._doFindNextMatchLineByLine = function ( e, t, n, i ) {
          const o = e.getLineCount(),
            r = t.lineNumber,
            s = e.getLineContent( r ),
            a = this._findFirstMatchInLine( n, s, r, t.column, i );
          if ( a ) return a;
          for ( let u = 1; u <= o; u++ ) {
            const l = ( r + u - 1 ) % o,
              c = e.getLineContent( l + 1 ),
              d = this._findFirstMatchInLine( n, c, l + 1, 1, i );
            if ( d ) return d
          }
          return null
        }, e._findFirstMatchInLine = ( e, t, n, i, o ) => {
          e.reset( i - 1 );
          const s = e.next( t );
          return s ? c( new r.a( n, s.index + 1, n, s.index + 1 + s[ 0 ].length ), s, o ) : null
        }, e.findPreviousMatch = function ( e, t, n, i ) {
          const o = t.parseSearchRequest();
          if ( !o ) return null;
          const r = new f( o.wordSeparators, o.regex );
          return o.regex.multiline ? this._doFindPreviousMatchMultiline( e, n, r, i ) : this._doFindPreviousMatchLineByLine( e, n, r, i )
        }, e._doFindPreviousMatchMultiline = function ( e, t, n, i ) {
          const s = this._doFindMatchesMultiline( e, new r.a( 1, 1, t.lineNumber, t.column ), n, i, 9990 );
          if ( s.length > 0 ) return s[ s.length - 1 ];
          const a = e.getLineCount();
          return t.lineNumber !== a || t.column !== e.getLineMaxColumn( a ) ? this._doFindPreviousMatchMultiline( e, new o.a( a, e.getLineMaxColumn( a ) ), n, i ) : null
        }, e._doFindPreviousMatchLineByLine = function ( e, t, n, i ) {
          const o = e.getLineCount(),
            r = t.lineNumber,
            s = e.getLineContent( r ).substring( 0, t.column - 1 ),
            a = this._findLastMatchInLine( n, s, r, i );
          if ( a ) return a;
          for ( let u = 1; u <= o; u++ ) {
            const l = ( o + r - u - 1 ) % o,
              c = e.getLineContent( l + 1 ),
              d = this._findLastMatchInLine( n, c, l + 1, i );
            if ( d ) return d
          }
          return null
        }, e._findLastMatchInLine = ( e, t, n, i ) => {
          let o, s = null;
          for ( e.reset( 0 ); o = e.next( t ); ) s = c( new r.a( n, o.index + 1, n, o.index + 1 + o[ 0 ].length ), o, i );
          return s
        }, e;
      } )();

      function p( e, t, n, i, o ) {
        return ( ( e, t, n, i, o ) => {
          if ( 0 === i ) return !0;
          const r = t.charCodeAt( i - 1 );
          if ( 0 !== e.get( r ) ) return !0;
          if ( 13 === r || 10 === r ) return !0;
          if ( o > 0 ) {
            const s = t.charCodeAt( i );
            if ( 0 !== e.get( s ) ) return !0
          }
          return !1
        } )( e, t, 0, i, o ) && ( ( e, t, n, i, o ) => {
          if ( i + o === n ) return !0;
          const r = t.charCodeAt( i + o );
          if ( 0 !== e.get( r ) ) return !0;
          if ( 13 === r || 10 === r ) return !0;
          if ( o > 0 ) {
            const s = t.charCodeAt( i + o - 1 );
            if ( 0 !== e.get( s ) ) return !0
          }
          return !1
        } )( e, t, n, i, o );
      }
      var f = ( () => {
        function e( e, t ) {
          this._wordSeparators = e, this._searchRegex = t, this._prevMatchStartIndex = -1, this._prevMatchLength = 0
        }
        return e.prototype.reset = function ( e ) {
          this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0
        }, e.prototype.next = function ( e ) {
          let t;
          const n = e.length;
          do {
            if ( this._prevMatchStartIndex + this._prevMatchLength === n ) return null;
            if ( !( t = this._searchRegex.exec( e ) ) ) return null;
            const i = t.index,
              o = t[ 0 ].length;
            if ( i === this._prevMatchStartIndex && o === this._prevMatchLength ) return null;
            if ( this._prevMatchStartIndex = i, this._prevMatchLength = o, !this._wordSeparators || p( this._wordSeparators, e, n, i, o ) ) return t
          } while ( t );
          return null
        }, e;
      } )()
    },
    jVwG( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "objective-c",
        extensions: [ ".m", ".mm" ],
        aliases: [ "Objective-C" ],
        loader() {
          return o.Promise.wrap( n.e( 281 ).then( n.bind( null, "fYNN" ) ) )
        }
      } )
    },
    jqkw( e, t, n ) {
      "use strict";
      n.r( t );
      n( "z3hU" ), n( "9XAT" ), n( "p5tG" ), n( "c2dO" ), n( "LNDK" );
      const i = n( "+KTK" );
      for ( const o in i ) "default" !== o && ( e => {
        n.d( t, e, ( () => {
          return i[ e ]
        } ) )
      } )( o )
    },
    jrbv( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "coffeescript",
        extensions: [ ".coffee", ".litcoffee" ],
        aliases: [ "CoffeeScript", "coffeescript", "coffee" ],
        mimetypes: [ "text/x-coffeescript", "text/coffeescript" ],
        loader() {
          return o.Promise.wrap( n.e( 259 ).then( n.bind( null, "2ZXa" ) ) )
        }
      } )
    },
    k7mE( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "java",
        extensions: [ ".java", ".jav" ],
        aliases: [ "Java", "java" ],
        mimetypes: [ "text/x-java-source", "text/x-java" ],
        loader() {
          return o.Promise.wrap( n.e( 271 ).then( n.bind( null, "BjZ/" ) ) )
        }
      } )
    },
    k7pc( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "ToggleTabFocusModeAction", ( () => {
        return a
      } ) );
      const i = n( "3/fG" );
      const o = n( "sswD" );
      const r = n( "iDAx" );
      const s = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var a = ( e => {
        function t() {
          return e.call( this, {
            id: t.ID,
            label: i.a( {
              key: "toggle.tabMovesFocus",
              comment: [ "Turn on/off use of tab key for moving focus around VS Code" ]
            }, "Toggle Tab Key Moves Focus" ),
            alias: "Toggle Tab Key Moves Focus",
            precondition: null,
            kbOpts: {
              kbExpr: null,
              primary: 2091,
              mac: {
                primary: 1323
              },
              weight: 100
            }
          } ) || this
        }
        return s( t, e ), t.prototype.run = ( e, t ) => {
          const n = r.b.getTabFocusMode();
          r.b.setTabFocusMode( !n )
        }, t.ID = "editor.action.toggleTabFocusMode", t;
      } )( o.b );
      Object( o.f )( a )
    },
    k9mg( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return w
      } ) ), n.d( t, "b", ( () => {
        return S
      } ) ), n.d( t, "c", ( () => {
        return A
      } ) ), n.d( t, "d", ( () => {
        return F
      } ) );
      let i;
      const o = n( "Cg/j" );
      const r = n( "pmY6" );
      const s = n( "T8No" );
      const a = n( "6rrl" );
      const u = n( "ptcw" );
      const l = n( "t9D7" );
      const c = n( "+7oY" );
      const d = n( "3/fG" );
      const h = n( "ic2d" );
      const p = n( "CRAX" );
      const f = n( "X8W9" );
      const g = n( "746U" );
      const m = n( "EffR" );
      const _ = n( "QuOb" );
      const v = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const y = Object.assign || function ( e ) {
        for ( let t, n = 1, i = arguments.length; n < i; n++ )
          for ( const o in t = arguments[ n ] ) Object.prototype.hasOwnProperty.call( t, o ) && ( e[ o ] = t[ o ] );
        return e
      };

      const b = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const C = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      var w = Object( o.c )( "listService" );
      var S = ( () => {
        function e( e ) {
          this.lists = [], this._lastFocusedWidget = void 0
        }
        return Object.defineProperty( e.prototype, "lastFocusedList", {
          get() {
            return this._lastFocusedWidget
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.register = function ( e, t ) {
          const n = this;
          if ( this.lists.some( ( t => {
              return t.widget === e
            } ) ) ) throw new Error( "Cannot register the same widget multiple times" );
          const i = {
            widget: e,
            extraContextKeys: t
          };
          return this.lists.push( i ), e.isDOMFocused() && ( this._lastFocusedWidget = e ), Object( r.c )( [ e.onDidFocus( ( () => {
            return n._lastFocusedWidget = e
          } ) ), Object( r.f )( ( () => {
            return n.lists.splice( n.lists.indexOf( i ), 1 )
          } ) ), e.onDidDispose( ( () => {
            n.lists = n.lists.filter( ( e => {
              return e !== i
            } ) ), n._lastFocusedWidget === e && ( n._lastFocusedWidget = void 0 )
          } ) ) ] );
        }, e = b( [ C( 0, s.e ) ], e );
      } )();
      const O = new s.f( "listFocus", !0 );
      const L = new s.f( "listSupportsMultiselect", !0 );
      const x = new s.f( "listHasSelectionOrFocus", !1 );
      const N = new s.f( "listDoubleSelection", !1 );
      const E = new s.f( "listMultiSelection", !1 );
      let k;
      const I = "workbench.list.multiSelectModifier";
      const D = "workbench.list.openMode";
      const M = "workbench.tree.horizontalScrolling";

      function T( e ) {
        return "alt" === e.getValue( I )
      }

      function R( e ) {
        return "doubleClick" !== e.getValue( D )
      }

      function P( e, t ) {
        return e.controller || ( e.controller = t.createInstance( F, {} ) ), e.styler || ( e.styler = new f.f( ( k || ( k = Object( m.o )() ), k ) ) ), e
      }
      var A = ( e => {
        function t( t, n, i, o, r, s, a, l ) {
          let c = this;
          const d = P( n, a );
          const h = l.getValue( M ) ? _.b.Auto : _.b.Hidden;
          const p = y( {
            horizontalScrollMode: h,
            keyboardSupport: !1
          }, Object( u.d )( s.getTheme(), u.e ), i );
          return ( c = e.call( this, t, d, p ) || this ).disposables = [], c.contextKeyService = ( ( e, t ) => {
            const n = e.createScoped( t.getHTMLElement() );
            return O.bindTo( n ), n
          } )( o, c ), L.bindTo( c.contextKeyService ), c.listHasSelectionOrFocus = x.bindTo( c.contextKeyService ), c.listDoubleSelection = N.bindTo( c.contextKeyService ), c.listMultiSelection = E.bindTo( c.contextKeyService ), c._openOnSingleClick = R( l ), c._useAltAsMultipleSelectionModifier = T( l ), c.disposables.push( c.contextKeyService, r.register( c ), Object( u.b )( c, s ) ), c.disposables.push( c.onDidChangeSelection( ( () => {
            const e = c.getSelection(),
              t = c.getFocus();
            c.listHasSelectionOrFocus.set( e && e.length > 0 || !!t ), c.listDoubleSelection.set( e && 2 === e.length ), c.listMultiSelection.set( e && e.length > 1 )
          } ) ) ), c.disposables.push( c.onDidChangeFocus( ( () => {
            const e = c.getSelection(),
              t = c.getFocus();
            c.listHasSelectionOrFocus.set( e && e.length > 0 || !!t )
          } ) ) ), c.disposables.push( l.onDidChangeConfiguration( ( e => {
            e.affectsConfiguration( D ) && ( c._openOnSingleClick = R( l ) ), e.affectsConfiguration( I ) && ( c._useAltAsMultipleSelectionModifier = T( l ) )
          } ) ) ), c;
        }
        return v( t, e ), t.prototype.dispose = function () {
          e.prototype.dispose.call( this ), this.disposables = Object( r.d )( this.disposables )
        }, t = b( [ C( 3, s.e ), C( 4, w ), C( 5, l.c ), C( 6, o.a ), C( 7, c.b ) ], t )
      } )( a.a );
      var F = ( e => {
        function t( t, n ) {
          const i = e.call(
            this,
            ( e => {
              return "boolean" !== typeof e.keyboardSupport && ( e.keyboardSupport = !1 ), "number" !== typeof e.clickBehavior && ( e.clickBehavior = f.a.ON_MOUSE_DOWN ), e
            } )( t )
          ) || this;
          return i.configurationService = n, i.disposables = [], Object( g.j )( t.openMode ) && ( i.setOpenMode( i.getOpenModeSetting() ), i.registerListeners() ), i
        }
        return v( t, e ), t.prototype.registerListeners = function () {
          const e = this;
          this.disposables.push( this.configurationService.onDidChangeConfiguration( ( t => {
            t.affectsConfiguration( D ) && e.setOpenMode( e.getOpenModeSetting() )
          } ) ) )
        }, t.prototype.getOpenModeSetting = function () {
          return R( this.configurationService ) ? f.g.SINGLE_CLICK : f.g.DOUBLE_CLICK
        }, t.prototype.dispose = function () {
          this.disposables = Object( r.d )( this.disposables )
        }, t = b( [ C( 1, c.b ) ], t );
      } )( f.c );
      h.a.as( p.b.Configuration ).registerConfiguration( {
        id: "workbench",
        order: 7,
        title: Object( d.a )( "workbenchConfigurationTitle", "Workbench" ),
        type: "object",
        properties: ( i = {}, i[ I ] = {
          type: "string",
          enum: [ "ctrlCmd", "alt" ],
          enumDescriptions: [ Object( d.a )( "multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS." ), Object( d.a )( "multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS." ) ],
          default: "ctrlCmd",
          description: Object( d.a )( {
            key: "multiSelectModifier",
            comment: [ "- `ctrlCmd` refers to a value the setting can take and should not be localized.", "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized." ]
          }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier." )
        }, i[ D ] = {
          type: "string",
          enum: [ "singleClick", "doubleClick" ],
          default: "singleClick",
          description: Object( d.a )( {
            key: "openModeModifier",
            comment: [ "`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized." ]
          }, "Controls how to open items in trees and lists using the mouse (if supported). For parents with children in trees, this setting will control if a single click expands the parent or a double click. Note that some trees and lists might choose to ignore this setting if it is not applicable. " )
        }, i[ M ] = {
          type: "boolean",
          default: !1,
          description: Object( d.a )( "horizontalScrolling setting", "Controls whether trees support horizontal scrolling in the workbench." )
        }, i )
      } )
    },
    kYye( e, t, n ) {
      "use strict";
      n.d( t, "o", ( () => {
        return a
      } ) ), n.d( t, "p", ( () => {
        return u
      } ) ), n.d( t, "g", ( () => {
        return d
      } ) ), n.d( t, "f", ( () => {
        return h
      } ) ), n.d( t, "l", ( () => {
        return f
      } ) ), n.d( t, "a", ( () => {
        return g
      } ) ), n.d( t, "q", ( () => {
        return m
      } ) ), n.d( t, "b", ( () => {
        return v
      } ) ), n.d( t, "s", ( () => {
        return y
      } ) ), n.d( t, "e", ( () => {
        return b
      } ) ), n.d( t, "c", ( () => {
        return C
      } ) ), n.d( t, "d", ( () => {
        return w
      } ) ), n.d( t, "r", ( () => {
        return S
      } ) ), n.d( t, "i", ( () => {
        return L
      } ) ), n.d( t, "h", ( () => {
        return x
      } ) ), n.d( t, "w", ( () => {
        return N
      } ) ), n.d( t, "v", ( () => {
        return E
      } ) ), n.d( t, "n", ( () => {
        return k
      } ) ), n.d( t, "m", ( () => {
        return I
      } ) ), n.d( t, "k", ( () => {
        return D
      } ) ), n.d( t, "j", ( () => {
        return M
      } ) ), n.d( t, "t", ( () => {
        return T
      } ) ), n.d( t, "u", ( () => {
        return R
      } ) ), n.d( t, "x", ( () => {
        return P
      } ) ), n.d( t, "z", ( () => {
        return A
      } ) ), n.d( t, "y", ( () => {
        return F
      } ) );
      const i = n( "3/fG" );
      const o = n( "MD5Z" );
      const r = n( "t9D7" );
      const s = n( "zrhQ" );
      var a = Object( o.kb )( "editor.lineHighlightBackground", {
        dark: null,
        light: null,
        hc: null
      }, i.a( "lineHighlight", "Background color for the highlight of line at the cursor position." ) );
      var u = Object( o.kb )( "editor.lineHighlightBorder", {
        dark: "#282828",
        light: "#eeeeee",
        hc: "#f38518"
      }, i.a( "lineHighlightBorderBox", "Background color for the border around the line at the cursor position." ) );
      const l = Object( o.kb )( "editor.rangeHighlightBackground", {
        dark: "#ffffff0b",
        light: "#fdff0033",
        hc: null
      }, i.a( "rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque to not hide underlying decorations." ), !0 );
      const c = Object( o.kb )( "editor.rangeHighlightBorder", {
        dark: null,
        light: null,
        hc: o.b
      }, i.a( "rangeHighlightBorder", "Background color of the border around highlighted ranges." ), !0 );
      var d = Object( o.kb )( "editorCursor.foreground", {
        dark: "#AEAFAD",
        light: s.a.black,
        hc: s.a.white
      }, i.a( "caret", "Color of the editor cursor." ) );
      var h = Object( o.kb )( "editorCursor.background", null, i.a( "editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor." ) );
      const p = Object( o.kb )( "editorWhitespace.foreground", {
        dark: "#e3e4e229",
        light: "#33333333",
        hc: "#e3e4e229"
      }, i.a( "editorWhitespaces", "Color of whitespace characters in the editor." ) );
      var f = Object( o.kb )( "editorIndentGuide.background", {
        dark: p,
        light: p,
        hc: p
      }, i.a( "editorIndentGuides", "Color of the editor indentation guides." ) );
      var g = Object( o.kb )( "editorIndentGuide.activeBackground", {
        dark: p,
        light: p,
        hc: p
      }, i.a( "editorActiveIndentGuide", "Color of the active editor indentation guides." ) );
      var m = Object( o.kb )( "editorLineNumber.foreground", {
        dark: "#858585",
        light: "#237893",
        hc: s.a.white
      }, i.a( "editorLineNumbers", "Color of editor line numbers." ) );
      const _ = Object( o.kb )( "editorActiveLineNumber.foreground", {
        dark: "#c6c6c6",
        light: "#0B216F",
        hc: o.b
      }, i.a( "editorActiveLineNumber", "Color of editor active line number" ), !1, i.a( "deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead." ) );
      var v = Object( o.kb )( "editorLineNumber.activeForeground", {
        dark: _,
        light: _,
        hc: _
      }, i.a( "editorActiveLineNumber", "Color of editor active line number" ) );
      var y = Object( o.kb )( "editorRuler.foreground", {
        dark: "#5A5A5A",
        light: s.a.lightgrey,
        hc: s.a.white
      }, i.a( "editorRuler", "Color of the editor rulers." ) );
      var b = Object( o.kb )( "editorCodeLens.foreground", {
        dark: "#999999",
        light: "#999999",
        hc: "#999999"
      }, i.a( "editorCodeLensForeground", "Foreground color of editor code lenses" ) );
      var C = Object( o.kb )( "editorBracketMatch.background", {
        dark: "#0064001a",
        light: "#0064001a",
        hc: "#0064001a"
      }, i.a( "editorBracketMatchBackground", "Background color behind matching brackets" ) );
      var w = Object( o.kb )( "editorBracketMatch.border", {
        dark: "#888",
        light: "#B9B9B9",
        hc: "#fff"
      }, i.a( "editorBracketMatchBorder", "Color for matching brackets boxes" ) );
      var S = Object( o.kb )( "editorOverviewRuler.border", {
        dark: "#7f7f7f4d",
        light: "#7f7f7f4d",
        hc: "#7f7f7f4d"
      }, i.a( "editorOverviewRulerBorder", "Color of the overview ruler border." ) );
      const O = Object( o.kb )( "editorGutter.background", {
        dark: o.n,
        light: o.n,
        hc: o.n
      }, i.a( "editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers." ) );
      var L = Object( o.kb )( "editorError.foreground", {
        dark: "#ea4646",
        light: "#d60a0a",
        hc: null
      }, i.a( "errorForeground", "Foreground color of error squigglies in the editor." ) );
      var x = Object( o.kb )( "editorError.border", {
        dark: null,
        light: null,
        hc: s.a.fromHex( "#E47777" ).transparent( .8 )
      }, i.a( "errorBorder", "Border color of error squigglies in the editor." ) );
      var N = Object( o.kb )( "editorWarning.foreground", {
        dark: "#4d9e4d",
        light: "#117711",
        hc: null
      }, i.a( "warningForeground", "Foreground color of warning squigglies in the editor." ) );
      var E = Object( o.kb )( "editorWarning.border", {
        dark: null,
        light: null,
        hc: s.a.fromHex( "#71B771" ).transparent( .8 )
      }, i.a( "warningBorder", "Border color of warning squigglies in the editor." ) );
      var k = Object( o.kb )( "editorInfo.foreground", {
        dark: "#008000",
        light: "#008000",
        hc: null
      }, i.a( "infoForeground", "Foreground color of info squigglies in the editor." ) );
      var I = Object( o.kb )( "editorInfo.border", {
        dark: null,
        light: null,
        hc: s.a.fromHex( "#71B771" ).transparent( .8 )
      }, i.a( "infoBorder", "Border color of info squigglies in the editor." ) );
      var D = Object( o.kb )( "editorHint.foreground", {
        dark: s.a.fromHex( "#eeeeee" ).transparent( .7 ),
        light: "#6c6c6c",
        hc: null
      }, i.a( "hintForeground", "Foreground color of hint squigglies in the editor." ) );
      var M = Object( o.kb )( "editorHint.border", {
        dark: null,
        light: null,
        hc: s.a.fromHex( "#eeeeee" ).transparent( .8 )
      }, i.a( "hintBorder", "Border color of hint squigglies in the editor." ) );
      var T = Object( o.kb )( "editorUnnecessaryCode.border", {
        dark: null,
        light: null,
        hc: s.a.fromHex( "#fff" ).transparent( .8 )
      }, i.a( "unnecessaryCodeBorder", "Border of unnecessary code in the editor." ) );
      var R = Object( o.kb )( "editorUnnecessaryCode.opacity", {
        dark: s.a.fromHex( "#000a" ),
        light: s.a.fromHex( "#0007" ),
        hc: null
      }, i.a( "unnecessaryCodeOpacity", "Opacity of unnecessary code in the editor." ) );
      var P = Object( o.kb )( "editorOverviewRuler.errorForeground", {
        dark: new s.a( new s.c( 255, 18, 18, .7 ) ),
        light: new s.a( new s.c( 255, 18, 18, .7 ) ),
        hc: new s.a( new s.c( 255, 50, 50, 1 ) )
      }, i.a( "overviewRuleError", "Overview ruler marker color for errors." ) );
      var A = Object( o.kb )( "editorOverviewRuler.warningForeground", {
        dark: new s.a( new s.c( 18, 136, 18, .7 ) ),
        light: new s.a( new s.c( 18, 136, 18, .7 ) ),
        hc: new s.a( new s.c( 50, 255, 50, 1 ) )
      }, i.a( "overviewRuleWarning", "Overview ruler marker color for warnings." ) );
      var F = Object( o.kb )( "editorOverviewRuler.infoForeground", {
        dark: new s.a( new s.c( 18, 18, 136, .7 ) ),
        light: new s.a( new s.c( 18, 18, 136, .7 ) ),
        hc: new s.a( new s.c( 50, 50, 255, 1 ) )
      }, i.a( "overviewRuleInfo", "Overview ruler marker color for infos." ) );
      Object( r.e )( ( ( e, t ) => {
        const n = e.getColor( o.n );
        n && t.addRule( ".monaco-editor, .monaco-editor-background, .monaco-editor .inputarea.ime-input { background-color: " + n + "; }" );
        const i = e.getColor( o.u );
        i && t.addRule( ".monaco-editor, .monaco-editor .inputarea.ime-input { color: " + i + "; }" );
        const r = e.getColor( O );
        r && t.addRule( ".monaco-editor .margin { background-color: " + r + "; }" );
        const s = e.getColor( l );
        s && t.addRule( ".monaco-editor .rangeHighlight { background-color: " + s + "; }" );
        const a = e.getColor( c );
        a && t.addRule( ".monaco-editor .rangeHighlight { border: 1px " + ( "hc" === e.type ? "dotted" : "solid" ) + " " + a + "; }" );
        const u = e.getColor( p );
        u && t.addRule( ".vs-whitespace { color: " + u + " !important; }" )
      } ) )
    },
    kdPm( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "cameligo",
        extensions: [ ".mligo" ],
        aliases: [ "Cameligo" ],
        loader() {
          return o.Promise.wrap( n.e( 257 ).then( n.bind( null, "3VBA" ) ) )
        }
      } )
    },
    kqbb( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "zrhQ" );

      function o( e, t ) {
        switch ( void 0 === t && ( t = 0 ), typeof e ) {
          case "object":
            return null === e ? r( 349, t ) : Array.isArray( e ) ? ( n = e, i = r( 104579, i = t ), n.reduce( ( ( e, t ) => {
              return o( t, e )
            } ), i ) ) : ( ( e, t ) => {
              return t = r( 181387, t ), Object.keys( e ).sort().reduce( ( ( t, n ) => {
                return t = s( n, t ), o( e[ n ], t )
              } ), t );
            } )( e, t );
          case "string":
            return s( e, t );
          case "boolean":
            return ( ( e, t ) => {
              return r( e ? 433 : 863, t )
            } )( e, t );
          case "number":
            return r( e, t );
          case "undefined":
            return r( e, 937 );
          default:
            return r( e, 617 )
        }
        var n, i
      }

      function r( e, t ) {
        return ( t << 5 ) - t + e | 0
      }

      function s( e, t ) {
        t = r( 149417, t );
        for ( let n = 0, i = e.length; n < i; n++ ) t = r( e.charCodeAt( n ), t );
        return t
      }
      const a = n( "pmY6" ),
        u = n( "sswD" ),
        l = n( "aokT" ),
        c = n( "twdY" ),
        d = n( "Vxe3" ),
        h = n( "ZIMw" ),
        p = n( "+7oY" ),
        f = n( "tX9W" ),
        g = n( "X+cX" ),
        m = n( "/cxE" );
      n.d( t, "ColorDetector", ( () => {
        return y
      } ) );

      const _ = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const v = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      var y = ( () => {
        function e( e, t, n ) {
          const i = this;
          this._editor = e, this._codeEditorService = t, this._configurationService = n, this._globalToDispose = [], this._localToDispose = [], this._decorationsIds = [], this._colorDatas = new Map, this._colorDecoratorIds = [], this._decorationsTypes = {}, this._globalToDispose.push( e.onDidChangeModel( ( e => {
            i._isEnabled = i.isEnabled(), i.onModelChanged()
          } ) ) ), this._globalToDispose.push( e.onDidChangeModelLanguage( ( e => {
            return i.onModelChanged()
          } ) ) ), this._globalToDispose.push( c.d.onDidChange( ( e => {
            return i.onModelChanged()
          } ) ) ), this._globalToDispose.push( e.onDidChangeConfiguration( ( e => {
            const t = i._isEnabled;
            i._isEnabled = i.isEnabled(), t !== i._isEnabled && ( i._isEnabled ? i.onModelChanged() : i.removeAllDecorations() )
          } ) ) ), this._timeoutTimer = null, this._computePromise = null, this._isEnabled = this.isEnabled(), this.onModelChanged()
        }
        return e.prototype.isEnabled = function () {
          const e = this._editor.getModel();
          if ( !e ) return !1;
          const t = e.getLanguageIdentifier(),
            n = this._configurationService.getValue( t.language );
          if ( n ) {
            const i = n.colorDecorators;
            if ( i && void 0 !== i.enable && !i.enable ) return i.enable
          }
          return this._editor.getConfiguration().contribInfo.colorDecorators
        }, e.prototype.getId = () => {
          return e.ID
        }, e.get = function ( e ) {
          return e.getContribution( this.ID )
        }, e.prototype.dispose = function () {
          this.stop(), this.removeAllDecorations(), this._globalToDispose = Object( a.d )( this._globalToDispose )
        }, e.prototype.onModelChanged = function () {
          const t = this;
          if ( this.stop(), this._isEnabled ) {
            const n = this._editor.getModel();
            c.d.has( n ) && ( this._localToDispose.push( this._editor.onDidChangeModelContent( ( n => {
              t._timeoutTimer || ( t._timeoutTimer = new g.f, t._timeoutTimer.cancelAndSet( ( () => {
                t._timeoutTimer = null, t.beginCompute()
              } ), e.RECOMPUTE_TIME ) )
            } ) ) ), this.beginCompute() )
          }
        }, e.prototype.beginCompute = function () {
          const e = this;
          this._computePromise = Object( g.i )( ( t => {
            return Object( h.b )( e._editor.getModel(), t )
          } ) ), this._computePromise.then( ( t => {
            e.updateDecorations( t ), e.updateColorDecorators( t ), e._computePromise = null
          } ), m.e )
        }, e.prototype.stop = function () {
          this._timeoutTimer && ( this._timeoutTimer.cancel(), this._timeoutTimer = null ), this._computePromise && ( this._computePromise.cancel(), this._computePromise = null ), this._localToDispose = Object( a.d )( this._localToDispose )
        }, e.prototype.updateDecorations = function ( e ) {
          const t = this,
            n = e.map( ( e => {
              return {
                range: {
                  startLineNumber: e.colorInfo.range.startLineNumber,
                  startColumn: e.colorInfo.range.startColumn,
                  endLineNumber: e.colorInfo.range.endLineNumber,
                  endColumn: e.colorInfo.range.endColumn
                },
                options: f.a.EMPTY
              }
            } ) );
          this._decorationsIds = this._editor.deltaDecorations( this._decorationsIds, n ), this._colorDatas = new Map, this._decorationsIds.forEach( ( ( n, i ) => {
            return t._colorDatas.set( n, e[ i ] )
          } ) )
        }, e.prototype.updateColorDecorators = function ( e ) {
          for ( var t = [], n = {}, r = 0; r < e.length && t.length < 500; r++ ) {
            const s = e[ r ].colorInfo.color,
              a = s.red,
              u = s.green,
              l = s.blue,
              c = s.alpha,
              d = new i.c( Math.round( 255 * a ), Math.round( 255 * u ), Math.round( 255 * l ), c ),
              h = o( d ).toString( 16 ),
              p = "rgba(" + d.r + ", " + d.g + ", " + d.b + ", " + d.a + ")",
              f = "colorBox-" + h;
            this._decorationsTypes[ f ] || n[ f ] || this._codeEditorService.registerDecorationType( f, {
              before: {
                contentText: " ",
                border: "solid 0.1em #000",
                margin: "0.1em 0.2em 0 0.2em",
                width: "0.8em",
                height: "0.8em",
                backgroundColor: p
              },
              dark: {
                before: {
                  border: "solid 0.1em #eee"
                }
              }
            } ), n[ f ] = !0, t.push( {
              range: {
                startLineNumber: e[ r ].colorInfo.range.startLineNumber,
                startColumn: e[ r ].colorInfo.range.startColumn,
                endLineNumber: e[ r ].colorInfo.range.endLineNumber,
                endColumn: e[ r ].colorInfo.range.endColumn
              },
              options: this._codeEditorService.resolveDecorationOptions( f, !0 )
            } )
          }
          for ( const g in this._decorationsTypes ) n[ g ] || this._codeEditorService.removeDecorationType( g );
          this._colorDecoratorIds = this._editor.deltaDecorations( this._colorDecoratorIds, t )
        }, e.prototype.removeAllDecorations = function () {
          for ( const e in ( this._decorationsIds = this._editor.deltaDecorations( this._decorationsIds, [] ), this._colorDecoratorIds = this._editor.deltaDecorations( this._colorDecoratorIds, [] ), this._decorationsTypes ) ) this._codeEditorService.removeDecorationType( e )
        }, e.prototype.getColorData = function ( e ) {
          const t = this,
            n = this._editor.getModel().getDecorationsInRange( l.a.fromPositions( e, e ) ).filter( ( e => {
              return t._colorDatas.has( e.id )
            } ) );
          return 0 === n.length ? null : this._colorDatas.get( n[ 0 ].id )
        }, e.ID = "editor.contrib.colorDetector", e.RECOMPUTE_TIME = 1e3, e = _( [ v( 1, d.a ), v( 2, p.b ) ], e );
      } )();
      Object( u.h )( y )
    },
    ksmt( e, t, n ) {
      "use strict";
      let i;
      n.d( t, "a", ( () => {
        return i
      } ) ), ( e => {
        e[ e.PREVIEW = 0 ] = "PREVIEW", e[ e.OPEN = 1 ] = "OPEN", e[ e.OPEN_IN_BACKGROUND = 2 ] = "OPEN_IN_BACKGROUND"
      } )( i || ( i = {} ) )
    },
    "kw+w": function ( e, t, n ) {},
    l2gE( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return E
      } ) );
      const i = n( "6OMU" ),
        o = n( "N0LK" ),
        r = n( "4J+e" ),
        s = n( "QDVR" ),
        a = n( "VMIq" ),
        u = "**",
        l = "/",
        c = "[/\\\\]",
        d = "[^/\\\\]",
        h = /\//g;

      function p( e ) {
        switch ( e ) {
          case 0:
            return "";
          case 1:
            return d + "*?";
          default:
            return "(?:" + c + "|" + d + "+" + c + "|" + c + d + "+)*?"
        }
      }

      function f( e, t ) {
        if ( !e ) return [];
        for ( var n, i = [], o = !1, r = !1, s = "", a = 0; a < e.length; a++ ) {
          switch ( n = e[ a ] ) {
            case t:
              if ( !o && !r ) {
                i.push( s ), s = "";
                continue
              }
              break;
            case "{":
              o = !0;
              break;
            case "}":
              o = !1;
              break;
            case "[":
              r = !0;
              break;
            case "]":
              r = !1
          }
          s += n
        }
        return s && i.push( s ), i
      }
      const g = /^\*\*\/\*\.[\w\.-]+$/,
        m = /^\*\*\/([\w\.-]+)\/?$/,
        _ = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/,
        v = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/,
        y = /^\*\*((\/[\w\.-]+)+)\/?$/,
        b = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/,
        C = new s.a( 1e4 ),
        w = () => {
          return !1
        },
        S = () => {
          return null
        };

      function O( e, t ) {
        if ( !e ) return S;
        let n;
        let r;
        const s = ( n = ( n = "string" !== typeof e ? e.pattern : e ).trim() ) + "_" + !!t.trimForExclusions;
        let a = C.get( s );
        if ( a ) return L( a, e );
        if ( g.test( n ) ) {
          const h = n.substr( 4 );
          a = ( e, t ) => {
            return e && o.endsWith( e, h ) ? n : null
          }
        } else a = ( r = m.exec( x( n, t ) ) ) ? ( ( e, t ) => {
          const n = "/" + e,
            i = "\\" + e,
            r = ( r, s ) => {
              return r ? s ? s === e ? t : null : r === e || o.endsWith( r, n ) || o.endsWith( r, i ) ? t : null : null
            },
            s = [ e ];
          return r.basenames = s, r.patterns = [ t ], r.allBasenames = s, r
        } )( r[ 1 ], n ) : ( t.trimForExclusions ? v : _ ).test( n ) ? ( ( e, t ) => {
          const n = k( e.slice( 1, -1 ).split( "," ).map( ( e => {
              return O( e, t )
            } ) ).filter( ( e => {
              return e !== S
            } ) ), e ),
            o = n.length;
          if ( !o ) return S;
          if ( 1 === o ) return n[ 0 ];
          const r = ( t, i ) => {
              for ( let o = 0, r = n.length; o < r; o++ )
                if ( n[ o ]( t, i ) ) return e;
              return null
            },
            s = i.g( n, ( e => {
              return !!e.allBasenames
            } ) );
          s && ( r.allBasenames = s.allBasenames );
          const a = n.reduce( ( ( e, t ) => {
            return t.allPaths ? e.concat( t.allPaths ) : e
          } ), [] );
          a.length && ( r.allPaths = a );
          return r
        } )( n, t ) : ( r = y.exec( x( n, t ) ) ) ? N( r[ 1 ].substr( 1 ), n, !0 ) : ( r = b.exec( x( n, t ) ) ) ? N( r[ 1 ], n, !1 ) : ( e => {
          try {
            const t = new RegExp( "^" + function e( t ) {
              if ( !t ) return "";
              let n = "";
              const i = f( t, l );
              if ( i.every( ( e => {
                  return e === u
                } ) ) ) n = ".*";
              else {
                let r = !1;
                i.forEach( ( ( t, s ) => {
                  if ( t !== u ) {
                    for ( let a, h = !1, g = "", m = !1, _ = "", v = 0; v < t.length; v++ )
                      if ( "}" !== ( a = t[ v ] ) && h ) g += a;
                      else if ( !m || "]" === a && _ ) switch ( a ) {
                      case "{":
                        h = !0;
                        continue;
                      case "[":
                        m = !0;
                        continue;
                      case "}":
                        const y = "(?:" + f( g, "," ).map( ( t => {
                          return e( t )
                        } ) ).join( "|" ) + ")";
                        n += y, h = !1, g = "";
                        break;
                      case "]":
                        n += "[" + _ + "]", m = !1, _ = "";
                        break;
                      case "?":
                        n += d;
                        continue;
                      case "*":
                        n += p( 1 );
                        continue;
                      default:
                        n += o.escapeRegExpCharacters( a )
                    } else {
                      _ += "-" === a ? a : "^" !== a && "!" !== a || _ ? a === l ? "" : o.escapeRegExpCharacters( a ) : "^"
                    }
                    s < i.length - 1 && ( i[ s + 1 ] !== u || s + 2 < i.length ) && ( n += c ), r = !1
                  } else r || ( n += p( 2 ), r = !0 )
                } ) )
              }
              return n
            }( e ) + "$" );
            return ( n, i ) => {
              return t.lastIndex = 0, n && t.test( n ) ? e : null
            };
          } catch ( n ) {
            return S
          }
        } )( n );
        return C.set( s, a ), L( a, e )
      }

      function L( e, t ) {
        return "string" === typeof t ? e : ( n, i ) => {
          return r.e( n, t.base ) ? e( r.h( t.pathToRelative( t.base, n ) ), i ) : null
        };
      }

      function x( e, t ) {
        return t.trimForExclusions && o.endsWith( e, "/**" ) ? e.substr( 0, e.length - 2 ) : e
      }

      function N( e, t, n ) {
        const i = r.g !== r.i ? e.replace( h, r.g ) : e,
          s = r.g + i,
          a = n ? ( e, n ) => {
            return e && ( e === i || o.endsWith( e, s ) ) ? t : null
          } : ( e, n ) => {
            return e && e === i ? t : null
          };
        return a.allPaths = [ ( n ? "*/" : "./" ) + e ], a
      }

      function E( e, t, n ) {
        return !( !e || !t ) && ( ( e, t ) => {
          void 0 === t && ( t = {} );
          if ( !e ) return w;
          if ( "string" === typeof e || ( e => {
              const t = e;
              return t && "string" === typeof t.base && "string" === typeof t.pattern && "function" === typeof t.pathToRelative
            } )( e ) ) {
            const n = O( e, t );
            if ( n === S ) return w;
            const o = ( e, t ) => {
              return !!n( e, t )
            };
            return n.allBasenames && ( o.allBasenames = n.allBasenames ), n.allPaths && ( o.allPaths = n.allPaths ), o
          }
          return ( ( e, t ) => {
            const n = k( Object.getOwnPropertyNames( e ).map( ( n => {
                return ( ( e, t, n ) => {
                  if ( !1 === t ) return S;
                  const i = O( e, n );
                  if ( i === S ) return S;
                  if ( "boolean" === typeof t ) return i;
                  if ( t ) {
                    const o = t.when;
                    if ( "string" === typeof o ) {
                      const r = ( t, n, r, s ) => {
                        if ( !s || !i( t, n ) ) return null;
                        const u = s( o.replace( "$(basename)", r ) );
                        return a.b.is( u ) ? u.then( ( t => {
                          return t ? e : null
                        } ) ) : u ? e : null;
                      };
                      return r.requiresSiblings = !0, r
                    }
                  }
                  return i
                } )( n, e[ n ], t );
              } ) ).filter( ( e => {
                return e !== S
              } ) ) ),
              o = n.length;
            if ( !o ) return S;
            if ( !n.some( ( e => {
                return e.requiresSiblings
              } ) ) ) {
              if ( 1 === o ) return n[ 0 ];
              const s = ( e, t ) => {
                  for ( let i = 0, o = n.length; i < o; i++ ) {
                    const r = n[ i ]( e, t );
                    if ( r ) return r
                  }
                  return null
                },
                u = i.g( n, ( e => {
                  return !!e.allBasenames
                } ) );
              u && ( s.allBasenames = u.allBasenames );
              const l = n.reduce( ( ( e, t ) => {
                return t.allPaths ? e.concat( t.allPaths ) : e
              } ), [] );
              return l.length && ( s.allPaths = l ), s
            }
            const c = ( e, t, i ) => {
                for ( let o, s = 0, a = n.length; s < a; s++ ) {
                  const u = n[ s ];
                  u.requiresSiblings && i && ( t || ( t = r.a( e ) ), o || ( o = t.substr( 0, t.length - r.c( e ).length ) ) );
                  const l = u( e, t, o, i );
                  if ( l ) return l
                }
                return null
              },
              d = i.g( n, ( e => {
                return !!e.allBasenames
              } ) );
            d && ( c.allBasenames = d.allBasenames );
            const h = n.reduce( ( ( e, t ) => {
              return t.allPaths ? e.concat( t.allPaths ) : e
            } ), [] );
            h.length && ( c.allPaths = h );
            return c
          } )( e, t );
        } )( e )( t, void 0, n );
      }

      function k( e, t ) {
        const n = e.filter( ( e => {
          return !!e.basenames
        } ) );
        if ( n.length < 2 ) return e;
        let i;
        const o = n.reduce( ( ( e, t ) => {
          return e.concat( t.basenames )
        } ), [] );
        if ( t ) {
          i = [];
          for ( let r = 0, s = o.length; r < s; r++ ) i.push( t )
        } else i = n.reduce( ( ( e, t ) => {
          return e.concat( t.patterns )
        } ), [] );
        const a = ( e, t ) => {
          if ( !e ) return null;
          if ( !t ) {
            let n = void 0;
            for ( n = e.length; n > 0; n-- ) {
              const r = e.charCodeAt( n - 1 );
              if ( 47 === r || 92 === r ) break
            }
            t = e.substr( n )
          }
          const s = o.indexOf( t );
          return -1 !== s ? i[ s ] : null
        };
        a.basenames = o, a.patterns = i, a.allBasenames = o;
        const u = e.filter( ( e => {
          return !e.basenames
        } ) );
        return u.push( a ), u
      }
    },
    lCHf( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return v
      } ) );
      n( "ehFp" );
      const i = n( "746U" ),
        o = n( "pmY6" ),
        r = n( "N0LK" ),
        s = n( "FWmy" ),
        a = n( "EffR" ),
        u = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        l = "_msDataKey";

      function c( e ) {
        return e[ l ] || ( e[ l ] = {} ), e[ l ]
      }

      function d( e ) {
        return !!e[ l ]
      }
      const h = ( () => {
          function e( e, t ) {
            this.offdom = t, this.container = e, this.currentElement = e, this.createdElements = [], this.toDispose = {}, this.captureToDispose = {}
          }
          return e.prototype.clone = function () {
            const t = new e( this.container, this.offdom );
            return t.currentElement = this.currentElement, t.createdElements = this.createdElements, t.captureToDispose = this.captureToDispose, t.toDispose = this.toDispose, t
          }, e.prototype.build = function ( t, n ) {
            s.a( this.offdom, "This builder was not created off-dom, so build() can not be called." ), t ? t instanceof e && ( t = t.getHTMLElement() ) : t = this.container, s.a( t, "Builder can only be build() with a container provided." ), s.a( a.C( t ), "The container must either be a HTMLElement or a Builder." );
            let o;
            let r;
            const u = t;
            const l = u.childNodes;
            if ( i.f( n ) && n < l.length )
              for ( o = 0, r = this.createdElements.length; o < r; o++ ) u.insertBefore( this.createdElements[ o ], l[ n++ ] );
            else
              for ( o = 0, r = this.createdElements.length; o < r; o++ ) u.appendChild( this.createdElements[ o ] );
            return this
          }, e.prototype.appendTo = function ( t, n ) {
            t ? t instanceof e && ( t = t.getHTMLElement() ) : t = this.container, s.a( t, "Builder can only be build() with a container provided." ), s.a( a.C( t ), "The container must either be a HTMLElement or a Builder." );
            const o = t;
            this.currentElement.parentNode && this.currentElement.parentNode.removeChild( this.currentElement );
            const r = o.childNodes;
            return i.f( n ) && n < r.length ? o.insertBefore( this.currentElement, r[ n ] ) : o.appendChild( this.currentElement ), this
          }, e.prototype.getHTMLElement = function () {
            return this.currentElement
          }, e.prototype.div = function ( e, t ) {
            return this.doElement( "div", e, t )
          }, e.prototype.element = function ( e, t, n ) {
            return this.doElement( e, t, n )
          }, e.prototype.doElement = function ( t, n, o ) {
            const r = document.createElement( t );
            if ( this.currentElement = r, this.offdom && this.createdElements.push( r ), i.g( n ) && this.attr( n ), i.e( n ) && ( o = n ), i.e( o ) ) {
              const s = new e( r );
              o.call( s, s )
            }
            return this.offdom || this.container.appendChild( r ), this
          }, e.prototype.domBlur = function () {
            return this.currentElement.blur(), this
          }, e.prototype.on = function ( e, t, n, o ) {
            const r = this;
            if ( i.b( e ) ) e.forEach( ( e => {
              r.on( e, t, n, o )
            } ) );
            else {
              const s = e,
                u = a.g( this.currentElement, s, ( e => {
                  t( e, r, u )
                } ), o || !1 );
              o ? ( this.captureToDispose[ s ] || ( this.captureToDispose[ s ] = [] ), this.captureToDispose[ s ].push( u ) ) : ( this.toDispose[ s ] || ( this.toDispose[ s ] = [] ), this.toDispose[ s ].push( u ) );
              const l = this.getProperty( "__$listeners", [] );
              l.push( u ), this.setProperty( "__$listeners", l ), n && i.b( n ) && n.push( u )
            }
            return this
          }, e.prototype.off = function ( e, t ) {
            const n = this;
            if ( i.b( e ) ) e.forEach( ( e => {
              n.off( e )
            } ) );
            else {
              const r = e;
              t ? this.captureToDispose[ r ] && ( this.captureToDispose[ r ] = Object( o.d )( this.captureToDispose[ r ] ) ) : this.toDispose[ r ] && ( this.toDispose[ r ] = Object( o.d )( this.toDispose[ r ] ) )
            }
            return this
          }, e.prototype.attr = function ( e, t ) {
            if ( i.g( e ) ) {
              for ( const n in e )
                if ( e.hasOwnProperty( n ) ) {
                  const o = e[ n ];
                  this.doSetAttr( n, o )
                } return this
            }
            return i.h( e ) && !i.h( t ) ? this.currentElement.getAttribute( e ) : ( i.h( e ) && ( i.h( t ) || ( t = String( t ) ), this.doSetAttr( e, t ) ), this )
          }, e.prototype.doSetAttr = function ( e, t ) {
            "class" === e && ( e = "addClass" ), this[ e ] ? i.b( t ) ? this[ e ].apply( this, t ) : this[ e ].call( this, t ) : this.currentElement.setAttribute( e, t )
          }, e.prototype.style = function ( e, t ) {
            if ( i.g( e ) ) {
              for ( const n in e )
                if ( e.hasOwnProperty( n ) ) {
                  const o = e[ n ];
                  this.doSetStyle( n, o )
                } return this
            }
            const r = i.h( e );
            return r && i.i( t ) ? this.currentElement.style[ this.cssKeyToJavaScriptProperty( e ) ] : ( r && this.doSetStyle( e, t ), this )
          }, e.prototype.doSetStyle = function ( e, t ) {
            if ( e.indexOf( "-" ) >= 0 ) {
              const n = e.split( "-" );
              e = n[ 0 ];
              for ( let i = 1; i < n.length; i++ ) {
                const o = n[ i ];
                e = e + o.charAt( 0 ).toUpperCase() + o.substr( 1 )
              }
            }
            this.currentElement.style[ this.cssKeyToJavaScriptProperty( e ) ] = t
          }, e.prototype.cssKeyToJavaScriptProperty = e => {
            if ( e.indexOf( "-" ) >= 0 ) {
              const t = e.split( "-" );
              e = t[ 0 ];
              for ( let n = 1; n < t.length; n++ ) {
                const i = t[ n ];
                e = e + i.charAt( 0 ).toUpperCase() + i.substr( 1 )
              }
            } else "float" === e && ( e = "cssFloat" );
            return e
          }, e.prototype.addClass = function () {
            for ( var e = this, t = [], n = 0; n < arguments.length; n++ ) t[ n ] = arguments[ n ];
            return t.forEach( ( t => {
              t.split( " " ).forEach( ( t => {
                a.f( e.currentElement, t )
              } ) )
            } ) ), this;
          }, e.prototype.setClass = function ( e, t ) {
            return void 0 === t && ( t = null ), null === t ? this.currentElement.className = e : t ? this.addClass( e ) : this.removeClass( e ), this
          }, e.prototype.hasClass = function ( e ) {
            return a.z( this.currentElement, e )
          }, e.prototype.removeClass = function () {
            for ( var e = this, t = [], n = 0; n < arguments.length; n++ ) t[ n ] = arguments[ n ];
            return t.forEach( ( t => {
              t.split( " " ).forEach( ( t => {
                a.G( e.currentElement, t )
              } ) )
            } ) ), this;
          }, e.prototype.show = function () {
            return this.hasClass( "monaco-builder-hidden" ) && this.removeClass( "monaco-builder-hidden" ), this.attr( "aria-hidden", "false" ), this.cancelVisibilityTimeout(), this
          }, e.prototype.hide = function () {
            return this.hasClass( "monaco-builder-hidden" ) || this.addClass( "monaco-builder-hidden" ), this.attr( "aria-hidden", "true" ), this.cancelVisibilityTimeout(), this
          }, e.prototype.cancelVisibilityTimeout = function () {
            const e = this.getProperty( "__$visibility" );
            e && ( e.dispose(), this.removeProperty( "__$visibility" ) )
          }, e.prototype.innerHtml = function ( e, t ) {
            return t ? this.currentElement.innerHTML += e : this.currentElement.innerHTML = e, this
          }, e.prototype.text = function ( e, t ) {
            return t ? 0 === this.currentElement.children.length ? this.currentElement.textContent += e : this.currentElement.appendChild( document.createTextNode( e ) ) : this.currentElement.textContent = e, this
          }, e.prototype.safeInnerHtml = function ( e, t ) {
            return this.innerHtml( r.escape( e ), t )
          }, e.prototype.setProperty = function ( e, t ) {
            return ( ( e, t, n ) => {
              c( e )[ t ] = n
            } )( this.currentElement, e, t ), this;
          }, e.prototype.getProperty = function ( e, t ) {
            return ( ( e, t, n ) => {
              if ( d( e ) ) {
                const o = c( e )[ t ];
                if ( !i.i( o ) ) return o
              }
              return n
            } )( this.currentElement, e, t );
          }, e.prototype.removeProperty = function ( e ) {
            return d( this.currentElement ) && delete c( this.currentElement )[ e ], this
          }, e.prototype.unbindDescendants = function ( e ) {
            if ( e && e.children )
              for ( let t = 0, n = e.children.length; t < n; t++ ) {
                const o = e.children.item( t );
                if ( d( o ) ) {
                  const r = c( o ).__$listeners;
                  if ( i.b( r ) )
                    for ( ; r.length; ) r.pop().dispose();
                  delete o[ l ]
                }
                this.unbindDescendants( o )
              }
          }, e.prototype.empty = function () {
            return this.unbindDescendants( this.currentElement ), this.clearChildren(), this.offdom && ( this.createdElements = [] ), this
          }, e.prototype.clearChildren = function () {
            return this.currentElement && a.l( this.currentElement ), this
          }, e.prototype.destroy = function () {
            if ( this.currentElement && ( this.currentElement.parentNode && this.currentElement.parentNode.removeChild( this.currentElement ), this.empty(), d( this.currentElement ) ) ) {
              const e = c( this.currentElement ).__$listeners;
              if ( i.b( e ) )
                for ( ; e.length; ) e.pop().dispose();
              delete this.currentElement[ l ]
            }
            let t;
            for ( t in this.toDispose ) this.toDispose.hasOwnProperty( t ) && i.b( this.toDispose[ t ] ) && ( this.toDispose[ t ] = Object( o.d )( this.toDispose[ t ] ) );
            for ( t in this.captureToDispose ) this.captureToDispose.hasOwnProperty( t ) && i.b( this.captureToDispose[ t ] ) && ( this.captureToDispose[ t ] = Object( o.d )( this.captureToDispose[ t ] ) );
            this.currentElement = null, this.container = null, this.offdom = null, this.createdElements = null, this.captureToDispose = null, this.toDispose = null
          }, e.prototype.dispose = function () {
            this.destroy()
          }, e.prototype.getTotalSize = function () {
            const e = a.y( this.currentElement ),
              t = a.x( this.currentElement );
            return new a.b( e, t )
          }, e.prototype.getClientArea = function () {
            return a.q( this.currentElement )
          }, e;
        } )(),
        p = ( e => {
          function t( n ) {
            let o = this;
            if ( s.a( i.b( n ) || n instanceof t, "Expected Array or MultiBuilder as parameter" ), ( o = e.call( this ) || this ).length = 0, o.builders = [], i.b( n ) )
              for ( var r = 0; r < n.length; r++ ) n[ r ] instanceof HTMLElement ? o.push( g( n[ r ] ) ) : o.push( n[ r ] );
            else
              for ( r = 0; r < n.length; r++ ) o.push( n.item( r ) );
            const a = o,
              u = e => {
                a[ e ] = function () {
                  for ( var n, o = Array.prototype.slice.call( arguments ), r = !1, s = 0; s < a.length; s++ ) {
                    const u = a.item( s )[ e ].apply( a.item( s ), o );
                    if ( u instanceof t ) {
                      n || ( n = [] ), r = !0;
                      for ( let l = 0; l < u.length; l++ ) n.push( u.item( l ) )
                    } else i.i( u ) || u instanceof h || ( n || ( n = [] ), n.push( u ) )
                  }
                  return n && r ? new t( n ) : n || a
                }
              };
            for ( const l in h.prototype ) "clone" !== l && "and" !== l && h.prototype.hasOwnProperty( l ) && i.e( h.prototype[ l ] ) && u( l );
            return o
          }
          return u( t, e ), t.prototype.item = function ( e ) {
            return this.builders[ e ]
          }, t.prototype.push = function () {
            for ( var e = [], t = 0; t < arguments.length; t++ ) e[ t ] = arguments[ t ];
            for ( let n = 0; n < e.length; n++ ) this.builders.push( e[ n ] );
            this.length = this.builders.length
          }, t.prototype.clone = function () {
            return new t( this )
          }, t;
        } )( h );

      function f( e, t ) {
        return e instanceof p ? new p( e ) : new h( e.getHTMLElement(), t )
      }

      function g( e, t ) {
        return new h( e, t )
      }

      function m() {
        return new h( null, !0 )
      }
      const _ = /([\w\-]+)?(#([\w\-]+))?((.([\w\-]+))*)/;

      var v = function ( e ) {
        if ( i.i( e ) ) return m();
        if ( !e ) throw new Error( "Bad use of $" );
        if ( a.C( e ) || e === window ) return g( e );
        if ( i.b( e ) ) return new p( e );
        if ( e instanceof h ) return f( e );
        if ( i.h( e ) ) {
          if ( "<" === e[ 0 ] ) {
            let t = void 0;
            const n = document.createElement( "div" );
            if ( n.innerHTML = r.format.apply( r, arguments ), 0 === n.children.length ) throw new Error( "Bad use of $" );
            if ( 1 === n.children.length ) return t = n.firstChild, n.removeChild( t ), g( t );
            for ( var o = []; n.firstChild; ) t = n.firstChild, n.removeChild( t ), o.push( g( t ) );
            return new p( o )
          }
          if ( 1 === arguments.length ) {
            const s = _.exec( e );
            if ( !s ) throw new Error( "Bad use of $" );
            const u = s[ 1 ] || "div",
              l = s[ 3 ] || void 0,
              c = ( s[ 4 ] || "" ).replace( /\./g, " " ),
              d = {};
            return l && ( d.id = l ), c && ( d.class = c ), m().element( u, d )
          }
          const v = m();
          return v.element.apply( v, arguments ), v
        }
        throw new Error( "Bad use of $" )
      };
    },
    lKfe( e, t, n ) {},
    "lY/7": function ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "MI8n" ),
        r = n( "pmY6" ),
        s = n( "T8No" ),
        a = n( "tADe" ),
        u = n( "aokT" ),
        l = n( "sswD" ),
        c = n( "t9D7" ),
        d = n( "wQH0" ),
        h = ( n( "alCU" ), n( "EffR" ) ),
        p = n( "cnVm" ),
        f = n( "MD5Z" ),
        g = n( "zrhQ" ),
        m = n( "kYye" ),
        _ = n( "GJhM" ),
        v = n( "QuOb" ),
        y = n( "3rx1" ),
        b = n( "6OMU" ),
        C = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        w = ( () => {
          function e( e, t, n ) {
            const i = this;
            this._lines = 0, this._longestLineLength = 0, this._relatedDiagnostics = new WeakMap, this._disposables = [], this._editor = t;
            const o = document.createElement( "div" );
            o.className = "descriptioncontainer", o.setAttribute( "aria-live", "assertive" ), o.setAttribute( "role", "alert" ), this._messageBlock = document.createElement( "div" ), o.appendChild( this._messageBlock ), this._relatedBlock = document.createElement( "div" ), o.appendChild( this._relatedBlock ), this._disposables.push( h.j( this._relatedBlock, "click", ( e => {
              e.preventDefault();
              const t = i._relatedDiagnostics.get( e.target );
              t && n( t )
            } ) ) ), this._scrollable = new _.b( o, {
              horizontal: v.b.Auto,
              vertical: v.b.Auto,
              useShadows: !1,
              horizontalScrollbarSize: 3,
              verticalScrollbarSize: 3
            } ), h.f( this._scrollable.getDomNode(), "block" ), e.appendChild( this._scrollable.getDomNode() ), this._disposables.push( this._scrollable.onScroll( ( e => {
              o.style.left = "-" + e.scrollLeft + "px", o.style.top = "-" + e.scrollTop + "px"
            } ) ) ), this._disposables.push( this._scrollable )
          }
          return e.prototype.dispose = function () {
            Object( r.d )( this._disposables )
          }, e.prototype.update = function ( e ) {
            const t = e.source;
            let n = e.message;
            const i = e.relatedInformation;
            if ( t ) {
              this._lines = 0, this._longestLineLength = 0;
              for ( let o = new Array( t.length + 3 + 1 ).join( " " ), r = n.split( /\r\n|\r|\n/g ), s = 0; s < r.length; s++ ) {
                const a = r[ s ];
                this._lines += 1, this._longestLineLength = Math.max( a.length, this._longestLineLength ), 0 === s ? n = "[" + t + "] " + a : n += "\n" + o + a
              }
            } else this._lines = 1, this._longestLineLength = n.length;
            if ( h.l( this._relatedBlock ), !Object( b.k )( i ) ) {
              this._relatedBlock.style.paddingTop = Math.floor( .66 * this._editor.getConfiguration().lineHeight ) + "px", this._lines += 1;
              for ( let u = 0, l = i; u < l.length; u++ ) {
                const c = l[ u ],
                  d = document.createElement( "div" ),
                  p = document.createElement( "span" );
                h.f( p, "filename" ), p.innerHTML = Object( y.a )( c.resource ) + "(" + c.startLineNumber + ", " + c.startColumn + "): ", p.title = Object( y.b )( c.resource, void 0 ), this._relatedDiagnostics.set( p, c );
                const f = document.createElement( "span" );
                f.innerText = c.message, this._editor.applyFontInfo( f ), d.appendChild( p ), d.appendChild( f ), this._lines += 1, this._relatedBlock.appendChild( d )
              }
            }
            this._messageBlock.innerText = n, this._editor.applyFontInfo( this._messageBlock );
            const g = this._editor.getConfiguration().fontInfo,
              m = Math.ceil( g.typicalFullwidthCharacterWidth * this._longestLineLength * .75 ),
              _ = g.lineHeight * this._lines;
            this._scrollable.setScrollDimensions( {
              scrollWidth: m,
              scrollHeight: _
            } )
          }, e.prototype.layout = function ( e, t ) {
            this._scrollable.getDomNode().style.height = e + "px", this._scrollable.setScrollDimensions( {
              width: t,
              height: e
            } )
          }, e.prototype.getHeightInLines = function () {
            return Math.min( 17, this._lines )
          }, e;
        } )(),
        S = ( e => {
          function t( t, n ) {
            const i = e.call( this, t, {
              showArrow: !0,
              showFrame: !0,
              isAccessible: !0
            } ) || this;
            return i._themeService = n, i._callOnDispose = [], i._onDidSelectRelatedInformation = new o.a, i.onDidSelectRelatedInformation = i._onDidSelectRelatedInformation.event, i._severity = a.b.Warning, i._backgroundColor = g.a.white, i._applyTheme( n.getTheme() ), i._callOnDispose.push( n.onThemeChange( i._applyTheme.bind( i ) ) ), i.create(), i
          }
          return C( t, e ), t.prototype._applyTheme = function ( e ) {
            this._backgroundColor = e.getColor( I );
            let t = N;
            this._severity === a.b.Warning ? t = E : this._severity === a.b.Info && ( t = k );
            const n = e.getColor( t );
            this.style( {
              arrowColor: n,
              frameColor: n
            } )
          }, t.prototype._applyStyles = function () {
            this._parentContainer && ( this._parentContainer.style.backgroundColor = this._backgroundColor.toString() ), e.prototype._applyStyles.call( this )
          }, t.prototype.dispose = function () {
            this._callOnDispose = Object( r.d )( this._callOnDispose ), e.prototype.dispose.call( this )
          }, t.prototype.focus = function () {
            this._parentContainer.focus()
          }, t.prototype._fillContainer = function ( e ) {
            const t = this;
            this._parentContainer = e, h.f( e, "marker-widget" ), this._parentContainer.tabIndex = 0, this._parentContainer.setAttribute( "role", "tooltip" ), this._container = document.createElement( "div" ), e.appendChild( this._container ), this._title = document.createElement( "div" ), this._title.className = "block title", this._container.appendChild( this._title ), this._message = new w( this._container, this.editor, ( e => {
              return t._onDidSelectRelatedInformation.fire( e )
            } ) ), this._disposables.push( this._message )
          }, t.prototype.show = ( e, t ) => {
            throw new Error( "call showAtMarker" )
          }, t.prototype.showAtMarker = function ( t, n, o ) {
            this._container.classList.remove( "stale" ), this._title.innerHTML = i.a( "title.wo_source", "({0}/{1})", n, o ), this._message.update( t ), this._severity = t.severity, this._applyTheme( this._themeService.getTheme() );
            const r = u.a.lift( t ),
              s = r.containsPosition( this.editor.getPosition() ) ? this.editor.getPosition() : r.getStartPosition();
            e.prototype.show.call( this, s, this.computeRequiredHeight() ), this.editor.revealPositionInCenter( s, 0 ), 1 !== this.editor.getConfiguration().accessibilitySupport && this.focus()
          }, t.prototype.updateMarker = function ( e ) {
            this._container.classList.remove( "stale" ), this._message.update( e )
          }, t.prototype.showStale = function () {
            this._container.classList.add( "stale" ), this._relayout()
          }, t.prototype._doLayout = function ( e, t ) {
            this._message.layout( e, t ), this._container.style.height = e + "px"
          }, t.prototype._relayout = function () {
            e.prototype._relayout.call( this, this.computeRequiredHeight() )
          }, t.prototype.computeRequiredHeight = function () {
            return 1 + this._message.getHeightInLines()
          }, t;
        } )( p.a ),
        O = Object( f.eb )( m.i, m.h ),
        L = Object( f.eb )( m.w, m.v ),
        x = Object( f.eb )( m.n, m.m ),
        N = Object( f.kb )( "editorMarkerNavigationError.background", {
          dark: O,
          light: O,
          hc: O
        }, i.a( "editorMarkerNavigationError", "Editor marker navigation widget error color." ) ),
        E = Object( f.kb )( "editorMarkerNavigationWarning.background", {
          dark: L,
          light: L,
          hc: L
        }, i.a( "editorMarkerNavigationWarning", "Editor marker navigation widget warning color." ) ),
        k = Object( f.kb )( "editorMarkerNavigationInfo.background", {
          dark: x,
          light: x,
          hc: x
        }, i.a( "editorMarkerNavigationInfo", "Editor marker navigation widget info color." ) ),
        I = Object( f.kb )( "editorMarkerNavigation.background", {
          dark: "#2D2D30",
          light: g.a.white,
          hc: "#0C141F"
        }, i.a( "editorMarkerNavigationBackground", "Editor marker navigation widget background." ) ),
        D = n( "N0LK" ),
        M = n( "Vxe3" ),
        T = n( "/cxE" ),
        R = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        P = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        A = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        F = ( () => {
          function e( e, t ) {
            const n = this;
            this._editor = e, this._markers = null, this._nextIdx = -1, this._toUnbind = [], this._ignoreSelectionChange = !1, this._onCurrentMarkerChanged = new o.a, this._onMarkerSetChanged = new o.a, this.setMarkers( t ), this._toUnbind.push( this._editor.onDidDispose( ( () => {
              return n.dispose()
            } ) ) ), this._toUnbind.push( this._editor.onDidChangeCursorPosition( ( () => {
              n._ignoreSelectionChange || n.currentMarker && u.a.containsPosition( n.currentMarker, n._editor.getPosition() ) || ( n._nextIdx = -1 )
            } ) ) )
          }
          return Object.defineProperty( e.prototype, "onCurrentMarkerChanged", {
            get() {
              return this._onCurrentMarkerChanged.event
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onMarkerSetChanged", {
            get() {
              return this._onMarkerSetChanged.event
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.setMarkers = function ( e ) {
            const t = this._nextIdx >= 0 ? this._markers[ this._nextIdx ] : void 0;
            this._markers = e || [], this._markers.sort( j.compareMarker ), this._nextIdx = t ? Math.max( -1, Object( b.b )( this._markers, t, j.compareMarker ) ) : -1, this._onMarkerSetChanged.fire( this )
          }, e.prototype.withoutWatchingEditorPosition = function ( e ) {
            this._ignoreSelectionChange = !0;
            try {
              e()
            } finally {
              this._ignoreSelectionChange = !1
            }
          }, e.prototype._initIdx = function ( e ) {
            for ( var t = !1, n = this._editor.getPosition(), i = 0; i < this._markers.length; i++ ) {
              let o = u.a.lift( this._markers[ i ] );
              if ( o.isEmpty() ) {
                const r = this._editor.getModel().getWordAtPosition( o.getStartPosition() );
                r && ( o = new u.a( o.startLineNumber, r.startColumn, o.startLineNumber, r.endColumn ) )
              }
              if ( o.containsPosition( n ) || n.isBeforeOrEqual( o.getStartPosition() ) ) {
                this._nextIdx = i, t = !0;
                break
              }
            }
            t || ( this._nextIdx = e ? 0 : this._markers.length - 1 ), this._nextIdx < 0 && ( this._nextIdx = this._markers.length - 1 )
          }, Object.defineProperty( e.prototype, "currentMarker", {
            get() {
              return this.canNavigate() ? this._markers[ this._nextIdx ] : void 0
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.move = function ( e, t ) {
            if ( !this.canNavigate() ) return this._onCurrentMarkerChanged.fire( void 0 ), !t;
            const n = this._nextIdx;
            let i = !1;
            if ( -1 === this._nextIdx ? this._initIdx( e ) : e ? t || this._nextIdx + 1 < this._markers.length ? this._nextIdx = ( this._nextIdx + 1 ) % this._markers.length : i = !0 : e || ( t || this._nextIdx > 0 ? this._nextIdx = ( this._nextIdx - 1 + this._markers.length ) % this._markers.length : i = !0 ), n !== this._nextIdx ) {
              const o = this._markers[ this._nextIdx ];
              this._onCurrentMarkerChanged.fire( o )
            }
            return i
          }, e.prototype.canNavigate = function () {
            return this._markers.length > 0
          }, e.prototype.findMarkerAtPosition = function ( e ) {
            for ( let t = 0, n = this._markers; t < n.length; t++ ) {
              const i = n[ t ];
              if ( u.a.containsPosition( i, e ) ) return i
            }
          }, Object.defineProperty( e.prototype, "total", {
            get() {
              return this._markers.length
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.indexOf = function ( e ) {
            return 1 + this._markers.indexOf( e )
          }, e.prototype.dispose = function () {
            this._toUnbind = Object( r.d )( this._toUnbind )
          }, e;
        } )(),
        W = ( () => {
          function e( e, t, n, i, o ) {
            this._markerService = t, this._contextKeyService = n, this._themeService = i, this._editorService = o, this._disposeOnClose = [], this._editor = e, this._widgetVisible = U.bindTo( this._contextKeyService )
          }
          return e.get = t => {
            return t.getContribution( e.ID )
          }, e.prototype.getId = () => {
            return e.ID
          }, e.prototype.dispose = function () {
            this._cleanUp()
          }, e.prototype._cleanUp = function () {
            this._widgetVisible.reset(), this._disposeOnClose = Object( r.d )( this._disposeOnClose ), this._widget = null, this._model = null
          }, e.prototype.getOrCreateModel = function () {
            const e = this;
            if ( this._model ) return this._model;
            const t = this._getMarkers();
            return this._model = new F( this._editor, t ), this._markerService.onMarkerChanged( this._onMarkerChanged, this, this._disposeOnClose ), this._widget = new S( this._editor, this._themeService ), this._widgetVisible.set( !0 ), this._disposeOnClose.push( this._model ), this._disposeOnClose.push( this._widget ), this._disposeOnClose.push( this._widget.onDidSelectRelatedInformation( ( t => {
              e._editorService.openCodeEditor( {
                resource: t.resource,
                options: {
                  pinned: !0,
                  revealIfOpened: !0,
                  selection: u.a.lift( t ).collapseToStart()
                }
              }, e._editor ).then( void 0, T.e ), e.closeMarkersNavigation( !1 )
            } ) ) ), this._disposeOnClose.push( this._editor.onDidChangeModel( ( () => {
              return e._cleanUp()
            } ) ) ), this._disposeOnClose.push( this._model.onCurrentMarkerChanged( ( t => {
              t ? e._model.withoutWatchingEditorPosition( ( () => {
                e._widget.showAtMarker( t, e._model.indexOf( t ), e._model.total )
              } ) ) : e._cleanUp()
            } ) ) ), this._disposeOnClose.push( this._model.onMarkerSetChanged( ( () => {
              const t = e._model.findMarkerAtPosition( e._widget.position );
              t ? e._widget.updateMarker( t ) : e._widget.showStale()
            } ) ) ), this._model;
          }, e.prototype.closeMarkersNavigation = function ( e ) {
            void 0 === e && ( e = !0 ), this._cleanUp(), e && this._editor.focus()
          }, e.prototype._onMarkerChanged = function ( e ) {
            const t = this;
            e.some( ( e => {
              return t._editor.getModel().uri.toString() === e.toString()
            } ) ) && this._model.setMarkers( this._getMarkers() )
          }, e.prototype._getMarkers = function () {
            return this._markerService.read( {
              resource: this._editor.getModel().uri,
              severities: a.b.Error | a.b.Warning | a.b.Info
            } )
          }, e.ID = "editor.contrib.markerController", e = P( [ A( 1, a.a ), A( 2, s.e ), A( 3, c.c ), A( 4, M.a ) ], e );
        } )(),
        j = ( e => {
          function t( t, n, i ) {
            const o = e.call( this, i ) || this;
            return o._isNext = t, o._multiFile = n, o
          }
          return R( t, e ), t.prototype.run = function ( e, n ) {
            const i = this,
              o = e.get( a.a ),
              r = e.get( M.a ),
              s = W.get( n );
            if ( s ) {
              const u = s.getOrCreateModel();
              if ( u.move( this._isNext, !this._multiFile ) && this._multiFile ) {
                const l = o.read( {
                  severities: a.b.Error | a.b.Warning | a.b.Info
                } ).sort( t.compareMarker );
                if ( 0 !== l.length ) {
                  const c = u.currentMarker || {
                    resource: n.getModel().uri,
                    severity: a.b.Error,
                    startLineNumber: 1,
                    startColumn: 1,
                    endLineNumber: 1,
                    endColumn: 1
                  };
                  let d = Object( b.b )( l, c, t.compareMarker );
                  d < 0 ? ( d = ~d, d %= l.length ) : d = this._isNext ? ( d + 1 ) % l.length : ( d + l.length - 1 ) % l.length;
                  const h = l[ d ];
                  if ( h.resource.toString() !== n.getModel().uri.toString() ) return s.closeMarkersNavigation(), r.openCodeEditor( {
                    resource: h.resource,
                    options: {
                      pinned: !1,
                      revealIfOpened: !0,
                      revealInCenterIfOutsideViewport: !0,
                      selection: h
                    }
                  }, n ).then( ( e => {
                    if ( e ) return e.getAction( i.id ).run()
                  } ) );
                  u.move( this._isNext, !0 )
                }
              }
            }
          }, t.compareMarker = ( e, t ) => {
            let n = Object( D.compare )( e.resource.toString(), t.resource.toString() );
            return 0 === n && ( n = a.b.compare( e.severity, t.severity ) ), 0 === n && ( n = u.a.compareRangesUsingStarts( e, t ) ), n
          }, t;
        } )( l.b ),
        V = ( e => {
          function t() {
            return e.call( this, !0, !1, {
              id: "editor.action.marker.next",
              label: i.a( "markerAction.next.label", "Go to Next Problem (Error, Warning, Info)" ),
              alias: "Go to Next Error or Warning",
              precondition: d.a.writable
            } ) || this
          }
          return R( t, e ), t
        } )( j ),
        B = ( e => {
          function t() {
            return e.call( this, !1, !1, {
              id: "editor.action.marker.prev",
              label: i.a( "markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)" ),
              alias: "Go to Previous Error or Warning",
              precondition: d.a.writable
            } ) || this
          }
          return R( t, e ), t
        } )( j ),
        H = ( e => {
          function t() {
            return e.call( this, !0, !0, {
              id: "editor.action.marker.nextInFiles",
              label: i.a( "markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)" ),
              alias: "Go to Next Error or Warning in Files",
              precondition: d.a.writable,
              kbOpts: {
                kbExpr: d.a.focus,
                primary: 66,
                weight: 100
              }
            } ) || this
          }
          return R( t, e ), t
        } )( j ),
        z = ( e => {
          function t() {
            return e.call( this, !1, !0, {
              id: "editor.action.marker.prevInFiles",
              label: i.a( "markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)" ),
              alias: "Go to Previous Error or Warning in Files",
              precondition: d.a.writable,
              kbOpts: {
                kbExpr: d.a.focus,
                primary: 1090,
                weight: 100
              }
            } ) || this
          }
          return R( t, e ), t
        } )( j );
      Object( l.h )( W ), Object( l.f )( V ), Object( l.f )( B ), Object( l.f )( H ), Object( l.f )( z );
      var U = new s.f( "markersNavigationVisible", !1 );
      const K = l.c.bindToContribution( W.get );
      Object( l.g )( new K( {
        id: "closeMarkersNavigation",
        precondition: U,
        handler( e ) {
          return e.closeMarkersNavigation()
        },
        kbOpts: {
          weight: 150,
          kbExpr: d.a.focus,
          primary: 9,
          secondary: [ 1033 ]
        }
      } ) )
    },
    li8W( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "bat",
        extensions: [ ".bat", ".cmd" ],
        aliases: [ "Batch", "bat" ],
        loader() {
          return o.Promise.wrap( n.e( 256 ).then( n.bind( null, "7s2V" ) ) )
        }
      } )
    },
    lrmC( e, t, n ) {},
    n01l( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "/kV6" ),
        r = n( "wQH0" ),
        s = n( "sswD" ),
        a = n( "0/Sa" ),
        u = n( "cGHE" ),
        l = n( "aokT" ),
        c = n( "gCVg" ),
        d = n( "cMvZ" ),
        h = ( () => {
          function e( e ) {
            this._selection = e, this._usedEndToken = null
          }
          return e._haystackHasNeedleAtOffset = ( e, t, n ) => {
            if ( n < 0 ) return !1;
            const i = t.length;
            if ( n + i > e.length ) return !1;
            for ( let o = 0; o < i; o++ ) {
              const r = e.charCodeAt( n + o ),
                s = t.charCodeAt( o );
              if ( r !== s && ( !( r >= 65 && r <= 90 && r + 32 === s ) && !( s >= 65 && s <= 90 && s + 32 === r ) ) ) return !1
            }
            return !0
          }, e.prototype._createOperationsForBlockComment = function ( t, n, i, o ) {
            let r;
            const s = t.startLineNumber;
            const a = t.startColumn;
            const u = t.endLineNumber;
            const c = t.endColumn;
            const d = i.getLineContent( s );
            const h = i.getLineContent( u );
            let p = n.blockCommentStartToken;
            let f = n.blockCommentEndToken;
            let g = d.lastIndexOf( p, a - 1 + p.length );
            let m = h.indexOf( f, c - 1 - f.length );
            if ( -1 !== g && -1 !== m )
              if ( s === u ) {
                d.substring( g + p.length, m ).indexOf( f ) >= 0 && ( g = -1, m = -1 )
              } else {
                const _ = d.substring( g + p.length ),
                  v = h.substring( 0, m );
                ( _.indexOf( f ) >= 0 || v.indexOf( f ) >= 0 ) && ( g = -1, m = -1 )
              } - 1 !== g && -1 !== m ? ( g + p.length < d.length && 32 === d.charCodeAt( g + p.length ) && ( p += " " ), m > 0 && 32 === h.charCodeAt( m - 1 ) && ( f = " " + f, m -= 1 ), r = e._createRemoveBlockCommentOperations( new l.a( s, g + p.length + 1, u, m + 1 ), p, f ) ) : ( r = e._createAddBlockCommentOperations( t, p, f ), this._usedEndToken = 1 === r.length ? f : null );
            for ( let y = 0; y < r.length; y++ ) o.addTrackedEditOperation( r[ y ].range, r[ y ].text )
          }, e._createRemoveBlockCommentOperations = ( e, t, n ) => {
            const i = [];
            return l.a.isEmpty( e ) ? i.push( a.a.delete( new l.a( e.startLineNumber, e.startColumn - t.length, e.endLineNumber, e.endColumn + n.length ) ) ) : ( i.push( a.a.delete( new l.a( e.startLineNumber, e.startColumn - t.length, e.startLineNumber, e.startColumn ) ) ), i.push( a.a.delete( new l.a( e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn + n.length ) ) ) ), i
          }, e._createAddBlockCommentOperations = ( e, t, n ) => {
            const i = [];
            return l.a.isEmpty( e ) ? i.push( a.a.replace( new l.a( e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn ), t + "  " + n ) ) : ( i.push( a.a.insert( new u.a( e.startLineNumber, e.startColumn ), t + " " ) ), i.push( a.a.insert( new u.a( e.endLineNumber, e.endColumn ), " " + n ) ) ), i
          }, e.prototype.getEditOperations = function ( e, t ) {
            const n = this._selection.startLineNumber,
              i = this._selection.startColumn;
            e.tokenizeIfCheap( n );
            const o = e.getLanguageIdAtPosition( n, i ),
              r = d.a.getComments( o );
            r && r.blockCommentStartToken && r.blockCommentEndToken && this._createOperationsForBlockComment( this._selection, r, e, t )
          }, e.prototype.computeCursorState = function ( e, t ) {
            const n = t.getInverseEditOperations();
            if ( 2 === n.length ) {
              const i = n[ 0 ],
                o = n[ 1 ];
              return new c.a( i.range.endLineNumber, i.range.endColumn, o.range.startLineNumber, o.range.startColumn )
            }
            const r = n[ 0 ].range,
              s = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
            return new c.a( r.endLineNumber, r.endColumn + s, r.endLineNumber, r.endColumn + s )
          }, e;
        } )(),
        p = n( "N0LK" ),
        f = ( () => {
          function e( e, t, n ) {
            this._selection = e, this._tabSize = t, this._type = n, this._deltaColumn = 0
          }
          return e._gatherPreflightCommentStrings = ( e, t, n ) => {
            e.tokenizeIfCheap( t );
            const i = e.getLanguageIdAtPosition( t, 1 ),
              o = d.a.getComments( i ),
              r = o ? o.lineCommentToken : null;
            if ( !r ) return null;
            for ( var s = [], a = 0, u = n - t + 1; a < u; a++ ) s[ a ] = {
              ignore: !1,
              commentStr: r,
              commentStrOffset: 0,
              commentStrLength: r.length
            };
            return s
          }, e._analyzeLines = ( e, t, n, i ) => {
            let o, r = !0;
            o = 0 === e || 1 !== e;
            for ( var s = 0, a = n.length; s < a; s++ ) {
              const u = n[ s ],
                l = i + s,
                c = t.getLineContent( l ),
                d = p.firstNonWhitespaceIndex( c );
              if ( -1 !== d ) {
                if ( r = !1, u.ignore = !1, u.commentStrOffset = d, o && !h._haystackHasNeedleAtOffset( c, u.commentStr, d ) && ( 0 === e ? o = !1 : 1 === e || ( u.ignore = !0 ) ), o ) {
                  const f = d + u.commentStrLength;
                  f < c.length && 32 === c.charCodeAt( f ) && ( u.commentStrLength += 1 )
                }
              } else u.ignore = !0, u.commentStrOffset = c.length
            }
            if ( 0 === e && r ) {
              o = !1;
              for ( s = 0, a = n.length; s < a; s++ ) n[ s ].ignore = !1
            }
            return {
              supported: !0,
              shouldRemoveComments: o,
              lines: n
            }
          }, e._gatherPreflightData = ( t, n, i, o ) => {
            const r = e._gatherPreflightCommentStrings( n, i, o );
            return null === r ? {
              supported: !1,
              shouldRemoveComments: !1,
              lines: null
            } : e._analyzeLines( t, n, r, i )
          }, e.prototype._executeLineComments = function ( t, n, i, o ) {
            let r;
            i.shouldRemoveComments ? r = e._createRemoveLineCommentsOperations( i.lines, o.startLineNumber ) : ( e._normalizeInsertionPoint( t, i.lines, o.startLineNumber, this._tabSize ), r = e._createAddLineCommentsOperations( i.lines, o.startLineNumber ) );
            for ( let s = new u.a( o.positionLineNumber, o.positionColumn ), a = 0, l = r.length; a < l; a++ ) {
              if ( n.addEditOperation( r[ a ].range, r[ a ].text ), r[ a ].range.isEmpty() && r[ a ].range.getStartPosition().equals( s ) ) t.getLineContent( s.lineNumber ).length + 1 === s.column && ( this._deltaColumn = r[ a ].text.length )
            }
            this._selectionId = n.trackSelection( o )
          }, e.prototype._attemptRemoveBlockComment = ( e, t, n, i ) => {
            let o = t.startLineNumber;
            let r = t.endLineNumber;
            const s = i.length + Math.max( e.getLineFirstNonWhitespaceColumn( t.startLineNumber ), t.startColumn );
            let a = e.getLineContent( o ).lastIndexOf( n, s - 1 );
            let u = e.getLineContent( r ).indexOf( i, t.endColumn - 1 - n.length );
            return -1 !== a && -1 === u && ( u = e.getLineContent( o ).indexOf( i, a + n.length ), r = o ), -1 === a && -1 !== u && ( a = e.getLineContent( r ).lastIndexOf( n, u ), o = r ), !t.isEmpty() || -1 !== a && -1 !== u || -1 !== ( a = e.getLineContent( o ).indexOf( n ) ) && ( u = e.getLineContent( o ).indexOf( i, a + n.length ) ), -1 !== a && 32 === e.getLineContent( o ).charCodeAt( a + n.length ) && ( n += " " ), -1 !== u && 32 === e.getLineContent( r ).charCodeAt( u - 1 ) && ( i = " " + i, u -= 1 ), -1 !== a && -1 !== u ? h._createRemoveBlockCommentOperations( new l.a( o, a + n.length + 1, r, u + 1 ), n, i ) : null
          }, e.prototype._executeBlockComment = function ( e, t, n ) {
            e.tokenizeIfCheap( n.startLineNumber );
            const i = e.getLanguageIdAtPosition( n.startLineNumber, 1 ),
              o = d.a.getComments( i );
            if ( o && o.blockCommentStartToken && o.blockCommentEndToken ) {
              const r = o.blockCommentStartToken;
              const s = o.blockCommentEndToken;
              let a = this._attemptRemoveBlockComment( e, n, r, s );
              if ( !a ) {
                if ( n.isEmpty() ) {
                  const u = e.getLineContent( n.startLineNumber );
                  let c = p.firstNonWhitespaceIndex( u ); -
                  1 === c && ( c = u.length ), a = h._createAddBlockCommentOperations( new l.a( n.startLineNumber, c + 1, n.startLineNumber, u.length + 1 ), r, s )
                } else a = h._createAddBlockCommentOperations( new l.a( n.startLineNumber, e.getLineFirstNonWhitespaceColumn( n.startLineNumber ), n.endLineNumber, e.getLineMaxColumn( n.endLineNumber ) ), r, s );
                1 === a.length && ( this._deltaColumn = r.length + 1 )
              }
              this._selectionId = t.trackSelection( n );
              for ( let f = 0; f < a.length; f++ ) t.addEditOperation( a[ f ].range, a[ f ].text )
            }
          }, e.prototype.getEditOperations = function ( t, n ) {
            let i = this._selection;
            this._moveEndPositionDown = !1, i.startLineNumber < i.endLineNumber && 1 === i.endColumn && ( this._moveEndPositionDown = !0, i = i.setEndPosition( i.endLineNumber - 1, t.getLineMaxColumn( i.endLineNumber - 1 ) ) );
            const o = e._gatherPreflightData( this._type, t, i.startLineNumber, i.endLineNumber );
            return o.supported ? this._executeLineComments( t, n, o, i ) : this._executeBlockComment( t, n, i )
          }, e.prototype.computeCursorState = function ( e, t ) {
            let n = t.getTrackedSelection( this._selectionId );
            return this._moveEndPositionDown && ( n = n.setEndPosition( n.endLineNumber + 1, 1 ) ), new c.a( n.selectionStartLineNumber, n.selectionStartColumn + this._deltaColumn, n.positionLineNumber, n.positionColumn + this._deltaColumn )
          }, e._createRemoveLineCommentsOperations = ( e, t ) => {
            for ( var n = [], i = 0, o = e.length; i < o; i++ ) {
              const r = e[ i ];
              r.ignore || n.push( a.a.delete( new l.a( t + i, r.commentStrOffset + 1, t + i, r.commentStrOffset + r.commentStrLength + 1 ) ) )
            }
            return n
          }, e._createAddLineCommentsOperations = ( e, t ) => {
            for ( var n = [], i = 0, o = e.length; i < o; i++ ) {
              const r = e[ i ];
              r.ignore || n.push( a.a.insert( new u.a( t + i, r.commentStrOffset + 1 ), r.commentStr + " " ) )
            }
            return n
          }, e.nextVisibleColumn = ( e, t, n, i ) => {
            return n ? e + ( t - e % t ) : e + i
          }, e._normalizeInsertionPoint = ( t, n, i, o ) => {
            for ( var r, s, a = Number.MAX_VALUE, u = 0, l = n.length; u < l; u++ )
              if ( !n[ u ].ignore ) {
                for ( var c = t.getLineContent( i + u ), d = 0, h = 0, p = n[ u ].commentStrOffset; d < a && h < p; h++ ) d = e.nextVisibleColumn( d, o, 9 === c.charCodeAt( h ), 1 );
                d < a && ( a = d )
              } a = Math.floor( a / o ) * o;
            for ( u = 0, l = n.length; u < l; u++ )
              if ( !n[ u ].ignore ) {
                c = t.getLineContent( i + u ), d = 0;
                for ( r = 0, s = n[ u ].commentStrOffset; d < a && r < s; r++ ) d = e.nextVisibleColumn( d, o, 9 === c.charCodeAt( r ), 1 );
                n[ u ].commentStrOffset = d > a ? r - 1 : r
              }
          }, e;
        } )(),
        g = n( "fjLI" ),
        m = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        _ = ( e => {
          function t( t, n ) {
            const i = e.call( this, n ) || this;
            return i._type = t, i
          }
          return m( t, e ), t.prototype.run = function ( e, t ) {
            const n = t.getModel();
            if ( n ) {
              for ( var i = [], o = t.getSelections(), r = n.getOptions(), s = 0; s < o.length; s++ ) i.push( new f( o[ s ], r.tabSize, this._type ) );
              t.pushUndoStop(), t.executeCommands( this.id, i ), t.pushUndoStop()
            }
          }, t;
        } )( s.b ),
        v = ( e => {
          function t() {
            return e.call( this, 0, {
              id: "editor.action.commentLine",
              label: i.a( "comment.line", "Toggle Line Comment" ),
              alias: "Toggle Line Comment",
              precondition: r.a.writable,
              kbOpts: {
                kbExpr: r.a.editorTextFocus,
                primary: 2133,
                weight: 100
              },
              menubarOpts: {
                menuId: g.b.MenubarEditMenu,
                group: "5_insert",
                title: i.a( {
                  key: "miToggleLineComment",
                  comment: [ "&& denotes a mnemonic" ]
                }, "&&Toggle Line Comment" ),
                order: 1
              }
            } ) || this
          }
          return m( t, e ), t
        } )( _ ),
        y = ( e => {
          function t() {
            return e.call( this, 1, {
              id: "editor.action.addCommentLine",
              label: i.a( "comment.line.add", "Add Line Comment" ),
              alias: "Add Line Comment",
              precondition: r.a.writable,
              kbOpts: {
                kbExpr: r.a.editorTextFocus,
                primary: Object( o.a )( 2089, 2081 ),
                weight: 100
              }
            } ) || this
          }
          return m( t, e ), t
        } )( _ ),
        b = ( e => {
          function t() {
            return e.call( this, 2, {
              id: "editor.action.removeCommentLine",
              label: i.a( "comment.line.remove", "Remove Line Comment" ),
              alias: "Remove Line Comment",
              precondition: r.a.writable,
              kbOpts: {
                kbExpr: r.a.editorTextFocus,
                primary: Object( o.a )( 2089, 2099 ),
                weight: 100
              }
            } ) || this
          }
          return m( t, e ), t
        } )( _ ),
        C = ( e => {
          function t() {
            return e.call( this, {
              id: "editor.action.blockComment",
              label: i.a( "comment.block", "Toggle Block Comment" ),
              alias: "Toggle Block Comment",
              precondition: r.a.writable,
              kbOpts: {
                kbExpr: r.a.editorTextFocus,
                primary: 1567,
                linux: {
                  primary: 3103
                },
                weight: 100
              },
              menubarOpts: {
                menuId: g.b.MenubarEditMenu,
                group: "5_insert",
                title: i.a( {
                  key: "miToggleBlockComment",
                  comment: [ "&& denotes a mnemonic" ]
                }, "Toggle &&Block Comment" ),
                order: 2
              }
            } ) || this
          }
          return m( t, e ), t.prototype.run = function ( e, t ) {
            for ( var n = [], i = t.getSelections(), o = 0; o < i.length; o++ ) n.push( new h( i[ o ] ) );
            t.pushUndoStop(), t.executeCommands( this.id, n ), t.pushUndoStop()
          }, t
        } )( s.b );
      Object( s.f )( v ), Object( s.f )( y ), Object( s.f )( b ), Object( s.f )( C )
    },
    n18v( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "twig",
        extensions: [ ".twig" ],
        aliases: [ "Twig", "twig" ],
        mimetypes: [ "text/x-twig" ],
        loader() {
          return o.Promise.wrap( n.e( 311 ).then( n.bind( null, "nNVF" ) ) )
        }
      } )
    },
    n3JV( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "DefinitionActionConfig", ( () => {
        return C
      } ) ), n.d( t, "DefinitionAction", ( () => {
        return w
      } ) ), n.d( t, "GoToDefinitionAction", ( () => {
        return O
      } ) ), n.d( t, "OpenDefinitionToSideAction", ( () => {
        return L
      } ) ), n.d( t, "PeekDefinitionAction", ( () => {
        return x
      } ) ), n.d( t, "ImplementationAction", ( () => {
        return N
      } ) ), n.d( t, "GoToImplementationAction", ( () => {
        return E
      } ) ), n.d( t, "PeekImplementationAction", ( () => {
        return k
      } ) ), n.d( t, "TypeDefinitionAction", ( () => {
        return I
      } ) ), n.d( t, "GoToTypeDefinitionAction", ( () => {
        return D
      } ) ), n.d( t, "PeekTypeDefinitionAction", ( () => {
        return M
      } ) );
      const i = n( "3/fG" );
      const o = n( "OBOq" );
      const r = n( "/kV6" );
      const s = n( "MNsG" );
      const a = n( "Vxe3" );
      const u = n( "aokT" );
      const l = n( "sswD" );
      const c = n( "UH51" );
      const d = n( "qkNm" );
      const h = n( "OlfL" );
      const p = n( "5aqo" );
      const f = n( "T8No" );
      const g = n( "NR8r" );
      const m = n( "wQH0" );
      const _ = n( "tTk5" );
      const v = n( "sM1p" );
      const y = n( "X+cX" );
      const b = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var C = function ( e, t, n, i ) {
        void 0 === e && ( e = !1 ), void 0 === t && ( t = !1 ), void 0 === n && ( n = !0 ), void 0 === i && ( i = !0 ), this.openToSide = e, this.openInPeek = t, this.filterCurrent = n, this.showMessage = i
      };
      var w = ( e => {
        function t( t, n ) {
          const i = e.call( this, n ) || this;
          return i._configuration = t, i
        }
        return b( t, e ), t.prototype.run = function ( e, t ) {
          const n = this,
            i = e.get( v.a ),
            o = e.get( a.a ),
            r = e.get( _.a ),
            s = t.getModel(),
            l = t.getPosition(),
            c = this._getDeclarationsAtPosition( s, l ).then( ( e => {
              if ( !s.isDisposed() && t.getModel() === s ) {
                for ( var i = -1, r = [], a = 0; a < e.length; a++ ) {
                  const c = e[ a ];
                  if ( c && c.range ) {
                    const d = c.uri,
                      p = c.range,
                      f = r.push( {
                        uri: d,
                        range: p
                      } );
                    n._configuration.filterCurrent && d.toString() === s.uri.toString() && u.a.containsPosition( p, l ) && -1 === i && ( i = f - 1 )
                  }
                }
                if ( 0 === r.length ) {
                  if ( n._configuration.showMessage ) {
                    const m = s.getWordAtPosition( l );
                    g.a.get( t ).showMessage( n._getNoResultFoundMessage( m ), l )
                  }
                } else if ( 1 === r.length && -1 !== i ) {
                  const _ = r[ 0 ];
                  n._openReference( t, o, _, !1 )
                } else n._onResult( o, t, new h.c( r ) )
              }
            } ), ( e => {
              i.error( e )
            } ) );
          return r.showWhile( c, 250 ), c
        }, t.prototype._getDeclarationsAtPosition = ( e, t ) => {
          return Object( c.a )( e, t )
        }, t.prototype._getNoResultFoundMessage = e => {
          return e && e.word ? i.a( "noResultWord", "No definition found for '{0}'", e.word ) : i.a( "generic.noResults", "No definition found" )
        }, t.prototype._getMetaTitle = e => {
          return e.references.length > 1 && i.a( "meta.title", " \u2013 {0} definitions", e.references.length )
        }, t.prototype._onResult = function ( e, t, n ) {
          const i = this,
            r = n.getAriaMessage();
          if ( Object( o.a )( r ), this._configuration.openInPeek ) this._openInPeek( e, t, n );
          else {
            const s = n.nearestReference( t.getModel().uri, t.getPosition() );
            this._openReference( t, e, s, this._configuration.openToSide ).then( ( t => {
              t && n.references.length > 1 ? i._openInPeek( e, t, n ) : n.dispose()
            } ) )
          }
        }, t.prototype._openReference = ( e, t, n, i ) => {
          const o = n.uri,
            r = n.range;
          return t.openCodeEditor( {
            resource: o,
            options: {
              selection: u.a.collapseToStart( r ),
              revealIfOpened: !0,
              revealInCenterIfOutsideViewport: !0
            }
          }, e, i )
        }, t.prototype._openInPeek = function ( e, t, n ) {
          const i = this,
            o = d.a.get( t );
          o ? o.toggleWidget( t.getSelection(), Object( y.i )( ( e => {
            return Promise.resolve( n )
          } ) ), {
            getMetaTitle( e ) {
              return i._getMetaTitle( e )
            },
            onGoto( n ) {
              return o.closeWidget(), i._openReference( t, e, n, !1 )
            }
          } ) : n.dispose()
        }, t;
      } )( l.b );
      const S = s.f ? 2118 : 70;
      var O = ( e => {
        function t() {
          return e.call( this, new C, {
            id: t.ID,
            label: i.a( "actions.goToDecl.label", "Go to Definition" ),
            alias: "Go to Definition",
            precondition: f.d.and( m.a.hasDefinitionProvider, m.a.isInEmbeddedEditor.toNegated() ),
            kbOpts: {
              kbExpr: m.a.editorTextFocus,
              primary: S,
              weight: 100
            },
            menuOpts: {
              group: "navigation",
              order: 1.1
            }
          } ) || this
        }
        return b( t, e ), t.ID = "editor.action.goToDeclaration", t
      } )( w );
      var L = ( e => {
        function t() {
          return e.call( this, new C( !0 ), {
            id: t.ID,
            label: i.a( "actions.goToDeclToSide.label", "Open Definition to the Side" ),
            alias: "Open Definition to the Side",
            precondition: f.d.and( m.a.hasDefinitionProvider, m.a.isInEmbeddedEditor.toNegated() ),
            kbOpts: {
              kbExpr: m.a.editorTextFocus,
              primary: Object( r.a )( 2089, S ),
              weight: 100
            }
          } ) || this
        }
        return b( t, e ), t.ID = "editor.action.openDeclarationToTheSide", t
      } )( w );
      var x = ( e => {
        function t() {
          return e.call( this, new C( void 0, !0, !1 ), {
            id: "editor.action.previewDeclaration",
            label: i.a( "actions.previewDecl.label", "Peek Definition" ),
            alias: "Peek Definition",
            precondition: f.d.and( m.a.hasDefinitionProvider, p.a.notInPeekEditor, m.a.isInEmbeddedEditor.toNegated() ),
            kbOpts: {
              kbExpr: m.a.editorTextFocus,
              primary: 582,
              linux: {
                primary: 3140
              },
              weight: 100
            },
            menuOpts: {
              group: "navigation",
              order: 1.2
            }
          } ) || this
        }
        return b( t, e ), t
      } )( w );
      var N = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return b( t, e ), t.prototype._getDeclarationsAtPosition = ( e, t ) => {
          return Object( c.b )( e, t )
        }, t.prototype._getNoResultFoundMessage = e => {
          return e && e.word ? i.a( "goToImplementation.noResultWord", "No implementation found for '{0}'", e.word ) : i.a( "goToImplementation.generic.noResults", "No implementation found" )
        }, t.prototype._getMetaTitle = e => {
          return e.references.length > 1 && i.a( "meta.implementations.title", " \u2013 {0} implementations", e.references.length )
        }, t;
      } )( w );
      var E = ( e => {
        function t() {
          return e.call( this, new C, {
            id: t.ID,
            label: i.a( "actions.goToImplementation.label", "Go to Implementation" ),
            alias: "Go to Implementation",
            precondition: f.d.and( m.a.hasImplementationProvider, m.a.isInEmbeddedEditor.toNegated() ),
            kbOpts: {
              kbExpr: m.a.editorTextFocus,
              primary: 2118,
              weight: 100
            }
          } ) || this
        }
        return b( t, e ), t.ID = "editor.action.goToImplementation", t
      } )( N );
      var k = ( e => {
        function t() {
          return e.call( this, new C( !1, !0, !1 ), {
            id: t.ID,
            label: i.a( "actions.peekImplementation.label", "Peek Implementation" ),
            alias: "Peek Implementation",
            precondition: f.d.and( m.a.hasImplementationProvider, m.a.isInEmbeddedEditor.toNegated() ),
            kbOpts: {
              kbExpr: m.a.editorTextFocus,
              primary: 3142,
              weight: 100
            }
          } ) || this
        }
        return b( t, e ), t.ID = "editor.action.peekImplementation", t
      } )( N );
      var I = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return b( t, e ), t.prototype._getDeclarationsAtPosition = ( e, t ) => {
          return Object( c.c )( e, t )
        }, t.prototype._getNoResultFoundMessage = e => {
          return e && e.word ? i.a( "goToTypeDefinition.noResultWord", "No type definition found for '{0}'", e.word ) : i.a( "goToTypeDefinition.generic.noResults", "No type definition found" )
        }, t.prototype._getMetaTitle = e => {
          return e.references.length > 1 && i.a( "meta.typeDefinitions.title", " \u2013 {0} type definitions", e.references.length )
        }, t;
      } )( w );
      var D = ( e => {
        function t() {
          return e.call( this, new C, {
            id: t.ID,
            label: i.a( "actions.goToTypeDefinition.label", "Go to Type Definition" ),
            alias: "Go to Type Definition",
            precondition: f.d.and( m.a.hasTypeDefinitionProvider, m.a.isInEmbeddedEditor.toNegated() ),
            kbOpts: {
              kbExpr: m.a.editorTextFocus,
              primary: 0,
              weight: 100
            },
            menuOpts: {
              group: "navigation",
              order: 1.4
            }
          } ) || this
        }
        return b( t, e ), t.ID = "editor.action.goToTypeDefinition", t
      } )( I );
      var M = ( e => {
        function t() {
          return e.call( this, new C( !1, !0, !1 ), {
            id: t.ID,
            label: i.a( "actions.peekTypeDefinition.label", "Peek Type Definition" ),
            alias: "Peek Type Definition",
            precondition: f.d.and( m.a.hasTypeDefinitionProvider, m.a.isInEmbeddedEditor.toNegated() ),
            kbOpts: {
              kbExpr: m.a.editorTextFocus,
              primary: 0,
              weight: 100
            }
          } ) || this
        }
        return b( t, e ), t.ID = "editor.action.peekTypeDefinition", t
      } )( I );
      Object( l.f )( O ), Object( l.f )( L ), Object( l.f )( x ), Object( l.f )( E ), Object( l.f )( k ), Object( l.f )( D ), Object( l.f )( M )
    },
    nB0o( e, t, n ) {
      "use strict";
      n( "lrmC" ), n( "t2jz" );
      const i = n( "3/fG" ),
        o = n( "EffR" ),
        r = n( "/cxE" ),
        s = n( "MI8n" ),
        a = n( "pmY6" ),
        u = n( "VMIq" ),
        l = n( "Cg/j" ),
        c = n( "8HsV" ),
        d = n( "T8No" ),
        h = n( "HdwC" ),
        p = n( "N0LK" ),
        f = n( "Ll0s" ),
        g = n( "cGHE" ),
        m = n( "aokT" ),
        _ = n( "gCVg" ),
        v = n( "M1Kb" ),
        y = ( () => {
          function e( e ) {
            this.modelState = null, this.viewState = null, this._selTrackedRange = null, this._trackSelection = !0, this._setState( e, new f.f( new m.a( 1, 1, 1, 1 ), 0, new g.a( 1, 1 ), 0 ), new f.f( new m.a( 1, 1, 1, 1 ), 0, new g.a( 1, 1 ), 0 ) )
          }
          return e.prototype.dispose = function ( e ) {
            this._removeTrackedRange( e )
          }, e.prototype.startTrackingSelection = function ( e ) {
            this._trackSelection = !0, this._updateTrackedRange( e )
          }, e.prototype.stopTrackingSelection = function ( e ) {
            this._trackSelection = !1, this._removeTrackedRange( e )
          }, e.prototype._updateTrackedRange = function ( e ) {
            this._trackSelection && ( this._selTrackedRange = e.model._setTrackedRange( this._selTrackedRange, this.modelState.selection, v.h.AlwaysGrowsWhenTypingAtEdges ) )
          }, e.prototype._removeTrackedRange = function ( e ) {
            this._selTrackedRange = e.model._setTrackedRange( this._selTrackedRange, null, v.h.AlwaysGrowsWhenTypingAtEdges )
          }, e.prototype.asCursorState = function () {
            return new f.d( this.modelState, this.viewState )
          }, e.prototype.readSelectionFromMarkers = function ( e ) {
            const t = e.model._getTrackedRange( this._selTrackedRange );
            return this.modelState.selection.getDirection() === _.b.LTR ? new _.a( t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn ) : new _.a( t.endLineNumber, t.endColumn, t.startLineNumber, t.startColumn )
          }, e.prototype.ensureValidState = function ( e ) {
            this._setState( e, this.modelState, this.viewState )
          }, e.prototype.setState = function ( e, t, n ) {
            this._setState( e, t, n )
          }, e.prototype._setState = function ( e, t, n ) {
            if ( t ) {
              r = e.model.validateRange( t.selectionStart );
              const i = t.selectionStart.equalsRange( r ) ? t.selectionStartLeftoverVisibleColumns : 0,
                o = ( s = e.model.validatePosition( t.position ), t.position.equals( s ) ? t.leftoverVisibleColumns : 0 );
              t = new f.f( r, i, s, o )
            } else {
              var r = e.model.validateRange( e.convertViewRangeToModelRange( n.selectionStart ) ),
                s = e.model.validatePosition( e.convertViewPositionToModelPosition( n.position.lineNumber, n.position.column ) );
              t = new f.f( r, n.selectionStartLeftoverVisibleColumns, s, n.leftoverVisibleColumns )
            }
            if ( n ) {
              l = e.validateViewRange( n.selectionStart, t.selectionStart ), c = e.validateViewPosition( n.position, t.position );
              n = new f.f( l, t.selectionStartLeftoverVisibleColumns, c, t.leftoverVisibleColumns )
            } else {
              const a = e.convertModelPositionToViewPosition( new g.a( t.selectionStart.startLineNumber, t.selectionStart.startColumn ) );
              const u = e.convertModelPositionToViewPosition( new g.a( t.selectionStart.endLineNumber, t.selectionStart.endColumn ) );
              var l = new m.a( a.lineNumber, a.column, u.lineNumber, u.column );
              var c = e.convertModelPositionToViewPosition( t.position );
              n = new f.f( l, t.selectionStartLeftoverVisibleColumns, c, t.leftoverVisibleColumns )
            }
            this.modelState = t, this.viewState = n, this._updateTrackedRange( e )
          }, e;
        } )(),
        b = ( () => {
          function e( e ) {
            this.context = e, this.primaryCursor = new y( e ), this.secondaryCursors = [], this.lastAddedCursorIndex = 0
          }
          return e.prototype.dispose = function () {
            this.primaryCursor.dispose( this.context ), this.killSecondaryCursors()
          }, e.prototype.startTrackingSelections = function () {
            this.primaryCursor.startTrackingSelection( this.context );
            for ( let e = 0, t = this.secondaryCursors.length; e < t; e++ ) this.secondaryCursors[ e ].startTrackingSelection( this.context )
          }, e.prototype.stopTrackingSelections = function () {
            this.primaryCursor.stopTrackingSelection( this.context );
            for ( let e = 0, t = this.secondaryCursors.length; e < t; e++ ) this.secondaryCursors[ e ].stopTrackingSelection( this.context )
          }, e.prototype.updateContext = function ( e ) {
            this.context = e
          }, e.prototype.ensureValidState = function () {
            this.primaryCursor.ensureValidState( this.context );
            for ( let e = 0, t = this.secondaryCursors.length; e < t; e++ ) this.secondaryCursors[ e ].ensureValidState( this.context )
          }, e.prototype.readSelectionFromMarkers = function () {
            const e = [];
            e[ 0 ] = this.primaryCursor.readSelectionFromMarkers( this.context );
            for ( let t = 0, n = this.secondaryCursors.length; t < n; t++ ) e[ t + 1 ] = this.secondaryCursors[ t ].readSelectionFromMarkers( this.context );
            return e
          }, e.prototype.getAll = function () {
            const e = [];
            e[ 0 ] = this.primaryCursor.asCursorState();
            for ( let t = 0, n = this.secondaryCursors.length; t < n; t++ ) e[ t + 1 ] = this.secondaryCursors[ t ].asCursorState();
            return e
          }, e.prototype.getViewPositions = function () {
            const e = [];
            e[ 0 ] = this.primaryCursor.viewState.position;
            for ( let t = 0, n = this.secondaryCursors.length; t < n; t++ ) e[ t + 1 ] = this.secondaryCursors[ t ].viewState.position;
            return e
          }, e.prototype.getSelections = function () {
            const e = [];
            e[ 0 ] = this.primaryCursor.modelState.selection;
            for ( let t = 0, n = this.secondaryCursors.length; t < n; t++ ) e[ t + 1 ] = this.secondaryCursors[ t ].modelState.selection;
            return e
          }, e.prototype.getViewSelections = function () {
            const e = [];
            e[ 0 ] = this.primaryCursor.viewState.selection;
            for ( let t = 0, n = this.secondaryCursors.length; t < n; t++ ) e[ t + 1 ] = this.secondaryCursors[ t ].viewState.selection;
            return e
          }, e.prototype.setSelections = function ( e ) {
            this.setStates( f.d.fromModelSelections( e ) )
          }, e.prototype.getPrimaryCursor = function () {
            return this.primaryCursor.asCursorState()
          }, e.prototype.setStates = function ( e ) {
            null !== e && ( this.primaryCursor.setState( this.context, e[ 0 ].modelState, e[ 0 ].viewState ), this._setSecondaryStates( e.slice( 1 ) ) )
          }, e.prototype._setSecondaryStates = function ( e ) {
            const t = this.secondaryCursors.length,
              n = e.length;
            if ( t < n )
              for ( var i = n - t, o = 0; o < i; o++ ) this._addSecondaryCursor();
            else if ( t > n ) {
              const r = t - n;
              for ( o = 0; o < r; o++ ) this._removeSecondaryCursor( this.secondaryCursors.length - 1 )
            }
            for ( o = 0; o < n; o++ ) this.secondaryCursors[ o ].setState( this.context, e[ o ].modelState, e[ o ].viewState )
          }, e.prototype.killSecondaryCursors = function () {
            this._setSecondaryStates( [] )
          }, e.prototype._addSecondaryCursor = function () {
            this.secondaryCursors.push( new y( this.context ) ), this.lastAddedCursorIndex = this.secondaryCursors.length
          }, e.prototype.getLastAddedCursorIndex = function () {
            return 0 === this.secondaryCursors.length || 0 === this.lastAddedCursorIndex ? 0 : this.lastAddedCursorIndex
          }, e.prototype._removeSecondaryCursor = function ( e ) {
            this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.secondaryCursors[ e ].dispose( this.context ), this.secondaryCursors.splice( e, 1 )
          }, e.prototype._getAll = function () {
            const e = [];
            e[ 0 ] = this.primaryCursor;
            for ( let t = 0, n = this.secondaryCursors.length; t < n; t++ ) e[ t + 1 ] = this.secondaryCursors[ t ];
            return e
          }, e.prototype.normalize = function () {
            if ( 0 !== this.secondaryCursors.length ) {
              for ( var e = this._getAll(), t = [], n = 0, i = e.length; n < i; n++ ) t.push( {
                index: n,
                selection: e[ n ].modelState.selection
              } );
              t.sort( ( ( e, t ) => {
                return e.selection.startLineNumber === t.selection.startLineNumber ? e.selection.startColumn - t.selection.startColumn : e.selection.startLineNumber - t.selection.startLineNumber
              } ) );
              for ( let o = 0; o < t.length - 1; o++ ) {
                const r = t[ o ],
                  s = t[ o + 1 ],
                  a = r.selection,
                  u = s.selection;
                if ( this.context.config.multiCursorMergeOverlapping ) {
                  if ( u.isEmpty() || a.isEmpty() ? u.getStartPosition().isBeforeOrEqual( a.getEndPosition() ) : u.getStartPosition().isBefore( a.getEndPosition() ) ) {
                    const l = r.index < s.index ? o : o + 1,
                      c = r.index < s.index ? o + 1 : o,
                      d = t[ c ].index,
                      h = t[ l ].index,
                      p = t[ c ].selection,
                      g = t[ l ].selection;
                    if ( !p.equalsSelection( g ) ) {
                      const m = p.plusRange( g );
                      const v = p.selectionStartLineNumber === p.startLineNumber && p.selectionStartColumn === p.startColumn;
                      const y = g.selectionStartLineNumber === g.startLineNumber && g.selectionStartColumn === g.startColumn;
                      let b = void 0;
                      d === this.lastAddedCursorIndex ? ( b = v, this.lastAddedCursorIndex = h ) : b = y;
                      let C = void 0;
                      C = b ? new _.a( m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn ) : new _.a( m.endLineNumber, m.endColumn, m.startLineNumber, m.startColumn ), t[ l ].selection = C;
                      const w = f.d.fromModelSelection( C );
                      e[ h ].setState( this.context, w.modelState, w.viewState )
                    }
                    for ( let S = 0; S < t.length; S++ ) t[ S ].index > d && t[ S ].index--;
                    e.splice( d, 1 ), t.splice( c, 1 ), this._removeSecondaryCursor( d - 1 ), o--
                  }
                }
              }
            }
          }, e;
        } )(),
        C = n( "iuje" ),
        w = n( "snIX" ),
        S = n( "GR/f" ),
        O = n( "uzpd" ),
        L = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        x = function ( e ) {
          this.type = 1, this.canUseLayerHinting = e.canUseLayerHinting, this.pixelRatio = e.pixelRatio, this.editorClassName = e.editorClassName, this.lineHeight = e.lineHeight, this.readOnly = e.readOnly, this.accessibilitySupport = e.accessibilitySupport, this.emptySelectionClipboard = e.emptySelectionClipboard, this.layoutInfo = e.layoutInfo, this.fontInfo = e.fontInfo, this.viewInfo = e.viewInfo, this.wrappingInfo = e.wrappingInfo
        },
        N = function ( e ) {
          this.type = 2, this.selections = e
        },
        E = function () {
          this.type = 3
        },
        k = function () {
          this.type = 4
        },
        I = function ( e ) {
          this.type = 5, this.isFocused = e
        },
        D = function () {
          this.type = 6
        },
        M = function ( e, t ) {
          this.type = 7, this.fromLineNumber = e, this.toLineNumber = t
        },
        T = function ( e, t ) {
          this.type = 8, this.fromLineNumber = e, this.toLineNumber = t
        },
        R = function ( e, t ) {
          this.type = 9, this.fromLineNumber = e, this.toLineNumber = t
        },
        P = function ( e, t, n, i ) {
          this.type = 10, this.range = e, this.verticalType = t, this.revealHorizontal = n, this.scrollType = i
        },
        A = function ( e ) {
          this.type = 11, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged
        },
        F = function ( e ) {
          this.type = 12, this.ranges = e
        },
        W = function () {
          this.type = 15
        },
        j = function () {
          this.type = 13
        },
        V = function () {
          this.type = 14
        },
        B = function () {
          this.type = 16
        },
        H = ( e => {
          function t() {
            const t = e.call( this ) || this;
            return t._listeners = [], t._collector = null, t._collectorCnt = 0, t
          }
          return L( t, e ), t.prototype.dispose = function () {
            this._listeners = [], e.prototype.dispose.call( this )
          }, t.prototype._beginEmit = function () {
            return this._collectorCnt++, 1 === this._collectorCnt && ( this._collector = new z ), this._collector
          }, t.prototype._endEmit = function () {
            if ( this._collectorCnt--, 0 === this._collectorCnt ) {
              const e = this._collector.finalize();
              this._collector = null, e.length > 0 && this._emit( e )
            }
          }, t.prototype._emit = function ( e ) {
            for ( let t = this._listeners.slice( 0 ), n = 0, i = t.length; n < i; n++ ) U( t[ n ], e )
          }, t.prototype.addEventListener = function ( e ) {
            const t = this;
            return this._listeners.push( e ), Object( a.f )( ( () => {
              for ( let n = t._listeners, i = 0, o = n.length; i < o; i++ )
                if ( n[ i ] === e ) {
                  n.splice( i, 1 );
                  break
                }
            } ) );
          }, t;
        } )( a.a ),
        z = ( () => {
          function e() {
            this._eventsLen = 0, this._events = [], this._eventsLen = 0
          }
          return e.prototype.emit = function ( e ) {
            this._events[ this._eventsLen++ ] = e
          }, e.prototype.finalize = function () {
            const e = this._events;
            return this._events = null, e
          }, e;
        } )();

      function U( e, t ) {
        try {
          e( t )
        } catch ( n ) {
          r.e( n )
        }
      }
      const K = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const q = function ( e, t, n ) {
          this.selections = e, this.source = t, this.reason = n
        },
        G = ( () => {
          function e( e, t ) {
            this.modelVersionId = e.getVersionId(), this.cursorState = t.getAll()
          }
          return e.prototype.equals = function ( e ) {
            if ( !e ) return !1;
            if ( this.modelVersionId !== e.modelVersionId ) return !1;
            if ( this.cursorState.length !== e.cursorState.length ) return !1;
            for ( let t = 0, n = this.cursorState.length; t < n; t++ )
              if ( !this.cursorState[ t ].equals( e.cursorState[ t ] ) ) return !1;
            return !0
          }, e;
        } )(),
        Y = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            o._onDidReachMaxCursorCount = o._register( new s.a ), o.onDidReachMaxCursorCount = o._onDidReachMaxCursorCount.event, o._onDidAttemptReadOnlyEdit = o._register( new s.a ), o.onDidAttemptReadOnlyEdit = o._onDidAttemptReadOnlyEdit.event, o._onDidChange = o._register( new s.a ), o.onDidChange = o._onDidChange.event, o._configuration = t, o._model = n, o._knownModelVersionId = o._model.getVersionId(), o._viewModel = i, o.context = new f.c( o._configuration, o._model, o._viewModel ), o._cursors = new b( o.context ), o._isHandling = !1, o._isDoingComposition = !1, o._columnSelectData = null, o._prevEditOperationType = 0, o._register( o._model.onDidChangeRawContent( ( e => {
              if ( o._knownModelVersionId = e.versionId, !o._isHandling ) {
                const t = e.containsEvent( 1 );
                o._onModelContentChanged( t )
              }
            } ) ) ), o._register( i.addEventListener( ( e => {
              ( e => {
                for ( let t = 0, n = e.length; t < n; t++ )
                  if ( 6 === e[ t ].type ) return !0;
                return !1
              } )( e ) && o._knownModelVersionId === o._model.getVersionId() && o.setStates( "viewModel", O.a.NotSet, o.getAll() )
            } ) ) );
            const r = () => {
              o.context = new f.c( o._configuration, o._model, o._viewModel ), o._cursors.updateContext( o.context )
            };
            return o._register( o._model.onDidChangeLanguage( ( e => {
              r()
            } ) ) ), o._register( o._model.onDidChangeLanguageConfiguration( ( () => {
              r()
            } ) ) ), o._register( o._model.onDidChangeOptions( ( () => {
              r()
            } ) ) ), o._register( o._configuration.onDidChange( ( e => {
              f.b.shouldRecreate( e ) && r()
            } ) ) ), o;
          }
          return K( t, e ), t.prototype.dispose = function () {
            this._cursors.dispose(), e.prototype.dispose.call( this )
          }, t.prototype.getPrimaryCursor = function () {
            return this._cursors.getPrimaryCursor()
          }, t.prototype.getLastAddedCursorIndex = function () {
            return this._cursors.getLastAddedCursorIndex()
          }, t.prototype.getAll = function () {
            return this._cursors.getAll()
          }, t.prototype.setStates = function ( e, n, i ) {
            i.length > t.MAX_CURSOR_COUNT && ( i = i.slice( 0, t.MAX_CURSOR_COUNT ), this._onDidReachMaxCursorCount.fire( void 0 ) );
            const o = new G( this._model, this );
            this._cursors.setStates( i ), this._cursors.normalize(), this._columnSelectData = null, this._emitStateChangedIfNecessary( e, n, o )
          }, t.prototype.setColumnSelectData = function ( e ) {
            this._columnSelectData = e
          }, t.prototype.reveal = function ( e, t, n ) {
            this._revealRange( t, 0, e, n )
          }, t.prototype.revealRange = function ( e, t, n, i ) {
            this.emitCursorRevealRange( t, n, e, i )
          }, t.prototype.scrollTo = function ( e ) {
            this._viewModel.viewLayout.setScrollPositionSmooth( {
              scrollTop: e
            } )
          }, t.prototype.saveState = function () {
            for ( var e = [], t = this._cursors.getSelections(), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              e.push( {
                inSelectionMode: !o.isEmpty(),
                selectionStart: {
                  lineNumber: o.selectionStartLineNumber,
                  column: o.selectionStartColumn
                },
                position: {
                  lineNumber: o.positionLineNumber,
                  column: o.positionColumn
                }
              } )
            }
            return e
          }, t.prototype.restoreState = function ( e ) {
            for ( var t = [], n = 0, i = e.length; n < i; n++ ) {
              const o = e[ n ];
              let r = 1;
              let s = 1;
              o.position && o.position.lineNumber && ( r = o.position.lineNumber ), o.position && o.position.column && ( s = o.position.column );
              let a = r,
                u = s;
              o.selectionStart && o.selectionStart.lineNumber && ( a = o.selectionStart.lineNumber ), o.selectionStart && o.selectionStart.column && ( u = o.selectionStart.column ), t.push( {
                selectionStartLineNumber: a,
                selectionStartColumn: u,
                positionLineNumber: r,
                positionColumn: s
              } )
            }
            this.setStates( "restoreState", O.a.NotSet, f.d.fromModelSelections( t ) ), this.reveal( !0, 0, 1 )
          }, t.prototype._onModelContentChanged = function ( e ) {
            if ( this._prevEditOperationType = 0, e ) this._cursors.dispose(), this._cursors = new b( this.context ), this._emitStateChangedIfNecessary( "model", O.a.ContentFlush, null );
            else {
              const t = this._cursors.readSelectionFromMarkers();
              this.setStates( "modelChange", O.a.RecoverFromMarkers, f.d.fromModelSelections( t ) )
            }
          }, t.prototype.getSelection = function () {
            return this._cursors.getPrimaryCursor().modelState.selection
          }, t.prototype.getColumnSelectData = function () {
            if ( this._columnSelectData ) return this._columnSelectData;
            const e = this._cursors.getPrimaryCursor().viewState.position;
            return {
              toViewLineNumber: e.lineNumber,
              toViewVisualColumn: f.a.visibleColumnFromColumn2( this.context.config, this.context.viewModel, e )
            }
          }, t.prototype.getSelections = function () {
            return this._cursors.getSelections()
          }, t.prototype.getViewSelections = function () {
            return this._cursors.getViewSelections()
          }, t.prototype.getPosition = function () {
            return this._cursors.getPrimaryCursor().modelState.position
          }, t.prototype.setSelections = function ( e, t ) {
            this.setStates( e, O.a.NotSet, f.d.fromModelSelections( t ) )
          }, t.prototype.getPrevEditOperationType = function () {
            return this._prevEditOperationType
          }, t.prototype.setPrevEditOperationType = function ( e ) {
            this._prevEditOperationType = e
          }, t.prototype._executeEditOperation = function ( e ) {
            if ( e ) {
              e.shouldPushStackElementBefore && this._model.pushStackElement();
              const t = X.executeCommands( this._model, this._cursors.getSelections(), e.commands );
              t && ( this._interpretCommandResult( t ), this._prevEditOperationType = e.type ), e.shouldPushStackElementAfter && this._model.pushStackElement()
            }
          }, t.prototype._interpretCommandResult = function ( e ) {
            e && 0 !== e.length || ( e = this._cursors.readSelectionFromMarkers() ), this._columnSelectData = null, this._cursors.setSelections( e ), this._cursors.normalize()
          }, t.prototype._emitStateChangedIfNecessary = function ( e, t, n ) {
            const i = new G( this._model, this );
            if ( i.equals( n ) ) return !1;
            const o = this._cursors.getSelections(),
              r = this._cursors.getViewSelections();
            try {
              this._beginEmit().emit( new N( r ) )
            } finally {
              this._endEmit()
            }
            return n && n.cursorState.length === i.cursorState.length && !i.cursorState.some( ( ( e, t ) => {
              return !e.modelState.equals( n.cursorState[ t ].modelState )
            } ) ) || this._onDidChange.fire( new q( o, e || "keyboard", t ) ), !0;
          }, t.prototype._revealRange = function ( e, t, n, i ) {
            const o = this._cursors.getViewPositions();
            let r = o[ 0 ];
            if ( 1 === e )
              for ( var s = 1; s < o.length; s++ ) o[ s ].isBefore( r ) && ( r = o[ s ] );
            else if ( 2 === e )
              for ( s = 1; s < o.length; s++ ) r.isBeforeOrEqual( o[ s ] ) && ( r = o[ s ] );
            else if ( o.length > 1 ) return;
            const a = new m.a( r.lineNumber, r.column, r.lineNumber, r.column );
            this.emitCursorRevealRange( a, t, n, i )
          }, t.prototype.emitCursorRevealRange = function ( e, t, n, i ) {
            try {
              this._beginEmit().emit( new P( e, t, n, i ) )
            } finally {
              this._endEmit()
            }
          }, t.prototype.trigger = function ( e, t, n ) {
            const i = C.b;
            if ( t !== i.CompositionStart )
              if ( t === i.CompositionEnd && ( this._isDoingComposition = !1 ), this._configuration.editor.readOnly ) this._onDidAttemptReadOnlyEdit.fire( void 0 );
              else {
                const o = new G( this._model, this );
                let s = O.a.NotSet;
                t !== i.Undo && t !== i.Redo && this._cursors.stopTrackingSelections(), this._cursors.ensureValidState(), this._isHandling = !0;
                try {
                  switch ( t ) {
                    case i.Type:
                      this._type( e, n.text );
                      break;
                    case i.ReplacePreviousChar:
                      this._replacePreviousChar( n.text, n.replaceCharCnt );
                      break;
                    case i.Paste:
                      s = O.a.Paste, this._paste( n.text, n.pasteOnNewLine, n.multicursorText );
                      break;
                    case i.Cut:
                      this._cut();
                      break;
                    case i.Undo:
                      s = O.a.Undo, this._interpretCommandResult( this._model.undo() );
                      break;
                    case i.Redo:
                      s = O.a.Redo, this._interpretCommandResult( this._model.redo() );
                      break;
                    case i.ExecuteCommand:
                      this._externalExecuteCommand( n );
                      break;
                    case i.ExecuteCommands:
                      this._externalExecuteCommands( n );
                      break;
                    case i.CompositionEnd:
                      this._interpretCompositionEnd( e )
                  }
                } catch ( a ) {
                  Object( r.e )( a )
                }
                this._isHandling = !1, t !== i.Undo && t !== i.Redo && this._cursors.startTrackingSelections(), this._emitStateChangedIfNecessary( e, s, o ) && this._revealRange( 0, 0, !0, 0 )
              }
            else this._isDoingComposition = !0
          }, t.prototype._interpretCompositionEnd = function ( e ) {
            this._isDoingComposition || "keyboard" !== e || this._executeEditOperation( S.TypeOperations.compositionEndWithInterceptors( this._prevEditOperationType, this.context.config, this.context.model, this.getSelections() ) )
          }, t.prototype._type = function ( e, t ) {
            if ( this._isDoingComposition || "keyboard" !== e ) this._executeEditOperation( S.TypeOperations.typeWithoutInterceptors( this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), t ) );
            else
              for ( let n = 0, i = t.length; n < i; n++ ) {
                const o = t.charCodeAt( n );
                let r = void 0;
                p.isHighSurrogate( o ) && n + 1 < i ? ( r = t.charAt( n ) + t.charAt( n + 1 ), n++ ) : r = t.charAt( n ), this._executeEditOperation( S.TypeOperations.typeWithInterceptors( this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), r ) )
              }
          }, t.prototype._replacePreviousChar = function ( e, t ) {
            this._executeEditOperation( S.TypeOperations.replacePreviousChar( this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), e, t ) )
          }, t.prototype._paste = function ( e, t, n ) {
            this._executeEditOperation( S.TypeOperations.paste( this.context.config, this.context.model, this.getSelections(), e, t, n ) )
          }, t.prototype._cut = function () {
            this._executeEditOperation( w.a.cut( this.context.config, this.context.model, this.getSelections() ) )
          }, t.prototype._externalExecuteCommand = function ( e ) {
            this._cursors.killSecondaryCursors(), this._executeEditOperation( new f.e( 0, [ e ], {
              shouldPushStackElementBefore: !1,
              shouldPushStackElementAfter: !1
            } ) )
          }, t.prototype._externalExecuteCommands = function ( e ) {
            this._executeEditOperation( new f.e( 0, e, {
              shouldPushStackElementBefore: !1,
              shouldPushStackElementAfter: !1
            } ) )
          }, t.MAX_CURSOR_COUNT = 1e4, t;
        } )( H ),
        X = ( () => {
          function e() {}
          return e.executeCommands = function ( e, t, n ) {
            for ( var i = {
                model: e,
                selectionsBefore: t,
                trackedRanges: [],
                trackedRangesDirection: []
              }, o = this._innerExecuteCommands( i, n ), r = 0, s = i.trackedRanges.length; r < s; r++ ) i.model._setTrackedRange( i.trackedRanges[ r ], null, v.h.AlwaysGrowsWhenTypingAtEdges );
            return o
          }, e._innerExecuteCommands = function ( e, t ) {
            if ( this._arrayIsEmpty( t ) ) return null;
            const n = this._getEditOperations( e, t );
            if ( 0 === n.operations.length ) return null;
            const i = n.operations,
              o = this._getLoserCursorMap( i );
            if ( o.hasOwnProperty( "0" ) ) return console.warn( "Ignoring commands" ), null;
            for ( var r = [], s = 0, a = i.length; s < a; s++ ) o.hasOwnProperty( i[ s ].identifier.major.toString() ) || r.push( i[ s ] );
            n.hadTrackedEditOperation && r.length > 0 && ( r[ 0 ]._isTracked = !0 );
            const u = e.model.pushEditOperations( e.selectionsBefore, r, ( n => {
                for ( var i = [], o = 0; o < e.selectionsBefore.length; o++ ) i[ o ] = [];
                for ( o = 0; o < n.length; o++ ) {
                  const r = n[ o ];
                  r.identifier && i[ r.identifier.major ].push( r )
                }
                const s = ( e, t ) => {
                    return e.identifier.minor - t.identifier.minor
                  },
                  a = [],
                  u = n => {
                    i[ n ].length > 0 ? ( i[ n ].sort( s ), a[ n ] = t[ n ].computeCursorState( e.model, {
                      getInverseEditOperations() {
                        return i[ n ]
                      },
                      getTrackedSelection( t ) {
                        const n = parseInt( t, 10 ),
                          i = e.model._getTrackedRange( e.trackedRanges[ n ] );
                        return e.trackedRangesDirection[ n ] === _.b.LTR ? new _.a( i.startLineNumber, i.startColumn, i.endLineNumber, i.endColumn ) : new _.a( i.endLineNumber, i.endColumn, i.startLineNumber, i.startColumn )
                      }
                    } ) ) : a[ n ] = e.selectionsBefore[ n ]
                  };
                for ( o = 0; o < e.selectionsBefore.length; o++ ) u( o );
                return a
              } ) ),
              l = [];
            for ( const c in o ) o.hasOwnProperty( c ) && l.push( parseInt( c, 10 ) );
            l.sort( ( ( e, t ) => {
              return t - e
            } ) );
            for ( s = 0; s < l.length; s++ ) u.splice( l[ s ], 1 );
            return u
          }, e._arrayIsEmpty = e => {
            for ( let t = 0, n = e.length; t < n; t++ )
              if ( e[ t ] ) return !1;
            return !0
          }, e._getEditOperations = function ( e, t ) {
            for ( var n = [], i = !1, o = 0, r = t.length; o < r; o++ )
              if ( t[ o ] ) {
                const s = this._getEditOperationsFromCommand( e, o, t[ o ] );
                n = n.concat( s.operations ), i = i || s.hadTrackedEditOperation
              } return {
              operations: n,
              hadTrackedEditOperation: i
            }
          }, e._getEditOperationsFromCommand = ( e, t, n ) => {
            const o = [];
            let s = 0;
            const a = ( e, i ) => {
              e.isEmpty() && "" === i || o.push( {
                identifier: {
                  major: t,
                  minor: s++
                },
                range: e,
                text: i,
                forceMoveMarkers: !1,
                isAutoWhitespaceEdit: n.insertsAutoWhitespace
              } )
            };
            let u = !1;
            const l = {
              addEditOperation: a,
              addTrackedEditOperation( e, t ) {
                u = !0, a( e, t )
              },
              trackSelection( t, n ) {
                let i;
                if ( t.isEmpty() )
                  if ( "boolean" === typeof n ) i = n ? v.h.GrowsOnlyWhenTypingBefore : v.h.GrowsOnlyWhenTypingAfter;
                  else {
                    const o = e.model.getLineMaxColumn( t.startLineNumber );
                    i = t.startColumn === o ? v.h.GrowsOnlyWhenTypingBefore : v.h.GrowsOnlyWhenTypingAfter
                  }
                else i = v.h.NeverGrowsWhenTypingAtEdges;
                const r = e.trackedRanges.length,
                  s = e.model._setTrackedRange( null, t, i );
                return e.trackedRanges[ r ] = s, e.trackedRangesDirection[ r ] = t.getDirection(), r.toString()
              }
            };
            try {
              n.getEditOperations( e.model, l )
            } catch ( c ) {
              return c.friendlyMessage = i.a( "corrupt.commands", "Unexpected exception while executing command." ), Object( r.e )( c ), {
                operations: [],
                hadTrackedEditOperation: !1
              }
            }
            return {
              operations: o,
              hadTrackedEditOperation: u
            }
          }, e._getLoserCursorMap = e => {
            ( e = e.slice( 0 ) ).sort( ( ( e, t ) => {
              return -m.a.compareRangesUsingEnds( e.range, t.range )
            } ) );
            for ( var t = {}, n = 1; n < e.length; n++ ) {
              const i = e[ n - 1 ],
                o = e[ n ];
              if ( i.range.getStartPosition().isBefore( o.range.getEndPosition() ) ) {
                let r = void 0;
                t[ ( r = i.identifier.major > o.identifier.major ? i.identifier.major : o.identifier.major ).toString() ] = !0;
                for ( let s = 0; s < e.length; s++ ) e[ s ].identifier.major === r && ( e.splice( s, 1 ), s < n && n--, s-- );
                n > 0 && n--
              }
            }
            return t
          }, e;
        } )(),
        $ = n( "twdY" ),
        Z = n( "TQUy" ),
        Q = n( "qNAo" ),
        J = ( () => {
          function e( e, t, n, i, o ) {
            this.editorId = e, this.model = t, this.configuration = n, this._linesCollection = i, this._coordinatesConverter = o, this._decorationsCache = Object.create( null ), this._clearCachedModelDecorationsResolver()
          }
          return e.prototype._clearCachedModelDecorationsResolver = function () {
            this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null
          }, e.prototype.dispose = function () {
            this._decorationsCache = null, this._clearCachedModelDecorationsResolver()
          }, e.prototype.reset = function () {
            this._decorationsCache = Object.create( null ), this._clearCachedModelDecorationsResolver()
          }, e.prototype.onModelDecorationsChanged = function () {
            this._decorationsCache = Object.create( null ), this._clearCachedModelDecorationsResolver()
          }, e.prototype.onLineMappingChanged = function () {
            this._decorationsCache = Object.create( null ), this._clearCachedModelDecorationsResolver()
          }, e.prototype._getOrCreateViewModelDecoration = function ( e ) {
            const t = e.id;
            let n = this._decorationsCache[ t ];
            if ( !n ) {
              const i = e.range;
              const o = e.options;
              let r = void 0;
              if ( o.isWholeLine ) {
                const s = this._coordinatesConverter.convertModelPositionToViewPosition( new g.a( i.startLineNumber, 1 ) ),
                  a = this._coordinatesConverter.convertModelPositionToViewPosition( new g.a( i.endLineNumber, this.model.getLineMaxColumn( i.endLineNumber ) ) );
                r = new m.a( s.lineNumber, s.column, a.lineNumber, a.column )
              } else r = this._coordinatesConverter.convertModelRangeToViewRange( i );
              n = new Q.e( r, o ), this._decorationsCache[ t ] = n
            }
            return n
          }, e.prototype.getDecorationsViewportData = function ( e ) {
            let t = !0;
            return ( t = ( t = t && null !== this._cachedModelDecorationsResolver ) && e.equalsRange( this._cachedModelDecorationsResolverViewRange ) ) || ( this._cachedModelDecorationsResolver = this._getDecorationsViewportData( e ), this._cachedModelDecorationsResolverViewRange = e ), this._cachedModelDecorationsResolver
          }, e.prototype._getDecorationsViewportData = function ( e ) {
            for ( var t = this._linesCollection.getDecorationsInRange( e, this.editorId, this.configuration.editor.readOnly ), n = e.startLineNumber, i = e.endLineNumber, o = [], r = 0, s = [], a = n; a <= i; a++ ) s[ a - n ] = [];
            for ( let u = 0, l = t.length; u < l; u++ ) {
              const c = t[ u ],
                d = c.options,
                h = this._getOrCreateViewModelDecoration( c ),
                p = h.range;
              if ( o[ r++ ] = h, d.inlineClassName ) {
                var f = new Q.a( p, d.inlineClassName, d.inlineClassNameAffectsLetterSpacing ? 3 : 0 );
                const g = Math.max( n, p.startLineNumber );
                const _ = Math.min( i, p.endLineNumber );
                for ( a = g; a <= _; a++ ) s[ a - n ].push( f )
              }
              if ( d.beforeContentClassName && n <= p.startLineNumber && p.startLineNumber <= i ) {
                f = new Q.a( new m.a( p.startLineNumber, p.startColumn, p.startLineNumber, p.startColumn ), d.beforeContentClassName, 1 );
                s[ p.startLineNumber - n ].push( f )
              }
              if ( d.afterContentClassName && n <= p.endLineNumber && p.endLineNumber <= i ) {
                f = new Q.a( new m.a( p.endLineNumber, p.endColumn, p.endLineNumber, p.endColumn ), d.afterContentClassName, 2 );
                s[ p.endLineNumber - n ].push( f )
              }
            }
            return {
              decorations: o,
              inlineDecorations: s
            }
          }, e;
        } )(),
        ee = n( "LeU+" ),
        te = n( "tX9W" ),
        ne = n( "zrhQ" ),
        ie = function ( e, t ) {
          this.outputLineIndex = e, this.outputOffset = t
        },
        oe = ( () => {
          function e( e ) {
            this._lines = e
          }
          return e.prototype.convertViewPositionToModelPosition = function ( e ) {
            return this._lines.convertViewPositionToModelPosition( e.lineNumber, e.column )
          }, e.prototype.convertViewRangeToModelRange = function ( e ) {
            const t = this._lines.convertViewPositionToModelPosition( e.startLineNumber, e.startColumn ),
              n = this._lines.convertViewPositionToModelPosition( e.endLineNumber, e.endColumn );
            return new m.a( t.lineNumber, t.column, n.lineNumber, n.column )
          }, e.prototype.validateViewPosition = function ( e, t ) {
            return this._lines.validateViewPosition( e.lineNumber, e.column, t )
          }, e.prototype.validateViewRange = function ( e, t ) {
            const n = this._lines.validateViewPosition( e.startLineNumber, e.startColumn, t.getStartPosition() ),
              i = this._lines.validateViewPosition( e.endLineNumber, e.endColumn, t.getEndPosition() );
            return new m.a( n.lineNumber, n.column, i.lineNumber, i.column )
          }, e.prototype.convertModelPositionToViewPosition = function ( e ) {
            return this._lines.convertModelPositionToViewPosition( e.lineNumber, e.column )
          }, e.prototype.convertModelRangeToViewRange = function ( e ) {
            const t = this._lines.convertModelPositionToViewPosition( e.startLineNumber, e.startColumn ),
              n = this._lines.convertModelPositionToViewPosition( e.endLineNumber, e.endColumn );
            return new m.a( t.lineNumber, t.column, n.lineNumber, n.column )
          }, e.prototype.modelPositionIsVisible = function ( e ) {
            return this._lines.modelPositionIsVisible( e.lineNumber, e.column )
          }, e;
        } )(),
        re = ( () => {
          function e( e, t, n, i, o, r ) {
            this.model = e, this._validModelVersionId = -1, this.tabSize = n, this.wrappingColumn = i, this.columnsForFullWidthChar = o, this.wrappingIndent = r, this.linePositionMapperFactory = t, this._constructLines( !0 )
          }
          return e.prototype.dispose = function () {
            this.hiddenAreasIds = this.model.deltaDecorations( this.hiddenAreasIds, [] )
          }, e.prototype.createCoordinatesConverter = function () {
            return new oe( this )
          }, e.prototype._ensureValidState = function () {
            if ( this.model.getVersionId() !== this._validModelVersionId ) throw new Error( "ViewModel is out of sync with Model!" )
          }, e.prototype._constructLines = function ( e ) {
            const t = this;
            this.lines = [], e && ( this.hiddenAreasIds = [] );
            for ( var n = this.model.getLinesContent(), i = n.length, o = new Uint32Array( i ), r = this.hiddenAreasIds.map( ( e => {
                return t.model.getDecorationRange( e )
              } ) ).sort( m.a.compareRangesUsingStarts ), s = 1, a = 0, u = -1, l = u + 1 < r.length ? a + 1 : i + 2, c = 0; c < i; c++ ) {
              const d = c + 1;
              d === l && ( s = r[ ++u ].startLineNumber, a = r[ u ].endLineNumber, l = u + 1 < r.length ? a + 1 : i + 2 );
              const h = d >= s && d <= a,
                p = le( this.linePositionMapperFactory, n[ c ], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !h );
              o[ c ] = p.getViewLineCount(), this.lines[ c ] = p
            }
            this._validModelVersionId = this.model.getVersionId(), this.prefixSumComputer = new ee.b( o )
          }, e.prototype.getHiddenAreas = function () {
            const e = this;
            return this.hiddenAreasIds.map( ( t => {
              return e.model.getDecorationRange( t )
            } ) );
          }, e.prototype._reduceRanges = function ( e ) {
            const t = this;
            if ( 0 === e.length ) return [];
            for ( var n = e.map( ( e => {
                return t.model.validateRange( e )
              } ) ).sort( m.a.compareRangesUsingStarts ), i = [], o = n[ 0 ].startLineNumber, r = n[ 0 ].endLineNumber, s = 1, a = n.length; s < a; s++ ) {
              const u = n[ s ];
              u.startLineNumber > r + 1 ? ( i.push( new m.a( o, 1, r, 1 ) ), o = u.startLineNumber, r = u.endLineNumber ) : u.endLineNumber > r && ( r = u.endLineNumber )
            }
            return i.push( new m.a( o, 1, r, 1 ) ), i
          }, e.prototype.setHiddenAreas = function ( e ) {
            const t = this,
              n = this._reduceRanges( e ),
              i = this.hiddenAreasIds.map( ( e => {
                return t.model.getDecorationRange( e )
              } ) ).sort( m.a.compareRangesUsingStarts );
            if ( n.length === i.length ) {
              for ( var o = !1, r = 0; r < n.length; r++ )
                if ( !n[ r ].equalsRange( i[ r ] ) ) {
                  o = !0;
                  break
                } if ( !o ) return !1
            }
            const s = [];
            for ( r = 0; r < n.length; r++ ) s.push( {
              range: n[ r ],
              options: te.a.EMPTY
            } );
            this.hiddenAreasIds = this.model.deltaDecorations( this.hiddenAreasIds, s );
            const a = n;
            let u = 1;
            let l = 0;
            let c = -1;
            let d = c + 1 < a.length ? l + 1 : this.lines.length + 2;
            let h = !1;
            for ( r = 0; r < this.lines.length; r++ ) {
              const p = r + 1;
              p === d && ( u = a[ ++c ].startLineNumber, l = a[ c ].endLineNumber, d = c + 1 < a.length ? l + 1 : this.lines.length + 2 );
              let f = !1;
              if ( p >= u && p <= l ? this.lines[ r ].isVisible() && ( this.lines[ r ] = this.lines[ r ].setVisible( !1 ), f = !0 ) : ( h = !0, this.lines[ r ].isVisible() || ( this.lines[ r ] = this.lines[ r ].setVisible( !0 ), f = !0 ) ), f ) {
                const g = this.lines[ r ].getViewLineCount();
                this.prefixSumComputer.changeValue( r, g )
              }
            }
            return h || this.setHiddenAreas( [] ), !0
          }, e.prototype.modelPositionIsVisible = function ( e, t ) {
            return !( e < 1 || e > this.lines.length ) && this.lines[ e - 1 ].isVisible()
          }, e.prototype.setTabSize = function ( e ) {
            return this.tabSize !== e && ( this.tabSize = e, this._constructLines( !1 ), !0 )
          }, e.prototype.setWrappingSettings = function ( e, t, n ) {
            return ( this.wrappingIndent !== e || this.wrappingColumn !== t || this.columnsForFullWidthChar !== n ) && ( this.wrappingIndent = e, this.wrappingColumn = t, this.columnsForFullWidthChar = n, this._constructLines( !1 ), !0 )
          }, e.prototype.onModelFlushed = function () {
            this._constructLines( !0 )
          }, e.prototype.onModelLinesDeleted = function ( e, t, n ) {
            if ( e <= this._validModelVersionId ) return null;
            const i = 1 === t ? 1 : this.prefixSumComputer.getAccumulatedValue( t - 2 ) + 1,
              o = this.prefixSumComputer.getAccumulatedValue( n - 1 );
            return this.lines.splice( t - 1, n - t + 1 ), this.prefixSumComputer.removeValues( t - 1, n - t + 1 ), new T( i, o )
          }, e.prototype.onModelLinesInserted = function ( e, t, n, i ) {
            if ( e <= this._validModelVersionId ) return null;
            for ( var o = this.getHiddenAreas(), r = !1, s = new g.a( t, 1 ), a = 0; a < o.length; a++ )
              if ( o[ a ].containsPosition( s ) ) {
                r = !0;
                break
              } for ( var u = 1 === t ? 1 : this.prefixSumComputer.getAccumulatedValue( t - 2 ) + 1, l = 0, c = [], d = new Uint32Array( i.length ), h = ( a = 0, i.length ); a < h; a++ ) {
              const p = le( this.linePositionMapperFactory, i[ a ], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !r );
              c.push( p );
              const f = p.getViewLineCount();
              l += f, d[ a ] = f
            }
            return this.lines = this.lines.slice( 0, t - 1 ).concat( c ).concat( this.lines.slice( t - 1 ) ), this.prefixSumComputer.insertValues( t - 1, d ), new R( u, u + l - 1 )
          }, e.prototype.onModelLineChanged = function ( e, t, n ) {
            if ( e <= this._validModelVersionId ) return [ !1, null, null, null ];
            const i = t - 1,
              o = this.lines[ i ].getViewLineCount(),
              r = this.lines[ i ].isVisible(),
              s = le( this.linePositionMapperFactory, n, this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, r );
            this.lines[ i ] = s;
            const a = this.lines[ i ].getViewLineCount();
            let u = !1;
            let l = 0;
            let c = -1;
            let d = 0;
            let h = -1;
            let p = 0;
            let f = -1;
            return o > a ? ( f = ( p = ( c = ( l = 1 === t ? 1 : this.prefixSumComputer.getAccumulatedValue( t - 2 ) + 1 ) + a - 1 ) + 1 ) + ( o - a ) - 1, u = !0 ) : o < a ? ( h = ( d = ( c = ( l = 1 === t ? 1 : this.prefixSumComputer.getAccumulatedValue( t - 2 ) + 1 ) + o - 1 ) + 1 ) + ( a - o ) - 1, u = !0 ) : c = ( l = 1 === t ? 1 : this.prefixSumComputer.getAccumulatedValue( t - 2 ) + 1 ) + a - 1, this.prefixSumComputer.changeValue( i, a ), [ u, l <= c ? new M( l, c ) : null, d <= h ? new R( d, h ) : null, p <= f ? new T( p, f ) : null ]
          }, e.prototype.acceptVersionId = function ( e ) {
            this._validModelVersionId = e, 1 !== this.lines.length || this.lines[ 0 ].isVisible() || this.setHiddenAreas( [] )
          }, e.prototype.getViewLineCount = function () {
            return this._ensureValidState(), this.prefixSumComputer.getTotalValue()
          }, e.prototype._toValidViewLineNumber = function ( e ) {
            if ( e < 1 ) return 1;
            const t = this.getViewLineCount();
            return e > t ? t : e
          }, e.prototype.warmUpLookupCache = function ( e, t ) {
            this.prefixSumComputer.warmUpCache( e - 1, t - 1 )
          }, e.prototype.getActiveIndentGuide = function ( e, t, n ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e ), t = this._toValidViewLineNumber( t ), n = this._toValidViewLineNumber( n );
            const i = this.convertViewPositionToModelPosition( e, this.getViewLineMinColumn( e ) ),
              o = this.convertViewPositionToModelPosition( t, this.getViewLineMinColumn( t ) ),
              r = this.convertViewPositionToModelPosition( n, this.getViewLineMinColumn( n ) ),
              s = this.model.getActiveIndentGuide( i.lineNumber, o.lineNumber, r.lineNumber ),
              a = this.convertModelPositionToViewPosition( s.startLineNumber, 1 ),
              u = this.convertModelPositionToViewPosition( s.endLineNumber, 1 );
            return {
              startLineNumber: a.lineNumber,
              endLineNumber: u.lineNumber,
              indent: s.indent
            }
          }, e.prototype.getViewLinesIndentGuides = function ( e, t ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e ), t = this._toValidViewLineNumber( t );
            for ( var n = this.convertViewPositionToModelPosition( e, this.getViewLineMinColumn( e ) ), i = this.convertViewPositionToModelPosition( t, this.getViewLineMaxColumn( t ) ), o = [], r = [], s = [], a = n.lineNumber - 1, u = i.lineNumber - 1, l = null, c = a; c <= u; c++ ) {
              const d = this.lines[ c ];
              if ( d.isVisible() ) {
                const h = d.getViewLineNumberOfModelPosition( 0, c === a ? n.column : 1 );
                const p = d.getViewLineNumberOfModelPosition( 0, this.model.getLineMaxColumn( c + 1 ) );
                var f = 0;
                ( w = p - h + 1 ) > 1 && 1 === d.getViewLineMinColumn( this.model, c + 1, p ) && ( f = 0 === h ? 1 : 2 ), r.push( w ), s.push( f ), null === l && ( l = new g.a( c + 1, 0 ) )
              } else null !== l && ( o = o.concat( this.model.getLinesIndentGuides( l.lineNumber, c ) ), l = null )
            }
            null !== l && ( o = o.concat( this.model.getLinesIndentGuides( l.lineNumber, i.lineNumber ) ), l = null );
            for ( var m = t - e + 1, _ = new Array( m ), v = 0, y = 0, b = o.length; y < b; y++ ) {
              let C = o[ y ];
              var w = Math.min( m - v, r[ y ] );
              let S = void 0;
              S = 2 === ( f = s[ y ] ) ? 0 : 1 === f ? 1 : w;
              for ( let O = 0; O < w; O++ ) O === S && ( C = 0 ), _[ v++ ] = C
            }
            return _
          }, e.prototype.getViewLineContent = function ( e ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e );
            const t = this.prefixSumComputer.getIndexOf( e - 1 ),
              n = t.index,
              i = t.remainder;
            return this.lines[ n ].getViewLineContent( this.model, n + 1, i )
          }, e.prototype.getViewLineLength = function ( e ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e );
            const t = this.prefixSumComputer.getIndexOf( e - 1 ),
              n = t.index,
              i = t.remainder;
            return this.lines[ n ].getViewLineLength( this.model, n + 1, i )
          }, e.prototype.getViewLineMinColumn = function ( e ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e );
            const t = this.prefixSumComputer.getIndexOf( e - 1 ),
              n = t.index,
              i = t.remainder;
            return this.lines[ n ].getViewLineMinColumn( this.model, n + 1, i )
          }, e.prototype.getViewLineMaxColumn = function ( e ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e );
            const t = this.prefixSumComputer.getIndexOf( e - 1 ),
              n = t.index,
              i = t.remainder;
            return this.lines[ n ].getViewLineMaxColumn( this.model, n + 1, i )
          }, e.prototype.getViewLineData = function ( e ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e );
            const t = this.prefixSumComputer.getIndexOf( e - 1 ),
              n = t.index,
              i = t.remainder;
            return this.lines[ n ].getViewLineData( this.model, n + 1, i )
          }, e.prototype.getViewLinesData = function ( e, t, n ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e ), t = this._toValidViewLineNumber( t );
            for ( var i = this.prefixSumComputer.getIndexOf( e - 1 ), o = e, r = i.index, s = i.remainder, a = [], u = r, l = this.model.getLineCount(); u < l; u++ ) {
              const c = this.lines[ u ];
              if ( c.isVisible() ) {
                const d = u === r ? s : 0;
                let h = c.getViewLineCount() - d;
                let p = !1;
                o + h > t && ( p = !0, h = t - o + 1 );
                const f = d + h;
                if ( c.getViewLinesData( this.model, u + 1, d, f, o - e, n, a ), o += h, p ) break
              }
            }
            return a
          }, e.prototype.validateViewPosition = function ( e, t, n ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e );
            const i = this.prefixSumComputer.getIndexOf( e - 1 ),
              o = i.index,
              r = i.remainder,
              s = this.lines[ o ],
              a = s.getViewLineMinColumn( this.model, o + 1, r ),
              u = s.getViewLineMaxColumn( this.model, o + 1, r );
            t < a && ( t = a ), t > u && ( t = u );
            const l = s.getModelColumnOfViewPosition( r, t );
            return this.model.validatePosition( new g.a( o + 1, l ) ).equals( n ) ? new g.a( e, t ) : this.convertModelPositionToViewPosition( n.lineNumber, n.column )
          }, e.prototype.convertViewPositionToModelPosition = function ( e, t ) {
            this._ensureValidState(), e = this._toValidViewLineNumber( e );
            const n = this.prefixSumComputer.getIndexOf( e - 1 ),
              i = n.index,
              o = n.remainder,
              r = this.lines[ i ].getModelColumnOfViewPosition( o, t );
            return this.model.validatePosition( new g.a( i + 1, r ) )
          }, e.prototype.convertModelPositionToViewPosition = function ( e, t ) {
            this._ensureValidState();
            for ( var n = this.model.validatePosition( new g.a( e, t ) ), i = n.lineNumber, o = n.column, r = i - 1, s = !1; r > 0 && !this.lines[ r ].isVisible(); ) r--, s = !0;
            if ( 0 === r && !this.lines[ r ].isVisible() ) return new g.a( 1, 1 );
            const a = 1 + ( 0 === r ? 0 : this.prefixSumComputer.getAccumulatedValue( r - 1 ) );
            return s ? this.lines[ r ].getViewPositionOfModelPosition( a, this.model.getLineMaxColumn( r + 1 ) ) : this.lines[ i - 1 ].getViewPositionOfModelPosition( a, o )
          }, e.prototype._getViewLineNumberForModelPosition = function ( e, t ) {
            let n = e - 1;
            if ( this.lines[ n ].isVisible() ) {
              const i = 1 + ( 0 === n ? 0 : this.prefixSumComputer.getAccumulatedValue( n - 1 ) );
              return this.lines[ n ].getViewLineNumberOfModelPosition( i, t )
            }
            for ( ; n > 0 && !this.lines[ n ].isVisible(); ) n--;
            if ( 0 === n && !this.lines[ n ].isVisible() ) return 1;
            const o = 1 + ( 0 === n ? 0 : this.prefixSumComputer.getAccumulatedValue( n - 1 ) );
            return this.lines[ n ].getViewLineNumberOfModelPosition( o, this.model.getLineMaxColumn( n + 1 ) )
          }, e.prototype.getAllOverviewRulerDecorations = function ( e, t, n ) {
            for ( var i = this.model.getOverviewRulerDecorations( e, t ), o = new he, r = 0, s = i.length; r < s; r++ ) {
              const a = i[ r ],
                u = a.options.overviewRuler,
                l = u.position;
              if ( 0 !== l ) {
                const c = pe( u, n ),
                  d = this._getViewLineNumberForModelPosition( a.range.startLineNumber, a.range.startColumn ),
                  h = this._getViewLineNumberForModelPosition( a.range.endLineNumber, a.range.endColumn );
                o.accept( c, d, h, l )
              }
            }
            return o.result
          }, e.prototype.getDecorationsInRange = function ( e, t, n ) {
            const i = this.convertViewPositionToModelPosition( e.startLineNumber, e.startColumn ),
              o = this.convertViewPositionToModelPosition( e.endLineNumber, e.endColumn );
            if ( o.lineNumber - i.lineNumber <= e.endLineNumber - e.startLineNumber ) return this.model.getDecorationsInRange( new m.a( i.lineNumber, i.column, o.lineNumber, o.column ), t, n );
            for ( var r = [], s = i.lineNumber - 1, a = o.lineNumber - 1, u = null, l = s; l <= a; l++ ) {
              if ( this.lines[ l ].isVisible() ) null === u && ( u = new g.a( l + 1, l === s ? i.column : 1 ) );
              else if ( null !== u ) {
                const c = this.model.getLineMaxColumn( l );
                r = r.concat( this.model.getDecorationsInRange( new m.a( u.lineNumber, u.column, l, c ), t, n ) ), u = null
              }
            }
            return null !== u && ( r = r.concat( this.model.getDecorationsInRange( new m.a( u.lineNumber, u.column, o.lineNumber, o.column ), t, n ) ), u = null ), r
          }, e;
        } )(),
        se = ( () => {
          function e() {}
          return e.prototype.isVisible = () => {
            return !0
          }, e.prototype.setVisible = function ( e ) {
            return e ? this : ae.INSTANCE
          }, e.prototype.getViewLineCount = () => {
            return 1
          }, e.prototype.getViewLineContent = ( e, t, n ) => {
            return e.getLineContent( t )
          }, e.prototype.getViewLineLength = ( e, t, n ) => {
            return e.getLineLength( t )
          }, e.prototype.getViewLineMinColumn = ( e, t, n ) => {
            return e.getLineMinColumn( t )
          }, e.prototype.getViewLineMaxColumn = ( e, t, n ) => {
            return e.getLineMaxColumn( t )
          }, e.prototype.getViewLineData = ( e, t, n ) => {
            const i = e.getLineTokens( t ),
              o = i.getLineContent();
            return new Q.c( o, !1, 1, o.length + 1, i.inflate() )
          }, e.prototype.getViewLinesData = function ( e, t, n, i, o, r, s ) {
            r[ o ] ? s[ o ] = this.getViewLineData( e, t, 0 ) : s[ o ] = null
          }, e.prototype.getModelColumnOfViewPosition = ( e, t ) => {
            return t
          }, e.prototype.getViewPositionOfModelPosition = ( e, t ) => {
            return new g.a( e, t )
          }, e.prototype.getViewLineNumberOfModelPosition = ( e, t ) => {
            return e
          }, e.INSTANCE = new e, e;
        } )(),
        ae = ( () => {
          function e() {}
          return e.prototype.isVisible = () => {
            return !1
          }, e.prototype.setVisible = function ( e ) {
            return e ? se.INSTANCE : this
          }, e.prototype.getViewLineCount = () => {
            return 0
          }, e.prototype.getViewLineContent = ( e, t, n ) => {
            throw new Error( "Not supported" )
          }, e.prototype.getViewLineLength = ( e, t, n ) => {
            throw new Error( "Not supported" )
          }, e.prototype.getViewLineMinColumn = ( e, t, n ) => {
            throw new Error( "Not supported" )
          }, e.prototype.getViewLineMaxColumn = ( e, t, n ) => {
            throw new Error( "Not supported" )
          }, e.prototype.getViewLineData = ( e, t, n ) => {
            throw new Error( "Not supported" )
          }, e.prototype.getViewLinesData = ( e, t, n, i, o, r, s ) => {
            throw new Error( "Not supported" )
          }, e.prototype.getModelColumnOfViewPosition = ( e, t ) => {
            throw new Error( "Not supported" )
          }, e.prototype.getViewPositionOfModelPosition = ( e, t ) => {
            throw new Error( "Not supported" )
          }, e.prototype.getViewLineNumberOfModelPosition = ( e, t ) => {
            throw new Error( "Not supported" )
          }, e.INSTANCE = new e, e;
        } )(),
        ue = ( () => {
          function e( e, t ) {
            this.positionMapper = e, this.wrappedIndent = this.positionMapper.getWrappedLinesIndent(), this.wrappedIndentLength = this.wrappedIndent.length, this.outputLineCount = this.positionMapper.getOutputLineCount(), this._isVisible = t
          }
          return e.prototype.isVisible = function () {
            return this._isVisible
          }, e.prototype.setVisible = function ( e ) {
            return this._isVisible = e, this
          }, e.prototype.getViewLineCount = function () {
            return this._isVisible ? this.outputLineCount : 0
          }, e.prototype.getInputStartOffsetOfOutputLineIndex = function ( e ) {
            return this.positionMapper.getInputOffsetOfOutputPosition( e, 0 )
          }, e.prototype.getInputEndOffsetOfOutputLineIndex = function ( e, t, n ) {
            return n + 1 === this.outputLineCount ? e.getLineMaxColumn( t ) - 1 : this.positionMapper.getInputOffsetOfOutputPosition( n + 1, 0 )
          }, e.prototype.getViewLineContent = function ( e, t, n ) {
            if ( !this._isVisible ) throw new Error( "Not supported" );
            const i = this.getInputStartOffsetOfOutputLineIndex( n );
            const o = this.getInputEndOffsetOfOutputLineIndex( e, t, n );
            let r = e.getValueInRange( {
              startLineNumber: t,
              startColumn: i + 1,
              endLineNumber: t,
              endColumn: o + 1
            } );
            return n > 0 && ( r = this.wrappedIndent + r ), r
          }, e.prototype.getViewLineLength = function ( e, t, n ) {
            if ( !this._isVisible ) throw new Error( "Not supported" );
            const i = this.getInputStartOffsetOfOutputLineIndex( n );
            let o = this.getInputEndOffsetOfOutputLineIndex( e, t, n ) - i;
            return n > 0 && ( o = this.wrappedIndent.length + o ), o
          }, e.prototype.getViewLineMinColumn = function ( e, t, n ) {
            if ( !this._isVisible ) throw new Error( "Not supported" );
            return n > 0 ? this.wrappedIndentLength + 1 : 1
          }, e.prototype.getViewLineMaxColumn = function ( e, t, n ) {
            if ( !this._isVisible ) throw new Error( "Not supported" );
            return this.getViewLineContent( e, t, n ).length + 1
          }, e.prototype.getViewLineData = function ( e, t, n ) {
            if ( !this._isVisible ) throw new Error( "Not supported" );
            const i = this.getInputStartOffsetOfOutputLineIndex( n );
            const o = this.getInputEndOffsetOfOutputLineIndex( e, t, n );
            let r = e.getValueInRange( {
              startLineNumber: t,
              startColumn: i + 1,
              endLineNumber: t,
              endColumn: o + 1
            } );
            n > 0 && ( r = this.wrappedIndent + r );
            const s = n > 0 ? this.wrappedIndentLength + 1 : 1;
            const a = r.length + 1;
            const u = n + 1 < this.getViewLineCount();
            let l = 0;
            n > 0 && ( l = this.wrappedIndentLength );
            const c = e.getLineTokens( t );
            return new Q.c( r, u, s, a, c.sliceAndInflate( i, o, l ) )
          }, e.prototype.getViewLinesData = function ( e, t, n, i, o, r, s ) {
            if ( !this._isVisible ) throw new Error( "Not supported" );
            for ( let a = n; a < i; a++ ) {
              const u = o + a - n;
              r[ u ] ? s[ u ] = this.getViewLineData( e, t, a ) : s[ u ] = null
            }
          }, e.prototype.getModelColumnOfViewPosition = function ( e, t ) {
            if ( !this._isVisible ) throw new Error( "Not supported" );
            let n = t - 1;
            return e > 0 && ( n < this.wrappedIndentLength ? n = 0 : n -= this.wrappedIndentLength ), this.positionMapper.getInputOffsetOfOutputPosition( e, n ) + 1
          }, e.prototype.getViewPositionOfModelPosition = function ( e, t ) {
            if ( !this._isVisible ) throw new Error( "Not supported" );
            const n = this.positionMapper.getOutputPositionOfInputOffset( t - 1 );
            const i = n.outputLineIndex;
            let o = n.outputOffset + 1;
            return i > 0 && ( o += this.wrappedIndentLength ), new g.a( e + i, o )
          }, e.prototype.getViewLineNumberOfModelPosition = function ( e, t ) {
            if ( !this._isVisible ) throw new Error( "Not supported" );
            return e + this.positionMapper.getOutputPositionOfInputOffset( t - 1 ).outputLineIndex
          }, e;
        } )();

      function le( e, t, n, i, o, r, s ) {
        const a = e.createLineMapping( t, n, i, o, r );
        return null === a ? s ? se.INSTANCE : ae.INSTANCE : new ue( a, s )
      }
      const ce = ( () => {
        function e( e ) {
          this._lines = e
        }
        return e.prototype._validPosition = function ( e ) {
          return this._lines.model.validatePosition( e )
        }, e.prototype._validRange = function ( e ) {
          return this._lines.model.validateRange( e )
        }, e.prototype.convertViewPositionToModelPosition = function ( e ) {
          return this._validPosition( e )
        }, e.prototype.convertViewRangeToModelRange = function ( e ) {
          return this._validRange( e )
        }, e.prototype.validateViewPosition = function ( e, t ) {
          return this._validPosition( t )
        }, e.prototype.validateViewRange = function ( e, t ) {
          return this._validRange( t )
        }, e.prototype.convertModelPositionToViewPosition = function ( e ) {
          return this._validPosition( e )
        }, e.prototype.convertModelRangeToViewRange = function ( e ) {
          return this._validRange( e )
        }, e.prototype.modelPositionIsVisible = function ( e ) {
          const t = this._lines.model.getLineCount();
          return !( e.lineNumber < 1 || e.lineNumber > t )
        }, e;
      } )();
      const de = ( () => {
        function e( e ) {
          this.model = e
        }
        return e.prototype.dispose = () => {}, e.prototype.createCoordinatesConverter = function () {
          return new ce( this )
        }, e.prototype.getHiddenAreas = () => {
          return []
        }, e.prototype.setHiddenAreas = e => {
          return !1
        }, e.prototype.setTabSize = e => {
          return !1
        }, e.prototype.setWrappingSettings = ( e, t, n ) => {
          return !1
        }, e.prototype.onModelFlushed = () => {}, e.prototype.onModelLinesDeleted = ( e, t, n ) => {
          return new T( t, n )
        }, e.prototype.onModelLinesInserted = ( e, t, n, i ) => {
          return new R( t, n )
        }, e.prototype.onModelLineChanged = ( e, t, n ) => {
          return [ !1, new M( t, t ), null, null ]
        }, e.prototype.acceptVersionId = e => {}, e.prototype.getViewLineCount = function () {
          return this.model.getLineCount()
        }, e.prototype.warmUpLookupCache = ( e, t ) => {}, e.prototype.getActiveIndentGuide = ( e, t, n ) => {
          return {
            startLineNumber: e,
            endLineNumber: e,
            indent: 0
          }
        }, e.prototype.getViewLinesIndentGuides = ( e, t ) => {
          for ( var n = t - e + 1, i = new Array( n ), o = 0; o < n; o++ ) i[ o ] = 0;
          return i
        }, e.prototype.getViewLineContent = function ( e ) {
          return this.model.getLineContent( e )
        }, e.prototype.getViewLineLength = function ( e ) {
          return this.model.getLineLength( e )
        }, e.prototype.getViewLineMinColumn = function ( e ) {
          return this.model.getLineMinColumn( e )
        }, e.prototype.getViewLineMaxColumn = function ( e ) {
          return this.model.getLineMaxColumn( e )
        }, e.prototype.getViewLineData = function ( e ) {
          const t = this.model.getLineTokens( e ),
            n = t.getLineContent();
          return new Q.c( n, !1, 1, n.length + 1, t.inflate() )
        }, e.prototype.getViewLinesData = function ( e, t, n ) {
          const i = this.model.getLineCount();
          e = Math.min( Math.max( 1, e ), i ), t = Math.min( Math.max( 1, t ), i );
          for ( var o = [], r = e; r <= t; r++ ) {
            const s = r - e;
            n[ s ] || ( o[ s ] = null ), o[ s ] = this.getViewLineData( r )
          }
          return o
        }, e.prototype.getAllOverviewRulerDecorations = function ( e, t, n ) {
          for ( var i = this.model.getOverviewRulerDecorations( e, t ), o = new he, r = 0, s = i.length; r < s; r++ ) {
            const a = i[ r ],
              u = a.options.overviewRuler,
              l = u.position;
            if ( 0 !== l ) {
              const c = pe( u, n ),
                d = a.range.startLineNumber,
                h = a.range.endLineNumber;
              o.accept( c, d, h, l )
            }
          }
          return o.result
        }, e.prototype.getDecorationsInRange = function ( e, t, n ) {
          return this.model.getDecorationsInRange( e, t, n )
        }, e;
      } )();
      var he = ( () => {
        function e() {
          this.result = Object.create( null )
        }
        return e.prototype.accept = function ( e, t, n, i ) {
          const o = this.result[ e ];
          if ( o ) {
            const r = o[ o.length - 3 ],
              s = o[ o.length - 1 ];
            if ( r === i && s + 1 >= t ) return void( n > s && ( o[ o.length - 1 ] = n ) );
            o.push( i, t, n )
          } else this.result[ e ] = [ i, t, n ]
        }, e;
      } )();

      function pe( e, t ) {
        if ( !e._resolvedColor ) {
          const n = t.type,
            i = "dark" === n ? e.darkColor : "light" === n ? e.color : e.hcColor;
          e._resolvedColor = ( ( e, t ) => {
            if ( "string" === typeof e ) return e;
            let n = e ? t.getColor( e.id ) : null;
            n || ( n = ne.a.transparent );
            return n.toString()
          } )( i, t )
        }
        return e._resolvedColor
      }
      const fe = ( () => {
          function e( t, n, i, o ) {
            this.r = e._clamp( t ), this.g = e._clamp( n ), this.b = e._clamp( i ), this.a = e._clamp( o )
          }
          return e._clamp = e => {
            return e < 0 ? 0 : e > 255 ? 255 : 0 | e
          }, e;
        } )(),
        ge = ( () => {
          function e() {
            const e = this;
            this._onDidChange = new s.a, this.onDidChange = this._onDidChange.event, this._updateColorMap(), $.y.onDidChange( ( t => {
              t.changedColorMap && e._updateColorMap()
            } ) )
          }
          return e.getInstance = function () {
            return this._INSTANCE || ( this._INSTANCE = new e ), this._INSTANCE
          }, e.prototype._updateColorMap = function () {
            const e = $.y.getColorMap();
            if ( !e ) return this._colors = [ null ], void( this._backgroundIsLight = !0 );
            this._colors = [ null ];
            for ( let t = 1; t < e.length; t++ ) {
              const n = e[ t ].rgba;
              this._colors[ t ] = new fe( n.r, n.g, n.b, Math.round( 255 * n.a ) )
            }
            const i = e[ 2 ].getRelativeLuminance();
            this._backgroundIsLight = i >= .5, this._onDidChange.fire( void 0 )
          }, e.prototype.getColor = function ( e ) {
            return ( e < 1 || e >= this._colors.length ) && ( e = 2 ), this._colors[ e ]
          }, e.prototype.backgroundIsLight = function () {
            return this._backgroundIsLight
          }, e._INSTANCE = null, e;
        } )(),
        me = ( () => {
          function e( t, n ) {
            if ( 760 !== t.length ) throw new Error( "Invalid x2CharData" );
            if ( 190 !== n.length ) throw new Error( "Invalid x1CharData" );
            this.x2charData = t, this.x1charData = n, this.x2charDataLight = e.soften( t, .8 ), this.x1charDataLight = e.soften( n, 50 / 60 )
          }
          return e.soften = ( e, t ) => {
            for ( var n = new Uint8ClampedArray( e.length ), i = 0, o = e.length; i < o; i++ ) n[ i ] = e[ i ] * t;
            return n
          }, e._getChIndex = e => {
            return ( e -= 32 ) < 0 && ( e += 95 ), e % 95
          }, e.prototype.x2RenderChar = function ( t, n, i, o, r, s, a ) {
            if ( n + 2 > t.width || i + 4 > t.height ) console.warn( "bad render request outside image data" );
            else {
              const u = a ? this.x2charDataLight : this.x2charData;
              const l = e._getChIndex( o );
              const c = 4 * t.width;
              const d = s.r;
              const h = s.g;
              const p = s.b;
              const f = r.r - d;
              const g = r.g - h;
              const m = r.b - p;
              const _ = t.data;
              const v = 4 * l * 2;
              let y = i * c + 4 * n;
              let b = u[ v ] / 255;
              _[ y + 0 ] = d + f * b, _[ y + 1 ] = h + g * b, _[ y + 2 ] = p + m * b;
              b = u[ v + 1 ] / 255;
              _[ y + 4 ] = d + f * b, _[ y + 5 ] = h + g * b, _[ y + 6 ] = p + m * b, y += c;
              b = u[ v + 2 ] / 255;
              _[ y + 0 ] = d + f * b, _[ y + 1 ] = h + g * b, _[ y + 2 ] = p + m * b;
              b = u[ v + 3 ] / 255;
              _[ y + 4 ] = d + f * b, _[ y + 5 ] = h + g * b, _[ y + 6 ] = p + m * b, y += c;
              b = u[ v + 4 ] / 255;
              _[ y + 0 ] = d + f * b, _[ y + 1 ] = h + g * b, _[ y + 2 ] = p + m * b;
              b = u[ v + 5 ] / 255;
              _[ y + 4 ] = d + f * b, _[ y + 5 ] = h + g * b, _[ y + 6 ] = p + m * b, y += c;
              b = u[ v + 6 ] / 255;
              _[ y + 0 ] = d + f * b, _[ y + 1 ] = h + g * b, _[ y + 2 ] = p + m * b;
              b = u[ v + 7 ] / 255;
              _[ y + 4 ] = d + f * b, _[ y + 5 ] = h + g * b, _[ y + 6 ] = p + m * b
            }
          }, e.prototype.x1RenderChar = function ( t, n, i, o, r, s, a ) {
            if ( n + 1 > t.width || i + 2 > t.height ) console.warn( "bad render request outside image data" );
            else {
              const u = a ? this.x1charDataLight : this.x1charData;
              const l = e._getChIndex( o );
              const c = 4 * t.width;
              const d = s.r;
              const h = s.g;
              const p = s.b;
              const f = r.r - d;
              const g = r.g - h;
              const m = r.b - p;
              const _ = t.data;
              const v = 2 * l * 1;
              let y = i * c + 4 * n;
              let b = u[ v ] / 255;
              _[ y + 0 ] = d + f * b, _[ y + 1 ] = h + g * b, _[ y + 2 ] = p + m * b, y += c;
              b = u[ v + 1 ] / 255;
              _[ y + 0 ] = d + f * b, _[ y + 1 ] = h + g * b, _[ y + 2 ] = p + m * b
            }
          }, e.prototype.x2BlockRenderChar = ( e, t, n, i, o, r ) => {
            if ( t + 2 > e.width || n + 4 > e.height ) console.warn( "bad render request outside image data" );
            else {
              const s = 4 * e.width;
              const a = o.r;
              const u = o.g;
              const l = o.b;
              const c = a + .5 * ( i.r - a );
              const d = u + .5 * ( i.g - u );
              const h = l + .5 * ( i.b - l );
              const p = e.data;
              let f = n * s + 4 * t;
              p[ f + 0 ] = c, p[ f + 1 ] = d, p[ f + 2 ] = h, p[ f + 4 ] = c, p[ f + 5 ] = d, p[ f + 6 ] = h, p[ ( f += s ) + 0 ] = c, p[ f + 1 ] = d, p[ f + 2 ] = h, p[ f + 4 ] = c, p[ f + 5 ] = d, p[ f + 6 ] = h, p[ ( f += s ) + 0 ] = c, p[ f + 1 ] = d, p[ f + 2 ] = h, p[ f + 4 ] = c, p[ f + 5 ] = d, p[ f + 6 ] = h, p[ ( f += s ) + 0 ] = c, p[ f + 1 ] = d, p[ f + 2 ] = h, p[ f + 4 ] = c, p[ f + 5 ] = d, p[ f + 6 ] = h
            }
          }, e.prototype.x1BlockRenderChar = ( e, t, n, i, o, r ) => {
            if ( t + 1 > e.width || n + 2 > e.height ) console.warn( "bad render request outside image data" );
            else {
              const s = 4 * e.width;
              const a = o.r;
              const u = o.g;
              const l = o.b;
              const c = a + .5 * ( i.r - a );
              const d = u + .5 * ( i.g - u );
              const h = l + .5 * ( i.b - l );
              const p = e.data;
              let f = n * s + 4 * t;
              p[ f + 0 ] = c, p[ f + 1 ] = d, p[ f + 2 ] = h, p[ ( f += s ) + 0 ] = c, p[ f + 1 ] = d, p[ f + 2 ] = h
            }
          }, e;
        } )(),
        _e = n( "MXAL" ),
        ve = n( "UHym" ),
        ye = n( "/UlZ" ),
        be = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Ce = ( e => {
          function t( t, n, i ) {
            for ( var o = e.call( this, 0 ) || this, r = 0; r < t.length; r++ ) o.set( t.charCodeAt( r ), 1 );
            for ( r = 0; r < n.length; r++ ) o.set( n.charCodeAt( r ), 2 );
            for ( r = 0; r < i.length; r++ ) o.set( i.charCodeAt( r ), 3 );
            return o
          }
          return be( t, e ), t.prototype.get = function ( t ) {
            return t >= 12352 && t <= 12543 || t >= 13312 && t <= 19903 || t >= 19968 && t <= 40959 ? 4 : e.prototype.get.call( this, t )
          }, t
        } )( _e.a ),
        we = ( () => {
          function e( e, t, n ) {
            this.classifier = new Ce( e, t, n )
          }
          return e.nextVisibleColumn = ( e, t, n, i ) => {
            return e = +e, t = +t, i = +i, n ? e + ( t - e % t ) : e + i
          }, e.prototype.createLineMapping = function ( t, n, i, o, r ) {
            if ( -1 === i ) return null;
            n = +n, i = +i, o = +o;
            let s = 0,
              a = "",
              u = -1;
            if ( ( r = +r ) !== ye.j.None && -1 !== ( u = p.firstNonWhitespaceIndex( t ) ) ) {
              a = t.substring( 0, u );
              for ( var l = 0; l < u; l++ ) s = e.nextVisibleColumn( s, n, 9 === t.charCodeAt( l ), 1 );
              let c = 0;
              r === ye.j.Indent ? c = 1 : r === ye.j.DeepIndent && ( c = 2 );
              for ( l = 0; l < c; l++ ) a += "\t", s = e.nextVisibleColumn( s, n, !0, 1 );
              s + o > i && ( a = "", s = 0 )
            }
            const d = this.classifier;
            let h = 0;
            const f = [];
            let g = 0;
            let m = 0;
            let _ = -1;
            let v = 0;
            let y = -1;
            let b = 0;
            const C = t.length;
            for ( l = 0; l < C; l++ ) {
              const w = t.charCodeAt( l ),
                S = 9 === w,
                O = d.get( w );
              if ( 1 === O && ( _ = l, v = s ), 4 === O && l > 0 ) {
                const L = t.charCodeAt( l - 1 );
                1 !== d.get( L ) && ( _ = l, v = s )
              }
              let x = 1;
              if ( p.isFullWidthCharacter( w ) && ( x = o ), ( m = e.nextVisibleColumn( m, n, S, x ) ) > i && 0 !== l ) {
                let N = void 0,
                  E = void 0; - 1 !== _ && v <= i ? ( N = _, E = v ) : -1 !== y && b <= i ? ( N = y, E = b ) : ( N = l, E = s ), f[ g++ ] = N - h, h = N, m = e.nextVisibleColumn( E, n, S, x ), _ = -1, v = 0, y = -1, b = 0
              }
              if ( -1 !== _ && ( v = e.nextVisibleColumn( v, n, S, x ) ), -1 !== y && ( b = e.nextVisibleColumn( b, n, S, x ) ), 2 === O && ( r === ye.j.None || l >= u ) && ( _ = l + 1, v = s ), 4 === O && l < C - 1 ) {
                const k = t.charCodeAt( l + 1 );
                2 !== d.get( k ) && ( _ = l + 1, v = s )
              }
              3 === O && ( y = l + 1, b = s )
            }
            return 0 === g ? null : ( f[ g++ ] = C - h, new Se( new ee.a( Object( ve.c )( f ) ), a ) )
          }, e;
        } )(),
        Se = ( () => {
          function e( e, t ) {
            this._prefixSums = e, this._wrappedLinesIndent = t
          }
          return e.prototype.getOutputLineCount = function () {
            return this._prefixSums.getCount()
          }, e.prototype.getWrappedLinesIndent = function () {
            return this._wrappedLinesIndent
          }, e.prototype.getInputOffsetOfOutputPosition = function ( e, t ) {
            return 0 === e ? t : this._prefixSums.getAccumulatedValue( e - 1 ) + t
          }, e.prototype.getOutputPositionOfInputOffset = function ( e ) {
            const t = this._prefixSums.getIndexOf( e );
            return new ie( t.index, t.remainder )
          }, e;
        } )(),
        Oe = n( "QuOb" ),
        Le = ( () => {
          function e() {
            this._heights = [], this._minWidths = [], this._ids = [], this._afterLineNumbers = [], this._ordinals = [], this._prefixSum = [], this._prefixSumValidIndex = -1, this._whitespaceId2Index = {}, this._lastWhitespaceId = 0, this._minWidth = -1
          }
          return e.findInsertionIndex = ( e, t, n, i ) => {
            for ( var o = 0, r = e.length; o < r; ) {
              const s = o + r >>> 1;
              t === e[ s ] ? i < n[ s ] ? r = s : o = s + 1 : t < e[ s ] ? r = s : o = s + 1
            }
            return o
          }, e.prototype.insertWhitespace = function ( t, n, i, o ) {
            t |= 0, n |= 0, i |= 0, o |= 0;
            const r = ++this._lastWhitespaceId,
              s = e.findInsertionIndex( this._afterLineNumbers, t, this._ordinals, n );
            return this._insertWhitespaceAtIndex( r, s, t, n, i, o ), this._minWidth = -1, r
          }, e.prototype._insertWhitespaceAtIndex = function ( e, t, n, i, o, r ) {
            e |= 0, t |= 0, n |= 0, i |= 0, o |= 0, r |= 0, this._heights.splice( t, 0, o ), this._minWidths.splice( t, 0, r ), this._ids.splice( t, 0, e ), this._afterLineNumbers.splice( t, 0, n ), this._ordinals.splice( t, 0, i ), this._prefixSum.splice( t, 0, 0 );
            for ( let s = Object.keys( this._whitespaceId2Index ), a = 0, u = s.length; a < u; a++ ) {
              const l = s[ a ],
                c = this._whitespaceId2Index[ l ];
              c >= t && ( this._whitespaceId2Index[ l ] = c + 1 )
            }
            this._whitespaceId2Index[ e.toString() ] = t, this._prefixSumValidIndex = Math.min( this._prefixSumValidIndex, t - 1 )
          }, e.prototype.changeWhitespace = function ( e, t, n ) {
            e |= 0, t |= 0, n |= 0;
            let i = !1;
            return i = this.changeWhitespaceHeight( e, n ) || i, i = this.changeWhitespaceAfterLineNumber( e, t ) || i
          }, e.prototype.changeWhitespaceHeight = function ( e, t ) {
            t |= 0;
            const n = ( e |= 0 ).toString();
            if ( this._whitespaceId2Index.hasOwnProperty( n ) ) {
              const i = this._whitespaceId2Index[ n ];
              if ( this._heights[ i ] !== t ) return this._heights[ i ] = t, this._prefixSumValidIndex = Math.min( this._prefixSumValidIndex, i - 1 ), !0
            }
            return !1
          }, e.prototype.changeWhitespaceAfterLineNumber = function ( t, n ) {
            n |= 0;
            const i = ( t |= 0 ).toString();
            if ( this._whitespaceId2Index.hasOwnProperty( i ) ) {
              const o = this._whitespaceId2Index[ i ];
              if ( this._afterLineNumbers[ o ] !== n ) {
                const r = this._ordinals[ o ],
                  s = this._heights[ o ],
                  a = this._minWidths[ o ];
                this.removeWhitespace( t );
                const u = e.findInsertionIndex( this._afterLineNumbers, n, this._ordinals, r );
                return this._insertWhitespaceAtIndex( t, u, n, r, s, a ), !0
              }
            }
            return !1
          }, e.prototype.removeWhitespace = function ( e ) {
            const t = ( e |= 0 ).toString();
            if ( this._whitespaceId2Index.hasOwnProperty( t ) ) {
              const n = this._whitespaceId2Index[ t ];
              return delete this._whitespaceId2Index[ t ], this._removeWhitespaceAtIndex( n ), this._minWidth = -1, !0
            }
            return !1
          }, e.prototype._removeWhitespaceAtIndex = function ( e ) {
            e |= 0, this._heights.splice( e, 1 ), this._minWidths.splice( e, 1 ), this._ids.splice( e, 1 ), this._afterLineNumbers.splice( e, 1 ), this._ordinals.splice( e, 1 ), this._prefixSum.splice( e, 1 ), this._prefixSumValidIndex = Math.min( this._prefixSumValidIndex, e - 1 );
            for ( let t = Object.keys( this._whitespaceId2Index ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ],
                r = this._whitespaceId2Index[ o ];
              r >= e && ( this._whitespaceId2Index[ o ] = r - 1 )
            }
          }, e.prototype.onLinesDeleted = function ( e, t ) {
            e |= 0, t |= 0;
            for ( let n = 0, i = this._afterLineNumbers.length; n < i; n++ ) {
              const o = this._afterLineNumbers[ n ];
              e <= o && o <= t ? this._afterLineNumbers[ n ] = e - 1 : o > t && ( this._afterLineNumbers[ n ] -= t - e + 1 )
            }
          }, e.prototype.onLinesInserted = function ( e, t ) {
            e |= 0, t |= 0;
            for ( let n = 0, i = this._afterLineNumbers.length; n < i; n++ ) {
              e <= this._afterLineNumbers[ n ] && ( this._afterLineNumbers[ n ] += t - e + 1 )
            }
          }, e.prototype.getTotalHeight = function () {
            return 0 === this._heights.length ? 0 : this.getAccumulatedHeight( this._heights.length - 1 )
          }, e.prototype.getAccumulatedHeight = function ( e ) {
            e |= 0;
            let t = Math.max( 0, this._prefixSumValidIndex + 1 );
            0 === t && ( this._prefixSum[ 0 ] = this._heights[ 0 ], t++ );
            for ( let n = t; n <= e; n++ ) this._prefixSum[ n ] = this._prefixSum[ n - 1 ] + this._heights[ n ];
            return this._prefixSumValidIndex = Math.max( this._prefixSumValidIndex, e ), this._prefixSum[ e ]
          }, e.prototype.getAccumulatedHeightBeforeLineNumber = function ( e ) {
            e |= 0;
            const t = this._findLastWhitespaceBeforeLineNumber( e );
            return -1 === t ? 0 : this.getAccumulatedHeight( t )
          }, e.prototype._findLastWhitespaceBeforeLineNumber = function ( e ) {
            e |= 0;
            for ( let t = this._afterLineNumbers, n = 0, i = t.length - 1; n <= i; ) {
              const o = n + ( ( i - n | 0 ) / 2 | 0 ) | 0;
              if ( t[ o ] < e ) {
                if ( o + 1 >= t.length || t[ o + 1 ] >= e ) return o;
                n = o + 1 | 0
              } else i = o - 1 | 0
            }
            return -1
          }, e.prototype._findFirstWhitespaceAfterLineNumber = function ( e ) {
            e |= 0;
            const t = this._findLastWhitespaceBeforeLineNumber( e ) + 1;
            return t < this._heights.length ? t : -1
          }, e.prototype.getFirstWhitespaceIndexAfterLineNumber = function ( e ) {
            return e |= 0, this._findFirstWhitespaceAfterLineNumber( e )
          }, e.prototype.getCount = function () {
            return this._heights.length
          }, e.prototype.getMinWidth = function () {
            if ( -1 === this._minWidth ) {
              for ( var e = 0, t = 0, n = this._minWidths.length; t < n; t++ ) e = Math.max( e, this._minWidths[ t ] );
              this._minWidth = e
            }
            return this._minWidth
          }, e.prototype.getAfterLineNumberForWhitespaceIndex = function ( e ) {
            return e |= 0, this._afterLineNumbers[ e ]
          }, e.prototype.getIdForWhitespaceIndex = function ( e ) {
            return e |= 0, this._ids[ e ]
          }, e.prototype.getHeightForWhitespaceIndex = function ( e ) {
            return e |= 0, this._heights[ e ]
          }, e.prototype.getWhitespaces = function ( e ) {
            e |= 0;
            for ( var t = [], n = 0; n < this._heights.length; n++ ) t.push( {
              id: this._ids[ n ],
              afterLineNumber: this._afterLineNumbers[ n ],
              heightInLines: this._heights[ n ] / e
            } );
            return t
          }, e;
        } )(),
        xe = ( () => {
          function e( e, t ) {
            this._lineCount = e, this._lineHeight = t, this._whitespaces = new Le
          }
          return e.prototype.setLineHeight = function ( e ) {
            this._lineHeight = e
          }, e.prototype.onFlushed = function ( e ) {
            this._lineCount = e
          }, e.prototype.insertWhitespace = function ( e, t, n, i ) {
            return this._whitespaces.insertWhitespace( e, t, n, i )
          }, e.prototype.changeWhitespace = function ( e, t, n ) {
            return this._whitespaces.changeWhitespace( e, t, n )
          }, e.prototype.removeWhitespace = function ( e ) {
            return this._whitespaces.removeWhitespace( e )
          }, e.prototype.onLinesDeleted = function ( e, t ) {
            this._lineCount -= t - e + 1, this._whitespaces.onLinesDeleted( e, t )
          }, e.prototype.onLinesInserted = function ( e, t ) {
            this._lineCount += t - e + 1, this._whitespaces.onLinesInserted( e, t )
          }, e.prototype.getLinesTotalHeight = function () {
            return this._lineHeight * this._lineCount + this._whitespaces.getTotalHeight()
          }, e.prototype.getVerticalOffsetForLineNumber = function ( e ) {
            return ( ( e |= 0 ) > 1 ? this._lineHeight * ( e - 1 ) : 0 ) + this._whitespaces.getAccumulatedHeightBeforeLineNumber( e )
          }, e.prototype.getWhitespaceAccumulatedHeightBeforeLineNumber = function ( e ) {
            return this._whitespaces.getAccumulatedHeightBeforeLineNumber( e )
          }, e.prototype.getWhitespaceMinWidth = function () {
            return this._whitespaces.getMinWidth()
          }, e.prototype.isAfterLines = function ( e ) {
            return e > this.getLinesTotalHeight()
          }, e.prototype.getLineNumberAtOrAfterVerticalOffset = function ( e ) {
            if ( ( e |= 0 ) < 0 ) return 1;
            for ( var t = 0 | this._lineCount, n = this._lineHeight, i = 1, o = t; i < o; ) {
              const r = ( i + o ) / 2 | 0,
                s = 0 | this.getVerticalOffsetForLineNumber( r );
              if ( e >= s + n ) i = r + 1;
              else {
                if ( e >= s ) return r;
                o = r
              }
            }
            return i > t ? t : i
          }, e.prototype.getLinesViewportData = function ( e, t ) {
            e |= 0, t |= 0;
            let n;
            let i;
            const o = this._lineHeight;
            const r = 0 | this.getLineNumberAtOrAfterVerticalOffset( e );
            const s = 0 | this.getVerticalOffsetForLineNumber( r );
            let a = 0 | this._lineCount;
            let u = 0 | this._whitespaces.getFirstWhitespaceIndexAfterLineNumber( r );
            const l = 0 | this._whitespaces.getCount(); -
            1 === u ? ( u = l, i = a + 1, n = 0 ) : ( i = 0 | this._whitespaces.getAfterLineNumberForWhitespaceIndex( u ), n = 0 | this._whitespaces.getHeightForWhitespaceIndex( u ) );
            let c = s,
              d = c,
              h = 0;
            s >= 5e5 && ( h = 5e5 * Math.floor( s / 5e5 ), d -= h = Math.floor( h / o ) * o );
            for ( var p = [], f = e + ( t - e ) / 2, g = -1, m = r; m <= a; m++ ) {
              if ( -1 === g ) {
                ( c <= f && f < c + o || c > f ) && ( g = m )
              }
              for ( c += o, p[ m - r ] = d, d += o; i === m; ) d += n, c += n, ++u >= l ? i = a + 1 : ( i = 0 | this._whitespaces.getAfterLineNumberForWhitespaceIndex( u ), n = 0 | this._whitespaces.getHeightForWhitespaceIndex( u ) );
              if ( c >= t ) {
                a = m;
                break
              }
            } - 1 === g && ( g = a );
            const _ = 0 | this.getVerticalOffsetForLineNumber( a );
            let v = r;
            let y = a;
            return v < y && s < e && v++, v < y && _ + o > t && y--, {
              bigNumbersDelta: h,
              startLineNumber: r,
              endLineNumber: a,
              relativeVerticalOffset: p,
              centeredLineNumber: g,
              completelyVisibleStartLineNumber: v,
              completelyVisibleEndLineNumber: y
            }
          }, e.prototype.getVerticalOffsetForWhitespaceIndex = function ( e ) {
            e |= 0;
            const t = this._whitespaces.getAfterLineNumberForWhitespaceIndex( e );
            return ( t >= 1 ? this._lineHeight * t : 0 ) + ( e > 0 ? this._whitespaces.getAccumulatedHeight( e - 1 ) : 0 )
          }, e.prototype.getWhitespaceIndexAtOrAfterVerticallOffset = function ( e ) {
            e |= 0;
            let t, n, i = 0,
              o = this._whitespaces.getCount() - 1;
            if ( o < 0 ) return -1;
            if ( e >= this.getVerticalOffsetForWhitespaceIndex( o ) + this._whitespaces.getHeightForWhitespaceIndex( o ) ) return -1;
            for ( ; i < o; )
              if ( t = Math.floor( ( i + o ) / 2 ), e >= ( n = this.getVerticalOffsetForWhitespaceIndex( t ) ) + this._whitespaces.getHeightForWhitespaceIndex( t ) ) i = t + 1;
              else {
                if ( e >= n ) return t;
                o = t
              } return i
          }, e.prototype.getWhitespaceAtVerticalOffset = function ( e ) {
            e |= 0;
            const t = this.getWhitespaceIndexAtOrAfterVerticallOffset( e );
            if ( t < 0 ) return null;
            if ( t >= this._whitespaces.getCount() ) return null;
            const n = this.getVerticalOffsetForWhitespaceIndex( t );
            if ( n > e ) return null;
            const i = this._whitespaces.getHeightForWhitespaceIndex( t );
            return {
              id: this._whitespaces.getIdForWhitespaceIndex( t ),
              afterLineNumber: this._whitespaces.getAfterLineNumberForWhitespaceIndex( t ),
              verticalOffset: n,
              height: i
            }
          }, e.prototype.getWhitespaceViewportData = function ( e, t ) {
            e |= 0, t |= 0;
            const n = this.getWhitespaceIndexAtOrAfterVerticallOffset( e ),
              i = this._whitespaces.getCount() - 1;
            if ( n < 0 ) return [];
            for ( var o = [], r = n; r <= i; r++ ) {
              const s = this.getVerticalOffsetForWhitespaceIndex( r ),
                a = this._whitespaces.getHeightForWhitespaceIndex( r );
              if ( s >= t ) break;
              o.push( {
                id: this._whitespaces.getIdForWhitespaceIndex( r ),
                afterLineNumber: this._whitespaces.getAfterLineNumberForWhitespaceIndex( r ),
                verticalOffset: s,
                height: a
              } )
            }
            return o
          }, e.prototype.getWhitespaces = function () {
            return this._whitespaces.getWhitespaces( this._lineHeight )
          }, e;
        } )(),
        Ne = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Ee = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            return o._configuration = t, o._linesLayout = new xe( n, o._configuration.editor.lineHeight ), o.scrollable = o._register( new Oe.a( 0, i ) ), o._configureSmoothScrollDuration(), o.scrollable.setScrollDimensions( {
              width: t.editor.layoutInfo.contentWidth,
              height: t.editor.layoutInfo.contentHeight
            } ), o.onDidScroll = o.scrollable.onScroll, o._updateHeight(), o
          }
          return Ne( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype.onHeightMaybeChanged = function () {
            this._updateHeight()
          }, t.prototype._configureSmoothScrollDuration = function () {
            this.scrollable.setSmoothScrollDuration( this._configuration.editor.viewInfo.smoothScrolling ? 125 : 0 )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            e.lineHeight && this._linesLayout.setLineHeight( this._configuration.editor.lineHeight ), e.layoutInfo && this.scrollable.setScrollDimensions( {
              width: this._configuration.editor.layoutInfo.contentWidth,
              height: this._configuration.editor.layoutInfo.contentHeight
            } ), e.viewInfo && this._configureSmoothScrollDuration(), this._updateHeight()
          }, t.prototype.onFlushed = function ( e ) {
            this._linesLayout.onFlushed( e )
          }, t.prototype.onLinesDeleted = function ( e, t ) {
            this._linesLayout.onLinesDeleted( e, t )
          }, t.prototype.onLinesInserted = function ( e, t ) {
            this._linesLayout.onLinesInserted( e, t )
          }, t.prototype._getHorizontalScrollbarHeight = function ( e ) {
            return this._configuration.editor.viewInfo.scrollbar.horizontal === Oe.b.Hidden ? 0 : e.width >= e.scrollWidth ? 0 : this._configuration.editor.viewInfo.scrollbar.horizontalScrollbarSize
          }, t.prototype._getTotalHeight = function () {
            const e = this.scrollable.getScrollDimensions();
            let t = this._linesLayout.getLinesTotalHeight();
            return this._configuration.editor.viewInfo.scrollBeyondLastLine ? t += e.height - this._configuration.editor.lineHeight : t += this._getHorizontalScrollbarHeight( e ), Math.max( e.height, t )
          }, t.prototype._updateHeight = function () {
            this.scrollable.setScrollDimensions( {
              scrollHeight: this._getTotalHeight()
            } )
          }, t.prototype.getCurrentViewport = function () {
            const e = this.scrollable.getScrollDimensions(),
              t = this.scrollable.getCurrentScrollPosition();
            return new Q.f( t.scrollTop, t.scrollLeft, e.width, e.height )
          }, t.prototype.getFutureViewport = function () {
            const e = this.scrollable.getScrollDimensions(),
              t = this.scrollable.getFutureScrollPosition();
            return new Q.f( t.scrollTop, t.scrollLeft, e.width, e.height )
          }, t.prototype._computeScrollWidth = function ( e, t ) {
            if ( !this._configuration.editor.wrappingInfo.isViewportWrapping ) {
              const n = this._configuration.editor.viewInfo.scrollBeyondLastColumn * this._configuration.editor.fontInfo.typicalHalfwidthCharacterWidth,
                i = this._linesLayout.getWhitespaceMinWidth();
              return Math.max( e + n, t, i )
            }
            return Math.max( e, t )
          }, t.prototype.onMaxLineWidthChanged = function ( e ) {
            const t = this._computeScrollWidth( e, this.getCurrentViewport().width );
            this.scrollable.setScrollDimensions( {
              scrollWidth: t
            } ), this._updateHeight()
          }, t.prototype.saveState = function () {
            const e = this.scrollable.getFutureScrollPosition(),
              t = e.scrollTop,
              n = this._linesLayout.getLineNumberAtOrAfterVerticalOffset( t );
            return {
              scrollTop: t,
              scrollTopWithoutViewZones: t - this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber( n ),
              scrollLeft: e.scrollLeft
            }
          }, t.prototype.addWhitespace = function ( e, t, n, i ) {
            return this._linesLayout.insertWhitespace( e, t, n, i )
          }, t.prototype.changeWhitespace = function ( e, t, n ) {
            return this._linesLayout.changeWhitespace( e, t, n )
          }, t.prototype.removeWhitespace = function ( e ) {
            return this._linesLayout.removeWhitespace( e )
          }, t.prototype.getVerticalOffsetForLineNumber = function ( e ) {
            return this._linesLayout.getVerticalOffsetForLineNumber( e )
          }, t.prototype.isAfterLines = function ( e ) {
            return this._linesLayout.isAfterLines( e )
          }, t.prototype.getLineNumberAtVerticalOffset = function ( e ) {
            return this._linesLayout.getLineNumberAtOrAfterVerticalOffset( e )
          }, t.prototype.getWhitespaceAtVerticalOffset = function ( e ) {
            return this._linesLayout.getWhitespaceAtVerticalOffset( e )
          }, t.prototype.getLinesViewportData = function () {
            const e = this.getCurrentViewport();
            return this._linesLayout.getLinesViewportData( e.top, e.top + e.height )
          }, t.prototype.getLinesViewportDataAtScrollTop = function ( e ) {
            const t = this.scrollable.getScrollDimensions();
            return e + t.height > t.scrollHeight && ( e = t.scrollHeight - t.height ), e < 0 && ( e = 0 ), this._linesLayout.getLinesViewportData( e, e + t.height )
          }, t.prototype.getWhitespaceViewportData = function () {
            const e = this.getCurrentViewport();
            return this._linesLayout.getWhitespaceViewportData( e.top, e.top + e.height )
          }, t.prototype.getWhitespaces = function () {
            return this._linesLayout.getWhitespaces()
          }, t.prototype.getScrollWidth = function () {
            return this.scrollable.getScrollDimensions().scrollWidth
          }, t.prototype.getScrollHeight = function () {
            return this.scrollable.getScrollDimensions().scrollHeight
          }, t.prototype.getCurrentScrollLeft = function () {
            return this.scrollable.getCurrentScrollPosition().scrollLeft
          }, t.prototype.getCurrentScrollTop = function () {
            return this.scrollable.getCurrentScrollPosition().scrollTop
          }, t.prototype.validateScrollPosition = function ( e ) {
            return this.scrollable.validateScrollPosition( e )
          }, t.prototype.setScrollPositionNow = function ( e ) {
            this.scrollable.setScrollPositionNow( e )
          }, t.prototype.setScrollPositionSmooth = function ( e ) {
            this.scrollable.setScrollPositionSmooth( e )
          }, t.prototype.deltaScrollNow = function ( e, t ) {
            const n = this.scrollable.getCurrentScrollPosition();
            this.scrollable.setScrollPositionNow( {
              scrollLeft: n.scrollLeft + e,
              scrollTop: n.scrollTop + t
            } )
          }, t;
        } )( a.a ),
        ke = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Ie = !0,
        De = ( e => {
          function t( t, n, i, o ) {
            const r = e.call( this ) || this;
            if ( r.editorId = t, r.configuration = n, r.model = i, r.hasFocus = !1, r.viewportStartLine = -1, r.viewportStartLineTrackedRange = null, r.viewportStartLineTop = 0, Ie && r.model.isTooLargeForTokenization() ) r.lines = new de( r.model );
            else {
              const s = r.configuration.editor,
                a = new we( s.wrappingInfo.wordWrapBreakBeforeCharacters, s.wrappingInfo.wordWrapBreakAfterCharacters, s.wrappingInfo.wordWrapBreakObtrusiveCharacters );
              r.lines = new re( r.model, a, r.model.getOptions().tabSize, s.wrappingInfo.wrappingColumn, s.fontInfo.typicalFullwidthCharacterWidth / s.fontInfo.typicalHalfwidthCharacterWidth, s.wrappingInfo.wrappingIndent )
            }
            return r.coordinatesConverter = r.lines.createCoordinatesConverter(), r.viewLayout = r._register( new Ee( r.configuration, r.getLineCount(), o ) ), r._register( r.viewLayout.onDidScroll( ( e => {
              try {
                r._beginEmit().emit( new A( e ) )
              } finally {
                r._endEmit()
              }
            } ) ) ), r.decorations = new J( r.editorId, r.model, r.configuration, r.lines, r.coordinatesConverter ), r._registerModelEvents(), r._register( r.configuration.onDidChange( ( e => {
              try {
                const t = r._beginEmit();
                r._onConfigurationChanged( t, e )
              } finally {
                r._endEmit()
              }
            } ) ) ), r._register( ge.getInstance().onDidChange( ( () => {
              try {
                r._beginEmit().emit( new j )
              } finally {
                r._endEmit()
              }
            } ) ) ), r;
          }
          return ke( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this ), this.decorations.dispose(), this.lines.dispose(), this.viewportStartLineTrackedRange = this.model._setTrackedRange( this.viewportStartLineTrackedRange, null, v.h.NeverGrowsWhenTypingAtEdges )
          }, t.prototype.setHasFocus = function ( e ) {
            this.hasFocus = e
          }, t.prototype._onConfigurationChanged = function ( e, t ) {
            let n = null;
            if ( -1 !== this.viewportStartLine ) {
              const i = new g.a( this.viewportStartLine, this.getLineMinColumn( this.viewportStartLine ) );
              n = this.coordinatesConverter.convertViewPositionToModelPosition( i )
            }
            let o = !1;
            const r = this.configuration.editor;
            if ( this.lines.setWrappingSettings( r.wrappingInfo.wrappingIndent, r.wrappingInfo.wrappingColumn, r.fontInfo.typicalFullwidthCharacterWidth / r.fontInfo.typicalHalfwidthCharacterWidth ) && ( e.emit( new k ), e.emit( new D ), e.emit( new E ), this.decorations.onLineMappingChanged(), this.viewLayout.onFlushed( this.getLineCount() ), 0 !== this.viewLayout.getCurrentScrollTop() && ( o = !0 ) ), t.readOnly && ( this.decorations.reset(), e.emit( new E ) ), e.emit( new x( t ) ), this.viewLayout.onConfigurationChanged( t ), o && n ) {
              const s = this.coordinatesConverter.convertModelPositionToViewPosition( n ),
                a = this.viewLayout.getVerticalOffsetForLineNumber( s.lineNumber );
              this.viewLayout.deltaScrollNow( 0, a - this.viewportStartLineTop )
            }
          }, t.prototype._registerModelEvents = function () {
            const e = this;
            this._register( this.model.onDidChangeRawContentFast( ( t => {
              try {
                for ( var n = e._beginEmit(), i = !1, o = !1, r = t.changes, s = t.versionId, a = 0, u = r.length; a < u; a++ ) {
                  const l = r[ a ];
                  switch ( l.changeType ) {
                    case 1:
                      e.lines.onModelFlushed(), n.emit( new k ), e.decorations.reset(), e.viewLayout.onFlushed( e.getLineCount() ), i = !0;
                      break;
                    case 3:
                      null !== ( f = e.lines.onModelLinesDeleted( s, l.fromLineNumber, l.toLineNumber ) ) && ( n.emit( f ), e.viewLayout.onLinesDeleted( f.fromLineNumber, f.toLineNumber ) ), i = !0;
                      break;
                    case 4:
                      null !== ( p = e.lines.onModelLinesInserted( s, l.fromLineNumber, l.toLineNumber, l.detail ) ) && ( n.emit( p ), e.viewLayout.onLinesInserted( p.fromLineNumber, p.toLineNumber ) ), i = !0;
                      break;
                    case 2:
                      const c = e.lines.onModelLineChanged( s, l.lineNumber, l.detail );
                      const d = c[ 0 ];
                      const h = c[ 1 ];
                      var p = c[ 2 ];
                      var f = c[ 3 ];
                      o = d, h && n.emit( h ), p && ( n.emit( p ), e.viewLayout.onLinesInserted( p.fromLineNumber, p.toLineNumber ) ), f && ( n.emit( f ), e.viewLayout.onLinesDeleted( f.fromLineNumber, f.toLineNumber ) )
                  }
                }
                e.lines.acceptVersionId( s ), e.viewLayout.onHeightMaybeChanged(), !i && o && ( n.emit( new D ), n.emit( new E ), e.decorations.onLineMappingChanged() )
              } finally {
                e._endEmit()
              }
              if ( e.viewportStartLine = -1, e.configuration.setMaxLineNumber( e.model.getLineCount() ), !e.hasFocus && e.model.getAttachedEditorCount() >= 2 && e.viewportStartLineTrackedRange ) {
                const g = e.model._getTrackedRange( e.viewportStartLineTrackedRange );
                if ( g ) {
                  const m = e.coordinatesConverter.convertModelPositionToViewPosition( g.getStartPosition() ),
                    _ = e.viewLayout.getVerticalOffsetForLineNumber( m.lineNumber );
                  e.viewLayout.deltaScrollNow( 0, _ - e.viewportStartLineTop )
                }
              }
            } ) ) ), this._register( this.model.onDidChangeTokens( ( t => {
              for ( var n = [], i = 0, o = t.ranges.length; i < o; i++ ) {
                const r = t.ranges[ i ],
                  s = e.coordinatesConverter.convertModelPositionToViewPosition( new g.a( r.fromLineNumber, 1 ) ).lineNumber,
                  a = e.coordinatesConverter.convertModelPositionToViewPosition( new g.a( r.toLineNumber, e.model.getLineMaxColumn( r.toLineNumber ) ) ).lineNumber;
                n[ i ] = {
                  fromLineNumber: s,
                  toLineNumber: a
                }
              }
              try {
                e._beginEmit().emit( new F( n ) )
              } finally {
                e._endEmit()
              }
            } ) ) ), this._register( this.model.onDidChangeLanguageConfiguration( ( t => {
              try {
                e._beginEmit().emit( new B )
              } finally {
                e._endEmit()
              }
            } ) ) ), this._register( this.model.onDidChangeOptions( ( t => {
              if ( e.lines.setTabSize( e.model.getOptions().tabSize ) ) {
                e.decorations.onLineMappingChanged(), e.viewLayout.onFlushed( e.getLineCount() );
                try {
                  const n = e._beginEmit();
                  n.emit( new k ), n.emit( new D ), n.emit( new E )
                } finally {
                  e._endEmit()
                }
              }
            } ) ) ), this._register( this.model.onDidChangeDecorations( ( t => {
              e.decorations.onModelDecorationsChanged();
              try {
                e._beginEmit().emit( new E )
              } finally {
                e._endEmit()
              }
            } ) ) )
          }, t.prototype.setHiddenAreas = function ( e ) {
            try {
              const t = this._beginEmit();
              this.lines.setHiddenAreas( e ) && ( t.emit( new k ), t.emit( new D ), t.emit( new E ), this.decorations.onLineMappingChanged(), this.viewLayout.onFlushed( this.getLineCount() ), this.viewLayout.onHeightMaybeChanged() )
            } finally {
              this._endEmit()
            }
          }, t.prototype.getVisibleRanges = function () {
            const e = this.getCompletelyVisibleViewRange(),
              t = this.coordinatesConverter.convertViewRangeToModelRange( e ),
              n = this.lines.getHiddenAreas();
            if ( 0 === n.length ) return [ t ];
            for ( var i = [], o = 0, r = t.startLineNumber, s = t.startColumn, a = t.endLineNumber, u = t.endColumn, l = 0, c = n.length; l < c; l++ ) {
              const d = n[ l ].startLineNumber,
                h = n[ l ].endLineNumber;
              h < r || ( d > a || ( r < d && ( i[ o++ ] = new m.a( r, s, d - 1, this.model.getLineMaxColumn( d - 1 ) ) ), r = h + 1, s = 1 ) )
            }
            return ( r < a || r === a && s < u ) && ( i[ o++ ] = new m.a( r, s, a, u ) ), i
          }, t.prototype.getCompletelyVisibleViewRange = function () {
            const e = this.viewLayout.getLinesViewportData(),
              t = e.completelyVisibleStartLineNumber,
              n = e.completelyVisibleEndLineNumber;
            return new m.a( t, this.getLineMinColumn( t ), n, this.getLineMaxColumn( n ) )
          }, t.prototype.getCompletelyVisibleViewRangeAtScrollTop = function ( e ) {
            const t = this.viewLayout.getLinesViewportDataAtScrollTop( e ),
              n = t.completelyVisibleStartLineNumber,
              i = t.completelyVisibleEndLineNumber;
            return new m.a( n, this.getLineMinColumn( n ), i, this.getLineMaxColumn( i ) )
          }, t.prototype.saveState = function () {
            const e = this.viewLayout.saveState(),
              t = e.scrollTop,
              n = this.viewLayout.getLineNumberAtVerticalOffset( t ),
              i = this.coordinatesConverter.convertViewPositionToModelPosition( new g.a( n, this.getLineMinColumn( n ) ) ),
              o = this.viewLayout.getVerticalOffsetForLineNumber( n ) - t;
            return {
              scrollLeft: e.scrollLeft,
              firstPosition: i,
              firstPositionDeltaTop: o
            }
          }, t.prototype.reduceRestoreState = function ( e ) {
            if ( "undefined" === typeof e.firstPosition ) return this._reduceRestoreStateCompatibility( e );
            const t = this.model.validatePosition( e.firstPosition ),
              n = this.coordinatesConverter.convertModelPositionToViewPosition( t ),
              i = this.viewLayout.getVerticalOffsetForLineNumber( n.lineNumber ) - e.firstPositionDeltaTop;
            return {
              scrollLeft: e.scrollLeft,
              scrollTop: i
            }
          }, t.prototype._reduceRestoreStateCompatibility = e => {
            return {
              scrollLeft: e.scrollLeft,
              scrollTop: e.scrollTopWithoutViewZones
            }
          }, t.prototype.getTabSize = function () {
            return this.model.getOptions().tabSize
          }, t.prototype.getLineCount = function () {
            return this.lines.getViewLineCount()
          }, t.prototype.setViewport = function ( e, t, n ) {
            this.lines.warmUpLookupCache( e, t ), this.viewportStartLine = e;
            const i = this.coordinatesConverter.convertViewPositionToModelPosition( new g.a( e, this.getLineMinColumn( e ) ) );
            this.viewportStartLineTrackedRange = this.model._setTrackedRange( this.viewportStartLineTrackedRange, new m.a( i.lineNumber, i.column, i.lineNumber, i.column ), v.h.NeverGrowsWhenTypingAtEdges ), this.viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber( e )
          }, t.prototype.getActiveIndentGuide = function ( e, t, n ) {
            return this.lines.getActiveIndentGuide( e, t, n )
          }, t.prototype.getLinesIndentGuides = function ( e, t ) {
            return this.lines.getViewLinesIndentGuides( e, t )
          }, t.prototype.getLineContent = function ( e ) {
            return this.lines.getViewLineContent( e )
          }, t.prototype.getLineLength = function ( e ) {
            return this.lines.getViewLineLength( e )
          }, t.prototype.getLineMinColumn = function ( e ) {
            return this.lines.getViewLineMinColumn( e )
          }, t.prototype.getLineMaxColumn = function ( e ) {
            return this.lines.getViewLineMaxColumn( e )
          }, t.prototype.getLineFirstNonWhitespaceColumn = function ( e ) {
            const t = p.firstNonWhitespaceIndex( this.getLineContent( e ) );
            return -1 === t ? 0 : t + 1
          }, t.prototype.getLineLastNonWhitespaceColumn = function ( e ) {
            const t = p.lastNonWhitespaceIndex( this.getLineContent( e ) );
            return -1 === t ? 0 : t + 2
          }, t.prototype.getDecorationsInViewport = function ( e ) {
            return this.decorations.getDecorationsViewportData( e ).decorations
          }, t.prototype.getViewLineRenderingData = function ( e, t ) {
            const n = this.model.mightContainRTL(),
              i = this.model.mightContainNonBasicASCII(),
              o = this.getTabSize(),
              r = this.lines.getViewLineData( t ),
              s = this.decorations.getDecorationsViewportData( e ).inlineDecorations[ t - e.startLineNumber ];
            return new Q.d( r.minColumn, r.maxColumn, r.content, r.continuesWithWrappedLine, n, i, r.tokens, s, o )
          }, t.prototype.getViewLineData = function ( e ) {
            return this.lines.getViewLineData( e )
          }, t.prototype.getMinimapLinesRenderingData = function ( e, t, n ) {
            const i = this.lines.getViewLinesData( e, t, n );
            return new Q.b( this.getTabSize(), i )
          }, t.prototype.getAllOverviewRulerDecorations = function ( e ) {
            return this.lines.getAllOverviewRulerDecorations( this.editorId, this.configuration.editor.readOnly, e )
          }, t.prototype.invalidateOverviewRulerColorCache = function () {
            for ( let e = this.model.getOverviewRulerDecorations(), t = 0, n = e.length; t < n; t++ ) {
              e[ t ].options.overviewRuler._resolvedColor = null
            }
          }, t.prototype.getValueInRange = function ( e, t ) {
            const n = this.coordinatesConverter.convertViewRangeToModelRange( e );
            return this.model.getValueInRange( n, t )
          }, t.prototype.getModelLineMaxColumn = function ( e ) {
            return this.model.getLineMaxColumn( e )
          }, t.prototype.validateModelPosition = function ( e ) {
            return this.model.validatePosition( e )
          }, t.prototype.deduceModelPositionRelativeToViewPosition = function ( e, t, n ) {
            const i = this.coordinatesConverter.convertViewPositionToModelPosition( e );
            2 === this.model.getEOL().length && ( t < 0 ? t -= n : t += n );
            const o = this.model.getOffsetAt( i ) + t;
            return this.model.getPositionAt( o )
          }, t.prototype.getEOL = function () {
            return this.model.getEOL()
          }, t.prototype.getPlainTextToCopy = function ( e, t, n ) {
            const i = this,
              o = n ? "\r\n" : this.model.getEOL();
            ( e = e.slice( 0 ) ).sort( m.a.compareRangesUsingStarts );
            const r = e.filter( ( e => {
              return !e.isEmpty()
            } ) );
            if ( 0 === r.length ) {
              if ( !t ) return "";
              for ( var s = e.map( ( e => {
                  const t = new g.a( e.startLineNumber, 1 );
                  return i.coordinatesConverter.convertViewPositionToModelPosition( t ).lineNumber
                } ) ), a = "", u = 0; u < s.length; u++ ) u > 0 && s[ u - 1 ] === s[ u ] || ( a += this.model.getLineContent( s[ u ] ) + o );
              return a
            }
            const l = [];
            for ( u = 0; u < r.length; u++ ) l.push( this.getValueInRange( r[ u ], n ? v.c.CRLF : v.c.TextDefined ) );
            return 1 === l.length ? l[ 0 ] : l
          }, t.prototype.getHTMLToCopy = function ( e, t ) {
            if ( 1 === this.model.getLanguageIdentifier().id ) return null;
            if ( 1 !== e.length ) return null;
            let n = this.coordinatesConverter.convertViewRangeToModelRange( e[ 0 ] );
            if ( n.isEmpty() ) {
              if ( !t ) return null;
              const i = n.startLineNumber;
              n = new m.a( i, this.model.getLineMinColumn( i ), i, this.model.getLineMaxColumn( i ) )
            }
            const o = this.configuration.editor.fontInfo,
              r = this._getColorMap();
            return '<div style="color: ' + r[ 1 ] + ";background-color: " + r[ 2 ] + ";font-family: " + o.fontFamily + ";font-weight: " + o.fontWeight + ";font-size: " + o.fontSize + "px;line-height: " + o.lineHeight + 'px;white-space: pre;">' + this._getHTMLToCopy( n, r ) + "</div>"
          }, t.prototype._getHTMLToCopy = function ( e, t ) {
            for ( var n = e.startLineNumber, i = e.startColumn, o = e.endLineNumber, r = e.endColumn, s = this.getTabSize(), a = "", u = n; u <= o; u++ ) {
              const l = this.model.getLineTokens( u ),
                c = l.getLineContent(),
                d = u === n ? i - 1 : 0,
                h = u === o ? r - 1 : c.length;
              a += "" === c ? "<br>" : Object( Z.a )( c, l.inflate(), t, d, h, s )
            }
            return a
          }, t.prototype._getColorMap = () => {
            for ( var e = $.y.getColorMap(), t = [ null ], n = 1, i = e.length; n < i; n++ ) t[ n ] = ne.a.Format.CSS.formatHex( e[ n ] );
            return t
          }, t;
        } )( H ),
        Me = n( "wQH0" ),
        Te = n( "tYmi" ),
        Re = n( "sM1p" ),
        Pe = n( "Vxe3" ),
        Ae = n( "nnTU" ),
        Fe = n( "t9D7" ),
        We = n( "ZlPH" ),
        je = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Ve = ( e => {
          function t() {
            const t = e.call( this ) || this;
            return t._shouldRender = !0, t
          }
          return je( t, e ), t.prototype.shouldRender = function () {
            return this._shouldRender
          }, t.prototype.forceShouldRender = function () {
            this._shouldRender = !0
          }, t.prototype.setShouldRender = function () {
            this._shouldRender = !0
          }, t.prototype.onDidRender = function () {
            this._shouldRender = !1
          }, t.prototype.onConfigurationChanged = e => {
            return !1
          }, t.prototype.onCursorStateChanged = e => {
            return !1
          }, t.prototype.onDecorationsChanged = e => {
            return !1
          }, t.prototype.onFlushed = e => {
            return !1
          }, t.prototype.onFocusChanged = e => {
            return !1
          }, t.prototype.onLanguageConfigurationChanged = e => {
            return !1
          }, t.prototype.onLineMappingChanged = e => {
            return !1
          }, t.prototype.onLinesChanged = e => {
            return !1
          }, t.prototype.onLinesDeleted = e => {
            return !1
          }, t.prototype.onLinesInserted = e => {
            return !1
          }, t.prototype.onRevealRangeRequest = e => {
            return !1
          }, t.prototype.onScrollChanged = e => {
            return !1
          }, t.prototype.onTokensChanged = e => {
            return !1
          }, t.prototype.onTokensColorsChanged = e => {
            return !1
          }, t.prototype.onZonesChanged = e => {
            return !1
          }, t.prototype.onThemeChanged = e => {
            return !1
          }, t.prototype.handleEvents = function ( e ) {
            for ( var t = !1, n = 0, i = e.length; n < i; n++ ) {
              const o = e[ n ];
              switch ( o.type ) {
                case 1:
                  this.onConfigurationChanged( o ) && ( t = !0 );
                  break;
                case 2:
                  this.onCursorStateChanged( o ) && ( t = !0 );
                  break;
                case 3:
                  this.onDecorationsChanged( o ) && ( t = !0 );
                  break;
                case 4:
                  this.onFlushed( o ) && ( t = !0 );
                  break;
                case 5:
                  this.onFocusChanged( o ) && ( t = !0 );
                  break;
                case 16:
                  this.onLanguageConfigurationChanged( o ) && ( t = !0 );
                  break;
                case 6:
                  this.onLineMappingChanged( o ) && ( t = !0 );
                  break;
                case 7:
                  this.onLinesChanged( o ) && ( t = !0 );
                  break;
                case 8:
                  this.onLinesDeleted( o ) && ( t = !0 );
                  break;
                case 9:
                  this.onLinesInserted( o ) && ( t = !0 );
                  break;
                case 10:
                  this.onRevealRangeRequest( o ) && ( t = !0 );
                  break;
                case 11:
                  this.onScrollChanged( o ) && ( t = !0 );
                  break;
                case 12:
                  this.onTokensChanged( o ) && ( t = !0 );
                  break;
                case 13:
                  this.onTokensColorsChanged( o ) && ( t = !0 );
                  break;
                case 14:
                  this.onZonesChanged( o ) && ( t = !0 );
                  break;
                case 15:
                  this.onThemeChanged( o ) && ( t = !0 );
                  break;
                default:
                  console.info( "View received unknown event: " ), console.info( o )
              }
            }
            t && ( this._shouldRender = !0 )
          }, t;
        } )( a.a ),
        Be = ( n( "VvMK" ), n( "MNsG" ) ),
        He = n( "D3Dy" ),
        ze = n( "5TxY" ),
        Ue = n( "Comh" ),
        Ke = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        qe = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._context = t, n._context.addEventHandler( n ), n
          }
          return Ke( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, e.prototype.dispose.call( this )
          }, t
        } )( Ve ),
        Ge = ( () => {
          function e() {}
          return e.write = ( e, t ) => {
            We.a, e.setAttribute( "data-mprt", String( t ) )
          }, e.read = e => {
            const t = e.getAttribute( "data-mprt" );
            return null === t ? 0 : parseInt( t, 10 )
          }, e.collect = function ( e, t ) {
            for ( var n = [], i = 0; e && e !== document.body && e !== t; ) e.nodeType === e.ELEMENT_NODE && ( n[ i++ ] = this.read( e ) ), e = e.parentElement;
            for ( var o = new Uint8Array( i ), r = 0; r < i; r++ ) o[ r ] = n[ i - r - 1 ];
            return o
          }, e;
        } )(),
        Ye = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Xe = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._canUseLayerHinting = n._context.configuration.editor.canUseLayerHinting, n._contentLeft = n._context.configuration.editor.layoutInfo.contentLeft, n._glyphMarginLeft = n._context.configuration.editor.layoutInfo.glyphMarginLeft, n._glyphMarginWidth = n._context.configuration.editor.layoutInfo.glyphMarginWidth, n._domNode = n._createDomNode(), n
          }
          return Ye( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype.getDomNode = function () {
            return this._domNode
          }, t.prototype._createDomNode = function () {
            const e = Object( We.b )( document.createElement( "div" ) );
            return e.setClassName( t.OUTER_CLASS_NAME ), e.setPosition( "absolute" ), e.setAttribute( "role", "presentation" ), e.setAttribute( "aria-hidden", "true" ), this._glyphMarginBackgroundDomNode = Object( We.b )( document.createElement( "div" ) ), this._glyphMarginBackgroundDomNode.setClassName( t.CLASS_NAME ), e.appendChild( this._glyphMarginBackgroundDomNode ), e
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.canUseLayerHinting && ( this._canUseLayerHinting = this._context.configuration.editor.canUseLayerHinting ), e.layoutInfo && ( this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft, this._glyphMarginLeft = this._context.configuration.editor.layoutInfo.glyphMarginLeft, this._glyphMarginWidth = this._context.configuration.editor.layoutInfo.glyphMarginWidth ), !0
          }, t.prototype.onScrollChanged = function ( t ) {
            return e.prototype.onScrollChanged.call( this, t ) || t.scrollTopChanged
          }, t.prototype.prepareRender = e => {}, t.prototype.render = function ( e ) {
            this._domNode.setLayerHinting( this._canUseLayerHinting );
            const t = e.scrollTop - e.bigNumbersDelta;
            this._domNode.setTop( -t );
            const n = Math.min( e.scrollHeight, 1e6 );
            this._domNode.setHeight( n ), this._domNode.setWidth( this._contentLeft ), this._glyphMarginBackgroundDomNode.setLeft( this._glyphMarginLeft ), this._glyphMarginBackgroundDomNode.setWidth( this._glyphMarginWidth ), this._glyphMarginBackgroundDomNode.setHeight( n )
          }, t.CLASS_NAME = "glyph-margin", t.OUTER_CLASS_NAME = "margin", t;
        } )( qe ),
        $e = ( n( "Krc3" ), n( "kYye" ) ),
        Ze = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Qe = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return Ze( t, e ), t
        } )( Ve ),
        Je = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        et = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._context = t, n._readConfig(), n._lastCursorModelPosition = new g.a( 1, 1 ), n._renderResult = null, n._context.addEventHandler( n ), n
          }
          return Je( t, e ), t.prototype._readConfig = function () {
            const e = this._context.configuration.editor;
            this._lineHeight = e.lineHeight, this._renderLineNumbers = e.viewInfo.renderLineNumbers, this._renderCustomLineNumbers = e.viewInfo.renderCustomLineNumbers, this._lineNumbersLeft = e.layoutInfo.lineNumbersLeft, this._lineNumbersWidth = e.layoutInfo.lineNumbersWidth
          }, t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, this._renderResult = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return this._readConfig(), !0
          }, t.prototype.onCursorStateChanged = function ( e ) {
            const t = e.selections[ 0 ].getPosition();
            return this._lastCursorModelPosition = this._context.model.coordinatesConverter.convertViewPositionToModelPosition( t ), 2 === this._renderLineNumbers || 3 === this._renderLineNumbers
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollTopChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype._getLineRenderLineNumber = function ( e ) {
            const t = this._context.model.coordinatesConverter.convertViewPositionToModelPosition( new g.a( e, 1 ) );
            if ( 1 !== t.column ) return "";
            const n = t.lineNumber;
            if ( this._renderCustomLineNumbers ) return this._renderCustomLineNumbers( n );
            if ( 2 === this._renderLineNumbers ) {
              const i = Math.abs( this._lastCursorModelPosition.lineNumber - n );
              return 0 === i ? '<span class="relative-current-line-number">' + n + "</span>" : String( i )
            }
            return 3 === this._renderLineNumbers ? this._lastCursorModelPosition.lineNumber === n ? String( n ) : n % 10 === 0 ? String( n ) : "" : String( n )
          }, t.prototype.prepareRender = function ( e ) {
            if ( 0 !== this._renderLineNumbers ) {
              for ( var n = Be.c ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, o = e.visibleRange.endLineNumber, r = '<div class="' + t.CLASS_NAME + n + '" style="left:' + this._lineNumbersLeft.toString() + "px;width:" + this._lineNumbersWidth.toString() + 'px;">', s = [], a = i; a <= o; a++ ) {
                const u = a - i,
                  l = this._getLineRenderLineNumber( a );
                s[ u ] = l ? r + l + "</div>" : ""
              }
              this._renderResult = s
            } else this._renderResult = null
          }, t.prototype.render = function ( e, t ) {
            if ( !this._renderResult ) return "";
            const n = t - e;
            return n < 0 || n >= this._renderResult.length ? "" : this._renderResult[ n ]
          }, t.CLASS_NAME = "line-numbers", t;
        } )( Qe );
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( $e.q );
        n && t.addRule( ".monaco-editor .line-numbers { color: " + n + "; }" );
        const i = e.getColor( $e.b );
        i && t.addRule( ".monaco-editor .current-line ~ .line-numbers { color: " + i + "; }" )
      } ) );
      const tt = n( "5v8Y" ),
        nt = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        it = ( () => {
          function e( e, t, n ) {
            this.top = e, this.left = t, this.width = n
          }
          return e.prototype.setWidth = function ( t ) {
            return new e( this.top, this.left, t )
          }, e
        } )(),
        ot = He.h || He.j,
        rt = ( () => {
          function e() {
            this._lastState = null
          }
          return e.prototype.set = function ( e ) {
            this._lastState = e
          }, e.prototype.get = function ( e ) {
            return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState : ( this._lastState = null, null )
          }, e.INSTANCE = new e, e
        } )(),
        st = ( e => {
          function t( t, n, i ) {
            const o = e.call( this, t ) || this;
            o._primaryCursorVisibleRange = null, o._viewController = n, o._viewHelper = i;
            const r = o._context.configuration.editor;
            o._accessibilitySupport = r.accessibilitySupport, o._contentLeft = r.layoutInfo.contentLeft, o._contentWidth = r.layoutInfo.contentWidth, o._contentHeight = r.layoutInfo.contentHeight, o._scrollLeft = 0, o._scrollTop = 0, o._fontInfo = r.fontInfo, o._lineHeight = r.lineHeight, o._emptySelectionClipboard = r.emptySelectionClipboard, o._visibleTextArea = null, o._selections = [ new _.a( 1, 1, 1, 1 ) ], o.textArea = Object( We.b )( document.createElement( "textarea" ) ), Ge.write( o.textArea, 6 ), o.textArea.setClassName( "inputarea" ), o.textArea.setAttribute( "wrap", "off" ), o.textArea.setAttribute( "autocorrect", "off" ), o.textArea.setAttribute( "autocapitalize", "off" ), o.textArea.setAttribute( "autocomplete", "off" ), o.textArea.setAttribute( "spellcheck", "false" ), o.textArea.setAttribute( "aria-label", r.viewInfo.ariaLabel ), o.textArea.setAttribute( "role", "textbox" ), o.textArea.setAttribute( "aria-multiline", "true" ), o.textArea.setAttribute( "aria-haspopup", "false" ), o.textArea.setAttribute( "aria-autocomplete", "both" ), o.textAreaCover = Object( We.b )( document.createElement( "div" ) ), o.textAreaCover.setPosition( "absolute" );
            const s = {
                getLineCount() {
                  return o._context.model.getLineCount()
                },
                getLineMaxColumn( e ) {
                  return o._context.model.getLineMaxColumn( e )
                },
                getValueInRange( e, t ) {
                  return o._context.model.getValueInRange( e, t )
                }
              },
              a = {
                getPlainTextToCopy() {
                  const e = o._context.model.getPlainTextToCopy( o._selections, o._emptySelectionClipboard, Be.g );
                  const t = o._context.model.getEOL();
                  const n = o._emptySelectionClipboard && 1 === o._selections.length && o._selections[ 0 ].isEmpty();
                  const i = Array.isArray( e ) ? e : null;
                  const r = Array.isArray( e ) ? e.join( t ) : e;
                  let s = null;
                  ( n || i ) && ( s = {
                    lastCopiedValue: He.j ? r.replace( /\r\n/g, "\n" ) : r,
                    isFromEmptySelection: o._emptySelectionClipboard && 1 === o._selections.length && o._selections[ 0 ].isEmpty(),
                    multicursorText: i
                  } );
                  return rt.INSTANCE.set( s ), r
                },
                getHTMLToCopy() {
                  return o._context.model.getHTMLToCopy( o._selections, o._emptySelectionClipboard )
                },
                getScreenReaderContent( e ) {
                  if ( He.l ) return Ue.b.EMPTY;
                  if ( 1 === o._accessibilitySupport ) {
                    if ( Be.d ) {
                      const t = o._selections[ 0 ];
                      if ( t.isEmpty() ) {
                        const n = t.getStartPosition();
                        let i = o._getWordBeforePosition( n );
                        if ( 0 === i.length && ( i = o._getCharacterBeforePosition( n ) ), i.length > 0 ) return new Ue.b( i, i.length, i.length, n, n )
                      }
                    }
                    return Ue.b.EMPTY
                  }
                  return Ue.a.fromEditorSelection( e, s, o._selections[ 0 ], 0 === o._accessibilitySupport )
                },
                deduceModelPosition( e, t, n ) {
                  return o._context.model.deduceModelPositionRelativeToViewPosition( e, t, n )
                }
              };
            return o._textAreaInput = o._register( new ze.b( a, o.textArea ) ), o._register( o._textAreaInput.onKeyDown( ( e => {
              o._viewController.emitKeyDown( e )
            } ) ) ), o._register( o._textAreaInput.onKeyUp( ( e => {
              o._viewController.emitKeyUp( e )
            } ) ) ), o._register( o._textAreaInput.onPaste( ( e => {
              const t = rt.INSTANCE.get( e.text );
              let n = !1;
              let i = null;
              t && ( n = o._emptySelectionClipboard && t.isFromEmptySelection, i = t.multicursorText ), o._viewController.paste( "keyboard", e.text, n, i )
            } ) ) ), o._register( o._textAreaInput.onCut( ( () => {
              o._viewController.cut( "keyboard" )
            } ) ) ), o._register( o._textAreaInput.onType( ( e => {
              e.replaceCharCnt ? o._viewController.replacePreviousChar( "keyboard", e.text, e.replaceCharCnt ) : o._viewController.type( "keyboard", e.text )
            } ) ) ), o._register( o._textAreaInput.onSelectionChangeRequest( ( e => {
              o._viewController.setSelection( "keyboard", e )
            } ) ) ), o._register( o._textAreaInput.onCompositionStart( ( () => {
              const e = o._selections[ 0 ].startLineNumber,
                t = o._selections[ 0 ].startColumn;
              o._context.privateViewEventBus.emit( new P( new m.a( e, t, e, t ), 0, !0, 1 ) );
              const n = o._viewHelper.visibleRangeForPositionRelativeToEditor( e, t );
              n && ( o._visibleTextArea = new it( o._context.viewLayout.getVerticalOffsetForLineNumber( e ), n.left, ot ? 0 : 1 ), o._render() ), o.textArea.setClassName( "inputarea ime-input" ), o._viewController.compositionStart( "keyboard" )
            } ) ) ), o._register( o._textAreaInput.onCompositionUpdate( ( e => {
              He.h ? o._visibleTextArea = o._visibleTextArea.setWidth( 0 ) : o._visibleTextArea = o._visibleTextArea.setWidth(
                ( ( e, t ) => {
                  const n = document.createElement( "canvas" ).getContext( "2d" );
                  n.font = ( e => {
                    return t = "normal", n = e.fontWeight, i = e.fontSize, o = e.lineHeight, r = e.fontFamily, t + " normal " + n + " " + i + "px / " + o + "px " + r;
                    var t, n, i, o, r
                  } )( t );
                  const i = n.measureText( e );
                  return He.j ? i.width + 2 : i.width
                } )( e.data, o._fontInfo )
              ), o._render()
            } ) ) ), o._register( o._textAreaInput.onCompositionEnd( ( () => {
              o._visibleTextArea = null, o._render(), o.textArea.setClassName( "inputarea" ), o._viewController.compositionEnd( "keyboard" )
            } ) ) ), o._register( o._textAreaInput.onFocus( ( () => {
              o._context.privateViewEventBus.emit( new I( !0 ) )
            } ) ) ), o._register( o._textAreaInput.onBlur( ( () => {
              o._context.privateViewEventBus.emit( new I( !1 ) )
            } ) ) ), o;
          }
          return nt( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype._getWordBeforePosition = function ( e ) {
            for ( var t = this._context.model.getLineContent( e.lineNumber ), n = Object( tt.a )( this._context.configuration.editor.wordSeparators ), i = e.column, o = 0; i > 1; ) {
              const r = t.charCodeAt( i - 2 );
              if ( 0 !== n.get( r ) || o > 50 ) return t.substring( i - 1, e.column - 1 );
              o++, i--
            }
            return t.substring( 0, e.column - 1 )
          }, t.prototype._getCharacterBeforePosition = function ( e ) {
            if ( e.column > 1 ) {
              const t = this._context.model.getLineContent( e.lineNumber ).charAt( e.column - 2 );
              if ( !p.isHighSurrogate( t.charCodeAt( 0 ) ) ) return t
            }
            return ""
          }, t.prototype.onConfigurationChanged = function ( e ) {
            const t = this._context.configuration.editor;
            return e.fontInfo && ( this._fontInfo = t.fontInfo ), e.viewInfo && this.textArea.setAttribute( "aria-label", t.viewInfo.ariaLabel ), e.layoutInfo && ( this._contentLeft = t.layoutInfo.contentLeft, this._contentWidth = t.layoutInfo.contentWidth, this._contentHeight = t.layoutInfo.contentHeight ), e.lineHeight && ( this._lineHeight = t.lineHeight ), e.accessibilitySupport && ( this._accessibilitySupport = t.accessibilitySupport, this._textAreaInput.writeScreenReaderContent( "strategy changed" ) ), e.emptySelectionClipboard && ( this._emptySelectionClipboard = t.emptySelectionClipboard ), !0
          }, t.prototype.onCursorStateChanged = function ( e ) {
            return this._selections = e.selections.slice( 0 ), this._textAreaInput.writeScreenReaderContent( "selection changed" ), !0
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = function ( e ) {
            return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, !0
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype.isFocused = function () {
            return this._textAreaInput.isFocused()
          }, t.prototype.focusTextArea = function () {
            this._textAreaInput.focusTextArea()
          }, t.prototype.prepareRender = function ( e ) {
            if ( 2 === this._accessibilitySupport ) this._primaryCursorVisibleRange = null;
            else {
              const t = new g.a( this._selections[ 0 ].positionLineNumber, this._selections[ 0 ].positionColumn );
              this._primaryCursorVisibleRange = e.visibleRangeForPosition( t )
            }
          }, t.prototype.render = function ( e ) {
            this._textAreaInput.writeScreenReaderContent( "render" ), this._render()
          }, t.prototype._render = function () {
            if ( this._visibleTextArea ) this._renderInsideEditor( this._visibleTextArea.top - this._scrollTop, this._contentLeft + this._visibleTextArea.left - this._scrollLeft, this._visibleTextArea.width, this._lineHeight, !0 );
            else if ( this._primaryCursorVisibleRange ) {
              const e = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
              if ( e < this._contentLeft || e > this._contentLeft + this._contentWidth ) this._renderAtTopLeft();
              else {
                const t = this._context.viewLayout.getVerticalOffsetForLineNumber( this._selections[ 0 ].positionLineNumber ) - this._scrollTop;
                t < 0 || t > this._contentHeight ? this._renderAtTopLeft() : this._renderInsideEditor( t, e, ot ? 0 : 1, ot ? 0 : 1, !1 )
              }
            } else this._renderAtTopLeft()
          }, t.prototype._renderInsideEditor = function ( e, t, n, i, o ) {
            const r = this.textArea,
              s = this.textAreaCover;
            o ? h.a.applyFontInfo( r, this._fontInfo ) : ( r.setFontSize( 1 ), r.setLineHeight( this._fontInfo.lineHeight ) ), r.setTop( e ), r.setLeft( t ), r.setWidth( n ), r.setHeight( i ), s.setTop( 0 ), s.setLeft( 0 ), s.setWidth( 0 ), s.setHeight( 0 )
          }, t.prototype._renderAtTopLeft = function () {
            const e = this.textArea,
              t = this.textAreaCover;
            if ( h.a.applyFontInfo( e, this._fontInfo ), e.setTop( 0 ), e.setLeft( 0 ), t.setTop( 0 ), t.setLeft( 0 ), ot ) return e.setWidth( 0 ), e.setHeight( 0 ), t.setWidth( 0 ), void t.setHeight( 0 );
            e.setWidth( 1 ), e.setHeight( 1 ), t.setWidth( 1 ), t.setHeight( 1 ), this._context.configuration.editor.viewInfo.glyphMargin ? t.setClassName( "monaco-editor-background textAreaCover " + Xe.OUTER_CLASS_NAME ) : 0 !== this._context.configuration.editor.viewInfo.renderLineNumbers ? t.setClassName( "monaco-editor-background textAreaCover " + et.CLASS_NAME ) : t.setClassName( "monaco-editor-background textAreaCover" )
          }, t;
        } )( qe );
      const at = n( "pg8w" ),
        ut = n( "sFUC" ),
        lt = n( "XSiN" ),
        ct = n( "AKMP" ),
        dt = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        ht = ( () => {
          function e( e, t ) {
            this.x = e, this.y = t
          }
          return e.prototype.toClientCoordinates = function () {
            return new pt( this.x - o.e.scrollX, this.y - o.e.scrollY )
          }, e
        } )(),
        pt = ( () => {
          function e( e, t ) {
            this.clientX = e, this.clientY = t
          }
          return e.prototype.toPageCoordinates = function () {
            return new ht( this.clientX + o.e.scrollX, this.clientY + o.e.scrollY )
          }, e
        } )(),
        ft = function ( e, t, n, i ) {
          this.x = e, this.y = t, this.width = n, this.height = i
        };

      function gt( e ) {
        const t = o.u( e );
        return new ft( t.left, t.top, t.width, t.height )
      }
      const mt = ( e => {
          function t( t, n ) {
            const i = e.call( this, t ) || this;
            return i.pos = new ht( i.posx, i.posy ), i.editorPos = gt( n ), i
          }
          return dt( t, e ), t
        } )( lt.b ),
        _t = ( () => {
          function e( e ) {
            this._editorViewDomNode = e
          }
          return e.prototype._create = function ( e ) {
            return new mt( e, this._editorViewDomNode )
          }, e.prototype.onContextMenu = function ( e, t ) {
            const n = this;
            return o.g( e, "contextmenu", ( e => {
              t( n._create( e ) )
            } ) );
          }, e.prototype.onMouseUp = function ( e, t ) {
            const n = this;
            return o.g( e, "mouseup", ( e => {
              t( n._create( e ) )
            } ) );
          }, e.prototype.onMouseDown = function ( e, t ) {
            const n = this;
            return o.g( e, "mousedown", ( e => {
              t( n._create( e ) )
            } ) );
          }, e.prototype.onMouseLeave = function ( e, t ) {
            const n = this;
            return o.h( e, ( e => {
              t( n._create( e ) )
            } ) );
          }, e.prototype.onMouseMoveThrottled = function ( e, t, n, i ) {
            const r = this;
            return o.i( e, "mousemove", t, ( ( e, t ) => {
              return n( e, r._create( t ) )
            } ), i );
          }, e;
        } )(),
        vt = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._editorViewDomNode = t, n._globalMouseMoveMonitor = n._register( new ct.a ), n._keydownListener = null, n
          }
          return dt( t, e ), t.prototype.startMonitoring = function ( e, t, n ) {
            const i = this;
            this._keydownListener = o.j( document, "keydown", ( e => {
              e.toKeybinding().isModifierKey() || i._globalMouseMoveMonitor.stopMonitoring( !0 )
            } ), !0 );
            this._globalMouseMoveMonitor.startMonitoring( ( ( t, n ) => {
              return e( t, new mt( n, i._editorViewDomNode ) )
            } ), t, ( () => {
              i._keydownListener.dispose(), n()
            } ) )
          }, t;
        } )( a.a ),
        yt = n( "dBaI" ),
        bt = n( "baJR" ),
        Ct = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        wt = ( e => {
          function t( t, n, i ) {
            const o = e.call( this, t, n ) || this;
            return o._viewLines = i, o
          }
          return Ct( t, e ), t.prototype.linesVisibleRangesForRange = function ( e, t ) {
            return this._viewLines.linesVisibleRangesForRange( e, t )
          }, t.prototype.visibleRangeForPosition = function ( e ) {
            const t = this._viewLines.visibleRangesForRange2( new m.a( e.lineNumber, e.column, e.lineNumber, e.column ) );
            return t ? t[ 0 ] : null
          }, t;
        } )(
          ( () => {
            function e( e, t ) {
              this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
              const n = this._viewLayout.getCurrentViewport();
              this.scrollTop = n.top, this.scrollLeft = n.left, this.viewportWidth = n.width, this.viewportHeight = n.height
            }
            return e.prototype.getScrolledTopFromAbsoluteTop = function ( e ) {
              return e - this.scrollTop
            }, e.prototype.getVerticalOffsetForLineNumber = function ( e ) {
              return this._viewLayout.getVerticalOffsetForLineNumber( e )
            }, e.prototype.getDecorationsInViewport = function () {
              return this.viewportData.getDecorationsInViewport()
            }, e
          } )()
        ),
        St = function ( e, t ) {
          this.lineNumber = e, this.ranges = t
        },
        Ot = ( () => {
          function e( e, t ) {
            this.left = Math.round( e ), this.width = Math.round( t )
          }
          return e.prototype.toString = function () {
            return "[" + this.left + "," + this.width + "]"
          }, e
        } )(),
        Lt = ( () => {
          function e( e, t ) {
            this.left = e, this.width = t
          }
          return e.prototype.toString = function () {
            return "[" + this.left + "," + this.width + "]"
          }, e.compare = ( e, t ) => {
            return e.left - t.left
          }, e;
        } )(),
        xt = ( () => {
          function e() {}
          return e._createRange = function () {
            return this._handyReadyRange || ( this._handyReadyRange = document.createRange() ), this._handyReadyRange
          }, e._detachRange = ( e, t ) => {
            e.selectNodeContents( t )
          }, e._readClientRects = function ( e, t, n, i, o ) {
            const r = this._createRange();
            try {
              return r.setStart( e, t ), r.setEnd( n, i ), r.getClientRects()
            } catch ( s ) {
              return null
            } finally {
              this._detachRange( r, o )
            }
          }, e._mergeAdjacentRanges = e => {
            if ( 1 === e.length ) return [ new Ot( e[ 0 ].left, e[ 0 ].width ) ];
            e.sort( Lt.compare );
            for ( var t = [], n = 0, i = e[ 0 ].left, o = e[ 0 ].width, r = 1, s = e.length; r < s; r++ ) {
              const a = e[ r ],
                u = a.left,
                l = a.width;
              i + o + .9 >= u ? o = Math.max( o, u + l - i ) : ( t[ n++ ] = new Ot( i, o ), i = u, o = l )
            }
            return t[ n++ ] = new Ot( i, o ), t
          }, e._createHorizontalRangesFromClientRects = function ( e, t ) {
            if ( !e || 0 === e.length ) return null;
            for ( var n = [], i = 0, o = e.length; i < o; i++ ) {
              const r = e[ i ];
              n[ i ] = new Lt( Math.max( 0, r.left - t ), r.width )
            }
            return this._mergeAdjacentRanges( n )
          }, e.readHorizontalRanges = function ( e, t, n, i, o, r, s ) {
            const a = e.children.length - 1;
            if ( 0 > a ) return null;
            ( t = Math.min( a, Math.max( 0, t ) ) ) !== ( i = Math.min( a, Math.max( 0, i ) ) ) && i > 0 && 0 === o && ( i--, o = Number.MAX_VALUE );
            let u = e.children[ t ].firstChild,
              l = e.children[ i ].firstChild;
            if ( u && l || ( !u && 0 === n && t > 0 && ( u = e.children[ t - 1 ].firstChild, n = 1073741824 ), !l && 0 === o && i > 0 && ( l = e.children[ i - 1 ].firstChild, o = 1073741824 ) ), !u || !l ) return null;
            n = Math.min( u.textContent.length, Math.max( 0, n ) ), o = Math.min( l.textContent.length, Math.max( 0, o ) );
            const c = this._readClientRects( u, n, l, o, s );
            return this._createHorizontalRangesFromClientRects( c, r )
          }, e;
        } )(),
        Nt = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Et = !!Be.e || !( Be.c || He.j || He.m ),
        kt = He.h,
        It = ( () => {
          function e( e, t ) {
            this._domNode = e, this._clientRectDeltaLeft = 0, this._clientRectDeltaLeftRead = !1, this.endNode = t
          }
          return Object.defineProperty( e.prototype, "clientRectDeltaLeft", {
            get() {
              return this._clientRectDeltaLeftRead || ( this._clientRectDeltaLeftRead = !0, this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left ), this._clientRectDeltaLeft
            },
            enumerable: !0,
            configurable: !0
          } ), e;
        } )(),
        Dt = ( () => {
          function e( e, t ) {
            this.themeType = t, this.renderWhitespace = e.editor.viewInfo.renderWhitespace, this.renderControlCharacters = e.editor.viewInfo.renderControlCharacters, this.spaceWidth = e.editor.fontInfo.spaceWidth, this.useMonospaceOptimizations = e.editor.fontInfo.isMonospace && !e.editor.viewInfo.disableMonospaceOptimizations, this.lineHeight = e.editor.lineHeight, this.stopRenderingLineAfter = e.editor.viewInfo.stopRenderingLineAfter, this.fontLigatures = e.editor.viewInfo.fontLigatures
          }
          return e.prototype.equals = function ( e ) {
            return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures
          }, e
        } )(),
        Mt = ( () => {
          function e( e ) {
            this._options = e, this._isMaybeInvalid = !0, this._renderedViewLine = null
          }
          return e.prototype.getDomNode = function () {
            return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null
          }, e.prototype.setDomNode = function ( e ) {
            if ( !this._renderedViewLine ) throw new Error( "I have no rendered view line to set the dom node to..." );
            this._renderedViewLine.domNode = Object( We.b )( e )
          }, e.prototype.onContentChanged = function () {
            this._isMaybeInvalid = !0
          }, e.prototype.onTokensChanged = function () {
            this._isMaybeInvalid = !0
          }, e.prototype.onDecorationsChanged = function () {
            this._isMaybeInvalid = !0
          }, e.prototype.onOptionsChanged = function ( e ) {
            this._isMaybeInvalid = !0, this._options = e
          }, e.prototype.onSelectionChanged = function () {
            return !( !kt && this._options.themeType !== Fe.b ) && ( this._isMaybeInvalid = !0, !0 )
          }, e.prototype.renderLine = function ( t, n, i, o ) {
            if ( !1 === this._isMaybeInvalid ) return !1;
            this._isMaybeInvalid = !1;
            const r = i.getViewLineRenderingData( t ),
              s = this._options,
              a = yt.a.filter( r.inlineDecorations, t, r.minColumn, r.maxColumn );
            if ( kt || s.themeType === Fe.b )
              for ( let u = i.selections, l = 0, c = u.length; l < c; l++ ) {
                const d = u[ l ];
                if ( !( d.endLineNumber < t || d.startLineNumber > t ) ) {
                  const h = d.startLineNumber === t ? d.startColumn : r.minColumn,
                    p = d.endLineNumber === t ? d.endColumn : r.maxColumn;
                  h < p && a.push( new yt.a( h, p, "inline-selected-text", 0 ) )
                }
              }
            const f = new bt.b( s.useMonospaceOptimizations, r.content, r.continuesWithWrappedLine, r.isBasicASCII, r.containsRTL, r.minColumn - 1, r.tokens, a, r.tabSize, s.spaceWidth, s.stopRenderingLineAfter, s.renderWhitespace, s.renderControlCharacters, s.fontLigatures );
            if ( this._renderedViewLine && this._renderedViewLine.input.equals( f ) ) return !1;
            o.appendASCIIString( '<div style="top:' ), o.appendASCIIString( String( n ) ), o.appendASCIIString( "px;height:" ), o.appendASCIIString( String( this._options.lineHeight ) ), o.appendASCIIString( 'px;" class="' ), o.appendASCIIString( e.CLASS_NAME ), o.appendASCIIString( '">' );
            const g = Object( bt.c )( f, o );
            o.appendASCIIString( "</div>" );
            let m = null;
            return Et && r.isBasicASCII && s.useMonospaceOptimizations && 0 === g.containsForeignElements && r.content.length < 300 && f.lineTokens.getCount() < 100 && ( m = new Tt( this._renderedViewLine ? this._renderedViewLine.domNode : null, f, g.characterMapping ) ), m || ( m = At( this._renderedViewLine ? this._renderedViewLine.domNode : null, f, g.characterMapping, g.containsRTL, g.containsForeignElements ) ), this._renderedViewLine = m, !0
          }, e.prototype.layoutLine = function ( e, t ) {
            this._renderedViewLine && this._renderedViewLine.domNode && ( this._renderedViewLine.domNode.setTop( t ), this._renderedViewLine.domNode.setHeight( this._options.lineHeight ) )
          }, e.prototype.getWidth = function () {
            return this._renderedViewLine ? this._renderedViewLine.getWidth() : 0
          }, e.prototype.getWidthIsFast = function () {
            return !this._renderedViewLine || this._renderedViewLine.getWidthIsFast()
          }, e.prototype.getVisibleRangesForRange = function ( e, t, n ) {
            e |= 0, t |= 0, e = Math.min( this._renderedViewLine.input.lineContent.length + 1, Math.max( 1, e ) ), t = Math.min( this._renderedViewLine.input.lineContent.length + 1, Math.max( 1, t ) );
            const i = 0 | this._renderedViewLine.input.stopRenderingLineAfter;
            return -1 !== i && e > i && t > i ? null : ( -1 !== i && e > i && ( e = i ), -1 !== i && t > i && ( t = i ), this._renderedViewLine.getVisibleRangesForRange( e, t, n ) )
          }, e.prototype.getColumnOfNodeOffset = function ( e, t, n ) {
            return this._renderedViewLine.getColumnOfNodeOffset( e, t, n )
          }, e.CLASS_NAME = "view-line", e;
        } )(),
        Tt = ( () => {
          function e( e, t, n ) {
            this.domNode = e, this.input = t, this._characterMapping = n, this._charWidth = t.spaceWidth
          }
          return e.prototype.getWidth = function () {
            return this._getCharPosition( this._characterMapping.length )
          }, e.prototype.getWidthIsFast = () => {
            return !0
          }, e.prototype.getVisibleRangesForRange = function ( e, t, n ) {
            const i = this._getCharPosition( e ),
              o = this._getCharPosition( t );
            return [ new Ot( i, o - i ) ]
          }, e.prototype._getCharPosition = function ( e ) {
            const t = this._characterMapping.getAbsoluteOffsets();
            return 0 === t.length ? 0 : Math.round( this._charWidth * t[ e - 1 ] )
          }, e.prototype.getColumnOfNodeOffset = function ( e, t, n ) {
            for ( var i = t.textContent.length, o = -1; t; ) t = t.previousSibling, o++;
            return this._characterMapping.partDataToCharOffset( o, i, n ) + 1
          }, e;
        } )(),
        Rt = ( () => {
          function e( e, t, n, i, o ) {
            if ( this.domNode = e, this.input = t, this._characterMapping = n, this._isWhitespaceOnly = /^\s*$/.test( t.lineContent ), this._containsForeignElements = o, this._cachedWidth = -1, this._pixelOffsetCache = null, !i || 0 === this._characterMapping.length ) {
              this._pixelOffsetCache = new Int32Array( Math.max( 2, this._characterMapping.length + 1 ) );
              for ( let r = 0, s = this._characterMapping.length; r <= s; r++ ) this._pixelOffsetCache[ r ] = -1
            }
          }
          return e.prototype._getReadingTarget = function () {
            return this.domNode.domNode.firstChild
          }, e.prototype.getWidth = function () {
            return -1 === this._cachedWidth && ( this._cachedWidth = this._getReadingTarget().offsetWidth ), this._cachedWidth
          }, e.prototype.getWidthIsFast = function () {
            return -1 !== this._cachedWidth
          }, e.prototype.getVisibleRangesForRange = function ( e, t, n ) {
            if ( null !== this._pixelOffsetCache ) {
              const i = this._readPixelOffset( e, n );
              if ( -1 === i ) return null;
              const o = this._readPixelOffset( t, n );
              return -1 === o ? null : [ new Ot( i, o - i ) ]
            }
            return this._readVisibleRangesForRange( e, t, n )
          }, e.prototype._readVisibleRangesForRange = function ( e, t, n ) {
            if ( e === t ) {
              const i = this._readPixelOffset( e, n );
              return -1 === i ? null : [ new Ot( i, 0 ) ]
            }
            return this._readRawVisibleRangesForRange( e, t, n )
          }, e.prototype._readPixelOffset = function ( e, t ) {
            if ( 0 === this._characterMapping.length ) {
              if ( 0 === this._containsForeignElements ) return 0;
              if ( 2 === this._containsForeignElements ) return 0;
              if ( 1 === this._containsForeignElements ) return this.getWidth()
            }
            if ( null !== this._pixelOffsetCache ) {
              const n = this._pixelOffsetCache[ e ];
              if ( -1 !== n ) return n;
              const i = this._actualReadPixelOffset( e, t );
              return this._pixelOffsetCache[ e ] = i, i
            }
            return this._actualReadPixelOffset( e, t )
          }, e.prototype._actualReadPixelOffset = function ( e, t ) {
            if ( 0 === this._characterMapping.length ) {
              const n = xt.readHorizontalRanges( this._getReadingTarget(), 0, 0, 0, 0, t.clientRectDeltaLeft, t.endNode );
              return n && 0 !== n.length ? n[ 0 ].left : -1
            }
            if ( e === this._characterMapping.length && this._isWhitespaceOnly && 0 === this._containsForeignElements ) return this.getWidth();
            const i = this._characterMapping.charOffsetToPartData( e - 1 ),
              o = bt.a.getPartIndex( i ),
              r = bt.a.getCharIndex( i ),
              s = xt.readHorizontalRanges( this._getReadingTarget(), o, r, o, r, t.clientRectDeltaLeft, t.endNode );
            return s && 0 !== s.length ? s[ 0 ].left : -1
          }, e.prototype._readRawVisibleRangesForRange = function ( e, t, n ) {
            if ( 1 === e && t === this._characterMapping.length ) return [ new Ot( 0, this.getWidth() ) ];
            const i = this._characterMapping.charOffsetToPartData( e - 1 ),
              o = bt.a.getPartIndex( i ),
              r = bt.a.getCharIndex( i ),
              s = this._characterMapping.charOffsetToPartData( t - 1 ),
              a = bt.a.getPartIndex( s ),
              u = bt.a.getCharIndex( s );
            return xt.readHorizontalRanges( this._getReadingTarget(), o, r, a, u, n.clientRectDeltaLeft, n.endNode )
          }, e.prototype.getColumnOfNodeOffset = function ( e, t, n ) {
            for ( var i = t.textContent.length, o = -1; t; ) t = t.previousSibling, o++;
            return this._characterMapping.partDataToCharOffset( o, i, n ) + 1
          }, e;
        } )(),
        Pt = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return Nt( t, e ), t.prototype._readVisibleRangesForRange = function ( t, n, i ) {
            const o = e.prototype._readVisibleRangesForRange.call( this, t, n, i );
            if ( !o || 0 === o.length || t === n || 1 === t && n === this._characterMapping.length ) return o;
            const r = this._readPixelOffset( n - 1, i ),
              s = this._readPixelOffset( n, i );
            if ( -1 !== r && -1 !== s ) {
              const a = r <= s,
                u = o[ o.length - 1 ];
              a && u.left < s && ( u.width = s - u.left )
            }
            return o
          }, t;
        } )( Rt ),
        At = He.n ? Ft : Wt;

      function Ft( e, t, n, i, o ) {
        return new Pt( e, t, n, i, o )
      }

      function Wt( e, t, n, i, o ) {
        return new Rt( e, t, n, i, o )
      }
      const jt = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Vt = ( () => {
          function e( e, t, n, i, o, r ) {
            void 0 === n && ( n = 0 ), void 0 === i && ( i = null ), void 0 === o && ( o = null ), void 0 === r && ( r = null ), this.element = e, this.type = t, this.mouseColumn = n, this.position = i, !o && i && ( o = new m.a( i.lineNumber, i.column, i.lineNumber, i.column ) ), this.range = o, this.detail = r
          }
          return e._typeToString = e => {
            return e === ut.b.TEXTAREA ? "TEXTAREA" : e === ut.b.GUTTER_GLYPH_MARGIN ? "GUTTER_GLYPH_MARGIN" : e === ut.b.GUTTER_LINE_NUMBERS ? "GUTTER_LINE_NUMBERS" : e === ut.b.GUTTER_LINE_DECORATIONS ? "GUTTER_LINE_DECORATIONS" : e === ut.b.GUTTER_VIEW_ZONE ? "GUTTER_VIEW_ZONE" : e === ut.b.CONTENT_TEXT ? "CONTENT_TEXT" : e === ut.b.CONTENT_EMPTY ? "CONTENT_EMPTY" : e === ut.b.CONTENT_VIEW_ZONE ? "CONTENT_VIEW_ZONE" : e === ut.b.CONTENT_WIDGET ? "CONTENT_WIDGET" : e === ut.b.OVERVIEW_RULER ? "OVERVIEW_RULER" : e === ut.b.SCROLLBAR ? "SCROLLBAR" : e === ut.b.OVERLAY_WIDGET ? "OVERLAY_WIDGET" : "UNKNOWN"
          }, e.toString = function ( e ) {
            return this._typeToString( e.type ) + ": " + e.position + " - " + e.range + " - " + e.detail
          }, e.prototype.toString = function () {
            return e.toString( this )
          }, e;
        } )(),
        Bt = ( () => {
          function e() {}
          return e.isTextArea = e => {
            return 2 === e.length && 3 === e[ 0 ] && 6 === e[ 1 ]
          }, e.isChildOfViewLines = e => {
            return e.length >= 4 && 3 === e[ 0 ] && 7 === e[ 3 ]
          }, e.isStrictChildOfViewLines = e => {
            return e.length > 4 && 3 === e[ 0 ] && 7 === e[ 3 ]
          }, e.isChildOfScrollableElement = e => {
            return e.length >= 2 && 3 === e[ 0 ] && 5 === e[ 1 ]
          }, e.isChildOfMinimap = e => {
            return e.length >= 2 && 3 === e[ 0 ] && 8 === e[ 1 ]
          }, e.isChildOfContentWidgets = e => {
            return e.length >= 4 && 3 === e[ 0 ] && 1 === e[ 3 ]
          }, e.isChildOfOverflowingContentWidgets = e => {
            return e.length >= 1 && 2 === e[ 0 ]
          }, e.isChildOfOverlayWidgets = e => {
            return e.length >= 2 && 3 === e[ 0 ] && 4 === e[ 1 ]
          }, e;
        } )(),
        Ht = ( () => {
          function e( e, t, n ) {
            this.model = e.model, this.layoutInfo = e.configuration.editor.layoutInfo, this.viewDomNode = t.viewDomNode, this.lineHeight = e.configuration.editor.lineHeight, this.typicalHalfwidthCharacterWidth = e.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth, this.lastViewCursorsRenderData = n, this._context = e, this._viewHelper = t
          }
          return e.prototype.getZoneAtCoord = function ( t ) {
            return e.getZoneAtCoord( this._context, t )
          }, e.getZoneAtCoord = ( e, t ) => {
            const n = e.viewLayout.getWhitespaceAtVerticalOffset( t );
            if ( n ) {
              const i = n.verticalOffset + n.height / 2;
              const o = e.model.getLineCount();
              let r = null;
              let s = void 0;
              let a = null;
              return n.afterLineNumber !== o && ( a = new g.a( n.afterLineNumber + 1, 1 ) ), n.afterLineNumber > 0 && ( r = new g.a( n.afterLineNumber, e.model.getLineMaxColumn( n.afterLineNumber ) ) ), s = null === a ? r : null === r ? a : t < i ? r : a, {
                viewZoneId: n.id,
                afterLineNumber: n.afterLineNumber,
                positionBefore: r,
                positionAfter: a,
                position: s
              }
            }
            return null
          }, e.prototype.getFullLineRangeAtCoord = function ( e ) {
            if ( this._context.viewLayout.isAfterLines( e ) ) {
              const t = this._context.model.getLineCount(),
                n = this._context.model.getLineMaxColumn( t );
              return {
                range: new m.a( t, n, t, n ),
                isAfterLines: !0
              }
            }
            const i = this._context.viewLayout.getLineNumberAtVerticalOffset( e ),
              o = this._context.model.getLineMaxColumn( i );
            return {
              range: new m.a( i, 1, i, o ),
              isAfterLines: !1
            }
          }, e.prototype.getLineNumberAtVerticalOffset = function ( e ) {
            return this._context.viewLayout.getLineNumberAtVerticalOffset( e )
          }, e.prototype.isAfterLines = function ( e ) {
            return this._context.viewLayout.isAfterLines( e )
          }, e.prototype.getVerticalOffsetForLineNumber = function ( e ) {
            return this._context.viewLayout.getVerticalOffsetForLineNumber( e )
          }, e.prototype.findAttribute = function ( t, n ) {
            return e._findAttribute( t, n, this._viewHelper.viewDomNode )
          }, e._findAttribute = ( e, t, n ) => {
            for ( ; e && e !== document.body; ) {
              if ( e.hasAttribute && e.hasAttribute( t ) ) return e.getAttribute( t );
              if ( e === n ) return null;
              e = e.parentNode
            }
            return null
          }, e.prototype.getLineWidth = function ( e ) {
            return this._viewHelper.getLineWidth( e )
          }, e.prototype.visibleRangeForPosition2 = function ( e, t ) {
            return this._viewHelper.visibleRangeForPosition2( e, t )
          }, e.prototype.getPositionFromDOMInfo = function ( e, t ) {
            return this._viewHelper.getPositionFromDOMInfo( e, t )
          }, e.prototype.getCurrentScrollTop = function () {
            return this._context.viewLayout.getCurrentScrollTop()
          }, e.prototype.getCurrentScrollLeft = function () {
            return this._context.viewLayout.getCurrentScrollLeft()
          }, e;
        } )(),
        zt = ( e => {
          function t( t, n, i, o ) {
            const r = e.call( this, t, n, i ) || this;
            return r._ctx = t, o ? ( r.target = o, r.targetPath = Ge.collect( o, t.viewDomNode ) ) : ( r.target = null, r.targetPath = new Uint8Array( 0 ) ), r
          }
          return jt( t, e ), t.prototype.toString = function () {
            return "pos(" + this.pos.x + "," + this.pos.y + "), editorPos(" + this.editorPos.x + "," + this.editorPos.y + "), mouseVerticalOffset: " + this.mouseVerticalOffset + ", mouseContentHorizontalOffset: " + this.mouseContentHorizontalOffset + "\n\ttarget: " + ( this.target ? this.target.outerHTML : null )
          }, t.prototype.fulfill = function ( e, t, n, i ) {
            return void 0 === t && ( t = null ), void 0 === n && ( n = null ), void 0 === i && ( i = null ), new Vt( this.target, e, this.mouseColumn, t, n, i )
          }, t.prototype.withTarget = function ( e ) {
            return new t( this._ctx, this.editorPos, this.pos, e )
          }, t
        } )(
          function ( e, t, n ) {
            this.editorPos = t, this.pos = n, this.mouseVerticalOffset = Math.max( 0, e.getCurrentScrollTop() + n.y - t.y ), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + n.x - t.x - e.layoutInfo.contentLeft, this.isInMarginArea = n.x - t.x < e.layoutInfo.contentLeft && n.x - t.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max( 0, qt._getMouseColumn( this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth ) )
          }
        ),
        Ut = {
          isAfterLines: !0
        };

      function Kt( e ) {
        return {
          isAfterLines: !1,
          horizontalDistanceToText: e
        }
      }

      var qt = ( () => {
        function e( e, t ) {
          this._context = e, this._viewHelper = t
        }
        return e.prototype.mouseTargetIsWidget = function ( e ) {
          const t = e.target,
            n = Ge.collect( t, this._viewHelper.viewDomNode );
          return !( !Bt.isChildOfContentWidgets( n ) && !Bt.isChildOfOverflowingContentWidgets( n ) ) || !!Bt.isChildOfOverlayWidgets( n )
        }, e.prototype.createMouseTarget = function ( t, n, i, o ) {
          const r = new Ht( this._context, this._viewHelper, t ),
            s = new zt( r, n, i, o );
          try {
            return e._createMouseTarget( r, s, !1 )
          } catch ( a ) {
            return s.fulfill( ut.b.UNKNOWN )
          }
        }, e._createMouseTarget = function ( t, n, i ) {
          if ( null === n.target ) {
            if ( i ) return n.fulfill( ut.b.UNKNOWN );
            const o = e._doHitTest( t, n );
            return o.position ? e.createMouseTargetFromHitTestPosition( t, n, o.position.lineNumber, o.position.column ) : this._createMouseTarget( t, n.withTarget( o.hitTarget ), !0 )
          }
          let r = null;
          return ( r = ( r = ( r = ( r = ( r = ( r = ( r = ( r = ( r = ( r = r || e._hitTestContentWidget( t, n ) ) || e._hitTestOverlayWidget( t, n ) ) || e._hitTestMinimap( t, n ) ) || e._hitTestScrollbarSlider( t, n ) ) || e._hitTestViewZone( t, n ) ) || e._hitTestMargin( t, n ) ) || e._hitTestViewCursor( t, n ) ) || e._hitTestTextArea( t, n ) ) || e._hitTestViewLines( t, n, i ) ) || e._hitTestScrollbar( t, n ) ) || n.fulfill( ut.b.UNKNOWN )
        }, e._hitTestContentWidget = ( e, t ) => {
          if ( Bt.isChildOfContentWidgets( t.targetPath ) || Bt.isChildOfOverflowingContentWidgets( t.targetPath ) ) {
            const n = e.findAttribute( t.target, "widgetId" );
            return n ? t.fulfill( ut.b.CONTENT_WIDGET, null, null, n ) : t.fulfill( ut.b.UNKNOWN )
          }
          return null
        }, e._hitTestOverlayWidget = ( e, t ) => {
          if ( Bt.isChildOfOverlayWidgets( t.targetPath ) ) {
            const n = e.findAttribute( t.target, "widgetId" );
            return n ? t.fulfill( ut.b.OVERLAY_WIDGET, null, null, n ) : t.fulfill( ut.b.UNKNOWN )
          }
          return null
        }, e._hitTestViewCursor = ( e, t ) => {
          if ( t.target )
            for ( var n = 0, i = ( r = e.lastViewCursorsRenderData ).length; n < i; n++ ) {
              var o = r[ n ];
              if ( t.target === o.domNode ) return t.fulfill( ut.b.CONTENT_TEXT, o.position )
            }
          if ( t.isInContentArea ) {
            var r = e.lastViewCursorsRenderData;
            const s = t.mouseContentHorizontalOffset;
            const a = t.mouseVerticalOffset;
            for ( n = 0, i = r.length; n < i; n++ ) {
              if ( !( s < ( o = r[ n ] ).contentLeft ) && !( s > o.contentLeft + o.width ) ) {
                const u = e.getVerticalOffsetForLineNumber( o.position.lineNumber );
                if ( u <= a && a <= u + o.height ) return t.fulfill( ut.b.CONTENT_TEXT, o.position )
              }
            }
          }
          return null
        }, e._hitTestViewZone = ( e, t ) => {
          const n = e.getZoneAtCoord( t.mouseVerticalOffset );
          if ( n ) {
            const i = t.isInContentArea ? ut.b.CONTENT_VIEW_ZONE : ut.b.GUTTER_VIEW_ZONE;
            return t.fulfill( i, n.position, null, n )
          }
          return null
        }, e._hitTestTextArea = ( e, t ) => {
          return Bt.isTextArea( t.targetPath ) ? t.fulfill( ut.b.TEXTAREA ) : null
        }, e._hitTestMargin = ( e, t ) => {
          if ( t.isInMarginArea ) {
            const n = e.getFullLineRangeAtCoord( t.mouseVerticalOffset );
            const i = n.range.getStartPosition();
            let o = Math.abs( t.pos.x - t.editorPos.x );
            const r = {
              isAfterLines: n.isAfterLines,
              glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
              glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
              lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
              offsetX: o
            };
            return ( o -= e.layoutInfo.glyphMarginLeft ) <= e.layoutInfo.glyphMarginWidth ? t.fulfill( ut.b.GUTTER_GLYPH_MARGIN, i, n.range, r ) : ( o -= e.layoutInfo.glyphMarginWidth ) <= e.layoutInfo.lineNumbersWidth ? t.fulfill( ut.b.GUTTER_LINE_NUMBERS, i, n.range, r ) : ( o -= e.layoutInfo.lineNumbersWidth, t.fulfill( ut.b.GUTTER_LINE_DECORATIONS, i, n.range, r ) )
          }
          return null
        }, e._hitTestViewLines = function ( t, n, i ) {
          if ( !Bt.isChildOfViewLines( n.targetPath ) ) return null;
          if ( t.isAfterLines( n.mouseVerticalOffset ) ) {
            const o = t.model.getLineCount(),
              r = t.model.getLineMaxColumn( o );
            return n.fulfill( ut.b.CONTENT_EMPTY, new g.a( o, r ), void 0, Ut )
          }
          if ( i ) {
            if ( Bt.isStrictChildOfViewLines( n.targetPath ) ) {
              const s = t.getLineNumberAtVerticalOffset( n.mouseVerticalOffset );
              if ( 0 === t.model.getLineLength( s ) ) {
                const a = t.getLineWidth( s ),
                  u = Kt( n.mouseContentHorizontalOffset - a );
                return n.fulfill( ut.b.CONTENT_EMPTY, new g.a( s, 1 ), void 0, u )
              }
            }
            return n.fulfill( ut.b.UNKNOWN )
          }
          const l = e._doHitTest( t, n );
          return l.position ? e.createMouseTargetFromHitTestPosition( t, n, l.position.lineNumber, l.position.column ) : this._createMouseTarget( t, n.withTarget( l.hitTarget ), !0 )
        }, e._hitTestMinimap = ( e, t ) => {
          if ( Bt.isChildOfMinimap( t.targetPath ) ) {
            const n = e.getLineNumberAtVerticalOffset( t.mouseVerticalOffset ),
              i = e.model.getLineMaxColumn( n );
            return t.fulfill( ut.b.SCROLLBAR, new g.a( n, i ) )
          }
          return null
        }, e._hitTestScrollbarSlider = ( e, t ) => {
          if ( Bt.isChildOfScrollableElement( t.targetPath ) && t.target && 1 === t.target.nodeType ) {
            const n = t.target.className;
            if ( n && /\b(slider|scrollbar)\b/.test( n ) ) {
              const i = e.getLineNumberAtVerticalOffset( t.mouseVerticalOffset ),
                o = e.model.getLineMaxColumn( i );
              return t.fulfill( ut.b.SCROLLBAR, new g.a( i, o ) )
            }
          }
          return null
        }, e._hitTestScrollbar = ( e, t ) => {
          if ( Bt.isChildOfScrollableElement( t.targetPath ) ) {
            const n = e.getLineNumberAtVerticalOffset( t.mouseVerticalOffset ),
              i = e.model.getLineMaxColumn( n );
            return t.fulfill( ut.b.SCROLLBAR, new g.a( n, i ) )
          }
          return null
        }, e.prototype.getMouseColumn = function ( t, n ) {
          const i = this._context.configuration.editor.layoutInfo,
            o = this._context.viewLayout.getCurrentScrollLeft() + n.x - t.x - i.contentLeft;
          return e._getMouseColumn( o, this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth )
        }, e._getMouseColumn = ( e, t ) => {
          return e < 0 ? 1 : Math.round( e / t ) + 1
        }, e.createMouseTargetFromHitTestPosition = ( e, t, n, i ) => {
          const o = new g.a( n, i ),
            r = e.getLineWidth( n );
          if ( t.mouseContentHorizontalOffset > r ) {
            if ( He.g && 1 === o.column ) {
              const s = Kt( t.mouseContentHorizontalOffset - r );
              return t.fulfill( ut.b.CONTENT_EMPTY, new g.a( n, e.model.getLineMaxColumn( n ) ), void 0, s )
            }
            const a = Kt( t.mouseContentHorizontalOffset - r );
            return t.fulfill( ut.b.CONTENT_EMPTY, o, void 0, a )
          }
          const u = e.visibleRangeForPosition2( n, i );
          if ( !u ) return t.fulfill( ut.b.UNKNOWN, o );
          const l = u.left;
          if ( t.mouseContentHorizontalOffset === l ) return t.fulfill( ut.b.CONTENT_TEXT, o );
          const c = [];
          if ( c.push( {
              offset: u.left,
              column: i
            } ), i > 1 ) {
            const d = e.visibleRangeForPosition2( n, i - 1 );
            d && c.push( {
              offset: d.left,
              column: i - 1
            } )
          }
          if ( i < e.model.getLineMaxColumn( n ) ) {
            const h = e.visibleRangeForPosition2( n, i + 1 );
            h && c.push( {
              offset: h.left,
              column: i + 1
            } )
          }
          c.sort( ( ( e, t ) => {
            return e.offset - t.offset
          } ) );
          for ( let p = 1; p < c.length; p++ ) {
            const f = c[ p - 1 ],
              _ = c[ p ];
            if ( f.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= _.offset ) {
              const v = new m.a( n, f.column, n, _.column );
              return t.fulfill( ut.b.CONTENT_TEXT, o, v )
            }
          }
          return t.fulfill( ut.b.CONTENT_TEXT, o )
        }, e._doHitTestWithCaretRangeFromPoint = function ( e, t ) {
          const n = e.getLineNumberAtVerticalOffset( t.mouseVerticalOffset );
          const i = e.getVerticalOffsetForLineNumber( n ) + Math.floor( e.lineHeight / 2 );
          let o = t.pos.y + ( i - t.mouseVerticalOffset );
          o <= t.editorPos.y && ( o = t.editorPos.y + 1 ), o >= t.editorPos.y + e.layoutInfo.height && ( o = t.editorPos.y + e.layoutInfo.height - 1 );
          const r = new ht( t.pos.x, o ),
            s = this._actualDoHitTestWithCaretRangeFromPoint( e, r.toClientCoordinates() );
          return s.position ? s : this._actualDoHitTestWithCaretRangeFromPoint( e, t.pos.toClientCoordinates() )
        }, e._actualDoHitTestWithCaretRangeFromPoint = ( e, t ) => {
          const n = document.caretRangeFromPoint( t.clientX, t.clientY );
          if ( !n || !n.startContainer ) return {
            position: null,
            hitTarget: null
          };
          let i;
          const o = n.startContainer;
          if ( o.nodeType === o.TEXT_NODE ) {
            const r = ( a = ( s = o.parentNode ) ? s.parentNode : null ) ? a.parentNode : null;
            if ( ( r && r.nodeType === r.ELEMENT_NODE ? r.className : null ) === Mt.CLASS_NAME ) return {
              position: e.getPositionFromDOMInfo( s, n.startOffset ),
              hitTarget: null
            };
            i = o.parentNode
          } else if ( o.nodeType === o.ELEMENT_NODE ) {
            var s, a;
            if ( ( ( a = ( s = o.parentNode ) ? s.parentNode : null ) && a.nodeType === a.ELEMENT_NODE ? a.className : null ) === Mt.CLASS_NAME ) return {
              position: e.getPositionFromDOMInfo( o, o.textContent.length ),
              hitTarget: null
            };
            i = o
          }
          return {
            position: null,
            hitTarget: i
          }
        }, e._doHitTestWithCaretPositionFromPoint = ( e, t ) => {
          const n = document.caretPositionFromPoint( t.clientX, t.clientY );
          if ( n.offsetNode.nodeType === n.offsetNode.TEXT_NODE ) {
            const i = n.offsetNode.parentNode,
              o = i ? i.parentNode : null,
              r = o ? o.parentNode : null;
            return ( r && r.nodeType === r.ELEMENT_NODE ? r.className : null ) === Mt.CLASS_NAME ? {
              position: e.getPositionFromDOMInfo( n.offsetNode.parentNode, n.offset ),
              hitTarget: null
            } : {
              position: null,
              hitTarget: n.offsetNode.parentNode
            }
          }
          return {
            position: null,
            hitTarget: n.offsetNode
          }
        }, e._doHitTestWithMoveToPoint = ( e, t ) => {
          let n = null;
          let i = null;
          const o = document.body.createTextRange();
          try {
            o.moveToPoint( t.clientX, t.clientY )
          } catch ( l ) {
            return {
              position: null,
              hitTarget: null
            }
          }
          o.collapse( !0 );
          const r = o ? o.parentElement() : null,
            s = r ? r.parentNode : null,
            a = s ? s.parentNode : null;
          if ( ( a && a.nodeType === a.ELEMENT_NODE ? a.className : "" ) === Mt.CLASS_NAME ) {
            const u = o.duplicate();
            u.moveToElementText( r ), u.setEndPoint( "EndToStart", o ), n = e.getPositionFromDOMInfo( r, u.text.length ), u.moveToElementText( e.viewDomNode )
          } else i = r;
          return o.moveToElementText( e.viewDomNode ), {
            position: n,
            hitTarget: i
          }
        }, e._doHitTest = function ( e, t ) {
          return document.caretRangeFromPoint ? this._doHitTestWithCaretRangeFromPoint( e, t ) : document.caretPositionFromPoint ? this._doHitTestWithCaretPositionFromPoint( e, t.pos.toClientCoordinates() ) : document.body.createTextRange ? this._doHitTestWithMoveToPoint( e, t.pos.toClientCoordinates() ) : {
            position: null,
            hitTarget: null
          }
        }, e;
      } )();

      const Gt = n( "X+cX" );
      const Yt = n( "Yr1X" );
      const Xt = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      function $t( e ) {
        return ( t, n ) => {
          let i = !1;
          return e && ( i = e.mouseTargetIsWidget( n ) ), i || n.preventDefault(), n
        };
      }
      const Zt = ( e => {
          function t( n, i, r ) {
            const s = e.call( this ) || this;
            s._isFocused = !1, s._context = n, s.viewController = i, s.viewHelper = r, s.mouseTargetFactory = new qt( s._context, r ), s._mouseDownOperation = s._register( new Qt( s._context, s.viewController, s.viewHelper, ( ( e, t ) => {
              return s._createMouseTarget( e, t )
            } ), ( e => {
              return s._getMouseColumn( e )
            } ) ) ), s._asyncFocus = s._register( new Gt.c( ( () => {
              return s.viewHelper.focusTextArea()
            } ), 0 ) ), s.lastMouseLeaveTime = -1;
            const a = new _t( s.viewHelper.viewDomNode );
            s._register( a.onContextMenu( s.viewHelper.viewDomNode, ( e => {
              return s._onContextMenu( e, !0 )
            } ) ) ), s._register( a.onMouseMoveThrottled( s.viewHelper.viewDomNode, ( e => {
              return s._onMouseMove( e )
            } ), $t( s.mouseTargetFactory ), t.MOUSE_MOVE_MINIMUM_TIME ) ), s._register( a.onMouseUp( s.viewHelper.viewDomNode, ( e => {
              return s._onMouseUp( e )
            } ) ) ), s._register( a.onMouseLeave( s.viewHelper.viewDomNode, ( e => {
              return s._onMouseLeave( e )
            } ) ) ), s._register( a.onMouseDown( s.viewHelper.viewDomNode, ( e => {
              return s._onMouseDown( e )
            } ) ) );
            const u = e => {
              if ( s._context.configuration.editor.viewInfo.mouseWheelZoom ) {
                const t = new lt.c( e );
                if ( t.browserEvent.ctrlKey || t.browserEvent.metaKey ) {
                  const n = Yt.a.getZoomLevel(),
                    i = t.deltaY > 0 ? 1 : -1;
                  Yt.a.setZoomLevel( n + i ), t.preventDefault(), t.stopPropagation()
                }
              }
            };
            return s._register( o.g( s.viewHelper.viewDomNode, "mousewheel", u, !0 ) ), s._register( o.g( s.viewHelper.viewDomNode, "DOMMouseScroll", u, !0 ) ), s._context.addEventHandler( s ), s
          }
          return Xt( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), e.prototype.dispose.call( this )
          }, t.prototype.onCursorStateChanged = function ( e ) {
            return this._mouseDownOperation.onCursorStateChanged( e ), !1
          }, t.prototype.onFocusChanged = function ( e ) {
            return this._isFocused = e.isFocused, !1
          }, t.prototype.onScrollChanged = function ( e ) {
            return this._mouseDownOperation.onScrollChanged(), !1
          }, t.prototype.getTargetAtClientPoint = function ( e, t ) {
            const n = new pt( e, t ).toPageCoordinates(),
              i = gt( this.viewHelper.viewDomNode );
            if ( n.y < i.y || n.y > i.y + i.height || n.x < i.x || n.x > i.x + i.width ) return null;
            const o = this.viewHelper.getLastViewCursorsRenderData();
            return this.mouseTargetFactory.createMouseTarget( o, i, n, null )
          }, t.prototype._createMouseTarget = function ( e, t ) {
            const n = this.viewHelper.getLastViewCursorsRenderData();
            return this.mouseTargetFactory.createMouseTarget( n, e.editorPos, e.pos, t ? e.target : null )
          }, t.prototype._getMouseColumn = function ( e ) {
            return this.mouseTargetFactory.getMouseColumn( e.editorPos, e.pos )
          }, t.prototype._onContextMenu = function ( e, t ) {
            this.viewController.emitContextMenu( {
              event: e,
              target: this._createMouseTarget( e, t )
            } )
          }, t.prototype._onMouseMove = function ( e ) {
            this._mouseDownOperation.isActive() || ( e.timestamp < this.lastMouseLeaveTime || this.viewController.emitMouseMove( {
              event: e,
              target: this._createMouseTarget( e, !0 )
            } ) )
          }, t.prototype._onMouseLeave = function ( e ) {
            this.lastMouseLeaveTime = ( new Date ).getTime(), this.viewController.emitMouseLeave( {
              event: e,
              target: null
            } )
          }, t.prototype._onMouseUp = function ( e ) {
            this.viewController.emitMouseUp( {
              event: e,
              target: this._createMouseTarget( e, !0 )
            } )
          }, t.prototype._onMouseDown = function ( e ) {
            const t = this;
            const n = this._createMouseTarget( e, !0 );
            const i = n.type === ut.b.CONTENT_TEXT || n.type === ut.b.CONTENT_EMPTY;
            const o = n.type === ut.b.GUTTER_GLYPH_MARGIN || n.type === ut.b.GUTTER_LINE_NUMBERS || n.type === ut.b.GUTTER_LINE_DECORATIONS;
            const r = n.type === ut.b.GUTTER_LINE_NUMBERS;
            const s = this._context.configuration.editor.viewInfo.selectOnLineNumbers;
            const a = n.type === ut.b.CONTENT_VIEW_ZONE || n.type === ut.b.GUTTER_VIEW_ZONE;
            const u = n.type === ut.b.CONTENT_WIDGET;
            let l = e.leftButton || e.middleButton;
            Be.d && e.leftButton && e.ctrlKey && ( l = !1 );
            const c = () => {
              He.k && !t._isFocused ? t._asyncFocus.schedule() : ( e.preventDefault(), t.viewHelper.focusTextArea() )
            };
            if ( l && ( i || r && s ) ) c(), this._mouseDownOperation.start( n.type, e );
            else if ( o ) e.preventDefault();
            else if ( a ) {
              const d = n.detail;
              this.viewHelper.shouldSuppressMouseDownOnViewZone( d.viewZoneId ) && ( c(), this._mouseDownOperation.start( n.type, e ), e.preventDefault() )
            } else u && this.viewHelper.shouldSuppressMouseDownOnWidget( n.detail ) && ( c(), e.preventDefault() );
            this.viewController.emitMouseDown( {
              event: e,
              target: n
            } )
          }, t.MOUSE_MOVE_MINIMUM_TIME = 100, t;
        } )( Ve ),
        Qt = ( e => {
          function t( t, n, i, o, r ) {
            const s = e.call( this ) || this;
            return s._context = t, s._viewController = n, s._viewHelper = i, s._createMouseTarget = o, s._getMouseColumn = r, s._mouseMoveMonitor = s._register( new vt( s._viewHelper.viewDomNode ) ), s._onScrollTimeout = s._register( new Gt.f ), s._mouseState = new Jt, s._currentSelection = new _.a( 1, 1, 1, 1 ), s._isActive = !1, s._lastMouseEvent = null, s
          }
          return Xt( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype.isActive = function () {
            return this._isActive
          }, t.prototype._onMouseDownThenMove = function ( e ) {
            this._lastMouseEvent = e, this._mouseState.setModifiers( e );
            const t = this._findMousePosition( e, !0 );
            t && ( this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag( {
              event: e,
              target: t
            } ) : this._dispatchMouse( t, !0 ) )
          }, t.prototype.start = function ( e, t ) {
            const n = this;
            this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers( e === ut.b.GUTTER_LINE_NUMBERS ), this._mouseState.setStartButtons( t ), this._mouseState.setModifiers( t );
            const i = this._findMousePosition( t, !0 );
            if ( i ) {
              if ( this._mouseState.trySetCount( t.detail, i.position ), t.detail = this._mouseState.count, !this._context.configuration.editor.readOnly && this._context.configuration.editor.dragAndDrop && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && this._currentSelection.containsPosition( i.position ) ) return this._mouseState.isDragAndDrop = !0, this._isActive = !0, void this._mouseMoveMonitor.startMonitoring( $t( null ), ( e => {
                return n._onMouseDownThenMove( e )
              } ), ( () => {
                const e = n._findMousePosition( n._lastMouseEvent, !0 );
                n._viewController.emitMouseDrop( {
                  event: n._lastMouseEvent,
                  target: e ? n._createMouseTarget( n._lastMouseEvent, !0 ) : null
                } ), n._stop()
              } ) );
              this._mouseState.isDragAndDrop = !1, this._dispatchMouse( i, t.shiftKey ), this._isActive || ( this._isActive = !0, this._mouseMoveMonitor.startMonitoring( $t( null ), ( e => {
                return n._onMouseDownThenMove( e )
              } ), ( () => {
                return n._stop()
              } ) ) )
            }
          }, t.prototype._stop = function () {
            this._isActive = !1, this._onScrollTimeout.cancel()
          }, t.prototype.onScrollChanged = function () {
            const e = this;
            this._isActive && this._onScrollTimeout.setIfNotSet( ( () => {
              const t = e._findMousePosition( e._lastMouseEvent, !1 );
              t && ( e._mouseState.isDragAndDrop || e._dispatchMouse( t, !0 ) )
            } ), 10 )
          }, t.prototype.onCursorStateChanged = function ( e ) {
            this._currentSelection = e.selections[ 0 ]
          }, t.prototype._getPositionOutsideEditor = function ( e ) {
            const t = e.editorPos,
              n = this._context.model,
              i = this._context.viewLayout,
              o = this._getMouseColumn( e );
            if ( e.posy < t.y ) {
              var r = Math.max( i.getCurrentScrollTop() - ( t.y - e.posy ), 0 );
              if ( a = Ht.getZoneAtCoord( this._context, r ) )
                if ( u = this._helpPositionJumpOverViewZone( a ) ) return new Vt( null, ut.b.OUTSIDE_EDITOR, o, u );
              const s = i.getLineNumberAtVerticalOffset( r );
              return new Vt( null, ut.b.OUTSIDE_EDITOR, o, new g.a( s, 1 ) )
            }
            if ( e.posy > t.y + t.height ) {
              var a, u;
              r = i.getCurrentScrollTop() + ( e.posy - t.y );
              if ( a = Ht.getZoneAtCoord( this._context, r ) )
                if ( u = this._helpPositionJumpOverViewZone( a ) ) return new Vt( null, ut.b.OUTSIDE_EDITOR, o, u );
              const l = i.getLineNumberAtVerticalOffset( r );
              return new Vt( null, ut.b.OUTSIDE_EDITOR, o, new g.a( l, n.getLineMaxColumn( l ) ) )
            }
            const c = i.getLineNumberAtVerticalOffset( i.getCurrentScrollTop() + ( e.posy - t.y ) );
            return e.posx < t.x ? new Vt( null, ut.b.OUTSIDE_EDITOR, o, new g.a( c, 1 ) ) : e.posx > t.x + t.width ? new Vt( null, ut.b.OUTSIDE_EDITOR, o, new g.a( c, n.getLineMaxColumn( c ) ) ) : null
          }, t.prototype._findMousePosition = function ( e, t ) {
            const n = this._getPositionOutsideEditor( e );
            if ( n ) return n;
            const i = this._createMouseTarget( e, t );
            if ( !i.position ) return null;
            if ( i.type === ut.b.CONTENT_VIEW_ZONE || i.type === ut.b.GUTTER_VIEW_ZONE ) {
              const o = this._helpPositionJumpOverViewZone( i.detail );
              if ( o ) return new Vt( i.element, i.type, i.mouseColumn, o, null, i.detail )
            }
            return i
          }, t.prototype._helpPositionJumpOverViewZone = function ( e ) {
            const t = new g.a( this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn ),
              n = e.positionBefore,
              i = e.positionAfter;
            return n && i ? n.isBefore( t ) ? n : i : null
          }, t.prototype._dispatchMouse = function ( e, t ) {
            this._viewController.dispatchMouse( {
              position: e.position,
              mouseColumn: e.mouseColumn,
              startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
              inSelectionMode: t,
              mouseDownCount: this._mouseState.count,
              altKey: this._mouseState.altKey,
              ctrlKey: this._mouseState.ctrlKey,
              metaKey: this._mouseState.metaKey,
              shiftKey: this._mouseState.shiftKey,
              leftButton: this._mouseState.leftButton,
              middleButton: this._mouseState.middleButton
            } )
          }, t;
        } )( a.a ),
        Jt = ( () => {
          function e() {
            this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._leftButton = !1, this._middleButton = !1, this._startedOnLineNumbers = !1, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = !1
          }
          return Object.defineProperty( e.prototype, "altKey", {
            get() {
              return this._altKey
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "ctrlKey", {
            get() {
              return this._ctrlKey
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "metaKey", {
            get() {
              return this._metaKey
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "shiftKey", {
            get() {
              return this._shiftKey
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "leftButton", {
            get() {
              return this._leftButton
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "middleButton", {
            get() {
              return this._middleButton
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "startedOnLineNumbers", {
            get() {
              return this._startedOnLineNumbers
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "count", {
            get() {
              return this._lastMouseDownCount
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.setModifiers = function ( e ) {
            this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey
          }, e.prototype.setStartButtons = function ( e ) {
            this._leftButton = e.leftButton, this._middleButton = e.middleButton
          }, e.prototype.setStartedOnLineNumbers = function ( e ) {
            this._startedOnLineNumbers = e
          }, e.prototype.trySetCount = function ( t, n ) {
            const i = ( new Date ).getTime();
            i - this._lastSetMouseDownCountTime > e.CLEAR_MOUSE_DOWN_COUNT_TIME && ( t = 1 ), this._lastSetMouseDownCountTime = i, t > this._lastMouseDownCount + 1 && ( t = this._lastMouseDownCount + 1 ), this._lastMouseDownPosition && this._lastMouseDownPosition.equals( n ) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = n, this._lastMouseDownCount = Math.min( t, this._lastMouseDownPositionEqualCount )
          }, e.CLEAR_MOUSE_DOWN_COUNT_TIME = 400, e;
        } )(),
        en = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )();

      function tn( e, t ) {
        const n = {
          translationY: t.translationY,
          translationX: t.translationX
        };
        return e && ( n.translationY += e.translationY, n.translationX += e.translationX ), n
      }
      const nn = ( e => {
          function t( t, n, i ) {
            const r = e.call( this, t, n, i ) || this;
            return r.viewHelper.linesContentDomNode.style.msTouchAction = "none", r.viewHelper.linesContentDomNode.style.msContentZooming = "none", r._installGestureHandlerTimeout = window.setTimeout( ( () => {
              if ( r._installGestureHandlerTimeout = -1, window.MSGesture ) {
                const e = new MSGesture,
                  t = new MSGesture;
                e.target = r.viewHelper.linesContentDomNode, t.target = r.viewHelper.linesContentDomNode, r.viewHelper.linesContentDomNode.addEventListener( "MSPointerDown", ( n => {
                  const i = n.pointerType;
                  i !== ( n.MSPOINTER_TYPE_MOUSE || "mouse" ) ? i === ( n.MSPOINTER_TYPE_TOUCH || "touch" ) ? ( r._lastPointerType = "touch", e.addPointer( n.pointerId ) ) : ( r._lastPointerType = "pen", t.addPointer( n.pointerId ) ) : r._lastPointerType = "mouse"
                } ) ), r._register( o.i( r.viewHelper.linesContentDomNode, "MSGestureChange", ( e => {
                  return r._onGestureChange( e )
                } ), tn ) ), r._register( o.g( r.viewHelper.linesContentDomNode, "MSGestureTap", ( e => {
                  return r._onCaptureGestureTap( e )
                } ), !0 ) )
              }
            } ), 100 ), r._lastPointerType = "mouse", r;
          }
          return en( t, e ), t.prototype._onMouseDown = function ( t ) {
            "mouse" === this._lastPointerType && e.prototype._onMouseDown.call( this, t )
          }, t.prototype._onCaptureGestureTap = function ( e ) {
            const t = this,
              n = new mt( e, this.viewHelper.viewDomNode ),
              i = this._createMouseTarget( n, !1 );
            i.position && this.viewController.moveTo( i.position ), n.browserEvent.fromElement ? ( n.preventDefault(), this.viewHelper.focusTextArea() ) : setTimeout( ( () => {
              t.viewHelper.focusTextArea()
            } ) )
          }, t.prototype._onGestureChange = function ( e ) {
            this._context.viewLayout.deltaScrollNow( -e.translationX, -e.translationY )
          }, t.prototype.dispose = function () {
            window.clearTimeout( this._installGestureHandlerTimeout ), e.prototype.dispose.call( this )
          }, t;
        } )( Zt ),
        on = ( e => {
          function t( t, n, i ) {
            const r = e.call( this, t, n, i ) || this;
            return r.viewHelper.linesContentDomNode.style.touchAction = "none", r._installGestureHandlerTimeout = window.setTimeout( ( () => {
              if ( r._installGestureHandlerTimeout = -1, window.MSGesture ) {
                const e = new MSGesture,
                  t = new MSGesture;
                e.target = r.viewHelper.linesContentDomNode, t.target = r.viewHelper.linesContentDomNode, r.viewHelper.linesContentDomNode.addEventListener( "pointerdown", ( n => {
                  const i = n.pointerType;
                  "mouse" !== i ? "touch" === i ? ( r._lastPointerType = "touch", e.addPointer( n.pointerId ) ) : ( r._lastPointerType = "pen", t.addPointer( n.pointerId ) ) : r._lastPointerType = "mouse"
                } ) ), r._register( o.i( r.viewHelper.linesContentDomNode, "MSGestureChange", ( e => {
                  return r._onGestureChange( e )
                } ), tn ) ), r._register( o.g( r.viewHelper.linesContentDomNode, "MSGestureTap", ( e => {
                  return r._onCaptureGestureTap( e )
                } ), !0 ) )
              }
            } ), 100 ), r._lastPointerType = "mouse", r;
          }
          return en( t, e ), t.prototype._onMouseDown = function ( t ) {
            "mouse" === this._lastPointerType && e.prototype._onMouseDown.call( this, t )
          }, t.prototype._onCaptureGestureTap = function ( e ) {
            const t = this,
              n = new mt( e, this.viewHelper.viewDomNode ),
              i = this._createMouseTarget( n, !1 );
            i.position && this.viewController.moveTo( i.position ), n.browserEvent.fromElement ? ( n.preventDefault(), this.viewHelper.focusTextArea() ) : setTimeout( ( () => {
              t.viewHelper.focusTextArea()
            } ) )
          }, t.prototype._onGestureChange = function ( e ) {
            this._context.viewLayout.deltaScrollNow( -e.translationX, -e.translationY )
          }, t.prototype.dispose = function () {
            window.clearTimeout( this._installGestureHandlerTimeout ), e.prototype.dispose.call( this )
          }, t;
        } )( Zt ),
        rn = ( e => {
          function t( t, n, i ) {
            const r = e.call( this, t, n, i ) || this;
            return at.b.addTarget( r.viewHelper.linesContentDomNode ), r._register( o.g( r.viewHelper.linesContentDomNode, at.a.Tap, ( e => {
              return r.onTap( e )
            } ) ) ), r._register( o.g( r.viewHelper.linesContentDomNode, at.a.Change, ( e => {
              return r.onChange( e )
            } ) ) ), r._register( o.g( r.viewHelper.linesContentDomNode, at.a.Contextmenu, ( e => {
              return r._onContextMenu( new mt( e, r.viewHelper.viewDomNode ), !1 )
            } ) ) ), r;
          }
          return en( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype.onTap = function ( e ) {
            e.preventDefault(), this.viewHelper.focusTextArea();
            const t = this._createMouseTarget( new mt( e, this.viewHelper.viewDomNode ), !1 );
            t.position && this.viewController.moveTo( t.position )
          }, t.prototype.onChange = function ( e ) {
            this._context.viewLayout.deltaScrollNow( -e.translationX, -e.translationY )
          }, t;
        } )( Zt ),
        sn = ( () => {
          function e( e, t, n ) {
            window.navigator.msPointerEnabled ? this.handler = new nn( e, t, n ) : window.TouchEvent ? this.handler = new rn( e, t, n ) : window.navigator.pointerEnabled || window.PointerEvent ? this.handler = new on( e, t, n ) : this.handler = new Zt( e, t, n )
          }
          return e.prototype.getTargetAtClientPoint = function ( e, t ) {
            return this.handler.getTargetAtClientPoint( e, t )
          }, e.prototype.dispose = function () {
            this.handler.dispose()
          }, e
        } )(),
        an = n( "1YUG" ),
        un = ( () => {
          function e( e, t, n, i, o ) {
            this.configuration = e, this.viewModel = t, this._execCoreEditorCommandFunc = n, this.outgoingEvents = i, this.commandDelegate = o
          }
          return e.prototype._execMouseCommand = function ( e, t ) {
            t.source = "mouse", this._execCoreEditorCommandFunc( e, t )
          }, e.prototype.paste = function ( e, t, n, i ) {
            this.commandDelegate.paste( e, t, n, i )
          }, e.prototype.type = function ( e, t ) {
            this.commandDelegate.type( e, t )
          }, e.prototype.replacePreviousChar = function ( e, t, n ) {
            this.commandDelegate.replacePreviousChar( e, t, n )
          }, e.prototype.compositionStart = function ( e ) {
            this.commandDelegate.compositionStart( e )
          }, e.prototype.compositionEnd = function ( e ) {
            this.commandDelegate.compositionEnd( e )
          }, e.prototype.cut = function ( e ) {
            this.commandDelegate.cut( e )
          }, e.prototype.setSelection = function ( e, t ) {
            this._execCoreEditorCommandFunc( an.CoreNavigationCommands.SetSelection, {
              source: e,
              selection: t
            } )
          }, e.prototype._validateViewColumn = function ( e ) {
            const t = this.viewModel.getLineMinColumn( e.lineNumber );
            return e.column < t ? new g.a( e.lineNumber, t ) : e
          }, e.prototype._hasMulticursorModifier = function ( e ) {
            switch ( this.configuration.editor.multiCursorModifier ) {
              case "altKey":
                return e.altKey;
              case "ctrlKey":
                return e.ctrlKey;
              case "metaKey":
                return e.metaKey
            }
            return !1
          }, e.prototype._hasNonMulticursorModifier = function ( e ) {
            switch ( this.configuration.editor.multiCursorModifier ) {
              case "altKey":
                return e.ctrlKey || e.metaKey;
              case "ctrlKey":
                return e.altKey || e.metaKey;
              case "metaKey":
                return e.ctrlKey || e.altKey
            }
            return !1
          }, e.prototype.dispatchMouse = function ( e ) {
            e.middleButton ? e.inSelectionMode ? this.columnSelect( e.position, e.mouseColumn ) : this.moveTo( e.position ) : e.startedOnLineNumbers ? this._hasMulticursorModifier( e ) ? e.inSelectionMode ? this.lastCursorLineSelect( e.position ) : this.createCursor( e.position, !0 ) : e.inSelectionMode ? this.lineSelectDrag( e.position ) : this.lineSelect( e.position ) : e.mouseDownCount >= 4 ? this.selectAll() : 3 === e.mouseDownCount ? this._hasMulticursorModifier( e ) ? e.inSelectionMode ? this.lastCursorLineSelectDrag( e.position ) : this.lastCursorLineSelect( e.position ) : e.inSelectionMode ? this.lineSelectDrag( e.position ) : this.lineSelect( e.position ) : 2 === e.mouseDownCount ? this._hasMulticursorModifier( e ) ? this.lastCursorWordSelect( e.position ) : e.inSelectionMode ? this.wordSelectDrag( e.position ) : this.wordSelect( e.position ) : this._hasMulticursorModifier( e ) ? this._hasNonMulticursorModifier( e ) || ( e.shiftKey ? this.columnSelect( e.position, e.mouseColumn ) : e.inSelectionMode ? this.lastCursorMoveToSelect( e.position ) : this.createCursor( e.position, !1 ) ) : e.inSelectionMode ? this.moveToSelect( e.position ) : this.moveTo( e.position )
          }, e.prototype._usualArgs = function ( e ) {
            return e = this._validateViewColumn( e ), {
              position: this.convertViewToModelPosition( e ),
              viewPosition: e
            }
          }, e.prototype.moveTo = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.MoveTo, this._usualArgs( e ) )
          }, e.prototype.moveToSelect = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.MoveToSelect, this._usualArgs( e ) )
          }, e.prototype.columnSelect = function ( e, t ) {
            e = this._validateViewColumn( e ), this._execMouseCommand( an.CoreNavigationCommands.ColumnSelect, {
              position: this.convertViewToModelPosition( e ),
              viewPosition: e,
              mouseColumn: t
            } )
          }, e.prototype.createCursor = function ( e, t ) {
            e = this._validateViewColumn( e ), this._execMouseCommand( an.CoreNavigationCommands.CreateCursor, {
              position: this.convertViewToModelPosition( e ),
              viewPosition: e,
              wholeLine: t
            } )
          }, e.prototype.lastCursorMoveToSelect = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.LastCursorMoveToSelect, this._usualArgs( e ) )
          }, e.prototype.wordSelect = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.WordSelect, this._usualArgs( e ) )
          }, e.prototype.wordSelectDrag = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.WordSelectDrag, this._usualArgs( e ) )
          }, e.prototype.lastCursorWordSelect = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.LastCursorWordSelect, this._usualArgs( e ) )
          }, e.prototype.lineSelect = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.LineSelect, this._usualArgs( e ) )
          }, e.prototype.lineSelectDrag = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.LineSelectDrag, this._usualArgs( e ) )
          }, e.prototype.lastCursorLineSelect = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.LastCursorLineSelect, this._usualArgs( e ) )
          }, e.prototype.lastCursorLineSelectDrag = function ( e ) {
            this._execMouseCommand( an.CoreNavigationCommands.LastCursorLineSelectDrag, this._usualArgs( e ) )
          }, e.prototype.selectAll = function () {
            this._execMouseCommand( an.CoreNavigationCommands.SelectAll, {} )
          }, e.prototype.convertViewToModelPosition = function ( e ) {
            return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition( e )
          }, e.prototype.emitKeyDown = function ( e ) {
            this.outgoingEvents.emitKeyDown( e )
          }, e.prototype.emitKeyUp = function ( e ) {
            this.outgoingEvents.emitKeyUp( e )
          }, e.prototype.emitContextMenu = function ( e ) {
            this.outgoingEvents.emitContextMenu( e )
          }, e.prototype.emitMouseMove = function ( e ) {
            this.outgoingEvents.emitMouseMove( e )
          }, e.prototype.emitMouseLeave = function ( e ) {
            this.outgoingEvents.emitMouseLeave( e )
          }, e.prototype.emitMouseUp = function ( e ) {
            this.outgoingEvents.emitMouseUp( e )
          }, e.prototype.emitMouseDown = function ( e ) {
            this.outgoingEvents.emitMouseDown( e )
          }, e.prototype.emitMouseDrag = function ( e ) {
            this.outgoingEvents.emitMouseDrag( e )
          }, e.prototype.emitMouseDrop = function ( e ) {
            this.outgoingEvents.emitMouseDrop( e )
          }, e;
        } )(),
        ln = ( () => {
          function e( e ) {
            this._eventHandlerGateKeeper = e, this._eventHandlers = [], this._eventQueue = null, this._isConsumingQueue = !1
          }
          return e.prototype.addEventHandler = function ( e ) {
            for ( let t = 0, n = this._eventHandlers.length; t < n; t++ ) this._eventHandlers[ t ] === e && console.warn( "Detected duplicate listener in ViewEventDispatcher", e );
            this._eventHandlers.push( e )
          }, e.prototype.removeEventHandler = function ( e ) {
            for ( let t = 0; t < this._eventHandlers.length; t++ )
              if ( this._eventHandlers[ t ] === e ) {
                this._eventHandlers.splice( t, 1 );
                break
              }
          }, e.prototype.emit = function ( e ) {
            this._eventQueue ? this._eventQueue.push( e ) : this._eventQueue = [ e ], this._isConsumingQueue || this.consumeQueue()
          }, e.prototype.emitMany = function ( e ) {
            this._eventQueue ? this._eventQueue = this._eventQueue.concat( e ) : this._eventQueue = e, this._isConsumingQueue || this.consumeQueue()
          }, e.prototype.consumeQueue = function () {
            const e = this;
            this._eventHandlerGateKeeper( ( () => {
              try {
                e._isConsumingQueue = !0, e._doConsumeQueue()
              } finally {
                e._isConsumingQueue = !1
              }
            } ) )
          }, e.prototype._doConsumeQueue = function () {
            for ( ; this._eventQueue; ) {
              const e = this._eventQueue;
              this._eventQueue = null;
              for ( let t = this._eventHandlers.slice( 0 ), n = 0, i = t.length; n < i; n++ ) t[ n ].handleEvents( e )
            }
          }, e;
        } )(),
        cn = n( "erNZ" ),
        dn = ( () => {
          function e( e ) {
            this._createLine = e, this._set( 1, [] )
          }
          return e.prototype.flush = function () {
            this._set( 1, [] )
          }, e.prototype._set = function ( e, t ) {
            this._lines = t, this._rendLineNumberStart = e
          }, e.prototype._get = function () {
            return {
              rendLineNumberStart: this._rendLineNumberStart,
              lines: this._lines
            }
          }, e.prototype.getStartLineNumber = function () {
            return this._rendLineNumberStart
          }, e.prototype.getEndLineNumber = function () {
            return this._rendLineNumberStart + this._lines.length - 1
          }, e.prototype.getCount = function () {
            return this._lines.length
          }, e.prototype.getLine = function ( e ) {
            const t = e - this._rendLineNumberStart;
            if ( t < 0 || t >= this._lines.length ) throw new Error( "Illegal value for lineNumber" );
            return this._lines[ t ]
          }, e.prototype.onLinesDeleted = function ( e, t ) {
            if ( 0 === this.getCount() ) return null;
            const n = this.getStartLineNumber(),
              i = this.getEndLineNumber();
            if ( t < n ) {
              const o = t - e + 1;
              return this._rendLineNumberStart -= o, null
            }
            if ( e > i ) return null;
            for ( var r = 0, s = 0, a = n; a <= i; a++ ) {
              const u = a - this._rendLineNumberStart;
              e <= a && a <= t && ( 0 === s ? ( r = u, s = 1 ) : s++ )
            }
            if ( e < n ) {
              let l = 0;
              l = t < n ? t - e + 1 : n - e, this._rendLineNumberStart -= l
            }
            return this._lines.splice( r, s )
          }, e.prototype.onLinesChanged = function ( e, t ) {
            if ( 0 === this.getCount() ) return !1;
            for ( var n = this.getStartLineNumber(), i = this.getEndLineNumber(), o = !1, r = e; r <= t; r++ ) r >= n && r <= i && ( this._lines[ r - this._rendLineNumberStart ].onContentChanged(), o = !0 );
            return o
          }, e.prototype.onLinesInserted = function ( e, t ) {
            if ( 0 === this.getCount() ) return null;
            const n = t - e + 1,
              i = this.getStartLineNumber(),
              o = this.getEndLineNumber();
            if ( e <= i ) return this._rendLineNumberStart += n, null;
            if ( e > o ) return null;
            if ( n + e > o ) return this._lines.splice( e - this._rendLineNumberStart, o - e + 1 );
            for ( var r = [], s = 0; s < n; s++ ) r[ s ] = this._createLine();
            const a = e - this._rendLineNumberStart,
              u = this._lines.slice( 0, a ),
              l = this._lines.slice( a, this._lines.length - n ),
              c = this._lines.slice( this._lines.length - n, this._lines.length );
            return this._lines = u.concat( r ).concat( l ), c
          }, e.prototype.onTokensChanged = function ( e ) {
            if ( 0 === this.getCount() ) return !1;
            for ( var t = this.getStartLineNumber(), n = this.getEndLineNumber(), i = !1, o = 0, r = e.length; o < r; o++ ) {
              const s = e[ o ];
              if ( !( s.toLineNumber < t || s.fromLineNumber > n ) )
                for ( let a = Math.max( t, s.fromLineNumber ), u = Math.min( n, s.toLineNumber ), l = a; l <= u; l++ ) {
                  const c = l - this._rendLineNumberStart;
                  this._lines[ c ].onTokensChanged(), i = !0
                }
            }
            return i
          }, e;
        } )(),
        hn = ( () => {
          function e( e ) {
            const t = this;
            this._host = e, this.domNode = this._createDomNode(), this._linesCollection = new dn( ( () => {
              return t._host.createVisibleLine()
            } ) )
          }
          return e.prototype._createDomNode = () => {
            const e = Object( We.b )( document.createElement( "div" ) );
            return e.setClassName( "view-layer" ), e.setPosition( "absolute" ), e.domNode.setAttribute( "role", "presentation" ), e.domNode.setAttribute( "aria-hidden", "true" ), e
          }, e.prototype.onConfigurationChanged = e => {
            return e.layoutInfo
          }, e.prototype.onFlushed = function ( e ) {
            return this._linesCollection.flush(), !0
          }, e.prototype.onLinesChanged = function ( e ) {
            return this._linesCollection.onLinesChanged( e.fromLineNumber, e.toLineNumber )
          }, e.prototype.onLinesDeleted = function ( e ) {
            const t = this._linesCollection.onLinesDeleted( e.fromLineNumber, e.toLineNumber );
            if ( t )
              for ( let n = 0, i = t.length; n < i; n++ ) {
                const o = t[ n ].getDomNode();
                o && this.domNode.domNode.removeChild( o )
              }
            return !0
          }, e.prototype.onLinesInserted = function ( e ) {
            const t = this._linesCollection.onLinesInserted( e.fromLineNumber, e.toLineNumber );
            if ( t )
              for ( let n = 0, i = t.length; n < i; n++ ) {
                const o = t[ n ].getDomNode();
                o && this.domNode.domNode.removeChild( o )
              }
            return !0
          }, e.prototype.onScrollChanged = e => {
            return e.scrollTopChanged
          }, e.prototype.onTokensChanged = function ( e ) {
            return this._linesCollection.onTokensChanged( e.ranges )
          }, e.prototype.onZonesChanged = e => {
            return !0
          }, e.prototype.getStartLineNumber = function () {
            return this._linesCollection.getStartLineNumber()
          }, e.prototype.getEndLineNumber = function () {
            return this._linesCollection.getEndLineNumber()
          }, e.prototype.getVisibleLine = function ( e ) {
            return this._linesCollection.getLine( e )
          }, e.prototype.renderLines = function ( e ) {
            const t = this._linesCollection._get(),
              n = new pn( this.domNode.domNode, this._host, e ),
              i = {
                rendLineNumberStart: t.rendLineNumberStart,
                lines: t.lines,
                linesLength: t.lines.length
              },
              o = n.render( i, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset );
            this._linesCollection._set( o.rendLineNumberStart, o.lines )
          }, e;
        } )(),
        pn = ( () => {
          function e( e, t, n ) {
            this.domNode = e, this.host = t, this.viewportData = n
          }
          return e.prototype.render = function ( e, t, n, i ) {
            const o = {
              rendLineNumberStart: e.rendLineNumberStart,
              lines: e.lines.slice( 0 ),
              linesLength: e.linesLength
            };
            if ( o.rendLineNumberStart + o.linesLength - 1 < t || n < o.rendLineNumberStart ) {
              o.rendLineNumberStart = t, o.linesLength = n - t + 1, o.lines = [];
              for ( let r = t; r <= n; r++ ) o.lines[ r - t ] = this.host.createVisibleLine();
              return this._finishRendering( o, !0, i ), o
            }
            if ( this._renderUntouchedLines( o, Math.max( t - o.rendLineNumberStart, 0 ), Math.min( n - o.rendLineNumberStart, o.linesLength - 1 ), i, t ), o.rendLineNumberStart > t )( u = t ) <= ( s = Math.min( n, o.rendLineNumberStart - 1 ) ) && ( this._insertLinesBefore( o, u, s, i, t ), o.linesLength += s - u + 1 );
            else if ( o.rendLineNumberStart < t ) {
              ( a = Math.min( o.linesLength, t - o.rendLineNumberStart ) ) > 0 && ( this._removeLinesBefore( o, a ), o.linesLength -= a )
            }
            if ( o.rendLineNumberStart = t, o.rendLineNumberStart + o.linesLength - 1 < n )( u = o.rendLineNumberStart + o.linesLength ) <= ( s = n ) && ( this._insertLinesAfter( o, u, s, i, t ), o.linesLength += s - u + 1 );
            else if ( o.rendLineNumberStart + o.linesLength - 1 > n ) {
              var s, a, u = Math.max( 0, n - o.rendLineNumberStart + 1 );
              ( a = ( s = o.linesLength - 1 ) - u + 1 ) > 0 && ( this._removeLinesAfter( o, a ), o.linesLength -= a )
            }
            return this._finishRendering( o, !1, i ), o
          }, e.prototype._renderUntouchedLines = ( e, t, n, i, o ) => {
            for ( let r = e.rendLineNumberStart, s = e.lines, a = t; a <= n; a++ ) {
              const u = r + a;
              s[ a ].layoutLine( u, i[ u - o ] )
            }
          }, e.prototype._insertLinesBefore = function ( e, t, n, i, o ) {
            for ( var r = [], s = 0, a = t; a <= n; a++ ) r[ s++ ] = this.host.createVisibleLine();
            e.lines = r.concat( e.lines )
          }, e.prototype._removeLinesBefore = function ( e, t ) {
            for ( let n = 0; n < t; n++ ) {
              const i = e.lines[ n ].getDomNode();
              i && this.domNode.removeChild( i )
            }
            e.lines.splice( 0, t )
          }, e.prototype._insertLinesAfter = function ( e, t, n, i, o ) {
            for ( var r = [], s = 0, a = t; a <= n; a++ ) r[ s++ ] = this.host.createVisibleLine();
            e.lines = e.lines.concat( r )
          }, e.prototype._removeLinesAfter = function ( e, t ) {
            for ( var n = e.linesLength - t, i = 0; i < t; i++ ) {
              const o = e.lines[ n + i ].getDomNode();
              o && this.domNode.removeChild( o )
            }
            e.lines.splice( n, t )
          }, e.prototype._finishRenderingNewLines = function ( e, t, n, i ) {
            const o = this.domNode.lastChild;
            t || !o ? this.domNode.innerHTML = n : o.insertAdjacentHTML( "afterend", n );
            for ( let r = this.domNode.lastChild, s = e.linesLength - 1; s >= 0; s-- ) {
              const a = e.lines[ s ];
              i[ s ] && ( a.setDomNode( r ), r = r.previousSibling )
            }
          }, e.prototype._finishRenderingInvalidLines = ( e, t, n ) => {
            const i = document.createElement( "div" );
            i.innerHTML = t;
            for ( let o = 0; o < e.linesLength; o++ ) {
              const r = e.lines[ o ];
              if ( n[ o ] ) {
                const s = i.firstChild,
                  a = r.getDomNode();
                a.parentNode.replaceChild( s, a ), r.setDomNode( s )
              }
            }
          }, e.prototype._finishRendering = function ( t, n, i ) {
            const o = e._sb,
              r = t.linesLength,
              s = t.lines,
              a = t.rendLineNumberStart,
              u = [];
            o.reset();
            for ( var l = !1, c = 0; c < r; c++ ) {
              var d = s[ c ];
              if ( u[ c ] = !1, !d.getDomNode() ) d.renderLine( c + a, i[ c ], this.viewportData, o ) && ( u[ c ] = !0, l = !0 )
            }
            l && this._finishRenderingNewLines( t, n, o.build(), u ), o.reset();
            let h = !1;
            const p = [];
            for ( c = 0; c < r; c++ ) {
              d = s[ c ];
              if ( p[ c ] = !1, !u[ c ] ) d.renderLine( c + a, i[ c ], this.viewportData, o ) && ( p[ c ] = !0, h = !0 )
            }
            h && this._finishRenderingInvalidLines( t, o.build(), p )
          }, e._sb = Object( cn.a )( 1e5 ), e;
        } )(),
        fn = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        gn = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._visibleLines = new hn( n ), n.domNode = n._visibleLines.domNode, n._dynamicOverlays = [], n._isFocused = !1, n.domNode.setClassName( "view-overlays" ), n
          }
          return fn( t, e ), t.prototype.shouldRender = function () {
            if ( e.prototype.shouldRender.call( this ) ) return !0;
            for ( let t = 0, n = this._dynamicOverlays.length; t < n; t++ ) {
              if ( this._dynamicOverlays[ t ].shouldRender() ) return !0
            }
            return !1
          }, t.prototype.dispose = function () {
            e.prototype.dispose.call( this );
            for ( let t = 0, n = this._dynamicOverlays.length; t < n; t++ ) {
              this._dynamicOverlays[ t ].dispose()
            }
            this._dynamicOverlays = null
          }, t.prototype.getDomNode = function () {
            return this.domNode
          }, t.prototype.createVisibleLine = function () {
            return new mn( this._context.configuration, this._dynamicOverlays )
          }, t.prototype.addDynamicOverlay = function ( e ) {
            this._dynamicOverlays.push( e )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            this._visibleLines.onConfigurationChanged( e );
            for ( let t = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber(), i = t; i <= n; i++ ) {
              this._visibleLines.getVisibleLine( i ).onConfigurationChanged( e )
            }
            return !0
          }, t.prototype.onFlushed = function ( e ) {
            return this._visibleLines.onFlushed( e )
          }, t.prototype.onFocusChanged = function ( e ) {
            return this._isFocused = e.isFocused, !0
          }, t.prototype.onLinesChanged = function ( e ) {
            return this._visibleLines.onLinesChanged( e )
          }, t.prototype.onLinesDeleted = function ( e ) {
            return this._visibleLines.onLinesDeleted( e )
          }, t.prototype.onLinesInserted = function ( e ) {
            return this._visibleLines.onLinesInserted( e )
          }, t.prototype.onScrollChanged = function ( e ) {
            return this._visibleLines.onScrollChanged( e ) || !0
          }, t.prototype.onTokensChanged = function ( e ) {
            return this._visibleLines.onTokensChanged( e )
          }, t.prototype.onZonesChanged = function ( e ) {
            return this._visibleLines.onZonesChanged( e )
          }, t.prototype.prepareRender = function ( e ) {
            for ( let t = this._dynamicOverlays.filter( ( e => {
                return e.shouldRender()
              } ) ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              o.prepareRender( e ), o.onDidRender()
            }
            return null
          }, t.prototype.render = function ( e ) {
            this._viewOverlaysRender( e ), this.domNode.toggleClassName( "focused", this._isFocused )
          }, t.prototype._viewOverlaysRender = function ( e ) {
            this._visibleLines.renderLines( e.viewportData )
          }, t;
        } )( qe ),
        mn = ( () => {
          function e( e, t ) {
            this._configuration = e, this._lineHeight = this._configuration.editor.lineHeight, this._dynamicOverlays = t, this._domNode = null, this._renderedContent = null
          }
          return e.prototype.getDomNode = function () {
            return this._domNode ? this._domNode.domNode : null
          }, e.prototype.setDomNode = function ( e ) {
            this._domNode = Object( We.b )( e )
          }, e.prototype.onContentChanged = () => {}, e.prototype.onTokensChanged = () => {}, e.prototype.onConfigurationChanged = function ( e ) {
            e.lineHeight && ( this._lineHeight = this._configuration.editor.lineHeight )
          }, e.prototype.renderLine = function ( e, t, n, i ) {
            for ( var o = "", r = 0, s = this._dynamicOverlays.length; r < s; r++ ) {
              o += this._dynamicOverlays[ r ].render( n.startLineNumber, e )
            }
            return this._renderedContent !== o && ( this._renderedContent = o, i.appendASCIIString( '<div style="position:absolute;top:' ), i.appendASCIIString( String( t ) ), i.appendASCIIString( "px;width:100%;height:" ), i.appendASCIIString( String( this._lineHeight ) ), i.appendASCIIString( 'px;">' ), i.appendASCIIString( o ), i.appendASCIIString( "</div>" ), !0 )
          }, e.prototype.layoutLine = function ( e, t ) {
            this._domNode && ( this._domNode.setTop( t ), this._domNode.setHeight( this._lineHeight ) )
          }, e;
        } )(),
        _n = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._contentWidth = n._context.configuration.editor.layoutInfo.contentWidth, n.domNode.setHeight( 0 ), n
          }
          return fn( t, e ), t.prototype.onConfigurationChanged = function ( t ) {
            return t.layoutInfo && ( this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth ), e.prototype.onConfigurationChanged.call( this, t )
          }, t.prototype.onScrollChanged = function ( t ) {
            return e.prototype.onScrollChanged.call( this, t ) || t.scrollWidthChanged
          }, t.prototype._viewOverlaysRender = function ( t ) {
            e.prototype._viewOverlaysRender.call( this, t ), this.domNode.setWidth( Math.max( t.scrollWidth, this._contentWidth ) )
          }, t
        } )( gn ),
        vn = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._contentLeft = n._context.configuration.editor.layoutInfo.contentLeft, n.domNode.setClassName( "margin-view-overlays" ), n.domNode.setWidth( 1 ), h.a.applyFontInfo( n.domNode, n._context.configuration.editor.fontInfo ), n
          }
          return fn( t, e ), t.prototype.onConfigurationChanged = function ( t ) {
            let n = !1;
            return t.fontInfo && ( h.a.applyFontInfo( this.domNode, this._context.configuration.editor.fontInfo ), n = !0 ), t.layoutInfo && ( this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft, n = !0 ), e.prototype.onConfigurationChanged.call( this, t ) || n
          }, t.prototype.onScrollChanged = function ( t ) {
            return e.prototype.onScrollChanged.call( this, t ) || t.scrollHeightChanged
          }, t.prototype._viewOverlaysRender = function ( t ) {
            e.prototype._viewOverlaysRender.call( this, t );
            const n = Math.min( t.scrollHeight, 1e6 );
            this.domNode.setHeight( n ), this.domNode.setWidth( this._contentLeft )
          }, t;
        } )( gn ),
        yn = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        bn = function ( e, t ) {
          this.top = e, this.left = t
        },
        Cn = ( e => {
          function t( t, n ) {
            const i = e.call( this, t ) || this;
            return i._viewDomNode = n, i._widgets = {}, i.domNode = Object( We.b )( document.createElement( "div" ) ), Ge.write( i.domNode, 1 ), i.domNode.setClassName( "contentWidgets" ), i.domNode.setPosition( "absolute" ), i.domNode.setTop( 0 ), i.overflowingContentWidgetsDomNode = Object( We.b )( document.createElement( "div" ) ), Ge.write( i.overflowingContentWidgetsDomNode, 2 ), i.overflowingContentWidgetsDomNode.setClassName( "overflowingContentWidgets" ), i
          }
          return yn( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this ), this._widgets = null, this.domNode = null
          }, t.prototype.onConfigurationChanged = function ( e ) {
            for ( let t = Object.keys( this._widgets ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              this._widgets[ o ].onConfigurationChanged( e )
            }
            return !0
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLineMappingChanged = function ( e ) {
            for ( let t = Object.keys( this._widgets ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              this._widgets[ o ].onLineMappingChanged( e )
            }
            return !0
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return !0
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype.addWidget = function ( e ) {
            const t = new wn( this._context, this._viewDomNode, e );
            this._widgets[ t.id ] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild( t.domNode ) : this.domNode.appendChild( t.domNode ), this.setShouldRender()
          }, t.prototype.setWidgetPosition = function ( e, t, n ) {
            this._widgets[ e.getId() ].setPosition( t, n ), this.setShouldRender()
          }, t.prototype.removeWidget = function ( e ) {
            const t = e.getId();
            if ( this._widgets.hasOwnProperty( t ) ) {
              const n = this._widgets[ t ];
              delete this._widgets[ t ];
              const i = n.domNode.domNode;
              i.parentNode.removeChild( i ), i.removeAttribute( "monaco-visible-content-widget" ), this.setShouldRender()
            }
          }, t.prototype.shouldSuppressMouseDownOnWidget = function ( e ) {
            return !!this._widgets.hasOwnProperty( e ) && this._widgets[ e ].suppressMouseDown
          }, t.prototype.onBeforeRender = function ( e ) {
            for ( let t = Object.keys( this._widgets ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              this._widgets[ o ].onBeforeRender( e )
            }
          }, t.prototype.prepareRender = function ( e ) {
            for ( let t = Object.keys( this._widgets ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              this._widgets[ o ].prepareRender( e )
            }
          }, t.prototype.render = function ( e ) {
            for ( let t = Object.keys( this._widgets ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              this._widgets[ o ].render( e )
            }
          }, t;
        } )( qe ),
        wn = ( () => {
          function e( e, t, n ) {
            this._context = e, this._viewDomNode = t, this._actual = n, this.domNode = Object( We.b )( this._actual.getDomNode() ), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || !1, this.suppressMouseDown = this._actual.suppressMouseDown || !1, this._fixedOverflowWidgets = this._context.configuration.editor.viewInfo.fixedOverflowWidgets, this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth, this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft, this._lineHeight = this._context.configuration.editor.lineHeight, this._setPosition( null ), this._preference = null, this._cachedDomNodeClientWidth = -1, this._cachedDomNodeClientHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = !1, this._renderData = null, this.domNode.setPosition( this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute" ), this.domNode.setVisibility( "hidden" ), this.domNode.setAttribute( "widgetId", this.id ), this.domNode.setMaxWidth( this._maxWidth )
          }
          return e.prototype.onConfigurationChanged = function ( e ) {
            e.lineHeight && ( this._lineHeight = this._context.configuration.editor.lineHeight ), e.layoutInfo && ( this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft, this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth, this._maxWidth = this._getMaxWidth() )
          }, e.prototype.onLineMappingChanged = function ( e ) {
            this._setPosition( this._position )
          }, e.prototype._setPosition = function ( e ) {
            if ( this._position = e, this._viewPosition = null, this._position ) {
              const t = this._context.model.validateModelPosition( this._position );
              this._context.model.coordinatesConverter.modelPositionIsVisible( t ) && ( this._viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition( t ) )
            }
          }, e.prototype._getMaxWidth = function () {
            return this.allowEditorOverflow ? window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth : this._contentWidth
          }, e.prototype.setPosition = function ( e, t ) {
            this._setPosition( e ), this._preference = t, this._cachedDomNodeClientWidth = -1, this._cachedDomNodeClientHeight = -1
          }, e.prototype._layoutBoxInViewport = function ( e, t, n, i ) {
            const o = e.top;
            const r = o;
            const s = e.top + this._lineHeight;
            const a = o - n;
            const u = r >= n;
            const l = s;
            const c = i.viewportHeight - s >= n;
            let d = e.left;
            return d + t > i.scrollLeft + i.viewportWidth && ( d = i.scrollLeft + i.viewportWidth - t ), d < i.scrollLeft && ( d = i.scrollLeft ), {
              aboveTop: a,
              fitsAbove: u,
              belowTop: l,
              fitsBelow: c,
              left: d
            }
          }, e.prototype._layoutBoxInPage = function ( e, t, n, i ) {
            const r = e.left - i.scrollLeft;
            if ( r < 0 || r > this._contentWidth ) return null;
            let s;
            let a = e.top - n;
            let u = e.top + this._lineHeight;
            let l = r + this._contentLeft;
            const c = o.u( this._viewDomNode.domNode );
            const d = c.top + a - o.e.scrollY;
            const h = c.top + u - o.e.scrollY;
            let p = c.left + l - o.e.scrollX;
            const f = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            const g = d >= 22;
            const m = h + n <= ( window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight ) - 22;
            p + t + 20 > f && ( p -= s = p - ( f - t - 20 ), l -= s );
            p < 0 && ( p -= s = p, l -= s );
            return this._fixedOverflowWidgets && ( a = d, u = h, l = p ), {
              aboveTop: a,
              fitsAbove: g,
              belowTop: u,
              fitsBelow: m,
              left: l
            }
          }, e.prototype._prepareRenderWidgetAtExactPositionOverflowing = function ( e ) {
            return new bn( e.top, e.left + this._contentLeft )
          }, e.prototype._getTopLeft = function ( e ) {
            if ( !this._viewPosition ) return null;
            const t = e.visibleRangeForPosition( this._viewPosition );
            if ( !t ) return null;
            const n = e.getVerticalOffsetForLineNumber( this._viewPosition.lineNumber ) - e.scrollTop;
            return new bn( n, t.left )
          }, e.prototype._prepareRenderWidget = function ( e, t ) {
            const n = this;
            if ( !e ) return null;
            for ( let i = null, o = () => {
                if ( !i ) {
                  if ( -1 === n._cachedDomNodeClientWidth || -1 === n._cachedDomNodeClientHeight ) {
                    const o = n.domNode.domNode;
                    n._cachedDomNodeClientWidth = o.clientWidth, n._cachedDomNodeClientHeight = o.clientHeight
                  }
                  i = n.allowEditorOverflow ? n._layoutBoxInPage( e, n._cachedDomNodeClientWidth, n._cachedDomNodeClientHeight, t ) : n._layoutBoxInViewport( e, n._cachedDomNodeClientWidth, n._cachedDomNodeClientHeight, t )
                }
              }, r = 1; r <= 2; r++ )
              for ( let s = 0; s < this._preference.length; s++ ) {
                const a = this._preference[ s ];
                if ( a === ut.a.ABOVE ) {
                  if ( o(), !i ) return null;
                  if ( 2 === r || i.fitsAbove ) return new bn( i.aboveTop, i.left )
                } else {
                  if ( a !== ut.a.BELOW ) return this.allowEditorOverflow ? this._prepareRenderWidgetAtExactPositionOverflowing( e ) : e;
                  if ( o(), !i ) return null;
                  if ( 2 === r || i.fitsBelow ) return new bn( i.belowTop, i.left )
                }
              }
            return null
          }, e.prototype.onBeforeRender = function ( e ) {
            this._viewPosition && this._preference && ( this._viewPosition.lineNumber < e.startLineNumber || this._viewPosition.lineNumber > e.endLineNumber || this.domNode.setMaxWidth( this._maxWidth ) )
          }, e.prototype.prepareRender = function ( e ) {
            const t = this._getTopLeft( e );
            this._renderData = this._prepareRenderWidget( t, e )
          }, e.prototype.render = function ( e ) {
            this._renderData ? ( this.allowEditorOverflow ? ( this.domNode.setTop( this._renderData.top ), this.domNode.setLeft( this._renderData.left ) ) : ( this.domNode.setTop( this._renderData.top + e.scrollTop - e.bigNumbersDelta ), this.domNode.setLeft( this._renderData.left ) ), this._isVisible || ( this.domNode.setVisibility( "inherit" ), this.domNode.setAttribute( "monaco-visible-content-widget", "true" ), this._isVisible = !0 ) ) : this._isVisible && ( this.domNode.removeAttribute( "monaco-visible-content-widget" ), this._isVisible = !1, this.domNode.setVisibility( "hidden" ) )
          }, e;
        } )(),
        Sn = ( n( "kw+w" ), ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )() ),
        On = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._context = t, n._lineHeight = n._context.configuration.editor.lineHeight, n._renderLineHighlight = n._context.configuration.editor.viewInfo.renderLineHighlight, n._selectionIsEmpty = !0, n._primaryCursorLineNumber = 1, n._scrollWidth = 0, n._contentWidth = n._context.configuration.editor.layoutInfo.contentWidth, n._context.addEventHandler( n ), n
          }
          return Sn( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.lineHeight && ( this._lineHeight = this._context.configuration.editor.lineHeight ), e.viewInfo && ( this._renderLineHighlight = this._context.configuration.editor.viewInfo.renderLineHighlight ), e.layoutInfo && ( this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth ), !0
          }, t.prototype.onCursorStateChanged = function ( e ) {
            let t = !1;
            const n = e.selections[ 0 ].positionLineNumber;
            this._primaryCursorLineNumber !== n && ( this._primaryCursorLineNumber = n, t = !0 );
            const i = e.selections[ 0 ].isEmpty();
            return this._selectionIsEmpty !== i ? ( this._selectionIsEmpty = i, t = !0, !0 ) : t
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollWidthChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype.prepareRender = function ( e ) {
            this._scrollWidth = e.scrollWidth
          }, t.prototype.render = function ( e, t ) {
            return t === this._primaryCursorLineNumber && this._shouldShowCurrentLine() ? '<div class="' + ( "current-line" + ( this._willRenderMarginCurrentLine() ? " current-line-both" : "" ) ) + '" style="width:' + String( Math.max( this._scrollWidth, this._contentWidth ) ) + "px; height:" + String( this._lineHeight ) + 'px;"></div>' : ""
          }, t.prototype._shouldShowCurrentLine = function () {
            return ( "line" === this._renderLineHighlight || "all" === this._renderLineHighlight ) && this._selectionIsEmpty
          }, t.prototype._willRenderMarginCurrentLine = function () {
            return "gutter" === this._renderLineHighlight || "all" === this._renderLineHighlight
          }, t;
        } )( Qe );
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( $e.o );
        if ( n && t.addRule( ".monaco-editor .view-overlays .current-line { background-color: " + n + "; }" ), !n || n.isTransparent() || e.defines( $e.p ) ) {
          const i = e.getColor( $e.p );
          i && ( t.addRule( ".monaco-editor .view-overlays .current-line { border: 2px solid " + i + "; }" ), "hc" === e.type && t.addRule( ".monaco-editor .view-overlays .current-line { border-width: 1px; }" ) )
        }
      } ) );
      n( "Tn3x" );
      const Ln = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        xn = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._context = t, n._lineHeight = n._context.configuration.editor.lineHeight, n._renderLineHighlight = n._context.configuration.editor.viewInfo.renderLineHighlight, n._selectionIsEmpty = !0, n._primaryCursorLineNumber = 1, n._contentLeft = n._context.configuration.editor.layoutInfo.contentLeft, n._context.addEventHandler( n ), n
          }
          return Ln( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.lineHeight && ( this._lineHeight = this._context.configuration.editor.lineHeight ), e.viewInfo && ( this._renderLineHighlight = this._context.configuration.editor.viewInfo.renderLineHighlight ), e.layoutInfo && ( this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft ), !0
          }, t.prototype.onCursorStateChanged = function ( e ) {
            let t = !1;
            const n = e.selections[ 0 ].positionLineNumber;
            this._primaryCursorLineNumber !== n && ( this._primaryCursorLineNumber = n, t = !0 );
            const i = e.selections[ 0 ].isEmpty();
            return this._selectionIsEmpty !== i ? ( this._selectionIsEmpty = i, t = !0, !0 ) : t
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype.prepareRender = e => {}, t.prototype.render = function ( e, t ) {
            if ( t === this._primaryCursorLineNumber ) {
              let n = "current-line";
              if ( this._shouldShowCurrentLine() ) n = "current-line current-line-margin" + ( this._willRenderContentCurrentLine() ? " current-line-margin-both" : "" );
              return '<div class="' + n + '" style="width:' + String( this._contentLeft ) + "px; height:" + String( this._lineHeight ) + 'px;"></div>'
            }
            return ""
          }, t.prototype._shouldShowCurrentLine = function () {
            return "gutter" === this._renderLineHighlight || "all" === this._renderLineHighlight
          }, t.prototype._willRenderContentCurrentLine = function () {
            return ( "line" === this._renderLineHighlight || "all" === this._renderLineHighlight ) && this._selectionIsEmpty
          }, t;
        } )( Qe );
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( $e.o );
        if ( n ) t.addRule( ".monaco-editor .margin-view-overlays .current-line-margin { background-color: " + n + "; border: none; }" );
        else {
          const i = e.getColor( $e.p );
          i && t.addRule( ".monaco-editor .margin-view-overlays .current-line-margin { border: 2px solid " + i + "; }" ), "hc" === e.type && t.addRule( ".monaco-editor .margin-view-overlays .current-line-margin { border-width: 1px; }" )
        }
      } ) );
      n( "Vtyv" );
      const Nn = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        En = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._context = t, n._lineHeight = n._context.configuration.editor.lineHeight, n._typicalHalfwidthCharacterWidth = n._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth, n._renderResult = null, n._context.addEventHandler( n ), n
          }
          return Nn( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, this._renderResult = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.lineHeight && ( this._lineHeight = this._context.configuration.editor.lineHeight ), e.fontInfo && ( this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth ), !0
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollTopChanged || e.scrollWidthChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype.prepareRender = function ( e ) {
            for ( var t = e.getDecorationsInViewport(), n = [], i = 0, o = 0, r = t.length; o < r; o++ ) {
              const s = t[ o ];
              s.options.className && ( n[ i++ ] = s )
            }
            n = n.sort( ( ( e, t ) => {
              if ( e.options.zIndex < t.options.zIndex ) return -1;
              if ( e.options.zIndex > t.options.zIndex ) return 1;
              const n = e.options.className,
                i = t.options.className;
              return n < i ? -1 : n > i ? 1 : m.a.compareRangesUsingStarts( e.range, t.range )
            } ) );
            for ( var a = e.visibleRange.startLineNumber, u = e.visibleRange.endLineNumber, l = [], c = a; c <= u; c++ ) {
              l[ c - a ] = ""
            }
            this._renderWholeLineDecorations( e, n, l ), this._renderNormalDecorations( e, n, l ), this._renderResult = l
          }, t.prototype._renderWholeLineDecorations = function ( e, t, n ) {
            for ( let i = String( this._lineHeight ), o = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, s = 0, a = t.length; s < a; s++ ) {
              const u = t[ s ];
              if ( u.options.isWholeLine )
                for ( let l = '<div class="cdr ' + u.options.className + '" style="left:0;width:100%;height:' + i + 'px;"></div>', c = Math.max( u.range.startLineNumber, o ), d = Math.min( u.range.endLineNumber, r ), h = c; h <= d; h++ ) {
                  n[ h - o ] += l
                }
            }
          }, t.prototype._renderNormalDecorations = function ( e, t, n ) {
            for ( var i = String( this._lineHeight ), o = e.visibleRange.startLineNumber, r = null, s = !1, a = null, u = 0, l = t.length; u < l; u++ ) {
              const c = t[ u ];
              if ( !c.options.isWholeLine ) {
                const d = c.options.className;
                const h = c.options.showIfCollapsed;
                let p = c.range;
                h && 1 === p.endColumn && p.endLineNumber !== p.startLineNumber && ( p = new m.a( p.startLineNumber, p.startColumn, p.endLineNumber - 1, this._context.model.getLineMaxColumn( p.endLineNumber - 1 ) ) ), r === d && s === h && m.a.areIntersectingOrTouching( a, p ) ? a = m.a.plusRange( a, p ) : ( null !== r && this._renderNormalDecoration( e, a, r, s, i, o, n ), r = d, s = h, a = p )
              }
            }
            null !== r && this._renderNormalDecoration( e, a, r, s, i, o, n )
          }, t.prototype._renderNormalDecoration = function ( e, t, n, i, o, r, s ) {
            const a = e.linesVisibleRangesForRange( t, "findMatch" === n );
            if ( a )
              for ( let u = 0, l = a.length; u < l; u++ ) {
                const c = a[ u ],
                  d = c.lineNumber - r;
                if ( i && 1 === c.ranges.length ) {
                  const h = c.ranges[ 0 ];
                  0 === h.width && ( c.ranges[ 0 ] = new Ot( h.left, this._typicalHalfwidthCharacterWidth ) )
                }
                for ( let p = 0, f = c.ranges.length; p < f; p++ ) {
                  const g = c.ranges[ p ],
                    m = '<div class="cdr ' + n + '" style="left:' + String( g.left ) + "px;width:" + String( g.width ) + "px;height:" + o + 'px;"></div>';
                  s[ d ] += m
                }
              }
          }, t.prototype.render = function ( e, t ) {
            if ( !this._renderResult ) return "";
            const n = t - e;
            return n < 0 || n >= this._renderResult.length ? "" : this._renderResult[ n ]
          }, t;
        } )( Qe ),
        kn = ( n( "hHjc" ), ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )() ),
        In = function ( e, t, n ) {
          this.startLineNumber = +e, this.endLineNumber = +t, this.className = String( n )
        },
        Dn = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return kn( t, e ), t.prototype._render = ( e, t, n ) => {
            for ( var i = [], o = e; o <= t; o++ ) {
              i[ o - e ] = []
            }
            if ( 0 === n.length ) return i;
            n.sort( ( ( e, t ) => {
              return e.className === t.className ? e.startLineNumber === t.startLineNumber ? e.endLineNumber - t.endLineNumber : e.startLineNumber - t.startLineNumber : e.className < t.className ? -1 : 1
            } ) );
            for ( let r = null, s = 0, a = 0, u = n.length; a < u; a++ ) {
              const l = n[ a ];
              const c = l.className;
              let d = Math.max( l.startLineNumber, e ) - e;
              const h = Math.min( l.endLineNumber, t ) - e;
              r === c ? ( d = Math.max( s + 1, d ), s = Math.max( s, h ) ) : ( r = c, s = h );
              for ( let p = d; p <= s; p++ ) i[ p ].push( r )
            }
            return i
          }, t;
        } )( Qe ),
        Mn = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._context = t, n._lineHeight = n._context.configuration.editor.lineHeight, n._glyphMargin = n._context.configuration.editor.viewInfo.glyphMargin, n._glyphMarginLeft = n._context.configuration.editor.layoutInfo.glyphMarginLeft, n._glyphMarginWidth = n._context.configuration.editor.layoutInfo.glyphMarginWidth, n._renderResult = null, n._context.addEventHandler( n ), n
          }
          return kn( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, this._renderResult = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.lineHeight && ( this._lineHeight = this._context.configuration.editor.lineHeight ), e.viewInfo && ( this._glyphMargin = this._context.configuration.editor.viewInfo.glyphMargin ), e.layoutInfo && ( this._glyphMarginLeft = this._context.configuration.editor.layoutInfo.glyphMarginLeft, this._glyphMarginWidth = this._context.configuration.editor.layoutInfo.glyphMarginWidth ), !0
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollTopChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype._getDecorations = e => {
            for ( var t = e.getDecorationsInViewport(), n = [], i = 0, o = 0, r = t.length; o < r; o++ ) {
              const s = t[ o ],
                a = s.options.glyphMarginClassName;
              a && ( n[ i++ ] = new In( s.range.startLineNumber, s.range.endLineNumber, a ) )
            }
            return n
          }, t.prototype.prepareRender = function ( e ) {
            if ( this._glyphMargin ) {
              for ( var t = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, i = this._render( t, n, this._getDecorations( e ) ), o = this._lineHeight.toString(), r = '" style="left:' + this._glyphMarginLeft.toString() + "px;width:" + this._glyphMarginWidth.toString() + "px;height:" + o + 'px;"></div>', s = [], a = t; a <= n; a++ ) {
                const u = a - t,
                  l = i[ u ];
                0 === l.length ? s[ u ] = "" : s[ u ] = '<div class="cgmr ' + l.join( " " ) + r
              }
              this._renderResult = s
            } else this._renderResult = null
          }, t.prototype.render = function ( e, t ) {
            if ( !this._renderResult ) return "";
            const n = t - e;
            return n < 0 || n >= this._renderResult.length ? "" : this._renderResult[ n ]
          }, t;
        } )( Dn ),
        Tn = ( n( "C6rC" ), ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )() ),
        Rn = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._context = t, n._primaryLineNumber = 0, n._lineHeight = n._context.configuration.editor.lineHeight, n._spaceWidth = n._context.configuration.editor.fontInfo.spaceWidth, n._enabled = n._context.configuration.editor.viewInfo.renderIndentGuides, n._activeIndentEnabled = n._context.configuration.editor.viewInfo.highlightActiveIndentGuide, n._renderResult = null, n._context.addEventHandler( n ), n
          }
          return Tn( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, this._renderResult = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.lineHeight && ( this._lineHeight = this._context.configuration.editor.lineHeight ), e.fontInfo && ( this._spaceWidth = this._context.configuration.editor.fontInfo.spaceWidth ), e.viewInfo && ( this._enabled = this._context.configuration.editor.viewInfo.renderIndentGuides, this._activeIndentEnabled = this._context.configuration.editor.viewInfo.highlightActiveIndentGuide ), !0
          }, t.prototype.onCursorStateChanged = function ( e ) {
            const t = e.selections[ 0 ],
              n = t.isEmpty() ? t.positionLineNumber : 0;
            return this._primaryLineNumber !== n && ( this._primaryLineNumber = n, !0 )
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollTopChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype.onLanguageConfigurationChanged = e => {
            return !0
          }, t.prototype.prepareRender = function ( e ) {
            if ( this._enabled ) {
              const t = e.visibleRange.startLineNumber;
              const n = e.visibleRange.endLineNumber;
              const i = this._context.model.getTabSize() * this._spaceWidth;
              const o = e.scrollWidth;
              const r = this._lineHeight;
              const s = i;
              const a = this._context.model.getLinesIndentGuides( t, n );
              let u = 0;
              let l = 0;
              let c = 0;
              if ( this._activeIndentEnabled && this._primaryLineNumber ) {
                const d = this._context.model.getActiveIndentGuide( this._primaryLineNumber, t, n );
                u = d.startLineNumber, l = d.endLineNumber, c = d.indent
              }
              for ( var h = [], p = t; p <= n; p++ ) {
                for ( var f = u <= p && p <= l, m = p - t, _ = a[ m ], v = "", y = e.visibleRangeForPosition( new g.a( p, 1 ) ), b = y ? y.left : 0, C = 1; C <= _; C++ ) {
                  if ( v += '<div class="' + ( f && C === c ? "cigra" : "cigr" ) + '" style="left:' + b + "px;height:" + r + "px;width:" + s + 'px"></div>', ( b += i ) > o ) break
                }
                h[ m ] = v
              }
              this._renderResult = h
            } else this._renderResult = null
          }, t.prototype.render = function ( e, t ) {
            if ( !this._renderResult ) return "";
            const n = t - e;
            return n < 0 || n >= this._renderResult.length ? "" : this._renderResult[ n ]
          }, t;
        } )( Qe );
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( $e.l );
        n && t.addRule( ".monaco-editor .lines-content .cigr { box-shadow: 1px 0 0 0 " + n + " inset; }" );
        const i = e.getColor( $e.a ) || n;
        i && t.addRule( ".monaco-editor .lines-content .cigra { box-shadow: 1px 0 0 0 " + i + " inset; }" )
      } ) );
      n( "OKK6" );
      const Pn = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        An = ( () => {
          function e() {
            this._currentVisibleRange = new m.a( 1, 1, 1, 1 )
          }
          return e.prototype.getCurrentVisibleRange = function () {
            return this._currentVisibleRange
          }, e.prototype.setCurrentVisibleRange = function ( e ) {
            this._currentVisibleRange = e
          }, e
        } )(),
        Fn = function ( e, t, n, i, o, r ) {
          this.lineNumber = e, this.startColumn = t, this.endColumn = n, this.startScrollTop = i, this.stopScrollTop = o, this.scrollType = r
        },
        Wn = ( e => {
          function t( t, n ) {
            const i = e.call( this, t ) || this;
            i._linesContent = n, i._textRangeRestingSpot = document.createElement( "div" ), i._visibleLines = new hn( i ), i.domNode = i._visibleLines.domNode;
            const o = i._context.configuration;
            return i._lineHeight = o.editor.lineHeight, i._typicalHalfwidthCharacterWidth = o.editor.fontInfo.typicalHalfwidthCharacterWidth, i._isViewportWrapping = o.editor.wrappingInfo.isViewportWrapping, i._revealHorizontalRightPadding = o.editor.viewInfo.revealHorizontalRightPadding, i._canUseLayerHinting = o.editor.canUseLayerHinting, i._viewLineOptions = new Dt( o, i._context.theme.type ), Ge.write( i.domNode, 7 ), i.domNode.setClassName( "view-lines" ), h.a.applyFontInfo( i.domNode, o.editor.fontInfo ), i._maxLineWidth = 0, i._asyncUpdateLineWidths = new Gt.c( ( () => {
              i._updateLineWidthsSlow()
            } ), 200 ), i._lastRenderedData = new An, i._horizontalRevealRequest = null, i;
          }
          return Pn( t, e ), t.prototype.dispose = function () {
            this._asyncUpdateLineWidths.dispose(), e.prototype.dispose.call( this )
          }, t.prototype.getDomNode = function () {
            return this.domNode
          }, t.prototype.createVisibleLine = function () {
            return new Mt( this._viewLineOptions )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            this._visibleLines.onConfigurationChanged( e ), e.wrappingInfo && ( this._maxLineWidth = 0 );
            const t = this._context.configuration;
            return e.lineHeight && ( this._lineHeight = t.editor.lineHeight ), e.fontInfo && ( this._typicalHalfwidthCharacterWidth = t.editor.fontInfo.typicalHalfwidthCharacterWidth ), e.wrappingInfo && ( this._isViewportWrapping = t.editor.wrappingInfo.isViewportWrapping ), e.viewInfo && ( this._revealHorizontalRightPadding = t.editor.viewInfo.revealHorizontalRightPadding ), e.canUseLayerHinting && ( this._canUseLayerHinting = t.editor.canUseLayerHinting ), e.fontInfo && h.a.applyFontInfo( this.domNode, t.editor.fontInfo ), this._onOptionsMaybeChanged(), e.layoutInfo && ( this._maxLineWidth = 0 ), !0
          }, t.prototype._onOptionsMaybeChanged = function () {
            const e = this._context.configuration,
              t = new Dt( e, this._context.theme.type );
            if ( !this._viewLineOptions.equals( t ) ) {
              this._viewLineOptions = t;
              for ( let n = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber(), o = n; o <= i; o++ ) {
                this._visibleLines.getVisibleLine( o ).onOptionsChanged( this._viewLineOptions )
              }
              return !0
            }
            return !1
          }, t.prototype.onCursorStateChanged = function ( e ) {
            for ( var t = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber(), i = !1, o = t; o <= n; o++ ) i = this._visibleLines.getVisibleLine( o ).onSelectionChanged() || i;
            return i
          }, t.prototype.onDecorationsChanged = function ( e ) {
            for ( let t = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber(), i = t; i <= n; i++ ) this._visibleLines.getVisibleLine( i ).onDecorationsChanged();
            return !0
          }, t.prototype.onFlushed = function ( e ) {
            const t = this._visibleLines.onFlushed( e );
            return this._maxLineWidth = 0, t
          }, t.prototype.onLinesChanged = function ( e ) {
            return this._visibleLines.onLinesChanged( e )
          }, t.prototype.onLinesDeleted = function ( e ) {
            return this._visibleLines.onLinesDeleted( e )
          }, t.prototype.onLinesInserted = function ( e ) {
            return this._visibleLines.onLinesInserted( e )
          }, t.prototype.onRevealRangeRequest = function ( e ) {
            const t = this._computeScrollTopToRevealRange( this._context.viewLayout.getFutureViewport(), e.range, e.verticalType );
            let n = this._context.viewLayout.validateScrollPosition( {
              scrollTop: t
            } );
            e.revealHorizontal ? e.range.startLineNumber !== e.range.endLineNumber ? n = {
              scrollTop: n.scrollTop,
              scrollLeft: 0
            } : this._horizontalRevealRequest = new Fn( e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), n.scrollTop, e.scrollType ) : this._horizontalRevealRequest = null;
            const i = Math.abs( this._context.viewLayout.getCurrentScrollTop() - n.scrollTop );
            return 0 === e.scrollType && i > this._lineHeight ? this._context.viewLayout.setScrollPositionSmooth( n ) : this._context.viewLayout.setScrollPositionNow( n ), !0
          }, t.prototype.onScrollChanged = function ( e ) {
            if ( this._horizontalRevealRequest && e.scrollLeftChanged && ( this._horizontalRevealRequest = null ), this._horizontalRevealRequest && e.scrollTopChanged ) {
              const t = Math.min( this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop ),
                n = Math.max( this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop );
              ( e.scrollTop < t || e.scrollTop > n ) && ( this._horizontalRevealRequest = null )
            }
            return this.domNode.setWidth( e.scrollWidth ), this._visibleLines.onScrollChanged( e ) || !0
          }, t.prototype.onTokensChanged = function ( e ) {
            return this._visibleLines.onTokensChanged( e )
          }, t.prototype.onZonesChanged = function ( e ) {
            return this._context.viewLayout.onMaxLineWidthChanged( this._maxLineWidth ), this._visibleLines.onZonesChanged( e )
          }, t.prototype.onThemeChanged = function ( e ) {
            return this._onOptionsMaybeChanged()
          }, t.prototype.getPositionFromDOMInfo = function ( e, t ) {
            const n = this._getViewLineDomNode( e );
            if ( null === n ) return null;
            const i = this._getLineNumberFor( n );
            if ( -1 === i ) return null;
            if ( i < 1 || i > this._context.model.getLineCount() ) return null;
            if ( 1 === this._context.model.getLineMaxColumn( i ) ) return new g.a( i, 1 );
            const o = this._visibleLines.getStartLineNumber(),
              r = this._visibleLines.getEndLineNumber();
            if ( i < o || i > r ) return null;
            let s = this._visibleLines.getVisibleLine( i ).getColumnOfNodeOffset( i, e, t );
            const a = this._context.model.getLineMinColumn( i );
            return s < a && ( s = a ), new g.a( i, s )
          }, t.prototype._getViewLineDomNode = e => {
            for ( ; e && 1 === e.nodeType; ) {
              if ( e.className === Mt.CLASS_NAME ) return e;
              e = e.parentElement
            }
            return null
          }, t.prototype._getLineNumberFor = function ( e ) {
            for ( let t = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber(), i = t; i <= n; i++ ) {
              if ( e === this._visibleLines.getVisibleLine( i ).getDomNode() ) return i
            }
            return -1
          }, t.prototype.getLineWidth = function ( e ) {
            const t = this._visibleLines.getStartLineNumber(),
              n = this._visibleLines.getEndLineNumber();
            return e < t || e > n ? -1 : this._visibleLines.getVisibleLine( e ).getWidth()
          }, t.prototype.linesVisibleRangesForRange = function ( e, t ) {
            if ( this.shouldRender() ) return null;
            const n = e.endLineNumber;
            if ( !( e = m.a.intersectRanges( e, this._lastRenderedData.getCurrentVisibleRange() ) ) ) return null;
            let i;
            const o = [];
            let r = 0;
            const s = new It( this.domNode.domNode, this._textRangeRestingSpot );
            t && ( i = this._context.model.coordinatesConverter.convertViewPositionToModelPosition( new g.a( e.startLineNumber, 1 ) ).lineNumber );
            for ( let a = this._visibleLines.getStartLineNumber(), u = this._visibleLines.getEndLineNumber(), l = e.startLineNumber; l <= e.endLineNumber; l++ )
              if ( !( l < a || l > u ) ) {
                const c = l === e.startLineNumber ? e.startColumn : 1,
                  d = l === e.endLineNumber ? e.endColumn : this._context.model.getLineMaxColumn( l ),
                  h = this._visibleLines.getVisibleLine( l ).getVisibleRangesForRange( c, d, s );
                if ( h && 0 !== h.length ) {
                  if ( t && l < n ) i !== ( i = this._context.model.coordinatesConverter.convertViewPositionToModelPosition( new g.a( l + 1, 1 ) ).lineNumber ) && ( h[ h.length - 1 ].width += this._typicalHalfwidthCharacterWidth );
                  o[ r++ ] = new St( l, h )
                }
              } return 0 === r ? null : o
          }, t.prototype.visibleRangesForRange2 = function ( e ) {
            if ( this.shouldRender() ) return null;
            if ( !( e = m.a.intersectRanges( e, this._lastRenderedData.getCurrentVisibleRange() ) ) ) return null;
            for ( var t = [], n = new It( this.domNode.domNode, this._textRangeRestingSpot ), i = this._visibleLines.getStartLineNumber(), o = this._visibleLines.getEndLineNumber(), r = e.startLineNumber; r <= e.endLineNumber; r++ )
              if ( !( r < i || r > o ) ) {
                const s = r === e.startLineNumber ? e.startColumn : 1,
                  a = r === e.endLineNumber ? e.endColumn : this._context.model.getLineMaxColumn( r ),
                  u = this._visibleLines.getVisibleLine( r ).getVisibleRangesForRange( s, a, n );
                u && 0 !== u.length && ( t = t.concat( u ) )
              } return 0 === t.length ? null : t
          }, t.prototype.updateLineWidths = function () {
            this._updateLineWidths( !1 )
          }, t.prototype._updateLineWidthsFast = function () {
            return this._updateLineWidths( !0 )
          }, t.prototype._updateLineWidthsSlow = function () {
            this._updateLineWidths( !1 )
          }, t.prototype._updateLineWidths = function ( e ) {
            for ( var t = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber(), i = 1, o = !0, r = t; r <= n; r++ ) {
              const s = this._visibleLines.getVisibleLine( r );
              !e || s.getWidthIsFast() ? i = Math.max( i, s.getWidth() ) : o = !1
            }
            return o && 1 === t && n === this._context.model.getLineCount() && ( this._maxLineWidth = 0 ), this._ensureMaxLineWidth( i ), o
          }, t.prototype.prepareRender = () => {
            throw new Error( "Not supported" )
          }, t.prototype.render = () => {
            throw new Error( "Not supported" )
          }, t.prototype.renderText = function ( e ) {
            if ( this._visibleLines.renderLines( e ), this._lastRenderedData.setCurrentVisibleRange( e.visibleRange ), this.domNode.setWidth( this._context.viewLayout.getScrollWidth() ), this.domNode.setHeight( Math.min( this._context.viewLayout.getScrollHeight(), 1e6 ) ), this._horizontalRevealRequest ) {
              const t = this._horizontalRevealRequest.lineNumber,
                n = this._horizontalRevealRequest.startColumn,
                i = this._horizontalRevealRequest.endColumn,
                o = this._horizontalRevealRequest.scrollType;
              if ( e.startLineNumber <= t && t <= e.endLineNumber ) {
                this._horizontalRevealRequest = null, this.onDidRender();
                const r = this._computeScrollLeftToRevealRange( t, n, i );
                this._isViewportWrapping || this._ensureMaxLineWidth( r.maxHorizontalOffset ), 0 === o ? this._context.viewLayout.setScrollPositionSmooth( {
                  scrollLeft: r.scrollLeft
                } ) : this._context.viewLayout.setScrollPositionNow( {
                  scrollLeft: r.scrollLeft
                } )
              }
            }
            this._updateLineWidthsFast() || this._asyncUpdateLineWidths.schedule(), this._linesContent.setLayerHinting( this._canUseLayerHinting );
            const s = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
            this._linesContent.setTop( -s ), this._linesContent.setLeft( -this._context.viewLayout.getCurrentScrollLeft() )
          }, t.prototype._ensureMaxLineWidth = function ( e ) {
            const t = Math.ceil( e );
            this._maxLineWidth < t && ( this._maxLineWidth = t, this._context.viewLayout.onMaxLineWidthChanged( this._maxLineWidth ) )
          }, t.prototype._computeScrollTopToRevealRange = function ( e, t, n ) {
            let i;
            let o;
            let r;
            const s = e.top;
            const a = e.height;
            const u = s + a;
            if ( i = this._context.viewLayout.getVerticalOffsetForLineNumber( t.startLineNumber ), o = this._context.viewLayout.getVerticalOffsetForLineNumber( t.endLineNumber ) + this._lineHeight, 0 !== n && 4 !== n || ( o += this._lineHeight ), 1 === n || 2 === n )
              if ( 2 === n && s <= i && o <= u ) r = s;
              else {
                const l = ( i + o ) / 2;
                r = Math.max( 0, l - a / 2 )
              }
            else r = this._computeMinimumScrolling( s, u, i, o, 3 === n, 4 === n );
            return r
          }, t.prototype._computeScrollLeftToRevealRange = function ( e, n, i ) {
            let o = 0;
            const r = this._context.viewLayout.getCurrentViewport();
            const s = r.left;
            const a = s + r.width;
            const u = this.visibleRangesForRange2( new m.a( e, n, e, i ) );
            let l = Number.MAX_VALUE;
            let c = 0;
            if ( !u ) return {
              scrollLeft: s,
              maxHorizontalOffset: o
            };
            for ( let d = 0; d < u.length; d++ ) {
              const h = u[ d ];
              h.left < l && ( l = h.left ), h.left + h.width > c && ( c = h.left + h.width )
            }
            return o = c, l = Math.max( 0, l - t.HORIZONTAL_EXTRA_PX ), c += this._revealHorizontalRightPadding, {
              scrollLeft: this._computeMinimumScrolling( s, a, l, c ),
              maxHorizontalOffset: o
            }
          }, t.prototype._computeMinimumScrolling = ( e, t, n, i, o, r ) => {
            o = !!o, r = !!r;
            const s = ( t |= 0 ) - ( e |= 0 );
            return ( i |= 0 ) - ( n |= 0 ) < s ? o ? n : r ? Math.max( 0, i - s ) : n < e ? n : i > t ? Math.max( 0, i - s ) : e : n
          }, t.HORIZONTAL_EXTRA_PX = 30, t;
        } )( qe ),
        jn = ( n( "J+ZK" ), ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )() ),
        Vn = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._context = t, n._decorationsLeft = n._context.configuration.editor.layoutInfo.decorationsLeft, n._decorationsWidth = n._context.configuration.editor.layoutInfo.decorationsWidth, n._renderResult = null, n._context.addEventHandler( n ), n
          }
          return jn( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, this._renderResult = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.layoutInfo && ( this._decorationsLeft = this._context.configuration.editor.layoutInfo.decorationsLeft, this._decorationsWidth = this._context.configuration.editor.layoutInfo.decorationsWidth ), !0
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollTopChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype._getDecorations = e => {
            for ( var t = e.getDecorationsInViewport(), n = [], i = 0, o = 0, r = t.length; o < r; o++ ) {
              const s = t[ o ],
                a = s.options.linesDecorationsClassName;
              a && ( n[ i++ ] = new In( s.range.startLineNumber, s.range.endLineNumber, a ) )
            }
            return n
          }, t.prototype.prepareRender = function ( e ) {
            for ( var t = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, i = this._render( t, n, this._getDecorations( e ) ), o = '" style="left:' + this._decorationsLeft.toString() + "px;width:" + this._decorationsWidth.toString() + 'px;"></div>', r = [], s = t; s <= n; s++ ) {
              for ( var a = s - t, u = i[ a ], l = "", c = 0, d = u.length; c < d; c++ ) l += '<div class="cldr ' + u[ c ] + o;
              r[ a ] = l
            }
            this._renderResult = r
          }, t.prototype.render = function ( e, t ) {
            return this._renderResult ? this._renderResult[ t - e ] : ""
          }, t;
        } )( Dn ),
        Bn = ( n( "XXBq" ), ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )() ),
        Hn = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._context = t, n._renderResult = null, n._context.addEventHandler( n ), n
          }
          return Bn( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, this._renderResult = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = e => {
            return !0
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollTopChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype._getDecorations = e => {
            for ( var t = e.getDecorationsInViewport(), n = [], i = 0, o = 0, r = t.length; o < r; o++ ) {
              const s = t[ o ],
                a = s.options.marginClassName;
              a && ( n[ i++ ] = new In( s.range.startLineNumber, s.range.endLineNumber, a ) )
            }
            return n
          }, t.prototype.prepareRender = function ( e ) {
            for ( var t = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, i = this._render( t, n, this._getDecorations( e ) ), o = [], r = t; r <= n; r++ ) {
              for ( var s = r - t, a = i[ s ], u = "", l = 0, c = a.length; l < c; l++ ) u += '<div class="cmdr ' + a[ l ] + '" style=""></div>';
              o[ s ] = u
            }
            this._renderResult = o
          }, t.prototype.render = function ( e, t ) {
            return this._renderResult ? this._renderResult[ t - e ] : ""
          }, t;
        } )( Dn ),
        zn = ( n( "cl4r" ), ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )() ),
        Un = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._widgets = {}, n._verticalScrollbarWidth = n._context.configuration.editor.layoutInfo.verticalScrollbarWidth, n._minimapWidth = n._context.configuration.editor.layoutInfo.minimapWidth, n._horizontalScrollbarHeight = n._context.configuration.editor.layoutInfo.horizontalScrollbarHeight, n._editorHeight = n._context.configuration.editor.layoutInfo.height, n._editorWidth = n._context.configuration.editor.layoutInfo.width, n._domNode = Object( We.b )( document.createElement( "div" ) ), Ge.write( n._domNode, 4 ), n._domNode.setClassName( "overlayWidgets" ), n
          }
          return zn( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this ), this._widgets = null
          }, t.prototype.getDomNode = function () {
            return this._domNode
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return !!e.layoutInfo && ( this._verticalScrollbarWidth = this._context.configuration.editor.layoutInfo.verticalScrollbarWidth, this._minimapWidth = this._context.configuration.editor.layoutInfo.minimapWidth, this._horizontalScrollbarHeight = this._context.configuration.editor.layoutInfo.horizontalScrollbarHeight, this._editorHeight = this._context.configuration.editor.layoutInfo.height, this._editorWidth = this._context.configuration.editor.layoutInfo.width, !0 )
          }, t.prototype.addWidget = function ( e ) {
            const t = Object( We.b )( e.getDomNode() );
            this._widgets[ e.getId() ] = {
              widget: e,
              preference: null,
              domNode: t
            }, t.setPosition( "absolute" ), t.setAttribute( "widgetId", e.getId() ), this._domNode.appendChild( t ), this.setShouldRender()
          }, t.prototype.setWidgetPosition = function ( e, t ) {
            const n = this._widgets[ e.getId() ];
            return n.preference !== t && ( n.preference = t, this.setShouldRender(), !0 )
          }, t.prototype.removeWidget = function ( e ) {
            const t = e.getId();
            if ( this._widgets.hasOwnProperty( t ) ) {
              const n = this._widgets[ t ].domNode.domNode;
              delete this._widgets[ t ], n.parentNode.removeChild( n ), this.setShouldRender()
            }
          }, t.prototype._renderWidget = function ( e ) {
            const t = e.domNode;
            if ( null !== e.preference )
              if ( e.preference === ut.c.TOP_RIGHT_CORNER ) t.setTop( 0 ), t.setRight( 2 * this._verticalScrollbarWidth + this._minimapWidth );
              else if ( e.preference === ut.c.BOTTOM_RIGHT_CORNER ) {
              const n = t.domNode.clientHeight;
              t.setTop( this._editorHeight - n - 2 * this._horizontalScrollbarHeight ), t.setRight( 2 * this._verticalScrollbarWidth + this._minimapWidth )
            } else e.preference === ut.c.TOP_CENTER && ( t.setTop( 0 ), t.domNode.style.right = "50%" );
            else t.unsetTop()
          }, t.prototype.prepareRender = e => {}, t.prototype.render = function ( e ) {
            this._domNode.setWidth( this._editorWidth );
            for ( let t = Object.keys( this._widgets ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              this._renderWidget( this._widgets[ o ] )
            }
          }, t;
        } )( qe ),
        Kn = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        qn = ( () => {
          function e( e, t ) {
            this.lineHeight = e.editor.lineHeight, this.pixelRatio = e.editor.pixelRatio, this.overviewRulerLanes = e.editor.viewInfo.overviewRulerLanes, this.renderBorder = e.editor.viewInfo.overviewRulerBorder;
            const n = t.getColor( $e.r );
            this.borderColor = n ? n.toString() : null, this.hideCursor = e.editor.viewInfo.hideCursorInOverviewRuler;
            const i = t.getColor( $e.g );
            this.cursorColor = i ? i.transparent( .7 ).toString() : null, this.themeType = t.type;
            const o = e.editor.viewInfo.minimap.enabled,
              r = e.editor.viewInfo.minimap.side,
              s = o ? $.y.getDefaultBackground() : null;
            this.backgroundColor = null === s || "left" === r ? null : ne.a.Format.CSS.formatHex( s );
            const a = e.editor.layoutInfo.overviewRuler;
            this.top = a.top, this.right = a.right, this.domWidth = a.width, this.domHeight = a.height, this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0;
            const u = this._initLanes( 1, this.canvasWidth, this.overviewRulerLanes ),
              l = u[ 0 ],
              c = u[ 1 ];
            this.x = l, this.w = c
          }
          return e.prototype._initLanes = ( e, t, n ) => {
            const i = t - e;
            if ( n >= 3 ) {
              var o;
              var r;
              var s;
              const a = i - ( o = Math.floor( i / 3 ) ) - ( r = Math.floor( i / 3 ) );
              const u = ( s = e ) + o;
              return [
                [ 0, s, u, s, s + o + a, s, u, s ],
                [ 0, o, a, o + a, r, o + a + r, a + r, o + a + r ]
              ]
            }
            if ( 2 === n ) return [
              [ 0, s = e, s, s, s + ( o = Math.floor( i / 2 ) ), s, s, s ],
              [ 0, o, o, o, r = i - o, o + r, o + r, o + r ]
            ];
            return [
              [ 0, e, e, e, e, e, e, e ],
              [ 0, i, i, i, i, i, i, i ]
            ]
          }, e.prototype.equals = function ( e ) {
            return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColor === e.cursorColor && this.themeType === e.themeType && this.backgroundColor === e.backgroundColor && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight
          }, e;
        } )(),
        Gn = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._domNode = Object( We.b )( document.createElement( "canvas" ) ), n._domNode.setClassName( "decorationsOverviewRuler" ), n._domNode.setPosition( "absolute" ), n._domNode.setLayerHinting( !0 ), n._domNode.setAttribute( "aria-hidden", "true" ), n._settings = null, n._updateSettings( !1 ), n._tokensColorTrackerListener = $.y.onDidChange( ( e => {
              e.changedColorMap && n._updateSettings( !0 )
            } ) ), n._cursorPositions = [], n;
          }
          return Kn( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this ), this._tokensColorTrackerListener.dispose()
          }, t.prototype._updateSettings = function ( e ) {
            const t = new qn( this._context.configuration, this._context.theme );
            return ( null === this._settings || !this._settings.equals( t ) ) && ( this._settings = t, this._domNode.setTop( this._settings.top ), this._domNode.setRight( this._settings.right ), this._domNode.setWidth( this._settings.domWidth ), this._domNode.setHeight( this._settings.domHeight ), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), !0 )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return this._updateSettings( !1 )
          }, t.prototype.onCursorStateChanged = function ( e ) {
            this._cursorPositions = [];
            for ( let t = 0, n = e.selections.length; t < n; t++ ) this._cursorPositions[ t ] = e.selections[ t ].getPosition();
            return this._cursorPositions.sort( g.a.compare ), !0
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollHeightChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype.onThemeChanged = function ( e ) {
            return this._context.model.invalidateOverviewRulerColorCache(), this._updateSettings( !1 )
          }, t.prototype.getDomNode = function () {
            return this._domNode.domNode
          }, t.prototype.prepareRender = e => {}, t.prototype.render = function ( e ) {
            this._render()
          }, t.prototype._render = function () {
            const e = this._settings.canvasWidth,
              t = this._settings.canvasHeight,
              n = this._settings.lineHeight,
              i = this._context.viewLayout,
              o = t / this._context.viewLayout.getScrollHeight(),
              r = this._context.model.getAllOverviewRulerDecorations( this._context.theme ),
              s = 6 * this._settings.pixelRatio | 0,
              a = s / 2 | 0,
              u = this._domNode.domNode.getContext( "2d" );
            null === this._settings.backgroundColor ? u.clearRect( 0, 0, e, t ) : ( u.fillStyle = this._settings.backgroundColor, u.fillRect( 0, 0, e, t ) );
            const l = this._settings.x,
              c = this._settings.w,
              d = Object.keys( r );
            d.sort();
            for ( let h = 0, p = d.length; h < p; h++ ) {
              const f = d[ h ],
                g = r[ f ];
              u.fillStyle = f;
              for ( var m = 0, _ = 0, v = 0, y = 0, b = g.length; y < b; y++ ) {
                const C = g[ 3 * y ];
                const w = g[ 3 * y + 1 ];
                const S = g[ 3 * y + 2 ];
                var O = i.getVerticalOffsetForLineNumber( w ) * o | 0;
                if ( ( D = ( i.getVerticalOffsetForLineNumber( S ) + n ) * o | 0 ) - O < s )( k = ( O + D ) / 2 | 0 ) < a ? k = a : k + a > t && ( k = t - a ), O = k - a, D = k + a;
                O > v + 1 || C !== m ? ( 0 !== y && u.fillRect( l[ m ], _, c[ m ], v - _ ), m = C, _ = O, v = D ) : D > v && ( v = D )
              }
              u.fillRect( l[ m ], _, c[ m ], v - _ )
            }
            if ( !this._settings.hideCursor ) {
              const L = 2 * this._settings.pixelRatio | 0,
                x = L / 2 | 0,
                N = this._settings.x[ 7 ],
                E = this._settings.w[ 7 ];
              u.fillStyle = this._settings.cursorColor;
              for ( _ = -100, v = -100, y = 0, b = this._cursorPositions.length; y < b; y++ ) {
                var k;
                const I = this._cursorPositions[ y ];
                ( k = i.getVerticalOffsetForLineNumber( I.lineNumber ) * o | 0 ) < x ? k = x : k + x > t && ( k = t - x );
                var D = ( O = k - x ) + L;
                O > v + 1 ? ( 0 !== y && u.fillRect( N, _, E, v - _ ), _ = O, v = D ) : D > v && ( v = D )
              }
              u.fillRect( N, _, E, v - _ )
            }
            this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && ( u.beginPath(), u.lineWidth = 1, u.strokeStyle = this._settings.borderColor, u.moveTo( 0, 0 ), u.lineTo( 0, t ), u.stroke(), u.moveTo( 0, 0 ), u.lineTo( e, 0 ), u.stroke() )
          }, t;
        } )( qe ),
        Yn = n( "MvK1" ),
        Xn = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        $n = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            return i._context = t, i._domNode = Object( We.b )( document.createElement( "canvas" ) ), i._domNode.setClassName( n ), i._domNode.setPosition( "absolute" ), i._domNode.setLayerHinting( !0 ), i._zoneManager = new Yn.b( ( e => {
              return i._context.viewLayout.getVerticalOffsetForLineNumber( e )
            } ) ), i._zoneManager.setDOMWidth( 0 ), i._zoneManager.setDOMHeight( 0 ), i._zoneManager.setOuterHeight( i._context.viewLayout.getScrollHeight() ), i._zoneManager.setLineHeight( i._context.configuration.editor.lineHeight ), i._zoneManager.setPixelRatio( i._context.configuration.editor.pixelRatio ), i._context.addEventHandler( i ), i;
          }
          return Xn( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._zoneManager = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.lineHeight && ( this._zoneManager.setLineHeight( this._context.configuration.editor.lineHeight ), this._render() ), e.pixelRatio && ( this._zoneManager.setPixelRatio( this._context.configuration.editor.pixelRatio ), this._domNode.setWidth( this._zoneManager.getDOMWidth() ), this._domNode.setHeight( this._zoneManager.getDOMHeight() ), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render() ), !0
          }, t.prototype.onFlushed = function ( e ) {
            return this._render(), !0
          }, t.prototype.onScrollChanged = function ( e ) {
            return e.scrollHeightChanged && ( this._zoneManager.setOuterHeight( e.scrollHeight ), this._render() ), !0
          }, t.prototype.onZonesChanged = function ( e ) {
            return this._render(), !0
          }, t.prototype.getDomNode = function () {
            return this._domNode.domNode
          }, t.prototype.setLayout = function ( e ) {
            this._domNode.setTop( e.top ), this._domNode.setRight( e.right );
            let t = !1;
            t = this._zoneManager.setDOMWidth( e.width ) || t, ( t = this._zoneManager.setDOMHeight( e.height ) || t ) && ( this._domNode.setWidth( this._zoneManager.getDOMWidth() ), this._domNode.setHeight( this._zoneManager.getDOMHeight() ), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render() )
          }, t.prototype.setZones = function ( e ) {
            this._zoneManager.setZones( e ), this._render()
          }, t.prototype._render = function () {
            if ( 0 === this._zoneManager.getOuterHeight() ) return !1;
            const e = this._zoneManager.getCanvasWidth(),
              t = this._zoneManager.getCanvasHeight(),
              n = this._zoneManager.resolveColorZones(),
              i = this._zoneManager.getId2Color(),
              o = this._domNode.domNode.getContext( "2d" );
            return o.clearRect( 0, 0, e, t ), n.length > 0 && this._renderOneLane( o, n, i, e ), !0
          }, t.prototype._renderOneLane = ( e, t, n, i ) => {
            for ( var o = 0, r = 0, s = 0, a = 0, u = t.length; a < u; a++ ) {
              const l = t[ a ],
                c = l.colorId,
                d = l.from,
                h = l.to;
              c !== o ? ( e.fillRect( 0, r, i, s - r ), o = c, e.fillStyle = n[ o ], r = d, s = h ) : s >= d ? s = Math.max( s, h ) : ( e.fillRect( 0, r, i, s - r ), r = d, s = h )
            }
            e.fillRect( 0, r, i, s - r )
          }, t;
        } )( Ve ),
        Zn = ( n( "7zd4" ), ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )() ),
        Qn = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n.domNode = Object( We.b )( document.createElement( "div" ) ), n.domNode.setAttribute( "role", "presentation" ), n.domNode.setAttribute( "aria-hidden", "true" ), n.domNode.setClassName( "view-rulers" ), n._renderedRulers = [], n._rulers = n._context.configuration.editor.viewInfo.rulers, n._typicalHalfwidthCharacterWidth = n._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth, n
          }
          return Zn( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return !!( e.viewInfo || e.layoutInfo || e.fontInfo ) && ( this._rulers = this._context.configuration.editor.viewInfo.rulers, this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth, !0 )
          }, t.prototype.onScrollChanged = e => {
            return e.scrollHeightChanged
          }, t.prototype.prepareRender = e => {}, t.prototype._ensureRulersCount = function () {
            const e = this._renderedRulers.length,
              t = this._rulers.length;
            if ( e !== t )
              if ( e < t )
                for ( let n = this._context.model.getTabSize(), i = t - e; i > 0; ) {
                  ( r = Object( We.b )( document.createElement( "div" ) ) ).setClassName( "view-ruler" ), r.setWidth( n ), this.domNode.appendChild( r ), this._renderedRulers.push( r ), i--
                } else
                  for ( let o = e - t; o > 0; ) {
                    var r = this._renderedRulers.pop();
                    this.domNode.removeChild( r ), o--
                  }
          }, t.prototype.render = function ( e ) {
            this._ensureRulersCount();
            for ( let t = 0, n = this._rulers.length; t < n; t++ ) {
              const i = this._renderedRulers[ t ];
              i.setHeight( Math.min( e.scrollHeight, 1e6 ) ), i.setLeft( this._rulers[ t ] * this._typicalHalfwidthCharacterWidth )
            }
          }, t;
        } )( qe );
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( $e.s );
        n && t.addRule( ".monaco-editor .view-ruler { box-shadow: 1px 0 0 0 " + n + " inset; }" )
      } ) );
      n( "2MPD" );
      const Jn = n( "MD5Z" ),
        ei = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        ti = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._scrollTop = 0, n._width = 0, n._updateWidth(), n._shouldShow = !1, n._useShadows = n._context.configuration.editor.viewInfo.scrollbar.useShadows, n._domNode = Object( We.b )( document.createElement( "div" ) ), n._domNode.setAttribute( "role", "presentation" ), n._domNode.setAttribute( "aria-hidden", "true" ), n
          }
          return ei( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype._updateShouldShow = function () {
            const e = this._useShadows && this._scrollTop > 0;
            return this._shouldShow !== e && ( this._shouldShow = e, !0 )
          }, t.prototype.getDomNode = function () {
            return this._domNode
          }, t.prototype._updateWidth = function () {
            const e = this._context.configuration.editor.layoutInfo;
            let t = 0;
            return t = 0 === e.renderMinimap || e.minimapWidth > 0 && 0 === e.minimapLeft ? e.width : e.width - e.minimapWidth - e.verticalScrollbarWidth, this._width !== t && ( this._width = t, !0 )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            let t = !1;
            return e.viewInfo && ( this._useShadows = this._context.configuration.editor.viewInfo.scrollbar.useShadows ), e.layoutInfo && ( t = this._updateWidth() ), this._updateShouldShow() || t
          }, t.prototype.onScrollChanged = function ( e ) {
            return this._scrollTop = e.scrollTop, this._updateShouldShow()
          }, t.prototype.prepareRender = e => {}, t.prototype.render = function ( e ) {
            this._domNode.setWidth( this._width ), this._domNode.setClassName( this._shouldShow ? "scroll-decoration" : "" )
          }, t;
        } )( qe );
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( Jn.lb );
        n && t.addRule( ".monaco-editor .scroll-decoration { box-shadow: " + n + " 0 6px 6px -6px inset; }" )
      } ) );
      n( "eC1c" );
      const ni = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        ii = function ( e ) {
          this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null
        },
        oi = function ( e, t ) {
          this.lineNumber = e, this.ranges = t
        };

      function ri( e ) {
        return new ii( e )
      }

      function si( e ) {
        return new oi( e.lineNumber, e.ranges.map( ri ) )
      }
      const ai = He.h,
        ui = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._previousFrameVisibleRangesWithStyle = [], n._context = t, n._lineHeight = n._context.configuration.editor.lineHeight, n._roundedSelection = n._context.configuration.editor.viewInfo.roundedSelection, n._typicalHalfwidthCharacterWidth = n._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth, n._selections = [], n._renderResult = null, n._context.addEventHandler( n ), n
          }
          return ni( t, e ), t.prototype.dispose = function () {
            this._context.removeEventHandler( this ), this._context = null, this._selections = null, this._renderResult = null, e.prototype.dispose.call( this )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.lineHeight && ( this._lineHeight = this._context.configuration.editor.lineHeight ), e.viewInfo && ( this._roundedSelection = this._context.configuration.editor.viewInfo.roundedSelection ), e.fontInfo && ( this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth ), !0
          }, t.prototype.onCursorStateChanged = function ( e ) {
            return this._selections = e.selections.slice( 0 ), !0
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollTopChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype._visibleRangesHaveGaps = e => {
            for ( let t = 0, n = e.length; t < n; t++ ) {
              if ( e[ t ].ranges.length > 1 ) return !0
            }
            return !1
          }, t.prototype._enrichVisibleRangesWithStyle = function ( e, t, n ) {
            const i = this._typicalHalfwidthCharacterWidth / 4;
            let o = null;
            let r = null;
            if ( n && n.length > 0 && t.length > 0 ) {
              const s = t[ 0 ].lineNumber;
              if ( s === e.startLineNumber )
                for ( var a = 0; !o && a < n.length; a++ ) n[ a ].lineNumber === s && ( o = n[ a ].ranges[ 0 ] );
              const u = t[ t.length - 1 ].lineNumber;
              if ( u === e.endLineNumber )
                for ( a = n.length - 1; !r && a >= 0; a-- ) n[ a ].lineNumber === u && ( r = n[ a ].ranges[ 0 ] );
              o && !o.startStyle && ( o = null ), r && !r.startStyle && ( r = null )
            }
            a = 0;
            for ( const l = t.length; a < l; a++ ) {
              const c = t[ a ].ranges[ 0 ],
                d = c.left,
                h = c.left + c.width,
                p = {
                  top: 0,
                  bottom: 0
                },
                f = {
                  top: 0,
                  bottom: 0
                };
              if ( a > 0 ) {
                const g = t[ a - 1 ].ranges[ 0 ].left,
                  m = t[ a - 1 ].ranges[ 0 ].left + t[ a - 1 ].ranges[ 0 ].width;
                li( d - g ) < i ? p.top = 2 : d > g && ( p.top = 1 ), li( h - m ) < i ? f.top = 2 : g < h && h < m && ( f.top = 1 )
              } else o && ( p.top = o.startStyle.top, f.top = o.endStyle.top );
              if ( a + 1 < l ) {
                const _ = t[ a + 1 ].ranges[ 0 ].left,
                  v = t[ a + 1 ].ranges[ 0 ].left + t[ a + 1 ].ranges[ 0 ].width;
                li( d - _ ) < i ? p.bottom = 2 : _ < d && d < v && ( p.bottom = 1 ), li( h - v ) < i ? f.bottom = 2 : h < v && ( f.bottom = 1 )
              } else r && ( p.bottom = r.startStyle.bottom, f.bottom = r.endStyle.bottom );
              c.startStyle = p, c.endStyle = f
            }
          }, t.prototype._getVisibleRangesWithStyle = function ( e, t, n ) {
            const i = ( t.linesVisibleRangesForRange( e, !0 ) || [] ).map( si ),
              o = this._visibleRangesHaveGaps( i );
            return ai || o || !this._roundedSelection || this._enrichVisibleRangesWithStyle( t.visibleRange, i, n ), i
          }, t.prototype._createSelectionPiece = ( e, t, n, i, o ) => {
            return '<div class="cslr ' + n + '" style="top:' + e.toString() + "px;left:" + i.toString() + "px;width:" + o.toString() + "px;height:" + t + 'px;"></div>'
          }, t.prototype._actualRenderOneSelection = function ( e, n, i, o ) {
            for ( let r = o.length > 0 && o[ 0 ].ranges[ 0 ].startStyle, s = this._lineHeight.toString(), a = ( this._lineHeight - 1 ).toString(), u = o.length > 0 ? o[ 0 ].lineNumber : 0, l = o.length > 0 ? o[ o.length - 1 ].lineNumber : 0, c = 0, d = o.length; c < d; c++ ) {
              for ( var h = o[ c ], p = h.lineNumber, f = p - n, g = i && ( p === l || p === u ) ? a : s, m = i && p === u ? 1 : 0, _ = "", v = 0, y = h.ranges.length; v < y; v++ ) {
                const b = h.ranges[ v ];
                if ( r ) {
                  if ( 1 === b.startStyle.top || 1 === b.startStyle.bottom ) {
                    _ += this._createSelectionPiece( m, g, t.SELECTION_CLASS_NAME, b.left - t.ROUNDED_PIECE_WIDTH, t.ROUNDED_PIECE_WIDTH );
                    let C = t.EDITOR_BACKGROUND_CLASS_NAME;
                    1 === b.startStyle.top && ( C += " " + t.SELECTION_TOP_RIGHT ), 1 === b.startStyle.bottom && ( C += " " + t.SELECTION_BOTTOM_RIGHT ), _ += this._createSelectionPiece( m, g, C, b.left - t.ROUNDED_PIECE_WIDTH, t.ROUNDED_PIECE_WIDTH )
                  }
                  if ( 1 === b.endStyle.top || 1 === b.endStyle.bottom ) {
                    _ += this._createSelectionPiece( m, g, t.SELECTION_CLASS_NAME, b.left + b.width, t.ROUNDED_PIECE_WIDTH );
                    let w = t.EDITOR_BACKGROUND_CLASS_NAME;
                    1 === b.endStyle.top && ( w += " " + t.SELECTION_TOP_LEFT ), 1 === b.endStyle.bottom && ( w += " " + t.SELECTION_BOTTOM_LEFT ), _ += this._createSelectionPiece( m, g, w, b.left + b.width, t.ROUNDED_PIECE_WIDTH )
                  }
                }
                let S = t.SELECTION_CLASS_NAME;
                r && ( 0 === b.startStyle.top && ( S += " " + t.SELECTION_TOP_LEFT ), 0 === b.startStyle.bottom && ( S += " " + t.SELECTION_BOTTOM_LEFT ), 0 === b.endStyle.top && ( S += " " + t.SELECTION_TOP_RIGHT ), 0 === b.endStyle.bottom && ( S += " " + t.SELECTION_BOTTOM_RIGHT ) ), _ += this._createSelectionPiece( m, g, S, b.left, b.width )
              }
              e[ f ] += _
            }
          }, t.prototype.prepareRender = function ( e ) {
            for ( var t = [], n = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, o = n; o <= i; o++ ) {
              t[ o - n ] = ""
            }
            for ( var r = [], s = 0, a = this._selections.length; s < a; s++ ) {
              const u = this._selections[ s ];
              if ( u.isEmpty() ) r[ s ] = null;
              else {
                const l = this._getVisibleRangesWithStyle( u, e, this._previousFrameVisibleRangesWithStyle[ s ] );
                r[ s ] = l, this._actualRenderOneSelection( t, n, this._selections.length > 1, l )
              }
            }
            this._previousFrameVisibleRangesWithStyle = r, this._renderResult = t
          }, t.prototype.render = function ( e, t ) {
            if ( !this._renderResult ) return "";
            const n = t - e;
            return n < 0 || n >= this._renderResult.length ? "" : this._renderResult[ n ]
          }, t.SELECTION_CLASS_NAME = "selected-text", t.SELECTION_TOP_LEFT = "top-left-radius", t.SELECTION_BOTTOM_LEFT = "bottom-left-radius", t.SELECTION_TOP_RIGHT = "top-right-radius", t.SELECTION_BOTTOM_RIGHT = "bottom-right-radius", t.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background", t.ROUNDED_PIECE_WIDTH = 10, t;
        } )( Qe );

      function li( e ) {
        return e < 0 ? -e : e
      }
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( Jn.z );
        n && t.addRule( ".monaco-editor .focused .selected-text { background-color: " + n + "; }" );
        const i = e.getColor( Jn.y );
        i && t.addRule( ".monaco-editor .selected-text { background-color: " + i + "; }" );
        const o = e.getColor( Jn.A );
        o && t.addRule( ".monaco-editor .view-line span.inline-selected-text { color: " + o + "; }" )
      } ) );
      n( "2Tsy" );
      const ci = function ( e, t, n, i, o, r ) {
          this.top = e, this.left = t, this.width = n, this.height = i, this.textContent = o, this.textContentClassName = r
        },
        di = ( () => {
          function e( e ) {
            this._context = e, this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle, this._lineHeight = this._context.configuration.editor.lineHeight, this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min( this._context.configuration.editor.viewInfo.cursorWidth, this._typicalHalfwidthCharacterWidth ), this._isVisible = !0, this._domNode = Object( We.b )( document.createElement( "div" ) ), this._domNode.setClassName( "cursor" ), this._domNode.setHeight( this._lineHeight ), this._domNode.setTop( 0 ), this._domNode.setLeft( 0 ), h.a.applyFontInfo( this._domNode, this._context.configuration.editor.fontInfo ), this._domNode.setDisplay( "none" ), this.updatePosition( new g.a( 1, 1 ) ), this._lastRenderedContent = "", this._renderData = null
          }
          return e.prototype.getDomNode = function () {
            return this._domNode
          }, e.prototype.getPosition = function () {
            return this._position
          }, e.prototype.show = function () {
            this._isVisible || ( this._domNode.setVisibility( "inherit" ), this._isVisible = !0 )
          }, e.prototype.hide = function () {
            this._isVisible && ( this._domNode.setVisibility( "hidden" ), this._isVisible = !1 )
          }, e.prototype.onConfigurationChanged = function ( e ) {
            return e.lineHeight && ( this._lineHeight = this._context.configuration.editor.lineHeight ), e.fontInfo && ( h.a.applyFontInfo( this._domNode, this._context.configuration.editor.fontInfo ), this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth ), e.viewInfo && ( this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle, this._lineCursorWidth = Math.min( this._context.configuration.editor.viewInfo.cursorWidth, this._typicalHalfwidthCharacterWidth ) ), !0
          }, e.prototype.onCursorPositionChanged = function ( e ) {
            return this.updatePosition( e ), !0
          }, e.prototype._prepareRender = function ( e ) {
            let t = "",
              n = "";
            if ( this._cursorStyle === ye.i.Line || this._cursorStyle === ye.i.LineThin ) {
              let i;
              const r = e.visibleRangeForPosition( this._position );
              if ( !r ) return null;
              if ( this._cursorStyle === ye.i.Line ) {
                if ( ( i = o.m( this._lineCursorWidth > 0 ? this._lineCursorWidth : 2 ) ) > 2 ) t = this._context.model.getLineContent( this._position.lineNumber ).charAt( this._position.column - 1 )
              } else i = o.m( 1 );
              const s = e.getVerticalOffsetForLineNumber( this._position.lineNumber ) - e.bigNumbersDelta;
              return new ci( s, r.left, i, this._lineHeight, t, n )
            }
            const a = e.linesVisibleRangesForRange( new m.a( this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column + 1 ), !1 );
            if ( !a || 0 === a.length || 0 === a[ 0 ].ranges.length ) return null;
            const u = a[ 0 ].ranges[ 0 ],
              l = u.width < 1 ? this._typicalHalfwidthCharacterWidth : u.width;
            if ( this._cursorStyle === ye.i.Block ) {
              const c = this._context.model.getViewLineData( this._position.lineNumber );
              t = c.content.charAt( this._position.column - 1 ), p.isHighSurrogate( c.content.charCodeAt( this._position.column - 1 ) ) && ( t += c.content.charAt( this._position.column ) );
              const d = c.tokens.findTokenIndexAtOffset( this._position.column - 1 );
              n = c.tokens.getClassName( d )
            }
            let h = e.getVerticalOffsetForLineNumber( this._position.lineNumber ) - e.bigNumbersDelta,
              f = this._lineHeight;
            return this._cursorStyle !== ye.i.Underline && this._cursorStyle !== ye.i.UnderlineThin || ( h += this._lineHeight - 2, f = 2 ), new ci( h, u.left, l, f, t, n )
          }, e.prototype.prepareRender = function ( e ) {
            this._renderData = this._prepareRender( e )
          }, e.prototype.render = function ( e ) {
            return this._renderData ? ( this._lastRenderedContent !== this._renderData.textContent && ( this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent ), this._domNode.setClassName( "cursor " + this._renderData.textContentClassName ), this._domNode.setDisplay( "block" ), this._domNode.setTop( this._renderData.top ), this._domNode.setLeft( this._renderData.left ), this._domNode.setWidth( this._renderData.width ), this._domNode.setLineHeight( this._renderData.height ), this._domNode.setHeight( this._renderData.height ), {
              domNode: this._domNode.domNode,
              position: this._position,
              contentLeft: this._renderData.left,
              height: this._renderData.height,
              width: 2
            } ) : ( this._domNode.setDisplay( "none" ), null )
          }, e.prototype.updatePosition = function ( e ) {
            this._position = e
          }, e;
        } )(),
        hi = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        pi = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._readOnly = n._context.configuration.editor.readOnly, n._cursorBlinking = n._context.configuration.editor.viewInfo.cursorBlinking, n._cursorStyle = n._context.configuration.editor.viewInfo.cursorStyle, n._selectionIsEmpty = !0, n._primaryCursor = new di( n._context ), n._secondaryCursors = [], n._renderData = [], n._domNode = Object( We.b )( document.createElement( "div" ) ), n._domNode.setAttribute( "role", "presentation" ), n._domNode.setAttribute( "aria-hidden", "true" ), n._updateDomClassName(), n._domNode.appendChild( n._primaryCursor.getDomNode() ), n._startCursorBlinkAnimation = new Gt.f, n._cursorFlatBlinkInterval = new Gt.b, n._blinkingEnabled = !1, n._editorHasFocus = !1, n._updateBlinking(), n
          }
          return hi( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this ), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose()
          }, t.prototype.getDomNode = function () {
            return this._domNode
          }, t.prototype.onConfigurationChanged = function ( e ) {
            e.readOnly && ( this._readOnly = this._context.configuration.editor.readOnly ), e.viewInfo && ( this._cursorBlinking = this._context.configuration.editor.viewInfo.cursorBlinking, this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle ), this._primaryCursor.onConfigurationChanged( e ), this._updateBlinking(), e.viewInfo && this._updateDomClassName();
            for ( let t = 0, n = this._secondaryCursors.length; t < n; t++ ) this._secondaryCursors[ t ].onConfigurationChanged( e );
            return !0
          }, t.prototype._onCursorPositionChanged = function ( e, t ) {
            if ( this._primaryCursor.onCursorPositionChanged( e ), this._updateBlinking(), this._secondaryCursors.length < t.length )
              for ( var n = t.length - this._secondaryCursors.length, i = 0; i < n; i++ ) {
                const o = new di( this._context );
                this._domNode.domNode.insertBefore( o.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling ), this._secondaryCursors.push( o )
              } else if ( this._secondaryCursors.length > t.length ) {
                const r = this._secondaryCursors.length - t.length;
                for ( i = 0; i < r; i++ ) this._domNode.removeChild( this._secondaryCursors[ 0 ].getDomNode() ), this._secondaryCursors.splice( 0, 1 )
              } for ( i = 0; i < t.length; i++ ) this._secondaryCursors[ i ].onCursorPositionChanged( t[ i ] )
          }, t.prototype.onCursorStateChanged = function ( e ) {
            for ( var t = [], n = 0, i = e.selections.length; n < i; n++ ) t[ n ] = e.selections[ n ].getPosition();
            this._onCursorPositionChanged( t[ 0 ], t.slice( 1 ) );
            const o = e.selections[ 0 ].isEmpty();
            return this._selectionIsEmpty !== o && ( this._selectionIsEmpty = o, this._updateDomClassName() ), !0
          }, t.prototype.onDecorationsChanged = e => {
            return !0
          }, t.prototype.onFlushed = e => {
            return !0
          }, t.prototype.onFocusChanged = function ( e ) {
            return this._editorHasFocus = e.isFocused, this._updateBlinking(), !1
          }, t.prototype.onLinesChanged = e => {
            return !0
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return !0
          }, t.prototype.onTokensChanged = function ( e ) {
            const t = t => {
              for ( let n = 0, i = e.ranges.length; n < i; n++ )
                if ( e.ranges[ n ].fromLineNumber <= t.lineNumber && t.lineNumber <= e.ranges[ n ].toLineNumber ) return !0;
              return !1
            };
            if ( t( this._primaryCursor.getPosition() ) ) return !0;
            for ( let n = 0; n < this._secondaryCursors.length; n++ )
              if ( t( this._secondaryCursors[ n ].getPosition() ) ) return !0;
            return !1
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype._getCursorBlinking = function () {
            return this._editorHasFocus ? this._readOnly ? ye.h.Solid : this._cursorBlinking : ye.h.Hidden
          }, t.prototype._updateBlinking = function () {
            const e = this;
            this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
            const n = this._getCursorBlinking(),
              i = n === ye.h.Hidden,
              o = n === ye.h.Solid;
            i ? this._hide() : this._show(), this._blinkingEnabled = !1, this._updateDomClassName(), i || o || ( n === ye.h.Blink ? this._cursorFlatBlinkInterval.cancelAndSet( ( () => {
              e._isVisible ? e._hide() : e._show()
            } ), t.BLINK_INTERVAL ) : this._startCursorBlinkAnimation.setIfNotSet( ( () => {
              e._blinkingEnabled = !0, e._updateDomClassName()
            } ), t.BLINK_INTERVAL ) )
          }, t.prototype._updateDomClassName = function () {
            this._domNode.setClassName( this._getClassName() )
          }, t.prototype._getClassName = function () {
            let e = "cursors-layer";
            switch ( this._selectionIsEmpty || ( e += " has-selection" ), this._cursorStyle ) {
              case ye.i.Line:
                e += " cursor-line-style";
                break;
              case ye.i.Block:
                e += " cursor-block-style";
                break;
              case ye.i.Underline:
                e += " cursor-underline-style";
                break;
              case ye.i.LineThin:
                e += " cursor-line-thin-style";
                break;
              case ye.i.BlockOutline:
                e += " cursor-block-outline-style";
                break;
              case ye.i.UnderlineThin:
                e += " cursor-underline-thin-style";
                break;
              default:
                e += " cursor-line-style"
            }
            if ( this._blinkingEnabled ) switch ( this._getCursorBlinking() ) {
              case ye.h.Blink:
                e += " cursor-blink";
                break;
              case ye.h.Smooth:
                e += " cursor-smooth";
                break;
              case ye.h.Phase:
                e += " cursor-phase";
                break;
              case ye.h.Expand:
                e += " cursor-expand";
                break;
              case ye.h.Solid:
                e += " cursor-solid";
                break;
              default:
                e += " cursor-solid"
            } else e += " cursor-solid";
            return e
          }, t.prototype._show = function () {
            this._primaryCursor.show();
            for ( let e = 0, t = this._secondaryCursors.length; e < t; e++ ) this._secondaryCursors[ e ].show();
            this._isVisible = !0
          }, t.prototype._hide = function () {
            this._primaryCursor.hide();
            for ( let e = 0, t = this._secondaryCursors.length; e < t; e++ ) this._secondaryCursors[ e ].hide();
            this._isVisible = !1
          }, t.prototype.prepareRender = function ( e ) {
            this._primaryCursor.prepareRender( e );
            for ( let t = 0, n = this._secondaryCursors.length; t < n; t++ ) this._secondaryCursors[ t ].prepareRender( e )
          }, t.prototype.render = function ( e ) {
            const t = [];
            let n = 0;
            const i = this._primaryCursor.render( e );
            i && ( t[ n++ ] = i );
            for ( let o = 0, r = this._secondaryCursors.length; o < r; o++ ) {
              const s = this._secondaryCursors[ o ].render( e );
              s && ( t[ n++ ] = s )
            }
            this._renderData = t
          }, t.prototype.getLastRenderData = function () {
            return this._renderData
          }, t.BLINK_INTERVAL = 500, t;
        } )( qe );
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( $e.g );
        if ( n ) {
          let i = e.getColor( $e.f );
          i || ( i = n.opposite() ), t.addRule( ".monaco-editor .cursor { background-color: " + n + "; border-color: " + n + "; color: " + i + "; }" ), "hc" === e.type && t.addRule( ".monaco-editor .cursors-layer.has-selection .cursor { border-left: 1px solid " + i + "; border-right: 1px solid " + i + "; }" )
        }
      } ) );
      const fi = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        gi = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._lineHeight = n._context.configuration.editor.lineHeight, n._contentWidth = n._context.configuration.editor.layoutInfo.contentWidth, n._contentLeft = n._context.configuration.editor.layoutInfo.contentLeft, n.domNode = Object( We.b )( document.createElement( "div" ) ), n.domNode.setClassName( "view-zones" ), n.domNode.setPosition( "absolute" ), n.domNode.setAttribute( "role", "presentation" ), n.domNode.setAttribute( "aria-hidden", "true" ), n.marginDomNode = Object( We.b )( document.createElement( "div" ) ), n.marginDomNode.setClassName( "margin-view-zones" ), n.marginDomNode.setPosition( "absolute" ), n.marginDomNode.setAttribute( "role", "presentation" ), n.marginDomNode.setAttribute( "aria-hidden", "true" ), n._zones = {}, n
          }
          return fi( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this ), this._zones = {}
          }, t.prototype._recomputeWhitespacesProps = function () {
            for ( var e = !1, t = Object.keys( this._zones ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ],
                r = this._zones[ o ],
                s = this._computeWhitespaceProps( r.delegate );
              this._context.viewLayout.changeWhitespace( parseInt( o, 10 ), s.afterViewLineNumber, s.heightInPx ) && ( this._safeCallOnComputedHeight( r.delegate, s.heightInPx ), e = !0 )
            }
            return e
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.lineHeight ? ( this._lineHeight = this._context.configuration.editor.lineHeight, this._recomputeWhitespacesProps() ) : ( e.layoutInfo && ( this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth, this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft ), !0 )
          }, t.prototype.onLineMappingChanged = function ( e ) {
            const t = this._recomputeWhitespacesProps();
            return t && this._context.viewLayout.onHeightMaybeChanged(), t
          }, t.prototype.onLinesDeleted = e => {
            return !0
          }, t.prototype.onScrollChanged = e => {
            return e.scrollTopChanged || e.scrollWidthChanged
          }, t.prototype.onZonesChanged = e => {
            return !0
          }, t.prototype.onLinesInserted = e => {
            return !0
          }, t.prototype._getZoneOrdinal = e => {
            return "undefined" !== typeof e.afterColumn ? e.afterColumn : 1e4
          }, t.prototype._computeWhitespaceProps = function ( e ) {
            if ( 0 === e.afterLineNumber ) return {
              afterViewLineNumber: 0,
              heightInPx: this._heightInPixels( e ),
              minWidthInPx: this._minWidthInPixels( e )
            };
            let t, n;
            if ( "undefined" !== typeof e.afterColumn ) t = this._context.model.validateModelPosition( {
              lineNumber: e.afterLineNumber,
              column: e.afterColumn
            } );
            else {
              const i = this._context.model.validateModelPosition( {
                lineNumber: e.afterLineNumber,
                column: 1
              } ).lineNumber;
              t = new g.a( i, this._context.model.getModelLineMaxColumn( i ) )
            }
            n = t.column === this._context.model.getModelLineMaxColumn( t.lineNumber ) ? this._context.model.validateModelPosition( {
              lineNumber: t.lineNumber + 1,
              column: 1
            } ) : this._context.model.validateModelPosition( {
              lineNumber: t.lineNumber,
              column: t.column + 1
            } );
            const o = this._context.model.coordinatesConverter.convertModelPositionToViewPosition( t ),
              r = this._context.model.coordinatesConverter.modelPositionIsVisible( n );
            return {
              afterViewLineNumber: o.lineNumber,
              heightInPx: r ? this._heightInPixels( e ) : 0,
              minWidthInPx: this._minWidthInPixels( e )
            }
          }, t.prototype.addZone = function ( e ) {
            const t = this._computeWhitespaceProps( e ),
              n = {
                whitespaceId: this._context.viewLayout.addWhitespace( t.afterViewLineNumber, this._getZoneOrdinal( e ), t.heightInPx, t.minWidthInPx ),
                delegate: e,
                isVisible: !1,
                domNode: Object( We.b )( e.domNode ),
                marginDomNode: e.marginDomNode ? Object( We.b )( e.marginDomNode ) : null
              };
            return this._safeCallOnComputedHeight( n.delegate, t.heightInPx ), n.domNode.setPosition( "absolute" ), n.domNode.domNode.style.width = "100%", n.domNode.setDisplay( "none" ), n.domNode.setAttribute( "monaco-view-zone", n.whitespaceId.toString() ), this.domNode.appendChild( n.domNode ), n.marginDomNode && ( n.marginDomNode.setPosition( "absolute" ), n.marginDomNode.domNode.style.width = "100%", n.marginDomNode.setDisplay( "none" ), n.marginDomNode.setAttribute( "monaco-view-zone", n.whitespaceId.toString() ), this.marginDomNode.appendChild( n.marginDomNode ) ), this._zones[ n.whitespaceId.toString() ] = n, this.setShouldRender(), n.whitespaceId
          }, t.prototype.removeZone = function ( e ) {
            if ( this._zones.hasOwnProperty( e.toString() ) ) {
              const t = this._zones[ e.toString() ];
              return delete this._zones[ e.toString() ], this._context.viewLayout.removeWhitespace( t.whitespaceId ), t.domNode.removeAttribute( "monaco-visible-view-zone" ), t.domNode.removeAttribute( "monaco-view-zone" ), t.domNode.domNode.parentNode.removeChild( t.domNode.domNode ), t.marginDomNode && ( t.marginDomNode.removeAttribute( "monaco-visible-view-zone" ), t.marginDomNode.removeAttribute( "monaco-view-zone" ), t.marginDomNode.domNode.parentNode.removeChild( t.marginDomNode.domNode ) ), this.setShouldRender(), !0
            }
            return !1
          }, t.prototype.layoutZone = function ( e ) {
            let t = !1;
            if ( this._zones.hasOwnProperty( e.toString() ) ) {
              const n = this._zones[ e.toString() ],
                i = this._computeWhitespaceProps( n.delegate );
              ( t = this._context.viewLayout.changeWhitespace( n.whitespaceId, i.afterViewLineNumber, i.heightInPx ) || t ) && ( this._safeCallOnComputedHeight( n.delegate, i.heightInPx ), this.setShouldRender() )
            }
            return t
          }, t.prototype.shouldSuppressMouseDownOnViewZone = function ( e ) {
            return !!this._zones.hasOwnProperty( e.toString() ) && this._zones[ e.toString() ].delegate.suppressMouseDown
          }, t.prototype._heightInPixels = function ( e ) {
            return "number" === typeof e.heightInPx ? e.heightInPx : "number" === typeof e.heightInLines ? this._lineHeight * e.heightInLines : this._lineHeight
          }, t.prototype._minWidthInPixels = e => {
            return "number" === typeof e.minWidthInPx ? e.minWidthInPx : 0
          }, t.prototype._safeCallOnComputedHeight = ( e, t ) => {
            if ( "function" === typeof e.onComputedHeight ) try {
              e.onComputedHeight( t )
            } catch ( n ) {
              Object( r.e )( n )
            }
          }, t.prototype._safeCallOnDomNodeTop = ( e, t ) => {
            if ( "function" === typeof e.onDomNodeTop ) try {
              e.onDomNodeTop( t )
            } catch ( n ) {
              Object( r.e )( n )
            }
          }, t.prototype.prepareRender = e => {}, t.prototype.render = function ( e ) {
            for ( var t = e.viewportData.whitespaceViewportData, n = {}, i = !1, o = 0, r = t.length; o < r; o++ ) n[ t[ o ].id.toString() ] = t[ o ], i = !0;
            const s = Object.keys( this._zones );
            for ( o = 0, r = s.length; o < r; o++ ) {
              const a = s[ o ];
              const u = this._zones[ a ];
              let l = 0;
              let c = 0;
              let d = "none";
              n.hasOwnProperty( a ) ? ( l = n[ a ].verticalOffset - e.bigNumbersDelta, c = n[ a ].height, d = "block", u.isVisible || ( u.domNode.setAttribute( "monaco-visible-view-zone", "true" ), u.isVisible = !0 ), this._safeCallOnDomNodeTop( u.delegate, e.getScrolledTopFromAbsoluteTop( n[ a ].verticalOffset ) ) ) : ( u.isVisible && ( u.domNode.removeAttribute( "monaco-visible-view-zone" ), u.isVisible = !1 ), this._safeCallOnDomNodeTop( u.delegate, e.getScrolledTopFromAbsoluteTop( -1e6 ) ) ), u.domNode.setTop( l ), u.domNode.setHeight( c ), u.domNode.setDisplay( d ), u.marginDomNode && ( u.marginDomNode.setTop( l ), u.marginDomNode.setHeight( c ), u.marginDomNode.setDisplay( d ) )
            }
            i && ( this.domNode.setWidth( Math.max( e.scrollWidth, this._contentWidth ) ), this.marginDomNode.setWidth( this._contentLeft ) )
          }, t;
        } )( qe ),
        mi = ( () => {
          function e( e, t, n, i ) {
            this.configuration = e, this.theme = t, this.model = n, this.viewLayout = n.viewLayout, this.privateViewEventBus = i
          }
          return e.prototype.addEventHandler = function ( e ) {
            this.privateViewEventBus.addEventHandler( e )
          }, e.prototype.removeEventHandler = function ( e ) {
            this.privateViewEventBus.removeEventHandler( e )
          }, e
        } )(),
        _i = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        vi = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n.onDidScroll = null, n.onDidGainFocus = null, n.onDidLoseFocus = null, n.onKeyDown = null, n.onKeyUp = null, n.onContextMenu = null, n.onMouseMove = null, n.onMouseLeave = null, n.onMouseUp = null, n.onMouseDown = null, n.onMouseDrag = null, n.onMouseDrop = null, n._viewModel = t, n
          }
          return _i( t, e ), t.prototype.emitScrollChanged = function ( e ) {
            this.onDidScroll && this.onDidScroll( e )
          }, t.prototype.emitViewFocusGained = function () {
            this.onDidGainFocus && this.onDidGainFocus( void 0 )
          }, t.prototype.emitViewFocusLost = function () {
            this.onDidLoseFocus && this.onDidLoseFocus( void 0 )
          }, t.prototype.emitKeyDown = function ( e ) {
            this.onKeyDown && this.onKeyDown( e )
          }, t.prototype.emitKeyUp = function ( e ) {
            this.onKeyUp && this.onKeyUp( e )
          }, t.prototype.emitContextMenu = function ( e ) {
            this.onContextMenu && this.onContextMenu( this._convertViewToModelMouseEvent( e ) )
          }, t.prototype.emitMouseMove = function ( e ) {
            this.onMouseMove && this.onMouseMove( this._convertViewToModelMouseEvent( e ) )
          }, t.prototype.emitMouseLeave = function ( e ) {
            this.onMouseLeave && this.onMouseLeave( this._convertViewToModelMouseEvent( e ) )
          }, t.prototype.emitMouseUp = function ( e ) {
            this.onMouseUp && this.onMouseUp( this._convertViewToModelMouseEvent( e ) )
          }, t.prototype.emitMouseDown = function ( e ) {
            this.onMouseDown && this.onMouseDown( this._convertViewToModelMouseEvent( e ) )
          }, t.prototype.emitMouseDrag = function ( e ) {
            this.onMouseDrag && this.onMouseDrag( this._convertViewToModelMouseEvent( e ) )
          }, t.prototype.emitMouseDrop = function ( e ) {
            this.onMouseDrop && this.onMouseDrop( this._convertViewToModelMouseEvent( e ) )
          }, t.prototype._convertViewToModelMouseEvent = function ( e ) {
            return e.target ? {
              event: e.event,
              target: this._convertViewToModelMouseTarget( e.target )
            } : e
          }, t.prototype._convertViewToModelMouseTarget = function ( e ) {
            return new yi( e.element, e.type, e.mouseColumn, e.position ? this._convertViewToModelPosition( e.position ) : null, e.range ? this._convertViewToModelRange( e.range ) : null, e.detail )
          }, t.prototype._convertViewToModelPosition = function ( e ) {
            return this._viewModel.coordinatesConverter.convertViewPositionToModelPosition( e )
          }, t.prototype._convertViewToModelRange = function ( e ) {
            return this._viewModel.coordinatesConverter.convertViewRangeToModelRange( e )
          }, t
        } )( a.a ),
        yi = ( () => {
          function e( e, t, n, i, o, r ) {
            this.element = e, this.type = t, this.mouseColumn = n, this.position = i, this.range = o, this.detail = r
          }
          return e.prototype.toString = function () {
            return Vt.toString( this )
          }, e
        } )(),
        bi = ( () => {
          function e( e, t, n, i ) {
            this.selections = e, this.startLineNumber = 0 | t.startLineNumber, this.endLineNumber = 0 | t.endLineNumber, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = 0 | t.bigNumbersDelta, this.whitespaceViewportData = n, this._model = i, this.visibleRange = new m.a( t.startLineNumber, this._model.getLineMinColumn( t.startLineNumber ), t.endLineNumber, this._model.getLineMaxColumn( t.endLineNumber ) )
          }
          return e.prototype.getViewLineRenderingData = function ( e ) {
            return this._model.getViewLineRenderingData( this.visibleRange, e )
          }, e.prototype.getDecorationsInViewport = function () {
            return this._model.getDecorationsInViewport( this.visibleRange )
          }, e
        } )(),
        Ci = n( "GJhM" ),
        wi = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Si = ( e => {
          function t( t, n, i, r ) {
            const s = e.call( this, t ) || this,
              a = s._context.configuration.editor.viewInfo.scrollbar,
              u = {
                listenOnDomNode: i.domNode,
                className: "editor-scrollable " + Object( Fe.d )( t.theme.type ),
                useShadows: !1,
                lazyRender: !0,
                vertical: a.vertical,
                horizontal: a.horizontal,
                verticalHasArrows: a.verticalHasArrows,
                horizontalHasArrows: a.horizontalHasArrows,
                verticalScrollbarSize: a.verticalScrollbarSize,
                verticalSliderSize: a.verticalSliderSize,
                horizontalScrollbarSize: a.horizontalScrollbarSize,
                horizontalSliderSize: a.horizontalSliderSize,
                handleMouseWheel: a.handleMouseWheel,
                arrowSize: a.arrowSize,
                mouseWheelScrollSensitivity: a.mouseWheelScrollSensitivity
              };
            s.scrollbar = s._register( new Ci.c( n.domNode, u, s._context.viewLayout.scrollable ) ), Ge.write( s.scrollbar.getDomNode(), 5 ), s.scrollbarDomNode = Object( We.b )( s.scrollbar.getDomNode() ), s.scrollbarDomNode.setPosition( "absolute" ), s._setLayout();
            const l = ( e, t, n ) => {
              const i = {};
              if ( t ) {
                const o = e.scrollTop;
                o && ( i.scrollTop = s._context.viewLayout.getCurrentScrollTop() + o, e.scrollTop = 0 )
              }
              if ( n ) {
                const r = e.scrollLeft;
                r && ( i.scrollLeft = s._context.viewLayout.getCurrentScrollLeft() + r, e.scrollLeft = 0 )
              }
              s._context.viewLayout.setScrollPositionNow( i )
            };
            return s._register( o.g( i.domNode, "scroll", ( e => {
              return l( i.domNode, !0, !0 )
            } ) ) ), s._register( o.g( n.domNode, "scroll", ( e => {
              return l( n.domNode, !0, !1 )
            } ) ) ), s._register( o.g( r.domNode, "scroll", ( e => {
              return l( r.domNode, !0, !1 )
            } ) ) ), s._register( o.g( s.scrollbarDomNode.domNode, "scroll", ( e => {
              return l( s.scrollbarDomNode.domNode, !0, !1 )
            } ) ) ), s;
          }
          return wi( t, e ), t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t.prototype._setLayout = function () {
            const e = this._context.configuration.editor.layoutInfo;
            this.scrollbarDomNode.setLeft( e.contentLeft ), "right" === this._context.configuration.editor.viewInfo.minimap.side ? this.scrollbarDomNode.setWidth( e.contentWidth + e.minimapWidth ) : this.scrollbarDomNode.setWidth( e.contentWidth ), this.scrollbarDomNode.setHeight( e.contentHeight )
          }, t.prototype.getOverviewRulerLayoutInfo = function () {
            return this.scrollbar.getOverviewRulerLayoutInfo()
          }, t.prototype.getDomNode = function () {
            return this.scrollbarDomNode
          }, t.prototype.delegateVerticalScrollbarMouseDown = function ( e ) {
            this.scrollbar.delegateVerticalScrollbarMouseDown( e )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            if ( e.viewInfo ) {
              const t = this._context.configuration.editor,
                n = {
                  handleMouseWheel: t.viewInfo.scrollbar.handleMouseWheel,
                  mouseWheelScrollSensitivity: t.viewInfo.scrollbar.mouseWheelScrollSensitivity
                };
              this.scrollbar.updateOptions( n )
            }
            return e.layoutInfo && this._setLayout(), !0
          }, t.prototype.onScrollChanged = e => {
            return !0
          }, t.prototype.onThemeChanged = function ( e ) {
            return this.scrollbar.updateClassName( "editor-scrollable " + Object( Fe.d )( this._context.theme.type ) ), !0
          }, t.prototype.prepareRender = e => {}, t.prototype.render = function ( e ) {
            this.scrollbar.renderNow()
          }, t;
        } )( qe );
      n( "8gvo" );

      function Oi( e ) {
        for ( var t = new Uint8ClampedArray( e.length ), n = 0, i = e.length; n < i; n++ ) t[ n ] = e[ n ];
        return t
      }
      let Li = null;

      function xi() {
        if ( !Li ) {
          const e = Oi( Ei );
          Ei = null;
          const t = Oi( Ni );
          Ni = null, Li = new me( t, e )
        }
        return Li
      }
      var Ni = [ 0, 0, 0, 0, 0, 0, 0, 0, 39, 14, 39, 14, 14, 5, 29, 10, 96, 96, 29, 29, 0, 0, 0, 0, 49, 113, 195, 214, 227, 166, 135, 42, 40, 29, 194, 38, 75, 148, 197, 187, 145, 0, 160, 61, 75, 143, 2, 183, 138, 58, 163, 6, 177, 223, 197, 227, 38, 13, 11, 4, 0, 0, 0, 0, 10, 54, 52, 8, 62, 4, 71, 122, 73, 2, 19, 40, 10, 50, 155, 36, 79, 70, 145, 121, 7, 5, 0, 0, 2, 1, 36, 12, 204, 166, 16, 5, 0, 0, 0, 0, 1, 0, 154, 34, 0, 0, 0, 0, 96, 83, 0, 0, 0, 0, 0, 0, 0, 0, 46, 34, 0, 82, 2, 56, 53, 3, 146, 0, 146, 119, 152, 132, 152, 131, 145, 119, 170, 42, 15, 42, 15, 42, 172, 194, 131, 132, 0, 139, 80, 28, 227, 143, 159, 135, 15, 118, 11, 126, 171, 144, 20, 124, 88, 106, 217, 196, 0, 106, 189, 92, 168, 43, 5, 130, 164, 133, 130, 115, 183, 65, 134, 120, 141, 141, 170, 196, 2, 106, 31, 32, 105, 2, 145, 130, 116, 114, 132, 135, 138, 140, 138, 113, 147, 137, 81, 183, 129, 94, 0, 0, 21, 16, 4, 3, 46, 34, 0, 0, 45, 34, 1, 0, 160, 49, 0, 0, 43, 143, 203, 23, 1, 76, 0, 0, 38, 28, 131, 96, 38, 28, 0, 0, 168, 31, 29, 191, 98, 0, 118, 139, 5, 113, 45, 13, 37, 6, 97, 115, 161, 179, 204, 105, 223, 224, 83, 52, 111, 100, 184, 186, 120, 132, 212, 145, 180, 139, 174, 161, 212, 182, 104, 162, 131, 0, 131, 0, 104, 161, 219, 120, 110, 116, 110, 116, 219, 120, 207, 154, 163, 40, 147, 22, 207, 154, 202, 159, 161, 47, 145, 23, 111, 0, 139, 154, 144, 30, 144, 135, 139, 187, 110, 110, 168, 161, 150, 145, 110, 110, 185, 162, 43, 16, 43, 16, 185, 162, 73, 129, 0, 110, 0, 110, 191, 87, 149, 149, 236, 48, 195, 91, 146, 149, 146, 0, 146, 0, 146, 0, 187, 173, 200, 201, 222, 215, 172, 147, 95, 95, 193, 97, 224, 129, 159, 206, 97, 192, 155, 139, 153, 115, 153, 115, 156, 140, 189, 158, 123, 136, 190, 64, 111, 0, 155, 139, 153, 115, 153, 114, 156, 241, 197, 148, 150, 152, 170, 116, 110, 157, 156, 128, 169, 14, 13, 159, 158, 149, 212, 189, 43, 16, 43, 16, 43, 16, 148, 110, 148, 110, 147, 109, 182, 151, 133, 121, 106, 118, 114, 103, 89, 66, 94, 94, 211, 188, 205, 207, 139, 168, 151, 152, 87, 76, 101, 79, 151, 152, 130, 156, 125, 116, 47, 29, 43, 16, 169, 228, 11, 103, 120, 6, 230, 176, 55, 49, 55, 6, 55, 6, 193, 102, 92, 0, 71, 0, 13, 30, 0, 147, 63, 43, 12, 43, 12, 43, 142, 152, 71, 53, 61, 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 146, 25, 2, 0, 0, 0, 0, 0, 0, 0, 0, 107, 130, 170, 194, 176, 188, 109, 0, 203, 159, 113, 111, 202, 158, 0, 0, 135, 135, 114, 0, 136, 135, 0, 109, 187, 190, 148, 126, 177, 187, 0, 0, 149, 130, 218, 105, 169, 135, 37, 113, 146, 113, 49, 13, 49, 13, 0, 0, 178, 195, 147, 114, 255, 255, 109, 0, 193, 149, 110, 109, 109, 109, 12, 15, 125, 41, 33, 41, 144, 188, 1, 6, 75, 53, 10, 53, 210, 161, 110, 0, 152, 148, 210, 60, 110, 156, 213, 5, 63, 5, 63, 5, 45, 111, 0, 0, 232, 172, 190, 168, 190, 169, 0, 0, 190, 144, 109, 109, 109, 109, 0, 0, 168, 140, 148, 111, 168, 140, 0, 0, 200, 151, 113, 110, 255, 158, 0, 0, 184, 188, 147, 139, 186, 255, 0, 0, 122, 130, 111, 0, 109, 0, 0, 0, 132, 69, 109, 93, 110, 136, 51, 5, 205, 103, 61, 6, 47, 106, 0, 0, 110, 109, 110, 122, 155, 179, 0, 0, 132, 120, 113, 114, 84, 63, 0, 0, 124, 108, 202, 189, 160, 174, 0, 0, 144, 142, 79, 57, 159, 146, 0, 0, 138, 138, 119, 117, 255, 69, 0, 0, 97, 198, 47, 38, 208, 84, 23, 112, 41, 14, 157, 7, 121, 192, 35, 11, 35, 11, 35, 11, 160, 61, 129, 9, 40, 19, 20, 139, 236, 44, 0, 0, 15, 3, 97, 93, 0, 0 ];
      var Ei = [ 0, 0, 23, 12, 53, 0, 130, 127, 58, 149, 67, 77, 72, 198, 13, 0, 25, 51, 25, 49, 94, 2, 8, 64, 0, 24, 0, 21, 0, 9, 19, 27, 126, 126, 51, 80, 72, 105, 87, 98, 73, 93, 106, 85, 111, 123, 87, 30, 116, 126, 123, 110, 4, 16, 9, 28, 21, 53, 8, 62, 23, 52, 73, 21, 132, 183, 78, 142, 168, 175, 70, 70, 128, 128, 123, 110, 125, 43, 100, 139, 125, 119, 78, 78, 54, 77, 139, 139, 33, 87, 201, 117, 162, 149, 130, 130, 138, 60, 130, 172, 149, 127, 95, 98, 95, 25, 118, 135, 110, 85, 147, 175, 105, 110, 121, 30, 101, 113, 34, 68, 20, 26, 34, 68, 56, 0, 0, 44, 3, 0, 27, 175, 80, 133, 31, 66, 85, 147, 32, 150, 90, 25, 45, 230, 77, 101, 36, 83, 22, 84, 71, 118, 44, 44, 52, 172, 38, 101, 35, 130, 40, 197, 43, 197, 29, 26, 23, 103, 67, 44, 25, 129, 29, 85, 27, 177, 33, 97, 32, 145, 33, 77, 38, 96, 20, 55, 36, 95, 2, 22 ];
      const ki = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      function Ii( e ) {
        return 2 === e ? 4 : 4 === e ? 6 : 1 === e ? 2 : 3
      }

      function Di( e ) {
        return 2 === e ? 2 : 4 === e ? 2 : 1
      }
      const Mi = 140,
        Ti = ( () => {
          function e( e ) {
            const t = e.editor.pixelRatio,
              n = e.editor.layoutInfo,
              i = e.editor.viewInfo,
              o = e.editor.fontInfo;
            this.renderMinimap = 0 | n.renderMinimap, this.scrollBeyondLastLine = i.scrollBeyondLastLine, this.showSlider = i.minimap.showSlider, this.pixelRatio = t, this.typicalHalfwidthCharacterWidth = o.typicalHalfwidthCharacterWidth, this.lineHeight = e.editor.lineHeight, this.minimapLeft = n.minimapLeft, this.minimapWidth = n.minimapWidth, this.minimapHeight = n.height, this.canvasInnerWidth = Math.max( 1, Math.floor( t * this.minimapWidth ) ), this.canvasInnerHeight = Math.max( 1, Math.floor( t * this.minimapHeight ) ), this.canvasOuterWidth = this.canvasInnerWidth / t, this.canvasOuterHeight = this.canvasInnerHeight / t
          }
          return e.prototype.equals = function ( e ) {
            return this.renderMinimap === e.renderMinimap && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.showSlider === e.showSlider && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight
          }, e
        } )(),
        Ri = ( () => {
          function e( e, t, n, i, o, r, s ) {
            this.scrollTop = e, this.scrollHeight = t, this._computedSliderRatio = n, this.sliderTop = i, this.sliderHeight = o, this.startLineNumber = r, this.endLineNumber = s
          }
          return e.prototype.getDesiredScrollTopFromDelta = function ( e ) {
            const t = this.sliderTop + e;
            return Math.round( t / this._computedSliderRatio )
          }, e.create = ( t, n, i, o, r, s, a, u, l ) => {
            let c;
            let d;
            const h = t.pixelRatio;
            const p = Ii( t.renderMinimap );
            const f = Math.floor( t.canvasInnerHeight / p );
            const g = t.lineHeight;
            if ( r && i !== s ) {
              const m = i - n + 1;
              c = Math.floor( m * p / h )
            } else {
              const _ = o / g;
              c = Math.floor( _ * p / h )
            }
            d = t.scrollBeyondLastLine ? ( s - 1 ) * p / h : Math.max( 0, s * p / h - c );
            const v = ( d = Math.min( t.minimapHeight - c, d ) ) / ( u - o ),
              y = a * v;
            if ( f >= s ) return new e( a, u, v, y, c, b = 1, s );
            var b = Math.max( 1, Math.floor( n - y * h / p ) );
            return l && l.scrollHeight === u && ( l.scrollTop > a && ( b = Math.min( b, l.startLineNumber ) ), l.scrollTop < a && ( b = Math.max( b, l.startLineNumber ) ) ), new e( a, u, v, y, c, b, Math.min( s, b + f - 1 ) )
          }, e;
        } )(),
        Pi = ( () => {
          function e( e ) {
            this.dy = e
          }
          return e.prototype.onContentChanged = function () {
            this.dy = -1
          }, e.prototype.onTokensChanged = function () {
            this.dy = -1
          }, e.INVALID = new e( -1 ), e
        } )(),
        Ai = ( () => {
          function e( e, t, n ) {
            this.renderedLayout = e, this._imageData = t, this._renderedLines = new dn( ( () => {
              return Pi.INVALID
            } ) ), this._renderedLines._set( e.startLineNumber, n )
          }
          return e.prototype.linesEquals = function ( e ) {
            if ( this.renderedLayout.startLineNumber !== e.startLineNumber ) return !1;
            if ( this.renderedLayout.endLineNumber !== e.endLineNumber ) return !1;
            for ( let t = this._renderedLines._get().lines, n = 0, i = t.length; n < i; n++ )
              if ( -1 === t[ n ].dy ) return !1;
            return !0
          }, e.prototype._get = function () {
            const e = this._renderedLines._get();
            return {
              imageData: this._imageData,
              rendLineNumberStart: e.rendLineNumberStart,
              lines: e.lines
            }
          }, e.prototype.onLinesChanged = function ( e ) {
            return this._renderedLines.onLinesChanged( e.fromLineNumber, e.toLineNumber )
          }, e.prototype.onLinesDeleted = function ( e ) {
            this._renderedLines.onLinesDeleted( e.fromLineNumber, e.toLineNumber )
          }, e.prototype.onLinesInserted = function ( e ) {
            this._renderedLines.onLinesInserted( e.fromLineNumber, e.toLineNumber )
          }, e.prototype.onTokensChanged = function ( e ) {
            return this._renderedLines.onTokensChanged( e.ranges )
          }, e;
        } )(),
        Fi = ( () => {
          function e( t, n, i, o ) {
            this._backgroundFillData = e._createBackgroundFillData( n, i, o ), this._buffers = [ t.createImageData( n, i ), t.createImageData( n, i ) ], this._lastUsedBuffer = 0
          }
          return e.prototype.getBuffer = function () {
            this._lastUsedBuffer = 1 - this._lastUsedBuffer;
            const e = this._buffers[ this._lastUsedBuffer ];
            return e.data.set( this._backgroundFillData ), e
          }, e._createBackgroundFillData = ( e, t, n ) => {
            for ( var i = n.r, o = n.g, r = n.b, s = new Uint8ClampedArray( e * t * 4 ), a = 0, u = 0; u < t; u++ )
              for ( let l = 0; l < e; l++ ) s[ a ] = i, s[ a + 1 ] = o, s[ a + 2 ] = r, s[ a + 3 ] = 255, a += 4;
            return s
          }, e;
        } )(),
        Wi = ( e => {
          function t( t ) {
            const n = e.call( this, t ) || this;
            return n._options = new Ti( n._context.configuration ), n._lastRenderData = null, n._buffers = null, n._domNode = Object( We.b )( document.createElement( "div" ) ), Ge.write( n._domNode, 8 ), n._domNode.setClassName( n._getMinimapDomNodeClassName() ), n._domNode.setPosition( "absolute" ), n._domNode.setAttribute( "role", "presentation" ), n._domNode.setAttribute( "aria-hidden", "true" ), n._shadow = Object( We.b )( document.createElement( "div" ) ), n._shadow.setClassName( "minimap-shadow-hidden" ), n._domNode.appendChild( n._shadow ), n._canvas = Object( We.b )( document.createElement( "canvas" ) ), n._canvas.setPosition( "absolute" ), n._canvas.setLeft( 0 ), n._domNode.appendChild( n._canvas ), n._slider = Object( We.b )( document.createElement( "div" ) ), n._slider.setPosition( "absolute" ), n._slider.setClassName( "minimap-slider" ), n._slider.setLayerHinting( !0 ), n._domNode.appendChild( n._slider ), n._sliderHorizontal = Object( We.b )( document.createElement( "div" ) ), n._sliderHorizontal.setPosition( "absolute" ), n._sliderHorizontal.setClassName( "minimap-slider-horizontal" ), n._slider.appendChild( n._sliderHorizontal ), n._tokensColorTracker = ge.getInstance(), n._applyLayout(), n._mouseDownListener = o.j( n._canvas.domNode, "mousedown", ( e => {
              e.preventDefault();
              const t = n._options.renderMinimap;
              if ( 0 !== t && n._lastRenderData ) {
                const i = Ii( t );
                const o = n._options.pixelRatio * e.browserEvent.offsetY;
                let r = Math.floor( o / i ) + n._lastRenderData.renderedLayout.startLineNumber;
                r = Math.min( r, n._context.model.getLineCount() ), n._context.privateViewEventBus.emit( new P( new m.a( r, 1, r, 1 ), 1, !1, 0 ) )
              }
            } ) ), n._sliderMouseMoveMonitor = new ct.a, n._sliderMouseDownListener = o.j( n._slider.domNode, "mousedown", ( e => {
              if ( e.preventDefault(), e.leftButton && n._lastRenderData ) {
                const t = e.posy,
                  i = e.posx,
                  o = n._lastRenderData.renderedLayout;
                n._slider.toggleClassName( "active", !0 ), n._sliderMouseMoveMonitor.startMonitoring( ct.b, ( e => {
                  const r = Math.abs( e.posx - i );
                  if ( Be.g && r > Mi ) n._context.viewLayout.setScrollPositionNow( {
                    scrollTop: o.scrollTop
                  } );
                  else {
                    const s = e.posy - t;
                    n._context.viewLayout.setScrollPositionNow( {
                      scrollTop: o.getDesiredScrollTopFromDelta( s )
                    } )
                  }
                } ), ( () => {
                  n._slider.toggleClassName( "active", !1 )
                } ) )
              }
            } ) ), n;
          }
          return ki( t, e ), t.prototype.dispose = function () {
            this._mouseDownListener.dispose(), this._sliderMouseMoveMonitor.dispose(), this._sliderMouseDownListener.dispose(), e.prototype.dispose.call( this )
          }, t.prototype._getMinimapDomNodeClassName = function () {
            return "always" === this._options.showSlider ? "minimap slider-always" : "minimap slider-mouseover"
          }, t.prototype.getDomNode = function () {
            return this._domNode
          }, t.prototype._applyLayout = function () {
            this._domNode.setLeft( this._options.minimapLeft ), this._domNode.setWidth( this._options.minimapWidth ), this._domNode.setHeight( this._options.minimapHeight ), this._shadow.setHeight( this._options.minimapHeight ), this._canvas.setWidth( this._options.canvasOuterWidth ), this._canvas.setHeight( this._options.canvasOuterHeight ), this._canvas.domNode.width = this._options.canvasInnerWidth, this._canvas.domNode.height = this._options.canvasInnerHeight, this._slider.setWidth( this._options.minimapWidth )
          }, t.prototype._getBuffer = function () {
            return this._buffers || ( this._buffers = new Fi( this._canvas.domNode.getContext( "2d" ), this._options.canvasInnerWidth, this._options.canvasInnerHeight, this._tokensColorTracker.getColor( 2 ) ) ), this._buffers.getBuffer()
          }, t.prototype._onOptionsMaybeChanged = function () {
            const e = new Ti( this._context.configuration );
            return !this._options.equals( e ) && ( this._options = e, this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName( this._getMinimapDomNodeClassName() ), !0 )
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return this._onOptionsMaybeChanged()
          }, t.prototype.onFlushed = function ( e ) {
            return this._lastRenderData = null, !0
          }, t.prototype.onLinesChanged = function ( e ) {
            return !!this._lastRenderData && this._lastRenderData.onLinesChanged( e )
          }, t.prototype.onLinesDeleted = function ( e ) {
            return this._lastRenderData && this._lastRenderData.onLinesDeleted( e ), !0
          }, t.prototype.onLinesInserted = function ( e ) {
            return this._lastRenderData && this._lastRenderData.onLinesInserted( e ), !0
          }, t.prototype.onScrollChanged = e => {
            return !0
          }, t.prototype.onTokensChanged = function ( e ) {
            return !!this._lastRenderData && this._lastRenderData.onTokensChanged( e )
          }, t.prototype.onTokensColorsChanged = function ( e ) {
            return this._lastRenderData = null, this._buffers = null, !0
          }, t.prototype.onZonesChanged = function ( e ) {
            return this._lastRenderData = null, !0
          }, t.prototype.prepareRender = e => {}, t.prototype.render = function ( e ) {
            if ( 0 === this._options.renderMinimap ) return this._shadow.setClassName( "minimap-shadow-hidden" ), this._sliderHorizontal.setWidth( 0 ), void this._sliderHorizontal.setHeight( 0 );
            e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName( "minimap-shadow-hidden" ) : this._shadow.setClassName( "minimap-shadow-visible" );
            const t = Ri.create( this._options, e.visibleRange.startLineNumber, e.visibleRange.endLineNumber, e.viewportHeight, e.viewportData.whitespaceViewportData.length > 0, this._context.model.getLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null );
            this._slider.setTop( t.sliderTop ), this._slider.setHeight( t.sliderHeight );
            const n = e.scrollLeft / this._options.typicalHalfwidthCharacterWidth,
              i = Math.min( this._options.minimapWidth, Math.round( n * Di( this._options.renderMinimap ) / this._options.pixelRatio ) );
            this._sliderHorizontal.setLeft( i ), this._sliderHorizontal.setWidth( this._options.minimapWidth - i ), this._sliderHorizontal.setTop( 0 ), this._sliderHorizontal.setHeight( t.sliderHeight ), this._lastRenderData = this.renderLines( t )
          }, t.prototype.renderLines = function ( e ) {
            const n = this._options.renderMinimap,
              i = e.startLineNumber,
              o = e.endLineNumber,
              r = Ii( n );
            if ( this._lastRenderData && this._lastRenderData.linesEquals( e ) ) {
              const s = this._lastRenderData._get();
              return new Ai( e, s.imageData, s.lines )
            }
            for ( var a = this._getBuffer(), u = t._renderUntouchedLines( a, i, o, r, this._lastRenderData ), l = u[ 0 ], c = u[ 1 ], d = u[ 2 ], h = this._context.model.getMinimapLinesRenderingData( i, o, d ), p = h.tabSize, f = this._tokensColorTracker.getColor( 2 ), g = this._tokensColorTracker.backgroundIsLight(), m = 0, _ = [], v = 0, y = o - i + 1; v < y; v++ ) d[ v ] && t._renderLine( a, f, g, n, this._tokensColorTracker, xi(), m, p, h.data[ v ] ), _[ v ] = new Pi( m ), m += r;
            const b = -1 === l ? 0 : l,
              C = ( -1 === c ? a.height : c ) - b;
            return this._canvas.domNode.getContext( "2d" ).putImageData( a, 0, 0, 0, b, a.width, C ), new Ai( e, a, _ )
          }, t._renderUntouchedLines = ( e, t, n, i, o ) => {
            const r = [];
            if ( !o ) {
              for ( let s = 0, a = n - t + 1; s < a; s++ ) r[ s ] = !0;
              return [ -1, -1, r ]
            }
            for ( var u = o._get(), l = u.imageData.data, c = u.rendLineNumberStart, d = u.lines, h = d.length, p = e.width, f = e.data, g = ( n - t + 1 ) * i * p * 4, m = -1, _ = -1, v = -1, y = -1, b = -1, C = -1, w = 0, S = t; S <= n; S++ ) {
              const O = S - t,
                L = S - c,
                x = L >= 0 && L < h ? d[ L ].dy : -1;
              if ( -1 !== x ) {
                const N = x * p * 4,
                  E = ( x + i ) * p * 4,
                  k = w * p * 4,
                  I = ( w + i ) * p * 4;
                y === N && C === k ? ( y = E, C = I ) : ( -1 !== v && ( f.set( l.subarray( v, y ), b ), -1 === m && 0 === v && v === b && ( m = y ), -1 === _ && y === g && v === b && ( _ = v ) ), v = N, y = E, b = k, C = I ), r[ O ] = !1, w += i
              } else r[ O ] = !0, w += i
            }
            return -1 !== v && ( f.set( l.subarray( v, y ), b ), -1 === m && 0 === v && v === b && ( m = y ), -1 === _ && y === g && v === b && ( _ = v ) ), [ -1 === m ? -1 : m / ( 4 * p ), -1 === _ ? -1 : _ / ( 4 * p ), r ]
          }, t._renderLine = ( e, t, n, i, o, r, s, a, u ) => {
            for ( let l = u.content, c = u.tokens, d = Di( i ), h = e.width - d, f = 0, g = 0, m = 0, _ = 0, v = c.getCount(); _ < v; _++ )
              for ( const y = c.getEndOffset( _ ), b = c.getForeground( _ ), C = o.getColor( b ); g < y; g++ ) {
                if ( f > h ) return;
                const w = l.charCodeAt( g );
                if ( 9 === w ) {
                  const S = a - ( g + m ) % a;
                  m += S - 1, f += S * d
                } else if ( 32 === w ) f += d;
                else
                  for ( let O = p.isFullWidthCharacter( w ) ? 2 : 1, L = 0; L < O; L++ )
                    if ( 2 === i ? r.x2RenderChar( e, f, s, w, C, t, n ) : 1 === i ? r.x1RenderChar( e, f, s, w, C, t, n ) : 4 === i ? r.x2BlockRenderChar( e, f, s, C, t, n ) : r.x1BlockRenderChar( e, f, s, C, t, n ), ( f += d ) > h ) return
              }
          }, t;
        } )( qe );
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( Jn.nb );
        if ( n ) {
          const i = n.transparent( .5 );
          t.addRule( ".monaco-editor .minimap-slider, .monaco-editor .minimap-slider .minimap-slider-horizontal { background: " + i + "; }" )
        }
        const o = e.getColor( Jn.ob );
        if ( o ) {
          const r = o.transparent( .5 );
          t.addRule( ".monaco-editor .minimap-slider:hover, .monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: " + r + "; }" )
        }
        const s = e.getColor( Jn.mb );
        if ( s ) {
          const a = s.transparent( .5 );
          t.addRule( ".monaco-editor .minimap-slider.active, .monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: " + a + "; }" )
        }
        const u = e.getColor( Jn.lb );
        u && t.addRule( ".monaco-editor .minimap-shadow-visible { box-shadow: " + u + " -6px 0 6px -6px inset; }" )
      } ) );
      const ji = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Vi = ( e => {
          function t( t, n, i, o, r, s ) {
            const a = e.call( this ) || this;
            a._cursor = r, a._renderAnimationFrame = null, a.outgoingEvents = new vi( o );
            const u = new un( n, o, s, a.outgoingEvents, t );
            return a.eventDispatcher = new ln( ( e => {
              return a._renderOnce( e )
            } ) ), a.eventDispatcher.addEventHandler( a ), a._context = new mi( n, i.getTheme(), o, a.eventDispatcher ), a._register( i.onThemeChange( ( e => {
              a._context.theme = e, a.eventDispatcher.emit( new W ), a.render( !0, !1 )
            } ) ) ), a.viewParts = [], a._textAreaHandler = new st( a._context, u, a.createTextAreaHandlerHelper() ), a.viewParts.push( a._textAreaHandler ), a.createViewParts(), a._setLayout(), a.pointerHandler = new sn( a._context, u, a.createPointerHandlerHelper() ), a._register( o.addEventListener( ( e => {
              a.eventDispatcher.emitMany( e )
            } ) ) ), a._register( a._cursor.addEventListener( ( e => {
              a.eventDispatcher.emitMany( e )
            } ) ) ), a;
          }
          return ji( t, e ), t.prototype.createViewParts = function () {
            this.linesContent = Object( We.b )( document.createElement( "div" ) ), this.linesContent.setClassName( "lines-content monaco-editor-background" ), this.linesContent.setPosition( "absolute" ), this.domNode = Object( We.b )( document.createElement( "div" ) ), this.domNode.setClassName( this.getEditorClassName() ), this.overflowGuardContainer = Object( We.b )( document.createElement( "div" ) ), Ge.write( this.overflowGuardContainer, 3 ), this.overflowGuardContainer.setClassName( "overflow-guard" ), this._scrollbar = new Si( this._context, this.linesContent, this.domNode, this.overflowGuardContainer ), this.viewParts.push( this._scrollbar ), this.viewLines = new Wn( this._context, this.linesContent ), this.viewZones = new gi( this._context ), this.viewParts.push( this.viewZones );
            const e = new Gn( this._context );
            this.viewParts.push( e );
            const t = new ti( this._context );
            this.viewParts.push( t );
            const n = new _n( this._context );
            this.viewParts.push( n ), n.addDynamicOverlay( new On( this._context ) ), n.addDynamicOverlay( new ui( this._context ) ), n.addDynamicOverlay( new Rn( this._context ) ), n.addDynamicOverlay( new En( this._context ) );
            const i = new vn( this._context );
            this.viewParts.push( i ), i.addDynamicOverlay( new xn( this._context ) ), i.addDynamicOverlay( new Mn( this._context ) ), i.addDynamicOverlay( new Hn( this._context ) ), i.addDynamicOverlay( new Vn( this._context ) ), i.addDynamicOverlay( new et( this._context ) );
            const o = new Xe( this._context );
            o.getDomNode().appendChild( this.viewZones.marginDomNode ), o.getDomNode().appendChild( i.getDomNode() ), this.viewParts.push( o ), this.contentWidgets = new Cn( this._context, this.domNode ), this.viewParts.push( this.contentWidgets ), this.viewCursors = new pi( this._context ), this.viewParts.push( this.viewCursors ), this.overlayWidgets = new Un( this._context ), this.viewParts.push( this.overlayWidgets );
            const r = new Qn( this._context );
            this.viewParts.push( r );
            const s = new Wi( this._context );
            if ( this.viewParts.push( s ), e ) {
              const a = this._scrollbar.getOverviewRulerLayoutInfo();
              a.parent.insertBefore( e.getDomNode(), a.insertBefore )
            }
            this.linesContent.appendChild( n.getDomNode() ), this.linesContent.appendChild( r.domNode ), this.linesContent.appendChild( this.viewZones.domNode ), this.linesContent.appendChild( this.viewLines.getDomNode() ), this.linesContent.appendChild( this.contentWidgets.domNode ), this.linesContent.appendChild( this.viewCursors.getDomNode() ), this.overflowGuardContainer.appendChild( o.getDomNode() ), this.overflowGuardContainer.appendChild( this._scrollbar.getDomNode() ), this.overflowGuardContainer.appendChild( t.getDomNode() ), this.overflowGuardContainer.appendChild( this._textAreaHandler.textArea ), this.overflowGuardContainer.appendChild( this._textAreaHandler.textAreaCover ), this.overflowGuardContainer.appendChild( this.overlayWidgets.getDomNode() ), this.overflowGuardContainer.appendChild( s.getDomNode() ), this.domNode.appendChild( this.overflowGuardContainer ), this.domNode.appendChild( this.contentWidgets.overflowingContentWidgetsDomNode )
          }, t.prototype._flushAccumulatedAndRenderNow = function () {
            this._renderNow()
          }, t.prototype.createPointerHandlerHelper = function () {
            const e = this;
            return {
              viewDomNode: this.domNode.domNode,
              linesContentDomNode: this.linesContent.domNode,
              focusTextArea() {
                e.focus()
              },
              getLastViewCursorsRenderData() {
                return e.viewCursors.getLastRenderData() || []
              },
              shouldSuppressMouseDownOnViewZone( t ) {
                return e.viewZones.shouldSuppressMouseDownOnViewZone( t )
              },
              shouldSuppressMouseDownOnWidget( t ) {
                return e.contentWidgets.shouldSuppressMouseDownOnWidget( t )
              },
              getPositionFromDOMInfo( t, n ) {
                return e._flushAccumulatedAndRenderNow(), e.viewLines.getPositionFromDOMInfo( t, n )
              },
              visibleRangeForPosition2( t, n ) {
                e._flushAccumulatedAndRenderNow();
                const i = e.viewLines.visibleRangesForRange2( new m.a( t, n, t, n ) );
                return i ? i[ 0 ] : null
              },
              getLineWidth( t ) {
                return e._flushAccumulatedAndRenderNow(), e.viewLines.getLineWidth( t )
              }
            };
          }, t.prototype.createTextAreaHandlerHelper = function () {
            const e = this;
            return {
              visibleRangeForPositionRelativeToEditor( t, n ) {
                e._flushAccumulatedAndRenderNow();
                const i = e.viewLines.visibleRangesForRange2( new m.a( t, n, t, n ) );
                return i ? i[ 0 ] : null
              }
            };
          }, t.prototype._setLayout = function () {
            const e = this._context.configuration.editor.layoutInfo;
            this.domNode.setWidth( e.width ), this.domNode.setHeight( e.height ), this.overflowGuardContainer.setWidth( e.width ), this.overflowGuardContainer.setHeight( e.height ), this.linesContent.setWidth( 1e6 ), this.linesContent.setHeight( 1e6 )
          }, t.prototype.getEditorClassName = function () {
            const e = this._textAreaHandler.isFocused() ? " focused" : "";
            return this._context.configuration.editor.editorClassName + " " + Object( Fe.d )( this._context.theme.type ) + e
          }, t.prototype.onConfigurationChanged = function ( e ) {
            return e.editorClassName && this.domNode.setClassName( this.getEditorClassName() ), e.layoutInfo && this._setLayout(), !1
          }, t.prototype.onFocusChanged = function ( e ) {
            return this.domNode.setClassName( this.getEditorClassName() ), this._context.model.setHasFocus( e.isFocused ), e.isFocused ? this.outgoingEvents.emitViewFocusGained() : this.outgoingEvents.emitViewFocusLost(), !1
          }, t.prototype.onScrollChanged = function ( e ) {
            return this.outgoingEvents.emitScrollChanged( e ), !1
          }, t.prototype.onThemeChanged = function ( e ) {
            return this.domNode.setClassName( this.getEditorClassName() ), !1
          }, t.prototype.dispose = function () {
            null !== this._renderAnimationFrame && ( this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null ), this.eventDispatcher.removeEventHandler( this ), this.outgoingEvents.dispose(), this.pointerHandler.dispose(), this.viewLines.dispose();
            for ( let t = 0, n = this.viewParts.length; t < n; t++ ) this.viewParts[ t ].dispose();
            this.viewParts = [], e.prototype.dispose.call( this )
          }, t.prototype._renderOnce = function ( e ) {
            const t = Bi( e );
            return this._scheduleRender(), t
          }, t.prototype._scheduleRender = function () {
            null === this._renderAnimationFrame && ( this._renderAnimationFrame = o.J( this._onRenderScheduled.bind( this ), 100 ) )
          }, t.prototype._onRenderScheduled = function () {
            this._renderAnimationFrame = null, this._flushAccumulatedAndRenderNow()
          }, t.prototype._renderNow = function () {
            const e = this;
            Bi( ( () => {
              return e._actualRender()
            } ) )
          }, t.prototype._getViewPartsToRender = function () {
            for ( var e = [], t = 0, n = 0, i = this.viewParts.length; n < i; n++ ) {
              const o = this.viewParts[ n ];
              o.shouldRender() && ( e[ t++ ] = o )
            }
            return e
          }, t.prototype._actualRender = function () {
            if ( o.D( this.domNode.domNode ) ) {
              let e = this._getViewPartsToRender();
              if ( this.viewLines.shouldRender() || 0 !== e.length ) {
                const t = this._context.viewLayout.getLinesViewportData();
                this._context.model.setViewport( t.startLineNumber, t.endLineNumber, t.centeredLineNumber );
                const n = new bi( this._cursor.getViewSelections(), t, this._context.viewLayout.getWhitespaceViewportData(), this._context.model );
                this.contentWidgets.shouldRender() && this.contentWidgets.onBeforeRender( n ), this.viewLines.shouldRender() && ( this.viewLines.renderText( n ), this.viewLines.onDidRender(), e = this._getViewPartsToRender() );
                for ( var i = new wt( this._context.viewLayout, n, this.viewLines ), r = 0, s = e.length; r < s; r++ ) {
                  ( a = e[ r ] ).prepareRender( i )
                }
                for ( r = 0, s = e.length; r < s; r++ ) {
                  var a;
                  ( a = e[ r ] ).render( i ), a.onDidRender()
                }
              }
            }
          }, t.prototype.delegateVerticalScrollbarMouseDown = function ( e ) {
            this._scrollbar.delegateVerticalScrollbarMouseDown( e )
          }, t.prototype.restoreState = function ( e ) {
            this._context.viewLayout.setScrollPositionNow( {
              scrollTop: e.scrollTop
            } ), this._renderNow(), this.viewLines.updateLineWidths(), this._context.viewLayout.setScrollPositionNow( {
              scrollLeft: e.scrollLeft
            } )
          }, t.prototype.getOffsetForColumn = function ( e, t ) {
            const n = this._context.model.validateModelPosition( {
                lineNumber: e,
                column: t
              } ),
              i = this._context.model.coordinatesConverter.convertModelPositionToViewPosition( n );
            this._flushAccumulatedAndRenderNow();
            const o = this.viewLines.visibleRangesForRange2( new m.a( i.lineNumber, i.column, i.lineNumber, i.column ) );
            return o ? o[ 0 ].left : -1
          }, t.prototype.getTargetAtClientPoint = function ( e, t ) {
            return this.pointerHandler.getTargetAtClientPoint( e, t )
          }, t.prototype.getInternalEventBus = function () {
            return this.outgoingEvents
          }, t.prototype.createOverviewRuler = function ( e ) {
            return new $n( this._context, e )
          }, t.prototype.change = function ( e ) {
            const t = this;
            let n = !1;
            return this._renderOnce( ( () => {
              const i = {
                addZone( e ) {
                  return n = !0, t.viewZones.addZone( e )
                },
                removeZone( e ) {
                  e && ( n = t.viewZones.removeZone( e ) || n )
                },
                layoutZone( e ) {
                  e && ( n = t.viewZones.layoutZone( e ) || n )
                }
              };
              !( ( e, t ) => {
                try {
                  e( t )
                } catch ( n ) {
                  Object( r.e )( n )
                }
              } )( e, i ), i.addZone = null, i.removeZone = null, n && ( t._context.viewLayout.onHeightMaybeChanged(), t._context.privateViewEventBus.emit( new V ) )
            } ) ), n;
          }, t.prototype.render = function ( e, t ) {
            if ( t ) {
              this.viewLines.forceShouldRender();
              for ( let n = 0, i = this.viewParts.length; n < i; n++ ) {
                this.viewParts[ n ].forceShouldRender()
              }
            }
            e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender()
          }, t.prototype.focus = function () {
            this._textAreaHandler.focusTextArea()
          }, t.prototype.isFocused = function () {
            return this._textAreaHandler.isFocused()
          }, t.prototype.addContentWidget = function ( e ) {
            this.contentWidgets.addWidget( e.widget ), this.layoutContentWidget( e ), this._scheduleRender()
          }, t.prototype.layoutContentWidget = function ( e ) {
            const t = e.position ? e.position.position : null,
              n = e.position ? e.position.preference : null;
            this.contentWidgets.setWidgetPosition( e.widget, t, n ), this._scheduleRender()
          }, t.prototype.removeContentWidget = function ( e ) {
            this.contentWidgets.removeWidget( e.widget ), this._scheduleRender()
          }, t.prototype.addOverlayWidget = function ( e ) {
            this.overlayWidgets.addWidget( e.widget ), this.layoutOverlayWidget( e ), this._scheduleRender()
          }, t.prototype.layoutOverlayWidget = function ( e ) {
            const t = e.position ? e.position.preference : null;
            this.overlayWidgets.setWidgetPosition( e.widget, t ) && this._scheduleRender()
          }, t.prototype.removeOverlayWidget = function ( e ) {
            this.overlayWidgets.removeWidget( e.widget ), this._scheduleRender()
          }, t;
        } )( Ve );

      function Bi( e ) {
        try {
          return e()
        } catch ( t ) {
          Object( r.e )( t )
        }
      }
      const Hi = n( "sswD" ),
        zi = n( "9Y+e" );
      n.d( t, "a", ( () => {
        return Xi
      } ) );
      const Ui = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const Ki = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const qi = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      let Gi = 0;
      const Yi = "showUnused";

      var Xi = ( e => {
        function t( t, n, i, o, a, u, l, h, p ) {
          const f = e.call( this ) || this;
          f._onDidDispose = f._register( new s.a ), f.onDidDispose = f._onDidDispose.event, f._onDidChangeModelContent = f._register( new s.a ), f.onDidChangeModelContent = f._onDidChangeModelContent.event, f._onDidChangeModelLanguage = f._register( new s.a ), f.onDidChangeModelLanguage = f._onDidChangeModelLanguage.event, f._onDidChangeModelLanguageConfiguration = f._register( new s.a ), f.onDidChangeModelLanguageConfiguration = f._onDidChangeModelLanguageConfiguration.event, f._onDidChangeModelOptions = f._register( new s.a ), f.onDidChangeModelOptions = f._onDidChangeModelOptions.event, f._onDidChangeModelDecorations = f._register( new s.a ), f.onDidChangeModelDecorations = f._onDidChangeModelDecorations.event, f._onDidChangeConfiguration = f._register( new s.a ), f.onDidChangeConfiguration = f._onDidChangeConfiguration.event, f._onDidChangeModel = f._register( new s.a ), f.onDidChangeModel = f._onDidChangeModel.event, f._onDidChangeCursorPosition = f._register( new s.a ), f.onDidChangeCursorPosition = f._onDidChangeCursorPosition.event, f._onDidChangeCursorSelection = f._register( new s.a ), f.onDidChangeCursorSelection = f._onDidChangeCursorSelection.event, f._onDidAttemptReadOnlyEdit = f._register( new s.a ), f.onDidAttemptReadOnlyEdit = f._onDidAttemptReadOnlyEdit.event, f._onDidLayoutChange = f._register( new s.a ), f.onDidLayoutChange = f._onDidLayoutChange.event, f._editorTextFocus = f._register( new $i ), f.onDidFocusEditorText = f._editorTextFocus.onDidChangeToTrue, f.onDidBlurEditorText = f._editorTextFocus.onDidChangeToFalse, f._editorWidgetFocus = f._register( new $i ), f.onDidFocusEditorWidget = f._editorWidgetFocus.onDidChangeToTrue, f.onDidBlurEditorWidget = f._editorWidgetFocus.onDidChangeToFalse, f._onWillType = f._register( new s.a ), f.onWillType = f._onWillType.event, f._onDidType = f._register( new s.a ), f.onDidType = f._onDidType.event, f._onDidPaste = f._register( new s.a ), f.onDidPaste = f._onDidPaste.event, f._onMouseUp = f._register( new s.a ), f.onMouseUp = f._onMouseUp.event, f._onMouseDown = f._register( new s.a ), f.onMouseDown = f._onMouseDown.event, f._onMouseDrag = f._register( new s.a ), f.onMouseDrag = f._onMouseDrag.event, f._onMouseDrop = f._register( new s.a ), f.onMouseDrop = f._onMouseDrop.event, f._onContextMenu = f._register( new s.a ), f.onContextMenu = f._onContextMenu.event, f._onMouseMove = f._register( new s.a ), f.onMouseMove = f._onMouseMove.event, f._onMouseLeave = f._register( new s.a ), f.onMouseLeave = f._onMouseLeave.event, f._onKeyUp = f._register( new s.a ), f.onKeyUp = f._onKeyUp.event, f._onKeyDown = f._register( new s.a ), f.onKeyDown = f._onKeyDown.event, f._onDidScrollChange = f._register( new s.a ), f.onDidScrollChange = f._onDidScrollChange.event, f._onDidChangeViewZones = f._register( new s.a ), f.onDidChangeViewZones = f._onDidChangeViewZones.event, f.domElement = t, f.id = ++Gi, f._decorationTypeKeysToIds = {}, f._decorationTypeSubtypes = {}, f.isSimpleWidget = i.isSimpleWidget || !1, f._telemetryData = i.telemetryData || null, n = n || {}, f._configuration = f._register( f._createConfiguration( n ) ), f._register( f._configuration.onDidChange( ( e => {
            f._onDidChangeConfiguration.fire( e ), e.layoutInfo && f._onDidLayoutChange.fire( f._configuration.editor.layoutInfo ), f._configuration.editor.showUnused ? f.domElement.classList.add( Yi ) : f.domElement.classList.remove( Yi )
          } ) ) ), f._contextKeyService = f._register( l.createScoped( f.domElement ) ), f._notificationService = p, f._codeEditorService = a, f._commandService = u, f._themeService = h, f._register( new Zi( f, f._contextKeyService ) ), f._register( new Qi( f, f._contextKeyService ) ), f._instantiationService = o.createChild( new c.a( [ d.e, f._contextKeyService ] ) ), f._attachModel( null ), f._contributions = {}, f._actions = {}, f._focusTracker = new Ji( t ), f._focusTracker.onChange( ( () => {
            f._editorWidgetFocus.setValue( f._focusTracker.hasFocus() )
          } ) ), f.contentWidgets = {}, f.overlayWidgets = {};
          let g = i.contributions;
          Array.isArray( g ) || ( g = Hi.d.getEditorContributions() );
          for ( let m = 0, _ = g.length; m < _; m++ ) {
            const v = g[ m ];
            try {
              const y = f._instantiationService.createInstance( v, f );
              f._contributions[ y.getId() ] = y
            } catch ( b ) {
              Object( r.e )( b )
            }
          }
          return Hi.d.getEditorActions().forEach( ( e => {
            const t = new zi.a( e.id, e.label, e.alias, e.precondition, ( () => {
              return f._instantiationService.invokeFunction( ( t => {
                return e.runEditorCommand( t, f, null )
              } ) );
            } ), f._contextKeyService );
            f._actions[ t.id ] = t
          } ) ), f._codeEditorService.addCodeEditor( f ), f;
        }
        return Ui( t, e ), t.prototype._createConfiguration = function ( e ) {
          return new h.a( e, this.domElement )
        }, t.prototype.getId = function () {
          return this.getEditorType() + ":" + this.id
        }, t.prototype.getEditorType = () => {
          return C.a.ICodeEditor
        }, t.prototype.dispose = function () {
          this._codeEditorService.removeCodeEditor( this ), this.contentWidgets = {}, this.overlayWidgets = {}, this._focusTracker.dispose();
          for ( let t = Object.keys( this._contributions ), n = 0, i = t.length; n < i; n++ ) {
            const o = t[ n ];
            this._contributions[ o ].dispose()
          }
          this._contributions = {}, this._actions = {}, this._removeDecorationTypes(), this._postDetachModelCleanup( this._detachModel() ), this._onDidDispose.fire(), e.prototype.dispose.call( this )
        }, t.prototype.invokeWithinContext = function ( e ) {
          return this._instantiationService.invokeFunction( e )
        }, t.prototype.updateOptions = function ( e ) {
          this._configuration.updateOptions( e )
        }, t.prototype.getConfiguration = function () {
          return this._configuration.editor
        }, t.prototype.getRawConfiguration = function () {
          return this._configuration.getRawOptions()
        }, t.prototype.getValue = function ( e ) {
          if ( void 0 === e && ( e = null ), this.model ) {
            const t = !( !e || !e.preserveBOM );
            let n = v.c.TextDefined;
            return e && e.lineEnding && "\n" === e.lineEnding ? n = v.c.LF : e && e.lineEnding && "\r\n" === e.lineEnding && ( n = v.c.CRLF ), this.model.getValue( n, t )
          }
          return ""
        }, t.prototype.setValue = function ( e ) {
          this.model && this.model.setValue( e )
        }, t.prototype.getModel = function () {
          return this.model
        }, t.prototype.setModel = function ( e ) {
          if ( void 0 === e && ( e = null ), this.model !== e ) {
            const t = this._detachModel();
            this._attachModel( e );
            const n = {
              oldModelUrl: t ? t.uri : null,
              newModelUrl: e ? e.uri : null
            };
            this._removeDecorationTypes(), this._onDidChangeModel.fire( n ), this._postDetachModelCleanup( t )
          }
        }, t.prototype._removeDecorationTypes = function () {
          if ( this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes ) {
            for ( const e in this._decorationTypeSubtypes ) {
              const t = this._decorationTypeSubtypes[ e ];
              for ( const n in t ) this._removeDecorationType( e + "-" + n )
            }
            this._decorationTypeSubtypes = {}
          }
        }, t.prototype.getVisibleRanges = function () {
          return this.hasView ? this.viewModel.getVisibleRanges() : []
        }, t.prototype.getWhitespaces = function () {
          return this.hasView ? this.viewModel.viewLayout.getWhitespaces() : []
        }, t.prototype._getVerticalOffsetForPosition = function ( e, t ) {
          const n = this.model.validatePosition( {
              lineNumber: e,
              column: t
            } ),
            i = this.viewModel.coordinatesConverter.convertModelPositionToViewPosition( n );
          return this.viewModel.viewLayout.getVerticalOffsetForLineNumber( i.lineNumber )
        }, t.prototype.getTopForLineNumber = function ( e ) {
          return this.hasView ? this._getVerticalOffsetForPosition( e, 1 ) : -1
        }, t.prototype.getTopForPosition = function ( e, t ) {
          return this.hasView ? this._getVerticalOffsetForPosition( e, t ) : -1
        }, t.prototype.setHiddenAreas = function ( e ) {
          this.viewModel && this.viewModel.setHiddenAreas( e.map( ( e => {
            return m.a.lift( e )
          } ) ) )
        }, t.prototype.getVisibleColumnFromPosition = function ( e ) {
          if ( !this.model ) return e.column;
          const t = this.model.validatePosition( e ),
            n = this.model.getOptions().tabSize;
          return f.a.visibleColumnFromColumn( this.model.getLineContent( t.lineNumber ), t.column, n ) + 1
        }, t.prototype.getPosition = function () {
          return this.cursor ? this.cursor.getPosition().clone() : null
        }, t.prototype.setPosition = function ( e ) {
          if ( this.cursor ) {
            if ( !g.a.isIPosition( e ) ) throw new Error( "Invalid arguments" );
            this.cursor.setSelections( "api", [ {
              selectionStartLineNumber: e.lineNumber,
              selectionStartColumn: e.column,
              positionLineNumber: e.lineNumber,
              positionColumn: e.column
            } ] )
          }
        }, t.prototype._sendRevealRange = function ( e, t, n, i ) {
          if ( this.model && this.cursor ) {
            if ( !m.a.isIRange( e ) ) throw new Error( "Invalid arguments" );
            const o = this.model.validateRange( e ),
              r = this.viewModel.coordinatesConverter.convertModelRangeToViewRange( o );
            this.cursor.emitCursorRevealRange( r, t, n, i )
          }
        }, t.prototype.revealLine = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._revealLine( e, 0, t )
        }, t.prototype.revealLineInCenter = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._revealLine( e, 1, t )
        }, t.prototype.revealLineInCenterIfOutsideViewport = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._revealLine( e, 2, t )
        }, t.prototype._revealLine = function ( e, t, n ) {
          if ( "number" !== typeof e ) throw new Error( "Invalid arguments" );
          this._sendRevealRange( new m.a( e, 1, e, 1 ), t, !1, n )
        }, t.prototype.revealPosition = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._revealPosition( e, 0, !0, t )
        }, t.prototype.revealPositionInCenter = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._revealPosition( e, 1, !0, t )
        }, t.prototype.revealPositionInCenterIfOutsideViewport = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._revealPosition( e, 2, !0, t )
        }, t.prototype._revealPosition = function ( e, t, n, i ) {
          if ( !g.a.isIPosition( e ) ) throw new Error( "Invalid arguments" );
          this._sendRevealRange( new m.a( e.lineNumber, e.column, e.lineNumber, e.column ), t, n, i )
        }, t.prototype.getSelection = function () {
          return this.cursor ? this.cursor.getSelection().clone() : null
        }, t.prototype.getSelections = function () {
          if ( !this.cursor ) return null;
          for ( var e = this.cursor.getSelections(), t = [], n = 0, i = e.length; n < i; n++ ) t[ n ] = e[ n ].clone();
          return t
        }, t.prototype.setSelection = function ( e ) {
          const t = _.a.isISelection( e ),
            n = m.a.isIRange( e );
          if ( !t && !n ) throw new Error( "Invalid arguments" );
          if ( t ) this._setSelectionImpl( e );
          else if ( n ) {
            const i = {
              selectionStartLineNumber: e.startLineNumber,
              selectionStartColumn: e.startColumn,
              positionLineNumber: e.endLineNumber,
              positionColumn: e.endColumn
            };
            this._setSelectionImpl( i )
          }
        }, t.prototype._setSelectionImpl = function ( e ) {
          if ( this.cursor ) {
            const t = new _.a( e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn );
            this.cursor.setSelections( "api", [ t ] )
          }
        }, t.prototype.revealLines = function ( e, t, n ) {
          void 0 === n && ( n = 0 ), this._revealLines( e, t, 0, n )
        }, t.prototype.revealLinesInCenter = function ( e, t, n ) {
          void 0 === n && ( n = 0 ), this._revealLines( e, t, 1, n )
        }, t.prototype.revealLinesInCenterIfOutsideViewport = function ( e, t, n ) {
          void 0 === n && ( n = 0 ), this._revealLines( e, t, 2, n )
        }, t.prototype._revealLines = function ( e, t, n, i ) {
          if ( "number" !== typeof e || "number" !== typeof t ) throw new Error( "Invalid arguments" );
          this._sendRevealRange( new m.a( e, 1, t, 1 ), n, !1, i )
        }, t.prototype.revealRange = function ( e, t, n, i ) {
          void 0 === t && ( t = 0 ), void 0 === n && ( n = !1 ), void 0 === i && ( i = !0 ), this._revealRange( e, n ? 1 : 0, i, t )
        }, t.prototype.revealRangeInCenter = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._revealRange( e, 1, !0, t )
        }, t.prototype.revealRangeInCenterIfOutsideViewport = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._revealRange( e, 2, !0, t )
        }, t.prototype.revealRangeAtTop = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._revealRange( e, 3, !0, t )
        }, t.prototype._revealRange = function ( e, t, n, i ) {
          if ( !m.a.isIRange( e ) ) throw new Error( "Invalid arguments" );
          this._sendRevealRange( m.a.lift( e ), t, n, i )
        }, t.prototype.setSelections = function ( e ) {
          if ( this.cursor ) {
            if ( !e || 0 === e.length ) throw new Error( "Invalid arguments" );
            for ( let t = 0, n = e.length; t < n; t++ )
              if ( !_.a.isISelection( e[ t ] ) ) throw new Error( "Invalid arguments" );
            this.cursor.setSelections( "api", e )
          }
        }, t.prototype.getScrollWidth = function () {
          return this.hasView ? this.viewModel.viewLayout.getScrollWidth() : -1
        }, t.prototype.getScrollLeft = function () {
          return this.hasView ? this.viewModel.viewLayout.getCurrentScrollLeft() : -1
        }, t.prototype.getScrollHeight = function () {
          return this.hasView ? this.viewModel.viewLayout.getScrollHeight() : -1
        }, t.prototype.getScrollTop = function () {
          return this.hasView ? this.viewModel.viewLayout.getCurrentScrollTop() : -1
        }, t.prototype.setScrollLeft = function ( e ) {
          if ( this.hasView ) {
            if ( "number" !== typeof e ) throw new Error( "Invalid arguments" );
            this.viewModel.viewLayout.setScrollPositionNow( {
              scrollLeft: e
            } )
          }
        }, t.prototype.setScrollTop = function ( e ) {
          if ( this.hasView ) {
            if ( "number" !== typeof e ) throw new Error( "Invalid arguments" );
            this.viewModel.viewLayout.setScrollPositionNow( {
              scrollTop: e
            } )
          }
        }, t.prototype.setScrollPosition = function ( e ) {
          this.hasView && this.viewModel.viewLayout.setScrollPositionNow( e )
        }, t.prototype.saveViewState = function () {
          if ( !this.cursor || !this.hasView ) return null;
          for ( var e = {}, t = Object.keys( this._contributions ), n = 0, i = t.length; n < i; n++ ) {
            const o = t[ n ],
              r = this._contributions[ o ];
            "function" === typeof r.saveViewState && ( e[ o ] = r.saveViewState() )
          }
          return {
            cursorState: this.cursor.saveState(),
            viewState: this.viewModel.saveState(),
            contributionsState: e
          }
        }, t.prototype.restoreViewState = function ( e ) {
          if ( this.cursor && this.hasView && e && e.cursorState && e.viewState ) {
            const t = e.cursorState;
            Array.isArray( t ) ? this.cursor.restoreState( t ) : this.cursor.restoreState( [ t ] );
            for ( let n = e.contributionsState || {}, i = Object.keys( this._contributions ), o = 0, r = i.length; o < r; o++ ) {
              const s = i[ o ],
                a = this._contributions[ s ];
              "function" === typeof a.restoreViewState && a.restoreViewState( n[ s ] )
            }
            const u = this.viewModel.reduceRestoreState( e.viewState ),
              l = this.viewModel.viewLayout.getLinesViewportDataAtScrollTop( u.scrollTop ),
              c = this.viewModel.coordinatesConverter.convertViewPositionToModelPosition( new g.a( l.startLineNumber, 1 ) ),
              d = this.viewModel.coordinatesConverter.convertViewPositionToModelPosition( new g.a( l.endLineNumber, 1 ) );
            this.model.tokenizeViewport( c.lineNumber, d.lineNumber ), this._view.restoreState( u )
          }
        }, t.prototype.getContribution = function ( e ) {
          return this._contributions[ e ] || null
        }, t.prototype.getActions = function () {
          for ( var e = [], t = Object.keys( this._actions ), n = 0, i = t.length; n < i; n++ ) {
            const o = t[ n ];
            e.push( this._actions[ o ] )
          }
          return e
        }, t.prototype.getSupportedActions = function () {
          let e = this.getActions();
          return e = e.filter( ( e => {
            return e.isSupported()
          } ) );
        }, t.prototype.getAction = function ( e ) {
          return this._actions[ e ] || null
        }, t.prototype.trigger = function ( e, t, n ) {
          if ( n = n || {}, t === C.b.Type ) {
            if ( !this.cursor || "string" !== typeof n.text || 0 === n.text.length ) return;
            return "keyboard" === e && this._onWillType.fire( n.text ), this.cursor.trigger( e, t, n ), void( "keyboard" === e && this._onDidType.fire( n.text ) )
          }
          if ( t !== C.b.Paste ) {
            const i = this.getAction( t );
            i ? u.b.as( i.run() ).then( null, r.e ) : this.cursor && ( this._triggerEditorCommand( e, t, n ) || this.cursor.trigger( e, t, n ) )
          } else {
            if ( !this.cursor || "string" !== typeof n.text || 0 === n.text.length ) return;
            const o = this.cursor.getSelection().getStartPosition();
            this.cursor.trigger( e, t, n );
            const s = this.cursor.getSelection().getStartPosition();
            "keyboard" === e && this._onDidPaste.fire( new m.a( o.lineNumber, o.column, s.lineNumber, s.column ) )
          }
        }, t.prototype._triggerEditorCommand = function ( e, t, n ) {
          const i = Hi.d.getEditorCommand( t );
          return !!i && ( ( n = n || {} ).source = e, u.b.as( i.runEditorCommand( null, this, n ) ).done( null, r.e ), !0 )
        }, t.prototype._getCursors = function () {
          return this.cursor
        }, t.prototype._getCursorConfiguration = function () {
          return this.cursor.context.config
        }, t.prototype.pushUndoStop = function () {
          return !!this.model && ( !this._configuration.editor.readOnly && ( this.model.pushStackElement(), !0 ) )
        }, t.prototype.executeEdits = function ( e, t, n ) {
          return !!this.cursor && ( !this._configuration.editor.readOnly && ( this.model.pushEditOperations( this.cursor.getSelections(), t, ( () => {
            return n || null
          } ) ), n && this.cursor.setSelections( e, n ), !0 ) );
        }, t.prototype.executeCommand = function ( e, t ) {
          this.cursor && this.cursor.trigger( e, C.b.ExecuteCommand, t )
        }, t.prototype.executeCommands = function ( e, t ) {
          this.cursor && this.cursor.trigger( e, C.b.ExecuteCommands, t )
        }, t.prototype.changeDecorations = function ( e ) {
          return this.model ? this.model.changeDecorations( e, this.id ) : null
        }, t.prototype.getLineDecorations = function ( e ) {
          return this.model ? this.model.getLineDecorations( e, this.id, this._configuration.editor.readOnly ) : null
        }, t.prototype.deltaDecorations = function ( e, t ) {
          return this.model ? 0 === e.length && 0 === t.length ? e : this.model.deltaDecorations( e, t, this.id ) : []
        }, t.prototype.removeDecorations = function ( e ) {
          const t = this._decorationTypeKeysToIds[ e ];
          t && this.deltaDecorations( t, [] ), this._decorationTypeKeysToIds.hasOwnProperty( e ) && delete this._decorationTypeKeysToIds[ e ], this._decorationTypeSubtypes.hasOwnProperty( e ) && delete this._decorationTypeSubtypes[ e ]
        }, t.prototype.getLayoutInfo = function () {
          return this._configuration.editor.layoutInfo
        }, t.prototype.createOverviewRuler = function ( e ) {
          return this._view.createOverviewRuler( e )
        }, t.prototype.getDomNode = function () {
          return this.hasView ? this._view.domNode.domNode : null
        }, t.prototype.delegateVerticalScrollbarMouseDown = function ( e ) {
          this.hasView && this._view.delegateVerticalScrollbarMouseDown( e )
        }, t.prototype.layout = function ( e ) {
          this._configuration.observeReferenceElement( e ), this.render()
        }, t.prototype.focus = function () {
          this.hasView && this._view.focus()
        }, t.prototype.hasTextFocus = function () {
          return this.hasView && this._view.isFocused()
        }, t.prototype.hasWidgetFocus = function () {
          return this._focusTracker && this._focusTracker.hasFocus()
        }, t.prototype.addContentWidget = function ( e ) {
          const t = {
            widget: e,
            position: e.getPosition()
          };
          this.contentWidgets.hasOwnProperty( e.getId() ) && console.warn( "Overwriting a content widget with the same id." ), this.contentWidgets[ e.getId() ] = t, this.hasView && this._view.addContentWidget( t )
        }, t.prototype.layoutContentWidget = function ( e ) {
          const t = e.getId();
          if ( this.contentWidgets.hasOwnProperty( t ) ) {
            const n = this.contentWidgets[ t ];
            n.position = e.getPosition(), this.hasView && this._view.layoutContentWidget( n )
          }
        }, t.prototype.removeContentWidget = function ( e ) {
          const t = e.getId();
          if ( this.contentWidgets.hasOwnProperty( t ) ) {
            const n = this.contentWidgets[ t ];
            delete this.contentWidgets[ t ], this.hasView && this._view.removeContentWidget( n )
          }
        }, t.prototype.addOverlayWidget = function ( e ) {
          const t = {
            widget: e,
            position: e.getPosition()
          };
          this.overlayWidgets.hasOwnProperty( e.getId() ) && console.warn( "Overwriting an overlay widget with the same id." ), this.overlayWidgets[ e.getId() ] = t, this.hasView && this._view.addOverlayWidget( t )
        }, t.prototype.layoutOverlayWidget = function ( e ) {
          const t = e.getId();
          if ( this.overlayWidgets.hasOwnProperty( t ) ) {
            const n = this.overlayWidgets[ t ];
            n.position = e.getPosition(), this.hasView && this._view.layoutOverlayWidget( n )
          }
        }, t.prototype.removeOverlayWidget = function ( e ) {
          const t = e.getId();
          if ( this.overlayWidgets.hasOwnProperty( t ) ) {
            const n = this.overlayWidgets[ t ];
            delete this.overlayWidgets[ t ], this.hasView && this._view.removeOverlayWidget( n )
          }
        }, t.prototype.changeViewZones = function ( e ) {
          this.hasView && ( this._view.change( e ) && this._onDidChangeViewZones.fire() )
        }, t.prototype.getTargetAtClientPoint = function ( e, t ) {
          return this.hasView ? this._view.getTargetAtClientPoint( e, t ) : null
        }, t.prototype.getScrolledVisiblePosition = function ( e ) {
          if ( !this.hasView ) return null;
          const t = this.model.validatePosition( e ),
            n = this._configuration.editor.layoutInfo;
          return {
            top: this._getVerticalOffsetForPosition( t.lineNumber, t.column ) - this.getScrollTop(),
            left: this._view.getOffsetForColumn( t.lineNumber, t.column ) + n.glyphMarginWidth + n.lineNumbersWidth + n.decorationsWidth - this.getScrollLeft(),
            height: this._configuration.editor.lineHeight
          }
        }, t.prototype.getOffsetForColumn = function ( e, t ) {
          return this.hasView ? this._view.getOffsetForColumn( e, t ) : -1
        }, t.prototype.render = function () {
          this.hasView && this._view.render( !0, !1 )
        }, t.prototype.applyFontInfo = function ( e ) {
          h.a.applyFontInfoSlow( e, this._configuration.editor.fontInfo )
        }, t.prototype._attachModel = function ( e ) {
          const t = this;
          if ( this._view = null, this.model = e || null, this.listenersToRemove = [], this.viewModel = null, this.cursor = null, this.model ? ( this.domElement.setAttribute( "data-mode-id", this.model.getLanguageIdentifier().language ), this._configuration.setIsDominatedByLongLines( this.model.isDominatedByLongLines() ), this._configuration.setMaxLineNumber( this.model.getLineCount() ), this.model.onBeforeAttached(), this.viewModel = new De( this.id, this._configuration, this.model, ( e => {
              return o.L( e )
            } ) ), this.listenersToRemove.push( this.model.onDidChangeDecorations( ( e => {
              return t._onDidChangeModelDecorations.fire( e )
            } ) ) ), this.listenersToRemove.push( this.model.onDidChangeLanguage( ( e => {
              t.model && ( t.domElement.setAttribute( "data-mode-id", t.model.getLanguageIdentifier().language ), t._onDidChangeModelLanguage.fire( e ) )
            } ) ) ), this.listenersToRemove.push( this.model.onDidChangeLanguageConfiguration( ( e => {
              return t._onDidChangeModelLanguageConfiguration.fire( e )
            } ) ) ), this.listenersToRemove.push( this.model.onDidChangeContent( ( e => {
              return t._onDidChangeModelContent.fire( e )
            } ) ) ), this.listenersToRemove.push( this.model.onDidChangeOptions( ( e => {
              return t._onDidChangeModelOptions.fire( e )
            } ) ) ), this.listenersToRemove.push( this.model.onWillDispose( ( () => {
              return t.setModel( null )
            } ) ) ), this.cursor = new Y( this._configuration, this.model, this.viewModel ), this._createView(), this.listenersToRemove.push( this.cursor.onDidReachMaxCursorCount( ( () => {
              t._notificationService.warn( i.a( "cursors.maximum", "The number of cursors has been limited to {0}.", Y.MAX_CURSOR_COUNT ) )
            } ) ) ), this.listenersToRemove.push( this.cursor.onDidAttemptReadOnlyEdit( ( () => {
              t._onDidAttemptReadOnlyEdit.fire( void 0 )
            } ) ) ), this.listenersToRemove.push( this.cursor.onDidChange( ( e => {
              for ( var n = [], i = 0, o = e.selections.length; i < o; i++ ) n[ i ] = e.selections[ i ].getPosition();
              const r = {
                position: n[ 0 ],
                secondaryPositions: n.slice( 1 ),
                reason: e.reason,
                source: e.source
              };
              t._onDidChangeCursorPosition.fire( r );
              const s = {
                selection: e.selections[ 0 ],
                secondarySelections: e.selections.slice( 1 ),
                source: e.source,
                reason: e.reason
              };
              t._onDidChangeCursorSelection.fire( s )
            } ) ) ) ) : this.hasView = !1, this._view ) {
            this.domElement.appendChild( this._view.domNode.domNode );
            for ( var n = Object.keys( this.contentWidgets ), r = 0, s = n.length; r < s; r++ ) {
              var a = n[ r ];
              this._view.addContentWidget( this.contentWidgets[ a ] )
            }
            for ( r = 0, s = ( n = Object.keys( this.overlayWidgets ) ).length; r < s; r++ ) {
              a = n[ r ];
              this._view.addOverlayWidget( this.overlayWidgets[ a ] )
            }
            this._view.render( !1, !0 ), this.hasView = !0, this._view.domNode.domNode.setAttribute( "data-uri", e.uri.toString() )
          }
        }, t.prototype._createView = function () {
          let e;
          const t = this;
          e = this.isSimpleWidget ? {
            paste( e, n, i, o ) {
              t.trigger( e, C.b.Paste, {
                text: n,
                pasteOnNewLine: i,
                multicursorText: o
              } )
            },
            type( e, n ) {
              t.trigger( e, C.b.Type, {
                text: n
              } )
            },
            replacePreviousChar( e, n, i ) {
              t.trigger( e, C.b.ReplacePreviousChar, {
                text: n,
                replaceCharCnt: i
              } )
            },
            compositionStart( e ) {
              t.trigger( e, C.b.CompositionStart, void 0 )
            },
            compositionEnd( e ) {
              t.trigger( e, C.b.CompositionEnd, void 0 )
            },
            cut( e ) {
              t.trigger( e, C.b.Cut, void 0 )
            }
          } : {
            paste( e, n, i, o ) {
              t._commandService.executeCommand( C.b.Paste, {
                text: n,
                pasteOnNewLine: i,
                multicursorText: o
              } )
            },
            type( e, n ) {
              t._commandService.executeCommand( C.b.Type, {
                text: n
              } )
            },
            replacePreviousChar( e, n, i ) {
              t._commandService.executeCommand( C.b.ReplacePreviousChar, {
                text: n,
                replaceCharCnt: i
              } )
            },
            compositionStart( e ) {
              t._commandService.executeCommand( C.b.CompositionStart, {} )
            },
            compositionEnd( e ) {
              t._commandService.executeCommand( C.b.CompositionEnd, {} )
            },
            cut( e ) {
              t._commandService.executeCommand( C.b.Cut, {} )
            }
          }, this._view = new Vi( e, this._configuration, this._themeService, this.viewModel, this.cursor, ( ( e, n ) => {
            t.cursor && e.runCoreEditorCommand( t.cursor, n )
          } ) );
          const n = this._view.getInternalEventBus();
          n.onDidGainFocus = () => {
            t._editorTextFocus.setValue( !0 ), t._editorWidgetFocus.setValue( !0 )
          }, n.onDidScroll = e => {
            return t._onDidScrollChange.fire( e )
          }, n.onDidLoseFocus = () => {
            return t._editorTextFocus.setValue( !1 )
          }, n.onContextMenu = e => {
            return t._onContextMenu.fire( e )
          }, n.onMouseDown = e => {
            return t._onMouseDown.fire( e )
          }, n.onMouseUp = e => {
            return t._onMouseUp.fire( e )
          }, n.onMouseDrag = e => {
            return t._onMouseDrag.fire( e )
          }, n.onMouseDrop = e => {
            return t._onMouseDrop.fire( e )
          }, n.onKeyUp = e => {
            return t._onKeyUp.fire( e )
          }, n.onMouseMove = e => {
            return t._onMouseMove.fire( e )
          }, n.onMouseLeave = e => {
            return t._onMouseLeave.fire( e )
          }, n.onKeyDown = e => {
            return t._onKeyDown.fire( e )
          }
        }, t.prototype._postDetachModelCleanup = function ( e ) {
          e && e.removeAllDecorationsWithOwnerId( this.id )
        }, t.prototype._detachModel = function () {
          let e = null;
          this._view && ( this._view.dispose(), e = this._view.domNode.domNode, this._view = null ), this.model && this.model.onBeforeDetached(), this.hasView = !1, this.listenersToRemove = Object( a.d )( this.listenersToRemove ), this.cursor && ( this.cursor.dispose(), this.cursor = null ), this.viewModel && ( this.viewModel.dispose(), this.viewModel = null );
          const t = this.model;
          return this.model = null, this.domElement.removeAttribute( "data-mode-id" ), e && this.domElement.removeChild( e ), t
        }, t.prototype._removeDecorationType = function ( e ) {
          this._codeEditorService.removeDecorationType( e )
        }, t.prototype.getTelemetryData = function () {
          return this._telemetryData
        }, t = Ki( [ qi( 3, l.a ), qi( 4, Pe.a ), qi( 5, Ae.b ), qi( 6, d.e ), qi( 7, Fe.c ), qi( 8, Re.a ) ], t );
      } )( a.a );

      const $i = ( e => {
        function t() {
          const t = e.call( this ) || this;
          return t._onDidChangeToTrue = t._register( new s.a ), t.onDidChangeToTrue = t._onDidChangeToTrue.event, t._onDidChangeToFalse = t._register( new s.a ), t.onDidChangeToFalse = t._onDidChangeToFalse.event, t._value = 0, t
        }
        return Ui( t, e ), t.prototype.setValue = function ( e ) {
          const t = e ? 2 : 1;
          this._value !== t && ( this._value = t, 2 === this._value ? this._onDidChangeToTrue.fire() : 1 === this._value && this._onDidChangeToFalse.fire() )
        }, t;
      } )( a.a );
      const Zi = ( e => {
        function t( t, n ) {
          const i = e.call( this ) || this;
          return i._editor = t, n.createKey( "editorId", t.getId() ), i._editorFocus = Me.a.focus.bindTo( n ), i._textInputFocus = Me.a.textInputFocus.bindTo( n ), i._editorTextFocus = Me.a.editorTextFocus.bindTo( n ), i._editorTabMovesFocus = Me.a.tabMovesFocus.bindTo( n ), i._editorReadonly = Me.a.readOnly.bindTo( n ), i._hasMultipleSelections = Me.a.hasMultipleSelections.bindTo( n ), i._hasNonEmptySelection = Me.a.hasNonEmptySelection.bindTo( n ), i._canUndo = Me.a.canUndo.bindTo( n ), i._canRedo = Me.a.canRedo.bindTo( n ), i._register( i._editor.onDidChangeConfiguration( ( () => {
            return i._updateFromConfig()
          } ) ) ), i._register( i._editor.onDidChangeCursorSelection( ( () => {
            return i._updateFromSelection()
          } ) ) ), i._register( i._editor.onDidFocusEditorWidget( ( () => {
            return i._updateFromFocus()
          } ) ) ), i._register( i._editor.onDidBlurEditorWidget( ( () => {
            return i._updateFromFocus()
          } ) ) ), i._register( i._editor.onDidFocusEditorText( ( () => {
            return i._updateFromFocus()
          } ) ) ), i._register( i._editor.onDidBlurEditorText( ( () => {
            return i._updateFromFocus()
          } ) ) ), i._register( i._editor.onDidChangeModel( ( () => {
            return i._updateFromModel()
          } ) ) ), i._register( i._editor.onDidChangeConfiguration( ( () => {
            return i._updateFromModel()
          } ) ) ), i._updateFromConfig(), i._updateFromSelection(), i._updateFromFocus(), i._updateFromModel(), i;
        }
        return Ui( t, e ), t.prototype._updateFromConfig = function () {
          const e = this._editor.getConfiguration();
          this._editorTabMovesFocus.set( e.tabFocusMode ), this._editorReadonly.set( e.readOnly )
        }, t.prototype._updateFromSelection = function () {
          const e = this._editor.getSelections();
          e ? ( this._hasMultipleSelections.set( e.length > 1 ), this._hasNonEmptySelection.set( e.some( ( e => {
            return !e.isEmpty()
          } ) ) ) ) : ( this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset() )
        }, t.prototype._updateFromFocus = function () {
          this._editorFocus.set( this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget ), this._editorTextFocus.set( this._editor.hasTextFocus() && !this._editor.isSimpleWidget ), this._textInputFocus.set( this._editor.hasTextFocus() )
        }, t.prototype._updateFromModel = function () {
          const e = this._editor.getModel();
          this._canUndo.set( e && e.canUndo() ), this._canRedo.set( e && e.canRedo() )
        }, t;
      } )( a.a );
      const Qi = ( e => {
        function t( t, n ) {
          const i = e.call( this ) || this;
          i._editor = t, i._langId = Me.a.languageId.bindTo( n ), i._hasCompletionItemProvider = Me.a.hasCompletionItemProvider.bindTo( n ), i._hasCodeActionsProvider = Me.a.hasCodeActionsProvider.bindTo( n ), i._hasCodeLensProvider = Me.a.hasCodeLensProvider.bindTo( n ), i._hasDefinitionProvider = Me.a.hasDefinitionProvider.bindTo( n ), i._hasImplementationProvider = Me.a.hasImplementationProvider.bindTo( n ), i._hasTypeDefinitionProvider = Me.a.hasTypeDefinitionProvider.bindTo( n ), i._hasHoverProvider = Me.a.hasHoverProvider.bindTo( n ), i._hasDocumentHighlightProvider = Me.a.hasDocumentHighlightProvider.bindTo( n ), i._hasDocumentSymbolProvider = Me.a.hasDocumentSymbolProvider.bindTo( n ), i._hasReferenceProvider = Me.a.hasReferenceProvider.bindTo( n ), i._hasRenameProvider = Me.a.hasRenameProvider.bindTo( n ), i._hasDocumentFormattingProvider = Me.a.hasDocumentFormattingProvider.bindTo( n ), i._hasDocumentSelectionFormattingProvider = Me.a.hasDocumentSelectionFormattingProvider.bindTo( n ), i._hasSignatureHelpProvider = Me.a.hasSignatureHelpProvider.bindTo( n ), i._isInWalkThrough = Me.a.isInEmbeddedEditor.bindTo( n );
          const o = () => {
            return i._update()
          };
          return i._register( t.onDidChangeModel( o ) ), i._register( t.onDidChangeModelLanguage( o ) ), i._register( $.u.onDidChange( o ) ), i._register( $.a.onDidChange( o ) ), i._register( $.c.onDidChange( o ) ), i._register( $.e.onDidChange( o ) ), i._register( $.n.onDidChange( o ) ), i._register( $.z.onDidChange( o ) ), i._register( $.m.onDidChange( o ) ), i._register( $.h.onDidChange( o ) ), i._register( $.j.onDidChange( o ) ), i._register( $.r.onDidChange( o ) ), i._register( $.s.onDidChange( o ) ), i._register( $.f.onDidChange( o ) ), i._register( $.i.onDidChange( o ) ), i._register( $.t.onDidChange( o ) ), o(), i
        }
        return Ui( t, e ), t.prototype.dispose = function () {
          e.prototype.dispose.call( this )
        }, t.prototype.reset = function () {
          this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInWalkThrough.reset()
        }, t.prototype._update = function () {
          const e = this._editor.getModel();
          e ? ( this._langId.set( e.getLanguageIdentifier().language ), this._hasCompletionItemProvider.set( $.u.has( e ) ), this._hasCodeActionsProvider.set( $.a.has( e ) ), this._hasCodeLensProvider.set( $.c.has( e ) ), this._hasDefinitionProvider.set( $.e.has( e ) ), this._hasImplementationProvider.set( $.n.has( e ) ), this._hasTypeDefinitionProvider.set( $.z.has( e ) ), this._hasHoverProvider.set( $.m.has( e ) ), this._hasDocumentHighlightProvider.set( $.h.has( e ) ), this._hasDocumentSymbolProvider.set( $.j.has( e ) ), this._hasReferenceProvider.set( $.r.has( e ) ), this._hasRenameProvider.set( $.s.has( e ) ), this._hasSignatureHelpProvider.set( $.t.has( e ) ), this._hasDocumentFormattingProvider.set( $.f.has( e ) || $.i.has( e ) ), this._hasDocumentSelectionFormattingProvider.set( $.i.has( e ) ), this._isInWalkThrough.set( e.uri.scheme === Te.a.walkThroughSnippet ) ) : this.reset()
        }, t;
      } )( a.a );
      const Ji = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n._onChange = n._register( new s.a ), n.onChange = n._onChange.event, n._hasFocus = !1, n._domFocusTracker = n._register( o.O( t ) ), n._register( n._domFocusTracker.onDidFocus( ( () => {
            n._hasFocus = !0, n._onChange.fire( void 0 )
          } ) ) ), n._register( n._domFocusTracker.onDidBlur( ( () => {
            n._hasFocus = !1, n._onChange.fire( void 0 )
          } ) ) ), n;
        }
        return Ui( t, e ), t.prototype.hasFocus = function () {
          return this._hasFocus
        }, t
      } )( a.a );
      const eo = encodeURIComponent( "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='" );
      const to = encodeURIComponent( "'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>" );

      function no( e ) {
        return eo + encodeURIComponent( e.toString() ) + to
      }
      const io = encodeURIComponent( '<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="' ),
        oo = encodeURIComponent( '"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>' );
      Object( Fe.e )( ( ( e, t ) => {
        const n = e.getColor( $e.h );
        n && t.addRule( ".monaco-editor .squiggly-error { border-bottom: 4px double " + n + "; }" );
        const i = e.getColor( $e.i );
        i && t.addRule( '.monaco-editor .squiggly-error { background: url("data:image/svg+xml,' + no( i ) + '") repeat-x bottom left; }' );
        const o = e.getColor( $e.v );
        o && t.addRule( ".monaco-editor .squiggly-warning { border-bottom: 4px double " + o + "; }" );
        const r = e.getColor( $e.w );
        r && t.addRule( '.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,' + no( r ) + '") repeat-x bottom left; }' );
        const s = e.getColor( $e.m );
        s && t.addRule( ".monaco-editor .squiggly-info { border-bottom: 4px double " + s + "; }" );
        const a = e.getColor( $e.n );
        a && t.addRule( '.monaco-editor .squiggly-info { background: url("data:image/svg+xml,' + no( a ) + '") repeat-x bottom left; }' );
        const u = e.getColor( $e.j );
        u && t.addRule( ".monaco-editor .squiggly-hint { border-bottom: 2px dotted " + u + "; }" );
        const l = e.getColor( $e.k );
        l && t.addRule( '.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,' + ( io + encodeURIComponent( l.toString() ) + oo ) + '") no-repeat bottom left; }' );
        const c = e.getColor( $e.u );
        c && t.addRule( "." + Yi + " .monaco-editor .squiggly-inline-unnecessary { opacity: " + c.rgba.a + "; will-change: opacity; }" );
        const d = e.getColor( $e.t );
        d && t.addRule( "." + Yi + " .monaco-editor .squiggly-unnecessary { border-bottom: 2px dashed " + d + "; }" )
      } ) )
    },
    nD70( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "b", ( () => {
        return o
      } ) );
      var i = ( () => {
          function e( e ) {
            this._prefix = e, this._lastId = 0
          }
          return e.prototype.nextId = function () {
            return this._prefix + ++this._lastId
          }, e
        } )(),
        o = new i( "id#" )
    },
    nnTU( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) );
      const i = n( "pmY6" );
      const o = n( "746U" );
      const r = n( "Cg/j" );
      const s = n( "24hK" );
      var a = Object( r.c )( "commandService" );

      var u = new( ( () => {
        function e() {
          this._commands = new Map
        }
        return e.prototype.registerCommand = function ( e, t ) {
          const n = this;
          if ( !e ) throw new Error( "invalid command" );
          if ( "string" === typeof e ) {
            if ( !t ) throw new Error( "invalid command" );
            return this.registerCommand( {
              id: e,
              handler: t
            } )
          }
          if ( e.description ) {
            for ( var r = [], a = 0, u = e.description.args; a < u.length; a++ ) {
              const l = u[ a ];
              r.push( l.constraint )
            }
            const c = e.handler;
            e.handler = function ( e ) {
              for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
              return Object( o.k )( t, r ), c.apply( void 0, [ e ].concat( t ) )
            }
          }
          const d = e.id;
          let h = this._commands.get( d );
          h || ( h = new s.a, this._commands.set( d, h ) );
          const p = h.unshift( e );
          return Object( i.f )( ( () => {
            p(), n._commands.get( d ).isEmpty() && n._commands.delete( d )
          } ) );
        }, e.prototype.registerCommandAlias = ( e, t ) => {
          return u.registerCommand( e, ( function ( e ) {
            for ( var n, i = [], o = 1; o < arguments.length; o++ ) i[ o - 1 ] = arguments[ o ];
            ( n = e.get( a ) ).executeCommand.apply( n, [ t ].concat( i ) )
          } ) )
        }, e.prototype.getCommand = function ( e ) {
          const t = this._commands.get( e );
          if ( t && !t.isEmpty() ) return t.iterator().next().value
        }, e.prototype.getCommands = function () {
          const e = this,
            t = Object.create( null );
          return this._commands.forEach( ( ( n, i ) => {
            t[ i ] = e.getCommand( i )
          } ) ), t;
        }, e;
      } )() )();
    },
    nrBJ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "vb",
        extensions: [ ".vb" ],
        aliases: [ "Visual Basic", "vb" ],
        loader() {
          return o.Promise.wrap( n.e( 312 ).then( n.bind( null, "eXtt" ) ) )
        }
      } )
    },
    nrhi( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return a
      } ) );
      const i = n( "/kV6" );
      const o = n( "MNsG" );
      const r = n( "nnTU" );
      const s = n( "ic2d" );
      var a = new( ( () => {
        function e() {
          this._keybindings = [], this._keybindingsSorted = !0
        }
        return e.bindToCurrentPlatform = e => {
          if ( 1 === o.a ) {
            if ( e && e.win ) return e.win
          } else if ( 2 === o.a ) {
            if ( e && e.mac ) return e.mac
          } else if ( e && e.linux ) return e.linux;
          return e
        }, e.prototype.registerKeybindingRule = function ( t, n ) {
          void 0 === n && ( n = 0 );
          const r = e.bindToCurrentPlatform( t );
          if ( r && r.primary && this._registerDefaultKeybinding( Object( i.f )( r.primary, o.a ), t.id, t.weight, 0, t.when, n ), r && Array.isArray( r.secondary ) )
            for ( let s = 0, a = r.secondary.length; s < a; s++ ) {
              const u = r.secondary[ s ];
              this._registerDefaultKeybinding( Object( i.f )( u, o.a ), t.id, t.weight, -s - 1, t.when, n )
            }
        }, e.prototype.registerCommandAndKeybindingRule = function ( e, t ) {
          void 0 === t && ( t = 0 ), this.registerKeybindingRule( e, t ), r.a.registerCommand( e )
        }, e._mightProduceChar = e => {
          return e >= 21 && e <= 30 || ( e >= 31 && e <= 56 || ( 80 === e || 81 === e || 82 === e || 83 === e || 84 === e || 85 === e || 86 === e || 110 === e || 111 === e || 87 === e || 88 === e || 89 === e || 90 === e || 91 === e || 92 === e ) )
        }, e.prototype._assertNoCtrlAlt = ( t, n ) => {
          t.ctrlKey && t.altKey && !t.metaKey && e._mightProduceChar( t.keyCode ) && console.warn( "Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ", t, " for ", n )
        }, e.prototype._registerDefaultKeybinding = function ( e, t, n, i, r, s ) {
          0 === s && 1 === o.a && ( 2 === e.type ? this._assertNoCtrlAlt( e.firstPart, t ) : this._assertNoCtrlAlt( e, t ) ), this._keybindings.push( {
            keybinding: e,
            command: t,
            commandArgs: void 0,
            when: r,
            weight1: n,
            weight2: i
          } ), this._keybindingsSorted = !1
        }, e.prototype.getDefaultKeybindings = function () {
          return this._keybindingsSorted || ( this._keybindings.sort( u ), this._keybindingsSorted = !0 ), this._keybindings.slice( 0 )
        }, e;
      } )() )();

      function u( e, t ) {
        return e.weight1 !== t.weight1 ? e.weight1 - t.weight1 : e.command < t.command ? -1 : e.command > t.command ? 1 : e.weight2 - t.weight2
      }
      s.a.add( "platform.keybindingsRegistry", a )
    },
    "o1O+": function ( e, t, n ) {
      "use strict";
      let i;
      const o = n( "EffR" );
      const r = n( "nD70" );
      const s = n( "N0LK" );
      const a = n( "eLzo" );
      ( ( e => {
        const t = {
          newline: /^\n+/,
          code: /^( {4}[^\n]+\n*)+/,
          fences: g,
          hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
          heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
          nptable: g,
          blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
          list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
          html: "^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?\\?>\\n*|<![A-Z][\\s\\S]*?>\\n*|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$))",
          def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
          table: g,
          lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
          paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)(?: +|\n|\/?>)|<(?:script|pre|style|!--))[^\n]+)*)/,
          text: /^[^\n]+/
        };

        function n( e ) {
          this.tokens = [], this.tokens.links = {}, this.options = e || y.defaults, this.rules = t.normal, this.options.pedantic ? this.rules = t.pedantic : this.options.gfm && ( this.options.tables ? this.rules = t.tables : this.rules = t.gfm )
        }
        t._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/, t._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/, t.def = d( t.def ).replace( "label", t._label ).replace( "title", t._title ).getRegex(), t.bullet = /(?:[*+-]|\d+\.)/, t.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/, t.item = d( t.item, "gm" ).replace( /bull/g, t.bullet ).getRegex(), t.list = d( t.list ).replace( /bull/g, t.bullet ).replace( "hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))" ).replace( "def", "\\n+(?=" + t.def.source + ")" ).getRegex(), t._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", t._comment = /<!--(?!-?>)[\s\S]*?-->/, t.html = d( t.html, "i" ).replace( "comment", t._comment ).replace( "tag", t._tag ).replace( "attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/ ).getRegex(), t.paragraph = d( t.paragraph ).replace( "hr", t.hr ).replace( "heading", t.heading ).replace( "lheading", t.lheading ).replace( "tag", t._tag ).getRegex(), t.blockquote = d( t.blockquote ).replace( "paragraph", t.paragraph ).getRegex(), t.normal = m( {}, t ), t.gfm = m( {}, t.normal, {
          fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,
          paragraph: /^/,
          heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
        } ), t.gfm.paragraph = d( t.paragraph ).replace( "(?!", "(?!" + t.gfm.fences.source.replace( "\\1", "\\2" ) + "|" + t.list.source.replace( "\\1", "\\3" ) + "|" ).getRegex(), t.tables = m( {}, t.gfm, {
          nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
          table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
        } ), t.pedantic = m( {}, t.normal, {
          html: d( "^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))" ).replace( "comment", t._comment ).replace( /tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b" ).getRegex(),
          def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/
        } ), n.rules = t, n.lex = ( e, t ) => {
          return new n( t ).lex( e )
        }, n.prototype.lex = function ( e ) {
          return e = e.replace( /\r\n|\r/g, "\n" ).replace( /\t/g, "    " ).replace( /\u00a0/g, " " ).replace( /\u2424/g, "\n" ), this.token( e, !0 )
        }, n.prototype.token = function ( e, n ) {
          let i, o, r, s, a, u, l, c, d, h, p, f, g;
          for ( e = e.replace( /^ +$/gm, "" ); e; )
            if ( ( r = this.rules.newline.exec( e ) ) && ( e = e.substring( r[ 0 ].length ), r[ 0 ].length > 1 && this.tokens.push( {
                type: "space"
              } ) ), r = this.rules.code.exec( e ) ) e = e.substring( r[ 0 ].length ), r = r[ 0 ].replace( /^ {4}/gm, "" ), this.tokens.push( {
              type: "code",
              text: this.options.pedantic ? r : v( r, "\n" )
            } );
            else if ( r = this.rules.fences.exec( e ) ) e = e.substring( r[ 0 ].length ), this.tokens.push( {
            type: "code",
            lang: r[ 2 ],
            text: r[ 3 ] || ""
          } );
          else if ( r = this.rules.heading.exec( e ) ) e = e.substring( r[ 0 ].length ), this.tokens.push( {
            type: "heading",
            depth: r[ 1 ].length,
            text: r[ 2 ]
          } );
          else if ( n && ( r = this.rules.nptable.exec( e ) ) && ( u = {
              type: "table",
              header: _( r[ 1 ].replace( /^ *| *\| *$/g, "" ) ),
              align: r[ 2 ].replace( /^ *|\| *$/g, "" ).split( / *\| */ ),
              cells: r[ 3 ] ? r[ 3 ].replace( /\n$/, "" ).split( "\n" ) : []
            } ).header.length === u.align.length ) {
            for ( e = e.substring( r[ 0 ].length ), c = 0; c < u.align.length; c++ ) /^ *-+: *$/.test( u.align[ c ] ) ? u.align[ c ] = "right" : /^ *:-+: *$/.test( u.align[ c ] ) ? u.align[ c ] = "center" : /^ *:-+ *$/.test( u.align[ c ] ) ? u.align[ c ] = "left" : u.align[ c ] = null;
            for ( c = 0; c < u.cells.length; c++ ) u.cells[ c ] = _( u.cells[ c ], u.header.length );
            this.tokens.push( u )
          } else if ( r = this.rules.hr.exec( e ) ) e = e.substring( r[ 0 ].length ), this.tokens.push( {
            type: "hr"
          } );
          else if ( r = this.rules.blockquote.exec( e ) ) e = e.substring( r[ 0 ].length ), this.tokens.push( {
            type: "blockquote_start"
          } ), r = r[ 0 ].replace( /^ *> ?/gm, "" ), this.token( r, n ), this.tokens.push( {
            type: "blockquote_end"
          } );
          else if ( r = this.rules.list.exec( e ) ) {
            for ( e = e.substring( r[ 0 ].length ), p = ( s = r[ 2 ] ).length > 1, this.tokens.push( {
                type: "list_start",
                ordered: p,
                start: p ? +s : ""
              } ), i = !1, h = ( r = r[ 0 ].match( this.rules.item ) ).length, c = 0; c < h; c++ ) l = ( u = r[ c ] ).length, ~( u = u.replace( /^ *([*+-]|\d+\.) +/, "" ) ).indexOf( "\n " ) && ( l -= u.length, u = this.options.pedantic ? u.replace( /^ {1,4}/gm, "" ) : u.replace( new RegExp( "^ {1," + l + "}", "gm" ), "" ) ), this.options.smartLists && c !== h - 1 && ( s === ( a = t.bullet.exec( r[ c + 1 ] )[ 0 ] ) || s.length > 1 && a.length > 1 || ( e = r.slice( c + 1 ).join( "\n" ) + e, c = h - 1 ) ), o = i || /\n\n(?!\s*$)/.test( u ), c !== h - 1 && ( i = "\n" === u.charAt( u.length - 1 ), o || ( o = i ) ), g = void 0, ( f = /^\[[ xX]\] /.test( u ) ) && ( g = " " !== u[ 1 ], u = u.replace( /^\[[ xX]\] +/, "" ) ), this.tokens.push( {
              type: o ? "loose_item_start" : "list_item_start",
              task: f,
              checked: g
            } ), this.token( u, !1 ), this.tokens.push( {
              type: "list_item_end"
            } );
            this.tokens.push( {
              type: "list_end"
            } )
          } else if ( r = this.rules.html.exec( e ) ) e = e.substring( r[ 0 ].length ), this.tokens.push( {
            type: this.options.sanitize ? "paragraph" : "html",
            pre: !this.options.sanitizer && ( "pre" === r[ 1 ] || "script" === r[ 1 ] || "style" === r[ 1 ] ),
            text: r[ 0 ]
          } );
          else if ( n && ( r = this.rules.def.exec( e ) ) ) e = e.substring( r[ 0 ].length ), r[ 3 ] && ( r[ 3 ] = r[ 3 ].substring( 1, r[ 3 ].length - 1 ) ), d = r[ 1 ].toLowerCase().replace( /\s+/g, " " ), this.tokens.links[ d ] || ( this.tokens.links[ d ] = {
            href: r[ 2 ],
            title: r[ 3 ]
          } );
          else if ( n && ( r = this.rules.table.exec( e ) ) && ( u = {
              type: "table",
              header: _( r[ 1 ].replace( /^ *| *\| *$/g, "" ) ),
              align: r[ 2 ].replace( /^ *|\| *$/g, "" ).split( / *\| */ ),
              cells: r[ 3 ] ? r[ 3 ].replace( /(?: *\| *)?\n$/, "" ).split( "\n" ) : []
            } ).header.length === u.align.length ) {
            for ( e = e.substring( r[ 0 ].length ), c = 0; c < u.align.length; c++ ) /^ *-+: *$/.test( u.align[ c ] ) ? u.align[ c ] = "right" : /^ *:-+: *$/.test( u.align[ c ] ) ? u.align[ c ] = "center" : /^ *:-+ *$/.test( u.align[ c ] ) ? u.align[ c ] = "left" : u.align[ c ] = null;
            for ( c = 0; c < u.cells.length; c++ ) u.cells[ c ] = _( u.cells[ c ].replace( /^ *\| *| *\| *$/g, "" ), u.header.length );
            this.tokens.push( u )
          } else if ( r = this.rules.lheading.exec( e ) ) e = e.substring( r[ 0 ].length ), this.tokens.push( {
            type: "heading",
            depth: "=" === r[ 2 ] ? 1 : 2,
            text: r[ 1 ]
          } );
          else if ( n && ( r = this.rules.paragraph.exec( e ) ) ) e = e.substring( r[ 0 ].length ), this.tokens.push( {
            type: "paragraph",
            text: "\n" === r[ 1 ].charAt( r[ 1 ].length - 1 ) ? r[ 1 ].slice( 0, -1 ) : r[ 1 ]
          } );
          else if ( r = this.rules.text.exec( e ) ) e = e.substring( r[ 0 ].length ), this.tokens.push( {
            type: "text",
            text: r[ 0 ]
          } );
          else if ( e ) throw new Error( "Infinite loop on byte: " + e.charCodeAt( 0 ) );
          return this.tokens
        };
        const o = {
          escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
          autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
          url: g,
          tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
          link: /^!?\[(label)\]\(href(?:\s+(title))?\s*\)/,
          reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
          nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
          strong: /^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)|^__([^\s])__(?!_)|^\*\*([^\s])\*\*(?!\*)/,
          em: /^_([^\s][\s\S]*?[^\s_])_(?!_)|^_([^\s_][\s\S]*?[^\s])_(?!_)|^\*([^\s][\s\S]*?[^\s*])\*(?!\*)|^\*([^\s*][\s\S]*?[^\s])\*(?!\*)|^_([^\s_])_(?!_)|^\*([^\s*])\*(?!\*)/,
          code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,
          br: /^ {2,}\n(?!\s*$)/,
          del: g,
          text: /^[\s\S]+?(?=[\\<!\[`*]|\b_| {2,}\n|$)/
        };

        function r( e, t ) {
          if ( this.options = t || y.defaults, this.links = e, this.rules = o.normal, this.renderer = this.options.renderer || new s, this.renderer.options = this.options, !this.links ) throw new Error( "Tokens array requires a `links` property." );
          this.options.pedantic ? this.rules = o.pedantic : this.options.gfm && ( this.options.breaks ? this.rules = o.breaks : this.rules = o.gfm )
        }

        function s( e ) {
          this.options = e || y.defaults
        }

        function a() {}

        function u( e ) {
          this.tokens = [], this.token = null, this.options = e || y.defaults, this.options.renderer = this.options.renderer || new s, this.renderer = this.options.renderer, this.renderer.options = this.options
        }

        function l( e, t ) {
          return e.replace( t ? /&/g : /&(?!#?\w+;)/g, "&amp;" ).replace( /</g, "&lt;" ).replace( />/g, "&gt;" ).replace( /"/g, "&quot;" ).replace( /'/g, "&#39;" )
        }

        function c( e ) {
          return e.replace( /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi, ( ( e, t ) => {
            return "colon" === ( t = t.toLowerCase() ) ? ":" : "#" === t.charAt( 0 ) ? "x" === t.charAt( 1 ) ? String.fromCharCode( parseInt( t.substring( 2 ), 16 ) ) : String.fromCharCode( +t.substring( 1 ) ) : ""
          } ) );
        }

        function d( e, t ) {
          return e = e.source || e, t = t || "", {
            replace( t, n ) {
              return n = ( n = n.source || n ).replace( /(^|[^\[])\^/g, "$1" ), e = e.replace( t, n ), this
            },
            getRegex() {
              return new RegExp( e, t )
            }
          };
        }

        function h( e, t ) {
          return p[ " " + e ] || ( /^[^:]+:\/*[^/]*$/.test( e ) ? p[ " " + e ] = e + "/" : p[ " " + e ] = v( e, "/", !0 ) ), e = p[ " " + e ], "//" === t.slice( 0, 2 ) ? e.replace( /:[\s\S]*/, ":" ) + t : "/" === t.charAt( 0 ) ? e.replace( /(:\/*[^/]*)[\s\S]*/, "$1" ) + t : e + t
        }
        o._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, o._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, o._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, o.autolink = d( o.autolink ).replace( "scheme", o._scheme ).replace( "email", o._email ).getRegex(), o._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, o.tag = d( o.tag ).replace( "comment", t._comment ).replace( "attribute", o._attribute ).getRegex(), o._label = /(?:\[[^\[\]]*\]|\\[\[\]]?|`[^`]*`|[^\[\]\\])*?/, o._href = /\s*(<(?:\\[<>]?|[^\s<>\\])*>|(?:\\[()]?|\([^\s\x00-\x1f()\\]*\)|[^\s\x00-\x1f()\\])*?)/, o._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, o.link = d( o.link ).replace( "label", o._label ).replace( "href", o._href ).replace( "title", o._title ).getRegex(), o.reflink = d( o.reflink ).replace( "label", o._label ).getRegex(), o.normal = m( {}, o ), o.pedantic = m( {}, o.normal, {
          strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
          em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
          link: d( /^!?\[(label)\]\((.*?)\)/ ).replace( "label", o._label ).getRegex(),
          reflink: d( /^!?\[(label)\]\s*\[([^\]]*)\]/ ).replace( "label", o._label ).getRegex()
        } ), o.gfm = m( {}, o.normal, {
          escape: d( o.escape ).replace( "])", "~|])" ).getRegex(),
          url: d( /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/ ).replace( "email", o._email ).getRegex(),
          _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
          del: /^~~(?=\S)([\s\S]*?\S)~~/,
          text: d( o.text ).replace( "]|", "~]|" ).replace( "|", "|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&'*+/=?^_`{\\|}~-]+@|" ).getRegex()
        } ), o.breaks = m( {}, o.gfm, {
          br: d( o.br ).replace( "{2,}", "*" ).getRegex(),
          text: d( o.gfm.text ).replace( "{2,}", "*" ).getRegex()
        } ), r.rules = o, r.output = ( e, t, n ) => {
          return new r( t, n ).output( e )
        }, r.prototype.output = function ( e ) {
          for ( var t, n, i, o, s, a = ""; e; )
            if ( s = this.rules.escape.exec( e ) ) e = e.substring( s[ 0 ].length ), a += s[ 1 ];
            else if ( s = this.rules.autolink.exec( e ) ) e = e.substring( s[ 0 ].length ), i = "@" === s[ 2 ] ? "mailto:" + ( n = l( this.mangle( s[ 1 ] ) ) ) : n = l( s[ 1 ] ), a += this.renderer.link( i, null, n );
          else if ( this.inLink || !( s = this.rules.url.exec( e ) ) ) {
            if ( s = this.rules.tag.exec( e ) ) !this.inLink && /^<a /i.test( s[ 0 ] ) ? this.inLink = !0 : this.inLink && /^<\/a>/i.test( s[ 0 ] ) && ( this.inLink = !1 ), e = e.substring( s[ 0 ].length ), a += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer( s[ 0 ] ) : l( s[ 0 ] ) : s[ 0 ];
            else if ( s = this.rules.link.exec( e ) ) e = e.substring( s[ 0 ].length ), this.inLink = !0, i = s[ 2 ], this.options.pedantic ? ( t = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec( i ) ) ? ( i = t[ 1 ], o = t[ 3 ] ) : o = "" : o = s[ 3 ] ? s[ 3 ].slice( 1, -1 ) : "", i = i.trim().replace( /^<([\s\S]*)>$/, "$1" ), a += this.outputLink( s, {
              href: r.escapes( i ),
              title: r.escapes( o )
            } ), this.inLink = !1;
            else if ( ( s = this.rules.reflink.exec( e ) ) || ( s = this.rules.nolink.exec( e ) ) ) {
              if ( e = e.substring( s[ 0 ].length ), t = ( s[ 2 ] || s[ 1 ] ).replace( /\s+/g, " " ), !( t = this.links[ t.toLowerCase() ] ) || !t.href ) {
                a += s[ 0 ].charAt( 0 ), e = s[ 0 ].substring( 1 ) + e;
                continue
              }
              this.inLink = !0, a += this.outputLink( s, t ), this.inLink = !1
            } else if ( s = this.rules.strong.exec( e ) ) e = e.substring( s[ 0 ].length ), a += this.renderer.strong( this.output( s[ 4 ] || s[ 3 ] || s[ 2 ] || s[ 1 ] ) );
            else if ( s = this.rules.em.exec( e ) ) e = e.substring( s[ 0 ].length ), a += this.renderer.em( this.output( s[ 6 ] || s[ 5 ] || s[ 4 ] || s[ 3 ] || s[ 2 ] || s[ 1 ] ) );
            else if ( s = this.rules.code.exec( e ) ) e = e.substring( s[ 0 ].length ), a += this.renderer.codespan( l( s[ 2 ].trim(), !0 ) );
            else if ( s = this.rules.br.exec( e ) ) e = e.substring( s[ 0 ].length ), a += this.renderer.br();
            else if ( s = this.rules.del.exec( e ) ) e = e.substring( s[ 0 ].length ), a += this.renderer.del( this.output( s[ 1 ] ) );
            else if ( s = this.rules.text.exec( e ) ) e = e.substring( s[ 0 ].length ), a += this.renderer.text( l( this.smartypants( s[ 0 ] ) ) );
            else if ( e ) throw new Error( "Infinite loop on byte: " + e.charCodeAt( 0 ) )
          } else s[ 0 ] = this.rules._backpedal.exec( s[ 0 ] )[ 0 ], e = e.substring( s[ 0 ].length ), "@" === s[ 2 ] ? i = "mailto:" + ( n = l( s[ 0 ] ) ) : ( n = l( s[ 0 ] ), i = "www." === s[ 1 ] ? "http://" + n : n ), a += this.renderer.link( i, null, n );
          return a
        }, r.escapes = e => {
          return e ? e.replace( r.rules._escapes, "$1" ) : e
        }, r.prototype.outputLink = function ( e, t ) {
          const n = t.href,
            i = t.title ? l( t.title ) : null;
          return "!" !== e[ 0 ].charAt( 0 ) ? this.renderer.link( n, i, this.output( e[ 1 ] ) ) : this.renderer.image( n, i, l( e[ 1 ] ) )
        }, r.prototype.smartypants = function ( e ) {
          return this.options.smartypants ? e.replace( /---/g, "\u2014" ).replace( /--/g, "\u2013" ).replace( /(^|[-\u2014/(\[{"\s])'/g, "$1\u2018" ).replace( /'/g, "\u2019" ).replace( /(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201c" ).replace( /"/g, "\u201d" ).replace( /\.{3}/g, "\u2026" ) : e
        }, r.prototype.mangle = function ( e ) {
          if ( !this.options.mangle ) return e;
          for ( var t, n = "", i = e.length, o = 0; o < i; o++ ) t = e.charCodeAt( o ), Math.random() > .5 && ( t = "x" + t.toString( 16 ) ), n += "&#" + t + ";";
          return n
        }, s.prototype.code = function ( e, t, n ) {
          if ( this.options.highlight ) {
            const i = this.options.highlight( e, t );
            null != i && i !== e && ( n = !0, e = i )
          }
          return t ? '<pre><code class="' + this.options.langPrefix + l( t, !0 ) + '">' + ( n ? e : l( e, !0 ) ) + "</code></pre>\n" : "<pre><code>" + ( n ? e : l( e, !0 ) ) + "</code></pre>"
        }, s.prototype.blockquote = e => {
          return "<blockquote>\n" + e + "</blockquote>\n"
        }, s.prototype.html = e => {
          return e
        }, s.prototype.heading = function ( e, t, n ) {
          return this.options.headerIds ? "<h" + t + ' id="' + this.options.headerPrefix + n.toLowerCase().replace( /[^\w]+/g, "-" ) + '">' + e + "</h" + t + ">\n" : "<h" + t + ">" + e + "</h" + t + ">\n"
        }, s.prototype.hr = function () {
          return this.options.xhtml ? "<hr/>\n" : "<hr>\n"
        }, s.prototype.list = ( e, t, n ) => {
          const i = t ? "ol" : "ul";
          return "<" + i + ( t && 1 !== n ? ' start="' + n + '"' : "" ) + ">\n" + e + "</" + i + ">\n"
        }, s.prototype.listitem = e => {
          return "<li>" + e + "</li>\n"
        }, s.prototype.checkbox = function ( e ) {
          return "<input " + ( e ? 'checked="" ' : "" ) + 'disabled="" type="checkbox"' + ( this.options.xhtml ? " /" : "" ) + "> "
        }, s.prototype.paragraph = e => {
          return "<p>" + e + "</p>\n"
        }, s.prototype.table = ( e, t ) => {
          return t && ( t = "<tbody>" + t + "</tbody>" ), "<table>\n<thead>\n" + e + "</thead>\n" + t + "</table>\n"
        }, s.prototype.tablerow = e => {
          return "<tr>\n" + e + "</tr>\n"
        }, s.prototype.tablecell = ( e, t ) => {
          const n = t.header ? "th" : "td";
          return ( t.align ? "<" + n + ' align="' + t.align + '">' : "<" + n + ">" ) + e + "</" + n + ">\n"
        }, s.prototype.strong = e => {
          return "<strong>" + e + "</strong>"
        }, s.prototype.em = e => {
          return "<em>" + e + "</em>"
        }, s.prototype.codespan = e => {
          return "<code>" + e + "</code>"
        }, s.prototype.br = function () {
          return this.options.xhtml ? "<br/>" : "<br>"
        }, s.prototype.del = e => {
          return "<del>" + e + "</del>"
        }, s.prototype.link = function ( e, t, n ) {
          if ( this.options.sanitize ) {
            try {
              var i = decodeURIComponent( c( e ) ).replace( /[^\w:]/g, "" ).toLowerCase()
            } catch ( r ) {
              return n
            }
            if ( 0 === i.indexOf( "javascript:" ) || 0 === i.indexOf( "vbscript:" ) || 0 === i.indexOf( "data:" ) ) return n
          }
          this.options.baseUrl && !f.test( e ) && ( e = h( this.options.baseUrl, e ) );
          try {
            e = encodeURI( e ).replace( /%25/g, "%" )
          } catch ( r ) {
            return n
          }
          let o = '<a href="' + l( e ) + '"';
          return t && ( o += ' title="' + t + '"' ), o += ">" + n + "</a>"
        }, s.prototype.image = function ( e, t, n ) {
          this.options.baseUrl && !f.test( e ) && ( e = h( this.options.baseUrl, e ) );
          let i = '<img src="' + e + '" alt="' + n + '"';
          return t && ( i += ' title="' + t + '"' ), i += this.options.xhtml ? "/>" : ">"
        }, s.prototype.text = e => {
          return e
        }, a.prototype.strong = a.prototype.em = a.prototype.codespan = a.prototype.del = a.prototype.text = e => {
          return e
        }, a.prototype.link = a.prototype.image = ( e, t, n ) => {
          return "" + n
        }, a.prototype.br = () => {
          return ""
        }, u.parse = ( e, t ) => {
          return new u( t ).parse( e )
        }, u.prototype.parse = function ( e ) {
          this.inline = new r( e.links, this.options ), this.inlineText = new r( e.links, m( {}, this.options, {
            renderer: new a
          } ) ), this.tokens = e.reverse();
          for ( var t = ""; this.next(); ) t += this.tok();
          return t
        }, u.prototype.next = function () {
          return this.token = this.tokens.pop()
        }, u.prototype.peek = function () {
          return this.tokens[ this.tokens.length - 1 ] || 0
        }, u.prototype.parseText = function () {
          for ( var e = this.token.text;
            "text" === this.peek().type; ) e += "\n" + this.next().text;
          return this.inline.output( e )
        }, u.prototype.tok = function () {
          switch ( this.token.type ) {
            case "space":
              return "";
            case "hr":
              return this.renderer.hr();
            case "heading":
              return this.renderer.heading( this.inline.output( this.token.text ), this.token.depth, c( this.inlineText.output( this.token.text ) ) );
            case "code":
              return this.renderer.code( this.token.text, this.token.lang, this.token.escaped );
            case "table":
              let e, t, n, i, o = "",
                r = "";
              for ( n = "", e = 0; e < this.token.header.length; e++ ) n += this.renderer.tablecell( this.inline.output( this.token.header[ e ] ), {
                header: !0,
                align: this.token.align[ e ]
              } );
              for ( o += this.renderer.tablerow( n ), e = 0; e < this.token.cells.length; e++ ) {
                for ( t = this.token.cells[ e ], n = "", i = 0; i < t.length; i++ ) n += this.renderer.tablecell( this.inline.output( t[ i ] ), {
                  header: !1,
                  align: this.token.align[ i ]
                } );
                r += this.renderer.tablerow( n )
              }
              return this.renderer.table( o, r );
            case "blockquote_start":
              for ( r = "";
                "blockquote_end" !== this.next().type; ) r += this.tok();
              return this.renderer.blockquote( r );
            case "list_start":
              r = "";
              for ( var s = this.token.ordered, a = this.token.start;
                "list_end" !== this.next().type; ) r += this.tok();
              return this.renderer.list( r, s, a );
            case "list_item_start":
              for ( r = "", this.token.task && ( r += this.renderer.checkbox( this.token.checked ) );
                "list_item_end" !== this.next().type; ) r += "text" === this.token.type ? this.parseText() : this.tok();
              return this.renderer.listitem( r );
            case "loose_item_start":
              for ( r = "";
                "list_item_end" !== this.next().type; ) r += this.tok();
              return this.renderer.listitem( r );
            case "html":
              return this.renderer.html( this.token.text );
            case "paragraph":
              return this.renderer.paragraph( this.inline.output( this.token.text ) );
            case "text":
              return this.renderer.paragraph( this.parseText() )
          }
        };
        var p = {},
          f = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

        function g() {}

        function m( e ) {
          for ( let t, n, i = 1; i < arguments.length; i++ )
            for ( n in t = arguments[ i ] ) Object.prototype.hasOwnProperty.call( t, n ) && ( e[ n ] = t[ n ] );
          return e
        }

        function _( e, t ) {
          const n = e.replace( /\|/g, ( ( e, t, n ) => {
            for ( var i = !1, o = t; --o >= 0 && "\\" === n[ o ]; ) i = !i;
            return i ? "|" : " |"
          } ) ).split( / \|/ );
          let i = 0;
          if ( n.length > t ) n.splice( t );
          else
            for ( ; n.length < t; ) n.push( "" );
          for ( ; i < n.length; i++ ) n[ i ] = n[ i ].trim().replace( /\\\|/g, "|" );
          return n
        }

        function v( e, t, n ) {
          if ( 0 === e.length ) return "";
          for ( var i = 0; i < e.length; ) {
            const o = e.charAt( e.length - i - 1 );
            if ( o !== t || n ) {
              if ( o === t || !n ) break;
              i++
            } else i++
          }
          return e.substr( 0, e.length - i )
        }

        function y( e, t, i ) {
          if ( "undefined" === typeof e || null === e ) throw new Error( "marked(): input parameter is undefined or null" );
          if ( "string" !== typeof e ) throw new Error( "marked(): input parameter is of type " + Object.prototype.toString.call( e ) + ", string expected" );
          if ( i || "function" === typeof t ) {
            i || ( i = t, t = null );
            let o;
            let r;
            const s = ( t = m( {}, y.defaults, t || {} ) ).highlight;
            let a = 0;
            try {
              o = n.lex( e, t )
            } catch ( d ) {
              return i( d )
            }
            r = o.length;
            const c = e => {
              if ( e ) return t.highlight = s, i( e );
              let n;
              try {
                n = u.parse( o, t )
              } catch ( d ) {
                e = d
              }
              return t.highlight = s, e ? i( e ) : i( null, n )
            };
            if ( !s || s.length < 3 ) return c();
            if ( delete t.highlight, !r ) return c();
            for ( ; a < o.length; a++ ) !( e => {
              "code" !== e.type ? --r || c() : s( e.text, e.lang, ( ( t, n ) => {
                return t ? c( t ) : null == n || n === e.text ? --r || c() : ( e.text = n, e.escaped = !0, void( --r || c() ) )
              } ) )
            } )( o[ a ] )
          } else try {
            return t && ( t = m( {}, y.defaults, t ) ), u.parse( n.lex( e, t ), t )
          } catch ( d ) {
            if ( d.message += "\nPlease report this to https://github.com/markedjs/marked.", ( t || y.defaults ).silent ) return "<p>An error occurred:</p><pre>" + l( d.message + "", !0 ) + "</pre>";
            throw d
          }
        }
        g.exec = g, y.options = y.setOptions = e => {
          return m( y.defaults, e ), y
        }, y.getDefaults = () => {
          return {
            baseUrl: null,
            breaks: !1,
            gfm: !0,
            headerIds: !0,
            headerPrefix: "",
            highlight: null,
            langPrefix: "language-",
            mangle: !0,
            pedantic: !1,
            renderer: new s,
            sanitize: !1,
            sanitizer: null,
            silent: !1,
            smartLists: !1,
            smartypants: !1,
            tables: !0,
            xhtml: !1
          }
        }, y.defaults = y.getDefaults(), y.Parser = u, y.parser = u.parse, y.Renderer = s, y.TextRenderer = a, y.Lexer = n, y.lexer = n.lex, y.InlineLexer = r, y.inlineLexer = r.output, y.parse = y, i = y
      } ) ).call( void 0 );
      const u = i;
      i.Parser, i.parser, i.Renderer, i.TextRenderer, i.Lexer, i.lexer, i.InlineLexer, i.inlineLexer, i.parse;

      function l( e ) {
        const t = e.inline ? "span" : "div",
          n = document.createElement( t );
        return e.className && ( n.className = e.className ), n
      }

      function c( e, t ) {
        void 0 === t && ( t = {} );
        const n = l( t );
        return n.textContent = e, n
      }

      function d( e, t ) {
        void 0 === t && ( t = {} );
        const n = l( t );
        return function e( t, n, i ) {
          let r;
          if ( 2 === n.type ) r = document.createTextNode( n.content );
          else if ( 3 === n.type ) r = document.createElement( "b" );
          else if ( 4 === n.type ) r = document.createElement( "i" );
          else if ( 5 === n.type && i ) {
            const s = document.createElement( "a" );
            s.href = "#", i.disposeables.push( o.j( s, "click", ( e => {
              i.callback( String( n.index ), e )
            } ) ) ), r = s
          } else 7 === n.type ? r = document.createElement( "br" ) : 1 === n.type && ( r = t );
          t !== r && t.appendChild( r );
          Array.isArray( n.children ) && n.children.forEach( ( t => {
            e( r, t, i )
          } ) )
        }(
          n,
          ( e => {
            const t = {
              type: 1,
              children: []
            };
            let n = 0;
            let i = t;
            const o = [];
            const r = new p( e );
            for ( ; !r.eos(); ) {
              let s = r.next();
              const a = "\\" === s && 0 !== f( r.peek() );
              if ( a && ( s = r.next() ), a || 0 === f( s ) || s !== r.peek() )
                if ( "\n" === s ) 2 === i.type && ( i = o.pop() ), i.children.push( {
                  type: 7
                } );
                else if ( 2 !== i.type ) {
                const u = {
                  type: 2,
                  content: s
                };
                i.children.push( u ), o.push( i ), i = u
              } else i.content += s;
              else {
                r.advance(), 2 === i.type && ( i = o.pop() );
                const l = f( s );
                if ( i.type === l || 5 === i.type && 6 === l ) i = o.pop();
                else {
                  const c = {
                    type: l,
                    children: []
                  };
                  5 === l && ( c.index = n, n++ ), i.children.push( c ), o.push( i ), i = c
                }
              }
            }
            2 === i.type && ( i = o.pop() );
            o.length;
            return t
          } )( e ),
          t.actionHandler
        ), n;
      }

      function h( e, t ) {
        void 0 === t && ( t = {} );
        let n;
        const i = l( t );
        const c = new Promise( ( e => {
          return n = e
        } ) );
        const d = new u.Renderer;
        d.image = ( e, t, n ) => {
          const i = [];
          if ( e ) {
            const o = e.split( "|" ).map( ( e => {
              return e.trim()
            } ) );
            e = o[ 0 ];
            const r = o[ 1 ];
            if ( r ) {
              const s = /height=(\d+)/.exec( r ),
                a = /width=(\d+)/.exec( r ),
                u = s && s[ 1 ],
                l = a && a[ 1 ],
                c = isFinite( parseInt( l ) ),
                d = isFinite( parseInt( u ) );
              c && i.push( 'width="' + l + '"' ), d && i.push( 'height="' + u + '"' )
            }
          }
          let h = [];
          return e && h.push( 'src="' + e + '"' ), n && h.push( 'alt="' + n + '"' ), t && h.push( 'title="' + t + '"' ), i.length && ( h = h.concat( i ) ), "<img " + h.join( " " ) + ">"
        }, d.link = ( t, n, i ) => {
          return t === i && ( i = Object( a.d )( i ) ), n = Object( a.d )( n ), !( t = Object( a.d )( t ) ) || t.match( /^data:|javascript:/i ) || t.match( /^command:/i ) && !e.isTrusted ? i : '<a href="#" data-href="' + t + '" title="' + ( n || t ) + '">' + i + "</a>"
        }, d.paragraph = e => {
          return "<p>" + e + "</p>"
        }, t.codeBlockRenderer && ( d.code = ( e, n ) => {
          const o = t.codeBlockRenderer( n, e ),
            a = r.b.nextId(),
            u = Promise.all( [ o, c ] ).then( ( e => {
              const t = e[ 0 ],
                n = i.querySelector( 'div[data-code="' + a + '"]' );
              n && ( n.innerHTML = t )
            } ) ).catch( ( e => {} ) );
          return t.codeBlockRenderCallback && u.then( t.codeBlockRenderCallback ), '<div class="code" data-code="' + a + '">' + Object( s.escape )( e ) + "</div>"
        } ), t.actionHandler && t.actionHandler.disposeables.push( o.j( i, "click", ( e => {
          let n = e.target;
          if ( "A" === n.tagName || ( n = n.parentElement ) && "A" === n.tagName ) {
            const i = n.dataset.href;
            i && t.actionHandler.callback( i, e )
          }
        } ) ) );
        const h = {
          sanitize: !0,
          renderer: d
        };
        return i.innerHTML = u( e.value, h ), n(), i
      }
      n.d( t, "c", ( () => {
        return c
      } ) ), n.d( t, "a", ( () => {
        return d
      } ) ), n.d( t, "b", ( () => {
        return h
      } ) );
      var p = ( () => {
        function e( e ) {
          this.source = e, this.index = 0
        }
        return e.prototype.eos = function () {
          return this.index >= this.source.length
        }, e.prototype.next = function () {
          const e = this.peek();
          return this.advance(), e
        }, e.prototype.peek = function () {
          return this.source[ this.index ]
        }, e.prototype.advance = function () {
          this.index++
        }, e;
      } )();

      function f( e ) {
        switch ( e ) {
          case "*":
            return 3;
          case "_":
            return 4;
          case "[":
            return 5;
          case "]":
            return 6;
          default:
            return 0
        }
      }
    },
    oAeH( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return c
      } ) ), n.d( t, "a", ( () => {
        return i
      } ) );
      var i;
      const o = n( "Ll0s" );
      const r = n( "cGHE" );
      const s = n( "aokT" );
      const a = n( "+Fos" );
      const u = n( "1I1M" );
      const l = n( "746U" );

      var c = ( () => {
        function e() {}
        return e.addCursorDown = ( e, t, n ) => {
          for ( var i = [], r = 0, s = 0, u = t.length; s < u; s++ ) {
            const l = t[ s ];
            i[ r++ ] = new o.d( l.modelState, l.viewState ), i[ r++ ] = n ? o.d.fromModelState( a.a.translateDown( e.config, e.model, l.modelState ) ) : o.d.fromViewState( a.a.translateDown( e.config, e.viewModel, l.viewState ) )
          }
          return i
        }, e.addCursorUp = ( e, t, n ) => {
          for ( var i = [], r = 0, s = 0, u = t.length; s < u; s++ ) {
            const l = t[ s ];
            i[ r++ ] = new o.d( l.modelState, l.viewState ), i[ r++ ] = n ? o.d.fromModelState( a.a.translateUp( e.config, e.model, l.modelState ) ) : o.d.fromViewState( a.a.translateUp( e.config, e.viewModel, l.viewState ) )
          }
          return i
        }, e.moveToBeginningOfLine = function ( e, t, n ) {
          for ( var i = [], o = 0, r = t.length; o < r; o++ ) {
            const s = t[ o ];
            i[ o ] = this._moveToLineStart( e, s, n )
          }
          return i
        }, e._moveToLineStart = function ( e, t, n ) {
          const i = t.viewState.position.column,
            o = i === t.modelState.position.column,
            r = t.viewState.position.lineNumber,
            s = e.viewModel.getLineFirstNonWhitespaceColumn( r );
          return o || i === s ? this._moveToLineStartByModel( e, t, n ) : this._moveToLineStartByView( e, t, n )
        }, e._moveToLineStartByView = ( e, t, n ) => {
          return o.d.fromViewState( a.a.moveToBeginningOfLine( e.config, e.viewModel, t.viewState, n ) )
        }, e._moveToLineStartByModel = ( e, t, n ) => {
          return o.d.fromModelState( a.a.moveToBeginningOfLine( e.config, e.model, t.modelState, n ) )
        }, e.moveToEndOfLine = function ( e, t, n ) {
          for ( var i = [], o = 0, r = t.length; o < r; o++ ) {
            const s = t[ o ];
            i[ o ] = this._moveToLineEnd( e, s, n )
          }
          return i
        }, e._moveToLineEnd = function ( e, t, n ) {
          const i = t.viewState.position,
            o = e.viewModel.getLineMaxColumn( i.lineNumber ),
            r = i.column === o,
            s = t.modelState.position,
            a = e.model.getLineMaxColumn( s.lineNumber ),
            u = o - i.column === a - s.column;
          return r || u ? this._moveToLineEndByModel( e, t, n ) : this._moveToLineEndByView( e, t, n )
        }, e._moveToLineEndByView = ( e, t, n ) => {
          return o.d.fromViewState( a.a.moveToEndOfLine( e.config, e.viewModel, t.viewState, n ) )
        }, e._moveToLineEndByModel = ( e, t, n ) => {
          return o.d.fromModelState( a.a.moveToEndOfLine( e.config, e.model, t.modelState, n ) )
        }, e.expandLineSelection = ( e, t ) => {
          for ( var n = [], i = 0, a = t.length; i < a; i++ ) {
            const u = t[ i ].viewState.selection;
            const l = u.startLineNumber;
            const c = e.viewModel.getLineCount();
            let d = u.endLineNumber;
            let h = void 0;
            d === c ? h = e.viewModel.getLineMaxColumn( c ) : ( d++, h = 1 ), n[ i ] = o.d.fromViewState( new o.f( new s.a( l, 1, l, 1 ), 0, new r.a( d, h ), 0 ) )
          }
          return n
        }, e.moveToBeginningOfBuffer = ( e, t, n ) => {
          for ( var i = [], r = 0, s = t.length; r < s; r++ ) {
            const u = t[ r ];
            i[ r ] = o.d.fromModelState( a.a.moveToBeginningOfBuffer( e.config, e.model, u.modelState, n ) )
          }
          return i
        }, e.moveToEndOfBuffer = ( e, t, n ) => {
          for ( var i = [], r = 0, s = t.length; r < s; r++ ) {
            const u = t[ r ];
            i[ r ] = o.d.fromModelState( a.a.moveToEndOfBuffer( e.config, e.model, u.modelState, n ) )
          }
          return i
        }, e.selectAll = ( e, t ) => {
          const n = e.model.getLineCount(),
            i = e.model.getLineMaxColumn( n );
          return o.d.fromModelState( new o.f( new s.a( 1, 1, 1, 1 ), 0, new r.a( n, i ), 0 ) )
        }, e.line = ( e, t, n, i, a ) => {
          const u = e.model.validatePosition( i ),
            l = a ? e.validateViewPosition( new r.a( a.lineNumber, a.column ), u ) : e.convertModelPositionToViewPosition( u );
          if ( !n || !t.modelState.hasSelection() ) {
            var c = e.model.getLineCount();
            let d = u.lineNumber + 1;
            let h = 1;
            return d > c && ( d = c, h = e.model.getLineMaxColumn( d ) ), o.d.fromModelState( new o.f( new s.a( u.lineNumber, 1, d, h ), 0, new r.a( d, h ), 0 ) )
          }
          const p = t.modelState.selectionStart.getStartPosition().lineNumber;
          if ( u.lineNumber < p ) return o.d.fromViewState( t.viewState.move( t.modelState.hasSelection(), l.lineNumber, 1, 0 ) );
          if ( u.lineNumber > p ) {
            c = e.viewModel.getLineCount();
            let f = l.lineNumber + 1,
              g = 1;
            return f > c && ( f = c, g = e.viewModel.getLineMaxColumn( f ) ), o.d.fromViewState( t.viewState.move( t.modelState.hasSelection(), f, g, 0 ) )
          }
          const m = t.modelState.selectionStart.getEndPosition();
          return o.d.fromModelState( t.modelState.move( t.modelState.hasSelection(), m.lineNumber, m.column, 0 ) )
        }, e.word = ( e, t, n, i ) => {
          const r = e.model.validatePosition( i );
          return o.d.fromModelState( u.a.word( e.config, e.model, t.modelState, n, r ) )
        }, e.cancelSelection = ( e, t ) => {
          if ( !t.modelState.hasSelection() ) return new o.d( t.modelState, t.viewState );
          const n = t.viewState.position.lineNumber,
            i = t.viewState.position.column;
          return o.d.fromViewState( new o.f( new s.a( n, i, n, i ), 0, new r.a( n, i ), 0 ) )
        }, e.moveTo = ( e, t, n, i, s ) => {
          const a = e.model.validatePosition( i ),
            u = s ? e.validateViewPosition( new r.a( s.lineNumber, s.column ), a ) : e.convertModelPositionToViewPosition( a );
          return o.d.fromViewState( t.viewState.move( n, u.lineNumber, u.column, 0 ) )
        }, e.move = function ( e, t, n ) {
          const i = n.select,
            o = n.value;
          switch ( n.direction ) {
            case 0:
              return 4 === n.unit ? this._moveHalfLineLeft( e, t, i ) : this._moveLeft( e, t, i, o );
            case 1:
              return 4 === n.unit ? this._moveHalfLineRight( e, t, i ) : this._moveRight( e, t, i, o );
            case 2:
              return 2 === n.unit ? this._moveUpByViewLines( e, t, i, o ) : this._moveUpByModelLines( e, t, i, o );
            case 3:
              return 2 === n.unit ? this._moveDownByViewLines( e, t, i, o ) : this._moveDownByModelLines( e, t, i, o );
            case 4:
              return this._moveToViewMinColumn( e, t, i );
            case 5:
              return this._moveToViewFirstNonWhitespaceColumn( e, t, i );
            case 6:
              return this._moveToViewCenterColumn( e, t, i );
            case 7:
              return this._moveToViewMaxColumn( e, t, i );
            case 8:
              return this._moveToViewLastNonWhitespaceColumn( e, t, i );
            case 9:
              let r = t[ 0 ],
                s = e.getCompletelyVisibleModelRange(),
                a = this._firstLineNumberInRange( e.model, s, o ),
                u = e.model.getLineFirstNonWhitespaceColumn( a );
              return [ this._moveToModelPosition( e, r, i, a, u ) ];
            case 11:
              r = t[ 0 ], s = e.getCompletelyVisibleModelRange(), a = this._lastLineNumberInRange( e.model, s, o ), u = e.model.getLineFirstNonWhitespaceColumn( a );
              return [ this._moveToModelPosition( e, r, i, a, u ) ];
            case 10:
              r = t[ 0 ], s = e.getCompletelyVisibleModelRange(), a = Math.round( ( s.startLineNumber + s.endLineNumber ) / 2 ), u = e.model.getLineFirstNonWhitespaceColumn( a );
              return [ this._moveToModelPosition( e, r, i, a, u ) ];
            case 12:
              for ( var l = e.getCompletelyVisibleViewRange(), c = [], d = 0, h = t.length; d < h; d++ ) {
                r = t[ d ];
                c[ d ] = this.findPositionInViewportIfOutside( e, r, l, i )
              }
              return c
          }
          return null
        }, e.findPositionInViewportIfOutside = function ( e, t, n, i ) {
          let r = t.viewState.position.lineNumber;
          if ( n.startLineNumber <= r && r <= n.endLineNumber - 1 ) return new o.d( t.modelState, t.viewState );
          r > n.endLineNumber - 1 && ( r = n.endLineNumber - 1 ), r < n.startLineNumber && ( r = n.startLineNumber );
          const s = e.viewModel.getLineFirstNonWhitespaceColumn( r );
          return this._moveToViewPosition( e, t, i, r, s )
        }, e._firstLineNumberInRange = ( e, t, n ) => {
          let i = t.startLineNumber;
          return t.startColumn !== e.getLineMinColumn( i ) && i++, Math.min( t.endLineNumber, i + n - 1 )
        }, e._lastLineNumberInRange = ( e, t, n ) => {
          let i = t.startLineNumber;
          return t.startColumn !== e.getLineMinColumn( i ) && i++, Math.max( i, t.endLineNumber - n + 1 )
        }, e._moveLeft = ( e, t, n, i ) => {
          for ( var r = [], s = 0, u = t.length; s < u; s++ ) {
            const l = t[ s ];
            let c = a.a.moveLeft( e.config, e.viewModel, l.viewState, n, i );
            if ( 1 === i && c.position.lineNumber !== l.viewState.position.lineNumber ) e.viewModel.coordinatesConverter.convertViewPositionToModelPosition( c.position ).lineNumber === l.modelState.position.lineNumber && ( c = a.a.moveLeft( e.config, e.viewModel, c, n, 1 ) );
            r[ s ] = o.d.fromViewState( c )
          }
          return r
        }, e._moveHalfLineLeft = ( e, t, n ) => {
          for ( var i = [], r = 0, s = t.length; r < s; r++ ) {
            const u = t[ r ],
              l = u.viewState.position.lineNumber,
              c = Math.round( e.viewModel.getLineContent( l ).length / 2 );
            i[ r ] = o.d.fromViewState( a.a.moveLeft( e.config, e.viewModel, u.viewState, n, c ) )
          }
          return i
        }, e._moveRight = ( e, t, n, i ) => {
          for ( var r = [], s = 0, u = t.length; s < u; s++ ) {
            const l = t[ s ];
            let c = a.a.moveRight( e.config, e.viewModel, l.viewState, n, i );
            if ( 1 === i && c.position.lineNumber !== l.viewState.position.lineNumber ) e.viewModel.coordinatesConverter.convertViewPositionToModelPosition( c.position ).lineNumber === l.modelState.position.lineNumber && ( c = a.a.moveRight( e.config, e.viewModel, c, n, 1 ) );
            r[ s ] = o.d.fromViewState( c )
          }
          return r
        }, e._moveHalfLineRight = ( e, t, n ) => {
          for ( var i = [], r = 0, s = t.length; r < s; r++ ) {
            const u = t[ r ],
              l = u.viewState.position.lineNumber,
              c = Math.round( e.viewModel.getLineContent( l ).length / 2 );
            i[ r ] = o.d.fromViewState( a.a.moveRight( e.config, e.viewModel, u.viewState, n, c ) )
          }
          return i
        }, e._moveDownByViewLines = ( e, t, n, i ) => {
          for ( var r = [], s = 0, u = t.length; s < u; s++ ) {
            const l = t[ s ];
            r[ s ] = o.d.fromViewState( a.a.moveDown( e.config, e.viewModel, l.viewState, n, i ) )
          }
          return r
        }, e._moveDownByModelLines = ( e, t, n, i ) => {
          for ( var r = [], s = 0, u = t.length; s < u; s++ ) {
            const l = t[ s ];
            r[ s ] = o.d.fromModelState( a.a.moveDown( e.config, e.model, l.modelState, n, i ) )
          }
          return r
        }, e._moveUpByViewLines = ( e, t, n, i ) => {
          for ( var r = [], s = 0, u = t.length; s < u; s++ ) {
            const l = t[ s ];
            r[ s ] = o.d.fromViewState( a.a.moveUp( e.config, e.viewModel, l.viewState, n, i ) )
          }
          return r
        }, e._moveUpByModelLines = ( e, t, n, i ) => {
          for ( var r = [], s = 0, u = t.length; s < u; s++ ) {
            const l = t[ s ];
            r[ s ] = o.d.fromModelState( a.a.moveUp( e.config, e.model, l.modelState, n, i ) )
          }
          return r
        }, e._moveToViewPosition = ( e, t, n, i, r ) => {
          return o.d.fromViewState( t.viewState.move( n, i, r, 0 ) )
        }, e._moveToModelPosition = ( e, t, n, i, r ) => {
          return o.d.fromModelState( t.modelState.move( n, i, r, 0 ) )
        }, e._moveToViewMinColumn = function ( e, t, n ) {
          for ( var i = [], o = 0, r = t.length; o < r; o++ ) {
            const s = t[ o ],
              a = s.viewState.position.lineNumber,
              u = e.viewModel.getLineMinColumn( a );
            i[ o ] = this._moveToViewPosition( e, s, n, a, u )
          }
          return i
        }, e._moveToViewFirstNonWhitespaceColumn = function ( e, t, n ) {
          for ( var i = [], o = 0, r = t.length; o < r; o++ ) {
            const s = t[ o ],
              a = s.viewState.position.lineNumber,
              u = e.viewModel.getLineFirstNonWhitespaceColumn( a );
            i[ o ] = this._moveToViewPosition( e, s, n, a, u )
          }
          return i
        }, e._moveToViewCenterColumn = function ( e, t, n ) {
          for ( var i = [], o = 0, r = t.length; o < r; o++ ) {
            const s = t[ o ],
              a = s.viewState.position.lineNumber,
              u = Math.round( ( e.viewModel.getLineMaxColumn( a ) + e.viewModel.getLineMinColumn( a ) ) / 2 );
            i[ o ] = this._moveToViewPosition( e, s, n, a, u )
          }
          return i
        }, e._moveToViewMaxColumn = function ( e, t, n ) {
          for ( var i = [], o = 0, r = t.length; o < r; o++ ) {
            const s = t[ o ],
              a = s.viewState.position.lineNumber,
              u = e.viewModel.getLineMaxColumn( a );
            i[ o ] = this._moveToViewPosition( e, s, n, a, u )
          }
          return i
        }, e._moveToViewLastNonWhitespaceColumn = function ( e, t, n ) {
          for ( var i = [], o = 0, r = t.length; o < r; o++ ) {
            const s = t[ o ],
              a = s.viewState.position.lineNumber,
              u = e.viewModel.getLineLastNonWhitespaceColumn( a );
            i[ o ] = this._moveToViewPosition( e, s, n, a, u )
          }
          return i
        }, e;
      } )();

      !( e => {
        e.description = {
          description: "Move cursor to a logical position in the view",
          args: [ {
            name: "Cursor move argument object",
            description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'left', 'right', 'up', 'down'\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t",
            constraint( e ) {
              if ( !l.g( e ) ) return !1;
              const t = e;
              return !!l.h( t.to ) && ( !( !l.i( t.select ) && !l.c( t.select ) ) && ( !( !l.i( t.by ) && !l.h( t.by ) ) && !( !l.i( t.value ) && !l.f( t.value ) ) ) )
            }
          } ]
        }, e.RawDirection = {
          Left: "left",
          Right: "right",
          Up: "up",
          Down: "down",
          WrappedLineStart: "wrappedLineStart",
          WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
          WrappedLineColumnCenter: "wrappedLineColumnCenter",
          WrappedLineEnd: "wrappedLineEnd",
          WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
          ViewPortTop: "viewPortTop",
          ViewPortCenter: "viewPortCenter",
          ViewPortBottom: "viewPortBottom",
          ViewPortIfOutside: "viewPortIfOutside"
        }, e.RawUnit = {
          Line: "line",
          WrappedLine: "wrappedLine",
          Character: "character",
          HalfLine: "halfLine"
        }, e.parse = t => {
          if ( !t.to ) return null;
          let n;
          switch ( t.to ) {
            case e.RawDirection.Left:
              n = 0;
              break;
            case e.RawDirection.Right:
              n = 1;
              break;
            case e.RawDirection.Up:
              n = 2;
              break;
            case e.RawDirection.Down:
              n = 3;
              break;
            case e.RawDirection.WrappedLineStart:
              n = 4;
              break;
            case e.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
              n = 5;
              break;
            case e.RawDirection.WrappedLineColumnCenter:
              n = 6;
              break;
            case e.RawDirection.WrappedLineEnd:
              n = 7;
              break;
            case e.RawDirection.WrappedLineLastNonWhitespaceCharacter:
              n = 8;
              break;
            case e.RawDirection.ViewPortTop:
              n = 9;
              break;
            case e.RawDirection.ViewPortBottom:
              n = 11;
              break;
            case e.RawDirection.ViewPortCenter:
              n = 10;
              break;
            case e.RawDirection.ViewPortIfOutside:
              n = 12;
              break;
            default:
              return null
          }
          let i = 0;
          switch ( t.by ) {
            case e.RawUnit.Line:
              i = 1;
              break;
            case e.RawUnit.WrappedLine:
              i = 2;
              break;
            case e.RawUnit.Character:
              i = 3;
              break;
            case e.RawUnit.HalfLine:
              i = 4
          }
          return {
            direction: n,
            unit: i,
            select: !!t.select,
            value: t.value || 1
          }
        }
      } )( i || ( i = {} ) )
    },
    oKJv( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "pgsql",
        extensions: [],
        aliases: [ "PostgreSQL", "postgres", "pg", "postgre" ],
        loader() {
          return o.Promise.wrap( n.e( 285 ).then( n.bind( null, "HGU1" ) ) )
        }
      } )
    },
    oQaD( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "pmY6" ),
        r = n( "T8No" ),
        s = n( "N0LK" ),
        a = n( "sswD" ),
        u = n( "X+cX" ),
        l = ( () => {
          function e( e ) {
            e && 0 !== e.length ? 1 === e.length && null !== e[ 0 ].staticValue ? ( this._staticValue = e[ 0 ].staticValue, this._pieces = null ) : ( this._staticValue = null, this._pieces = e ) : ( this._staticValue = "", this._pieces = null )
          }
          return e.fromStaticValue = t => {
            return new e( [ c.staticValue( t ) ] )
          }, Object.defineProperty( e.prototype, "hasReplacementPatterns", {
            get() {
              return null === this._staticValue
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.buildReplaceString = function ( t ) {
            if ( null !== this._staticValue ) return this._staticValue;
            for ( var n = "", i = 0, o = this._pieces.length; i < o; i++ ) {
              const r = this._pieces[ i ];
              null === r.staticValue ? n += e._substitute( r.matchIndex, t ) : n += r.staticValue
            }
            return n
          }, e._substitute = ( e, t ) => {
            if ( 0 === e ) return t[ 0 ];
            for ( var n = ""; e > 0; ) {
              if ( e < t.length ) return ( t[ e ] || "" ) + n;
              n = String( e % 10 ) + n, e = Math.floor( e / 10 )
            }
            return "$" + n
          }, e;
        } )(),
        c = ( () => {
          function e( e, t ) {
            this.staticValue = e, this.matchIndex = t
          }
          return e.staticValue = t => {
            return new e( t, -1 )
          }, e.matchIndex = t => {
            return new e( null, t )
          }, e;
        } )(),
        d = ( () => {
          function e( e ) {
            this._source = e, this._lastCharIndex = 0, this._result = [], this._resultLen = 0, this._currentStaticPiece = ""
          }
          return e.prototype.emitUnchanged = function ( e ) {
            this._emitStatic( this._source.substring( this._lastCharIndex, e ) ), this._lastCharIndex = e
          }, e.prototype.emitStatic = function ( e, t ) {
            this._emitStatic( e ), this._lastCharIndex = t
          }, e.prototype._emitStatic = function ( e ) {
            0 !== e.length && ( this._currentStaticPiece += e )
          }, e.prototype.emitMatchIndex = function ( e, t ) {
            0 !== this._currentStaticPiece.length && ( this._result[ this._resultLen++ ] = c.staticValue( this._currentStaticPiece ), this._currentStaticPiece = "" ), this._result[ this._resultLen++ ] = c.matchIndex( e ), this._lastCharIndex = t
          }, e.prototype.finalize = function () {
            return this.emitUnchanged( this._source.length ), 0 !== this._currentStaticPiece.length && ( this._result[ this._resultLen++ ] = c.staticValue( this._currentStaticPiece ), this._currentStaticPiece = "" ), new l( this._result )
          }, e
        } )();
      const h = n( "LCkn" ),
        p = n( "cGHE" ),
        f = n( "aokT" ),
        g = n( "tX9W" ),
        m = n( "MD5Z" ),
        _ = n( "t9D7" ),
        v = n( "M1Kb" ),
        y = ( () => {
          function e( e ) {
            this._editor = e, this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationId = null, this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null, this._startPosition = this._editor.getPosition()
          }
          return e.prototype.dispose = function () {
            this._editor.deltaDecorations( this._allDecorations(), [] ), this._editor = null, this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationId = null, this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null, this._startPosition = null
          }, e.prototype.reset = function () {
            this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationId = null, this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null
          }, e.prototype.getCount = function () {
            return this._decorations.length
          }, e.prototype.getFindScope = function () {
            return this._findScopeDecorationId ? this._editor.getModel().getDecorationRange( this._findScopeDecorationId ) : null
          }, e.prototype.getStartPosition = function () {
            return this._startPosition
          }, e.prototype.setStartPosition = function ( e ) {
            this._startPosition = e, this.setCurrentFindMatch( null )
          }, e.prototype._getDecorationIndex = function ( e ) {
            const t = this._decorations.indexOf( e );
            return t >= 0 ? t + 1 : 1
          }, e.prototype.getCurrentMatchesPosition = function ( t ) {
            for ( let n = this._editor.getModel().getDecorationsInRange( t ), i = 0, o = n.length; i < o; i++ ) {
              const r = n[ i ],
                s = r.options;
              if ( s === e._FIND_MATCH_DECORATION || s === e._CURRENT_FIND_MATCH_DECORATION ) return this._getDecorationIndex( r.id )
            }
            return 1
          }, e.prototype.setCurrentFindMatch = function ( t ) {
            const n = this;
            let i = null;
            let o = 0;
            if ( t )
              for ( let r = 0, s = this._decorations.length; r < s; r++ ) {
                const a = this._editor.getModel().getDecorationRange( this._decorations[ r ] );
                if ( t.equalsRange( a ) ) {
                  i = this._decorations[ r ], o = r + 1;
                  break
                }
              }
            return null === this._highlightedDecorationId && null === i || this._editor.changeDecorations( ( t => {
              if ( null !== n._highlightedDecorationId && ( t.changeDecorationOptions( n._highlightedDecorationId, e._FIND_MATCH_DECORATION ), n._highlightedDecorationId = null ), null !== i && ( n._highlightedDecorationId = i, t.changeDecorationOptions( n._highlightedDecorationId, e._CURRENT_FIND_MATCH_DECORATION ) ), null !== n._rangeHighlightDecorationId && ( t.removeDecoration( n._rangeHighlightDecorationId ), n._rangeHighlightDecorationId = null ), null !== i ) {
                let o = n._editor.getModel().getDecorationRange( i );
                if ( o.startLineNumber !== o.endLineNumber && 1 === o.endColumn ) {
                  const r = o.endLineNumber - 1,
                    s = n._editor.getModel().getLineMaxColumn( r );
                  o = new f.a( o.startLineNumber, o.startColumn, r, s )
                }
                n._rangeHighlightDecorationId = t.addDecoration( o, e._RANGE_HIGHLIGHT_DECORATION )
              }
            } ) ), o;
          }, e.prototype.set = function ( t, n ) {
            const i = this;
            this._editor.changeDecorations( ( o => {
              let r = e._FIND_MATCH_DECORATION;
              const s = [];
              if ( t.length > 1e3 ) {
                r = e._FIND_MATCH_NO_OVERVIEW_DECORATION;
                for ( var a = i._editor.getModel().getLineCount(), u = i._editor.getLayoutInfo().height / a, l = Math.max( 2, Math.ceil( 3 / u ) ), c = t[ 0 ].range.startLineNumber, d = t[ 0 ].range.endLineNumber, h = 1, p = t.length; h < p; h++ ) {
                  const g = t[ h ].range;
                  d + l >= g.startLineNumber ? g.endLineNumber > d && ( d = g.endLineNumber ) : ( s.push( {
                    range: new f.a( c, 1, d, 1 ),
                    options: e._FIND_MATCH_ONLY_OVERVIEW_DECORATION
                  } ), c = g.startLineNumber, d = g.endLineNumber )
                }
                s.push( {
                  range: new f.a( c, 1, d, 1 ),
                  options: e._FIND_MATCH_ONLY_OVERVIEW_DECORATION
                } )
              }
              const m = new Array( t.length );
              for ( h = 0, p = t.length; h < p; h++ ) m[ h ] = {
                range: t[ h ].range,
                options: r
              };
              i._decorations = o.deltaDecorations( i._decorations, m ), i._overviewRulerApproximateDecorations = o.deltaDecorations( i._overviewRulerApproximateDecorations, s ), i._rangeHighlightDecorationId && ( o.removeDecoration( i._rangeHighlightDecorationId ), i._rangeHighlightDecorationId = null ), i._findScopeDecorationId && ( o.removeDecoration( i._findScopeDecorationId ), i._findScopeDecorationId = null ), n && ( i._findScopeDecorationId = o.addDecoration( n, e._FIND_SCOPE_DECORATION ) )
            } ) )
          }, e.prototype.matchBeforePosition = function ( e ) {
            if ( 0 === this._decorations.length ) return null;
            for ( let t = this._decorations.length - 1; t >= 0; t-- ) {
              const n = this._decorations[ t ],
                i = this._editor.getModel().getDecorationRange( n );
              if ( i && !( i.endLineNumber > e.lineNumber ) ) {
                if ( i.endLineNumber < e.lineNumber ) return i;
                if ( !( i.endColumn > e.column ) ) return i
              }
            }
            return this._editor.getModel().getDecorationRange( this._decorations[ this._decorations.length - 1 ] )
          }, e.prototype.matchAfterPosition = function ( e ) {
            if ( 0 === this._decorations.length ) return null;
            for ( let t = 0, n = this._decorations.length; t < n; t++ ) {
              const i = this._decorations[ t ],
                o = this._editor.getModel().getDecorationRange( i );
              if ( o && !( o.startLineNumber < e.lineNumber ) ) {
                if ( o.startLineNumber > e.lineNumber ) return o;
                if ( !( o.startColumn < e.column ) ) return o
              }
            }
            return this._editor.getModel().getDecorationRange( this._decorations[ 0 ] )
          }, e.prototype._allDecorations = function () {
            let e = [];
            return e = ( e = e.concat( this._decorations ) ).concat( this._overviewRulerApproximateDecorations ), this._findScopeDecorationId && e.push( this._findScopeDecorationId ), this._rangeHighlightDecorationId && e.push( this._rangeHighlightDecorationId ), e
          }, e._CURRENT_FIND_MATCH_DECORATION = g.a.register( {
            stickiness: v.h.NeverGrowsWhenTypingAtEdges,
            zIndex: 13,
            className: "currentFindMatch",
            showIfCollapsed: !0,
            overviewRuler: {
              color: Object( _.f )( m.fb ),
              darkColor: Object( _.f )( m.fb ),
              position: v.f.Center
            }
          } ), e._FIND_MATCH_DECORATION = g.a.register( {
            stickiness: v.h.NeverGrowsWhenTypingAtEdges,
            className: "findMatch",
            showIfCollapsed: !0,
            overviewRuler: {
              color: Object( _.f )( m.fb ),
              darkColor: Object( _.f )( m.fb ),
              position: v.f.Center
            }
          } ), e._FIND_MATCH_NO_OVERVIEW_DECORATION = g.a.register( {
            stickiness: v.h.NeverGrowsWhenTypingAtEdges,
            className: "findMatch",
            showIfCollapsed: !0
          } ), e._FIND_MATCH_ONLY_OVERVIEW_DECORATION = g.a.register( {
            stickiness: v.h.NeverGrowsWhenTypingAtEdges,
            overviewRuler: {
              color: Object( _.f )( m.fb ),
              darkColor: Object( _.f )( m.fb ),
              position: v.f.Center
            }
          } ), e._RANGE_HIGHLIGHT_DECORATION = g.a.register( {
            stickiness: v.h.NeverGrowsWhenTypingAtEdges,
            className: "rangeHighlight",
            isWholeLine: !0
          } ), e._FIND_SCOPE_DECORATION = g.a.register( {
            className: "findScope",
            isWholeLine: !0
          } ), e;
        } )(),
        b = ( () => {
          function e( e, t, n ) {
            this._editorSelection = e, this._ranges = t, this._replaceStrings = n
          }
          return e.prototype.getEditOperations = function ( e, t ) {
            if ( this._ranges.length > 0 ) {
              for ( var n = [], i = 0; i < this._ranges.length; i++ ) n.push( {
                range: this._ranges[ i ],
                text: this._replaceStrings[ i ]
              } );
              n.sort( ( ( e, t ) => {
                return f.a.compareRangesUsingStarts( e.range, t.range )
              } ) );
              const o = [];
              let r = n[ 0 ];
              for ( i = 1; i < n.length; i++ ) r.range.endLineNumber === n[ i ].range.startLineNumber && r.range.endColumn === n[ i ].range.startColumn ? ( r.range = r.range.plusRange( n[ i ].range ), r.text = r.text + n[ i ].text ) : ( o.push( r ), r = n[ i ] );
              o.push( r );
              for ( i = 0; i < o.length; i++ ) t.addEditOperation( o[ i ].range, o[ i ].text )
            }
            this._trackedEditorSelectionId = t.trackSelection( this._editorSelection )
          }, e.prototype.computeCursorState = function ( e, t ) {
            return t.getTrackedSelection( this._trackedEditorSelectionId )
          }, e;
        } )(),
        C = n( "gCVg" ),
        w = n( "jAJ/" ),
        S = n( "uzpd" ),
        O = new r.f( "findWidgetVisible", !1 ),
        L = new r.f( "findInputFocussed", !1 ),
        x = new r.f( "replaceInputFocussed", !1 ),
        N = {
          primary: 545,
          mac: {
            primary: 2593
          }
        },
        E = {
          primary: 565,
          mac: {
            primary: 2613
          }
        },
        k = {
          primary: 560,
          mac: {
            primary: 2608
          }
        },
        I = {
          primary: 554,
          mac: {
            primary: 2602
          }
        },
        D = {
          StartFindAction: "actions.find",
          StartFindWithSelection: "actions.findWithSelection",
          NextMatchFindAction: "editor.action.nextMatchFindAction",
          PreviousMatchFindAction: "editor.action.previousMatchFindAction",
          NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
          PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
          StartFindReplaceAction: "editor.action.startFindReplaceAction",
          CloseFindWidgetCommand: "closeFindWidget",
          ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
          ToggleWholeWordCommand: "toggleFindWholeWord",
          ToggleRegexCommand: "toggleFindRegex",
          ToggleSearchScopeCommand: "toggleFindInSelection",
          ReplaceOneAction: "editor.action.replaceOne",
          ReplaceAllAction: "editor.action.replaceAll",
          SelectAllMatchesAction: "editor.action.selectAllMatches"
        },
        M = ( () => {
          function e( e, t ) {
            const n = this;
            this._editor = e, this._state = t, this._toDispose = [], this._isDisposed = !1, this._startSearchingTimer = new u.f, this._decorations = new y( e ), this._toDispose.push( this._decorations ), this._updateDecorationsScheduler = new u.c( ( () => {
              return n.research( !1 )
            } ), 100 ), this._toDispose.push( this._updateDecorationsScheduler ), this._toDispose.push( this._editor.onDidChangeCursorPosition( ( e => {
              e.reason !== S.a.Explicit && e.reason !== S.a.Undo && e.reason !== S.a.Redo || n._decorations.setStartPosition( n._editor.getPosition() )
            } ) ) ), this._ignoreModelContentChanged = !1, this._toDispose.push( this._editor.onDidChangeModelContent( ( e => {
              n._ignoreModelContentChanged || ( e.isFlush && n._decorations.reset(), n._decorations.setStartPosition( n._editor.getPosition() ), n._updateDecorationsScheduler.schedule() )
            } ) ) ), this._toDispose.push( this._state.onFindReplaceStateChange( ( e => {
              return n._onStateChanged( e )
            } ) ) ), this.research( !1, this._state.searchScope )
          }
          return e.prototype.dispose = function () {
            this._isDisposed = !0, Object( o.d )( this._startSearchingTimer ), this._toDispose = Object( o.d )( this._toDispose )
          }, e.prototype._onStateChanged = function ( e ) {
            const t = this;
            this._isDisposed || this._editor.getModel() && ( e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope ) && ( this._editor.getModel().isTooLargeForSyncing() ? ( this._startSearchingTimer.cancel(), this._startSearchingTimer.setIfNotSet( ( () => {
              e.searchScope ? t.research( e.moveCursor, t._state.searchScope ) : t.research( e.moveCursor )
            } ), 240 ) ) : e.searchScope ? this.research( e.moveCursor, this._state.searchScope ) : this.research( e.moveCursor ) )
          }, e._getSearchRange = ( e, t ) => {
            let n = e.getFullModelRange();
            return t && ( n = n.intersectRanges( t ) ), n
          }, e.prototype.research = function ( e, t ) {
            let n = null;
            null !== ( n = "undefined" !== typeof t ? t : this._decorations.getFindScope() ) && n.startLineNumber !== n.endLineNumber && ( n = new f.a( n.startLineNumber, 1, n.endLineNumber, this._editor.getModel().getLineMaxColumn( n.endLineNumber ) ) );
            const i = this._findMatches( n, !1, 19999 );
            this._decorations.set( i, n ), this._state.changeMatchInfo( this._decorations.getCurrentMatchesPosition( this._editor.getSelection() ), this._decorations.getCount(), void 0 ), e && this._moveToNextMatch( this._decorations.getStartPosition() )
          }, e.prototype._hasMatches = function () {
            return this._state.matchesCount > 0
          }, e.prototype._cannotFind = function () {
            if ( !this._hasMatches() ) {
              const e = this._decorations.getFindScope();
              return e && this._editor.revealRangeInCenterIfOutsideViewport( e, 0 ), !0
            }
            return !1
          }, e.prototype._setCurrentFindMatch = function ( e ) {
            const t = this._decorations.setCurrentFindMatch( e );
            this._state.changeMatchInfo( t, this._decorations.getCount(), e ), this._editor.setSelection( e ), this._editor.revealRangeInCenterIfOutsideViewport( e, 0 )
          }, e.prototype._prevSearchPosition = function ( e ) {
            const t = this._state.isRegex && ( this._state.searchString.indexOf( "^" ) >= 0 || this._state.searchString.indexOf( "$" ) >= 0 );
            let n = e.lineNumber;
            let i = e.column;
            const o = this._editor.getModel();
            return t || 1 === i ? ( 1 === n ? n = o.getLineCount() : n--, i = o.getLineMaxColumn( n ) ) : i--, new p.a( n, i )
          }, e.prototype._moveToPrevMatch = function ( t, n ) {
            if ( void 0 === n && ( n = !1 ), this._decorations.getCount() < 19999 ) {
              let i = this._decorations.matchBeforePosition( t );
              return i && i.isEmpty() && i.getStartPosition().equals( t ) && ( t = this._prevSearchPosition( t ), i = this._decorations.matchBeforePosition( t ) ), void( i && this._setCurrentFindMatch( i ) )
            }
            if ( !this._cannotFind() ) {
              const o = this._decorations.getFindScope(),
                r = e._getSearchRange( this._editor.getModel(), o );
              r.getEndPosition().isBefore( t ) && ( t = r.getEndPosition() ), t.isBefore( r.getStartPosition() ) && ( t = r.getEndPosition() );
              const s = t.lineNumber;
              const a = t.column;
              const u = this._editor.getModel();
              let l = new p.a( s, a );
              let c = u.findPreviousMatch( this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, !1 );
              return c && c.range.isEmpty() && c.range.getStartPosition().equals( l ) && ( l = this._prevSearchPosition( l ), c = u.findPreviousMatch( this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, !1 ) ), c ? n || r.containsRange( c.range ) ? void this._setCurrentFindMatch( c.range ) : this._moveToPrevMatch( c.range.getStartPosition(), !0 ) : null
            }
          }, e.prototype.moveToPrevMatch = function () {
            this._moveToPrevMatch( this._editor.getSelection().getStartPosition() )
          }, e.prototype._nextSearchPosition = function ( e ) {
            const t = this._state.isRegex && ( this._state.searchString.indexOf( "^" ) >= 0 || this._state.searchString.indexOf( "$" ) >= 0 );
            let n = e.lineNumber;
            let i = e.column;
            const o = this._editor.getModel();
            return t || i === o.getLineMaxColumn( n ) ? ( n === o.getLineCount() ? n = 1 : n++, i = 1 ) : i++, new p.a( n, i )
          }, e.prototype._moveToNextMatch = function ( e ) {
            if ( this._decorations.getCount() < 19999 ) {
              let t = this._decorations.matchAfterPosition( e );
              return t && t.isEmpty() && t.getStartPosition().equals( e ) && ( e = this._nextSearchPosition( e ), t = this._decorations.matchAfterPosition( e ) ), void( t && this._setCurrentFindMatch( t ) )
            }
            const n = this._getNextMatch( e, !1, !0 );
            n && this._setCurrentFindMatch( n.range )
          }, e.prototype._getNextMatch = function ( t, n, i, o ) {
            if ( void 0 === o && ( o = !1 ), this._cannotFind() ) return null;
            const r = this._decorations.getFindScope(),
              s = e._getSearchRange( this._editor.getModel(), r );
            s.getEndPosition().isBefore( t ) && ( t = s.getStartPosition() ), t.isBefore( s.getStartPosition() ) && ( t = s.getStartPosition() );
            const a = t.lineNumber;
            const u = t.column;
            const l = this._editor.getModel();
            let c = new p.a( a, u );
            let d = l.findNextMatch( this._state.searchString, c, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, n );
            return i && d && d.range.isEmpty() && d.range.getStartPosition().equals( c ) && ( c = this._nextSearchPosition( c ), d = l.findNextMatch( this._state.searchString, c, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, n ) ), d ? o || s.containsRange( d.range ) ? d : this._getNextMatch( d.range.getEndPosition(), n, i, !0 ) : null
          }, e.prototype.moveToNextMatch = function () {
            this._moveToNextMatch( this._editor.getSelection().getEndPosition() )
          }, e.prototype._getReplacePattern = function () {
            return this._state.isRegex ? ( e => {
              if ( !e || 0 === e.length ) return new l( null );
              for ( var t = new d( e ), n = 0, i = e.length; n < i; n++ ) {
                const o = e.charCodeAt( n );
                if ( 92 !== o ) {
                  if ( 36 === o ) {
                    if ( ++n >= i ) break;
                    if ( 36 === ( a = e.charCodeAt( n ) ) ) {
                      t.emitUnchanged( n - 1 ), t.emitStatic( "$", n + 1 );
                      continue
                    }
                    if ( 48 === a || 38 === a ) {
                      t.emitUnchanged( n - 1 ), t.emitMatchIndex( 0, n + 1 );
                      continue
                    }
                    if ( 49 <= a && a <= 57 ) {
                      let r = a - 48;
                      if ( n + 1 < i ) {
                        const s = e.charCodeAt( n + 1 );
                        if ( 48 <= s && s <= 57 ) {
                          n++, r = 10 * r + ( s - 48 ), t.emitUnchanged( n - 2 ), t.emitMatchIndex( r, n + 1 );
                          continue
                        }
                      }
                      t.emitUnchanged( n - 1 ), t.emitMatchIndex( r, n + 1 );
                      continue
                    }
                  }
                } else {
                  if ( ++n >= i ) break;
                  var a;
                  switch ( a = e.charCodeAt( n ) ) {
                    case 92:
                      t.emitUnchanged( n - 1 ), t.emitStatic( "\\", n + 1 );
                      break;
                    case 110:
                      t.emitUnchanged( n - 1 ), t.emitStatic( "\n", n + 1 );
                      break;
                    case 116:
                      t.emitUnchanged( n - 1 ), t.emitStatic( "\t", n + 1 )
                  }
                }
              }
              return t.finalize()
            } )( this._state.replaceString ) : l.fromStaticValue( this._state.replaceString );
          }, e.prototype.replace = function () {
            if ( this._hasMatches() ) {
              const e = this._getReplacePattern(),
                t = this._editor.getSelection(),
                n = this._getNextMatch( t.getStartPosition(), e.hasReplacementPatterns, !1 );
              if ( n )
                if ( t.equalsRange( n.range ) ) {
                  const i = e.buildReplaceString( n.matches ),
                    o = new h.a( t, i );
                  this._executeEditorCommand( "replace", o ), this._decorations.setStartPosition( new p.a( t.startLineNumber, t.startColumn + i.length ) ), this.research( !0 )
                } else this._decorations.setStartPosition( this._editor.getPosition() ), this._setCurrentFindMatch( n.range )
            }
          }, e.prototype._findMatches = function ( t, n, i ) {
            const o = e._getSearchRange( this._editor.getModel(), t );
            return this._editor.getModel().findMatches( this._state.searchString, o, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, n, i )
          }, e.prototype.replaceAll = function () {
            if ( this._hasMatches() ) {
              const e = this._decorations.getFindScope();
              null === e && this._state.matchesCount >= 19999 ? this._largeReplaceAll() : this._regularReplaceAll( e ), this.research( !1 )
            }
          }, e.prototype._largeReplaceAll = function () {
            const e = new w.a( this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null ).parseSearchRequest();
            if ( e ) {
              let t = e.regex;
              if ( !t.multiline ) {
                let n = "m";
                t.ignoreCase && ( n += "i" ), t.global && ( n += "g" ), t = new RegExp( t.source, n )
              }
              let i;
              const o = this._editor.getModel();
              const r = o.getValue( v.c.LF );
              const s = o.getFullModelRange();
              const a = this._getReplacePattern();
              i = a.hasReplacementPatterns ? r.replace( t, ( function () {
                return a.buildReplaceString( arguments )
              } ) ) : r.replace( t, a.buildReplaceString( null ) );
              const u = new h.b( s, i, this._editor.getSelection() );
              this._executeEditorCommand( "replaceAll", u )
            }
          }, e.prototype._regularReplaceAll = function ( e ) {
            for ( var t = this._getReplacePattern(), n = this._findMatches( e, t.hasReplacementPatterns, 1073741824 ), i = [], o = 0, r = n.length; o < r; o++ ) i[ o ] = t.buildReplaceString( n[ o ].matches );
            const s = new b( this._editor.getSelection(), n.map( ( e => {
              return e.range
            } ) ), i );
            this._executeEditorCommand( "replaceAll", s )
          }, e.prototype.selectAllMatches = function () {
            if ( this._hasMatches() ) {
              for ( var e = this._decorations.getFindScope(), t = this._findMatches( e, !1, 1073741824 ).map( ( e => {
                  return new C.a( e.range.startLineNumber, e.range.startColumn, e.range.endLineNumber, e.range.endColumn )
                } ) ), n = this._editor.getSelection(), i = 0, o = t.length; i < o; i++ ) {
                if ( t[ i ].equalsRange( n ) ) {
                  t = [ n ].concat( t.slice( 0, i ) ).concat( t.slice( i + 1 ) );
                  break
                }
              }
              this._editor.setSelections( t )
            }
          }, e.prototype._executeEditorCommand = function ( e, t ) {
            try {
              this._ignoreModelContentChanged = !0, this._editor.pushUndoStop(), this._editor.executeCommand( e, t ), this._editor.pushUndoStop()
            } finally {
              this._ignoreModelContentChanged = !1
            }
          }, e;
        } )(),
        T = n( "MI8n" );

      function R( e, t ) {
        return 1 === e || 2 !== e && t
      }
      const P = ( () => {
          function e() {
            this._searchString = "", this._replaceString = "", this._isRevealed = !1, this._isReplaceRevealed = !1, this._isRegex = !1, this._isRegexOverride = 0, this._wholeWord = !1, this._wholeWordOverride = 0, this._matchCase = !1, this._matchCaseOverride = 0, this._searchScope = null, this._matchesPosition = 0, this._matchesCount = 0, this._currentMatch = null, this._onFindReplaceStateChange = new T.a
          }
          return Object.defineProperty( e.prototype, "searchString", {
            get() {
              return this._searchString
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "replaceString", {
            get() {
              return this._replaceString
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "isRevealed", {
            get() {
              return this._isRevealed
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "isReplaceRevealed", {
            get() {
              return this._isReplaceRevealed
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "isRegex", {
            get() {
              return R( this._isRegexOverride, this._isRegex )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "wholeWord", {
            get() {
              return R( this._wholeWordOverride, this._wholeWord )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "matchCase", {
            get() {
              return R( this._matchCaseOverride, this._matchCase )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "actualIsRegex", {
            get() {
              return this._isRegex
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "actualWholeWord", {
            get() {
              return this._wholeWord
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "actualMatchCase", {
            get() {
              return this._matchCase
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "searchScope", {
            get() {
              return this._searchScope
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "matchesPosition", {
            get() {
              return this._matchesPosition
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "matchesCount", {
            get() {
              return this._matchesCount
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "currentMatch", {
            get() {
              return this._currentMatch
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "onFindReplaceStateChange", {
            get() {
              return this._onFindReplaceStateChange.event
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.dispose = () => {}, e.prototype.changeMatchInfo = function ( e, t, n ) {
            const i = {
              moveCursor: !1,
              updateHistory: !1,
              searchString: !1,
              replaceString: !1,
              isRevealed: !1,
              isReplaceRevealed: !1,
              isRegex: !1,
              wholeWord: !1,
              matchCase: !1,
              searchScope: !1,
              matchesPosition: !1,
              matchesCount: !1,
              currentMatch: !1
            };
            let o = !1;
            0 === t && ( e = 0 ), e > t && ( e = t ), this._matchesPosition !== e && ( this._matchesPosition = e, i.matchesPosition = !0, o = !0 ), this._matchesCount !== t && ( this._matchesCount = t, i.matchesCount = !0, o = !0 ), "undefined" !== typeof n && ( f.a.equalsRange( this._currentMatch, n ) || ( this._currentMatch = n, i.currentMatch = !0, o = !0 ) ), o && this._onFindReplaceStateChange.fire( i )
          }, e.prototype.change = function ( e, t, n ) {
            void 0 === n && ( n = !0 );
            const i = {
              moveCursor: t,
              updateHistory: n,
              searchString: !1,
              replaceString: !1,
              isRevealed: !1,
              isReplaceRevealed: !1,
              isRegex: !1,
              wholeWord: !1,
              matchCase: !1,
              searchScope: !1,
              matchesPosition: !1,
              matchesCount: !1,
              currentMatch: !1
            };
            let o = !1;
            const r = this.isRegex;
            const s = this.wholeWord;
            const a = this.matchCase;
            "undefined" !== typeof e.searchString && this._searchString !== e.searchString && ( this._searchString = e.searchString, i.searchString = !0, o = !0 ), "undefined" !== typeof e.replaceString && this._replaceString !== e.replaceString && ( this._replaceString = e.replaceString, i.replaceString = !0, o = !0 ), "undefined" !== typeof e.isRevealed && this._isRevealed !== e.isRevealed && ( this._isRevealed = e.isRevealed, i.isRevealed = !0, o = !0 ), "undefined" !== typeof e.isReplaceRevealed && this._isReplaceRevealed !== e.isReplaceRevealed && ( this._isReplaceRevealed = e.isReplaceRevealed, i.isReplaceRevealed = !0, o = !0 ), "undefined" !== typeof e.isRegex && ( this._isRegex = e.isRegex ), "undefined" !== typeof e.wholeWord && ( this._wholeWord = e.wholeWord ), "undefined" !== typeof e.matchCase && ( this._matchCase = e.matchCase ), "undefined" !== typeof e.searchScope && ( f.a.equalsRange( this._searchScope, e.searchScope ) || ( this._searchScope = e.searchScope, i.searchScope = !0, o = !0 ) ), this._isRegexOverride = "undefined" !== typeof e.isRegexOverride ? e.isRegexOverride : 0, this._wholeWordOverride = "undefined" !== typeof e.wholeWordOverride ? e.wholeWordOverride : 0, this._matchCaseOverride = "undefined" !== typeof e.matchCaseOverride ? e.matchCaseOverride : 0, r !== this.isRegex && ( o = !0, i.isRegex = !0 ), s !== this.wholeWord && ( o = !0, i.wholeWord = !0 ), a !== this.matchCase && ( o = !0, i.matchCase = !0 ), o && this._onFindReplaceStateChange.fire( i )
          }, e;
        } )(),
        A = n( "wQH0" ),
        F = n( "A+jI" ),
        W = n( "9XeP" ),
        j = n( "Uzvx" ),
        V = n( "bexQ" ),
        B = ( n( "AbCa" ), n( "/cxE" ) ),
        H = n( "MNsG" ),
        z = n( "EffR" ),
        U = n( "G300" ),
        K = n( "cMOf" ),
        q = n( "sFUC" ),
        G = n( "0+8E" ),
        Y = ( n( "yqFB" ), n( "iJk1" ), n( "zrhQ" ) ),
        X = n( "qj0h" ),
        $ = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Z = {
          inputActiveOptionBorder: Y.a.fromHex( "#007ACC" )
        },
        Q = ( e => {
          function t( t ) {
            const n = e.call( this ) || this;
            return n._onChange = n._register( new T.a ), n._onKeyDown = n._register( new T.a ), n._opts = X.c( t ), X.g( n._opts, Z, !1 ), n._checked = n._opts.isChecked, n.domNode = document.createElement( "div" ), n.domNode.title = n._opts.title, n.domNode.className = "monaco-custom-checkbox " + n._opts.actionClassName + " " + ( n._checked ? "checked" : "unchecked" ), n.domNode.tabIndex = 0, n.domNode.setAttribute( "role", "checkbox" ), n.domNode.setAttribute( "aria-checked", String( n._checked ) ), n.domNode.setAttribute( "aria-label", n._opts.title ), n.applyStyles(), n.onclick( n.domNode, ( e => {
              n.checked = !n._checked, n._onChange.fire( !1 ), e.preventDefault()
            } ) ), n.onkeydown( n.domNode, ( e => {
              if ( 10 === e.keyCode || 3 === e.keyCode ) return n.checked = !n._checked, n._onChange.fire( !0 ), void e.preventDefault();
              n._onKeyDown.fire( e )
            } ) ), n;
          }
          return $( t, e ), Object.defineProperty( t.prototype, "onChange", {
            get() {
              return this._onChange.event
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( t.prototype, "onKeyDown", {
            get() {
              return this._onKeyDown.event
            },
            enumerable: !0,
            configurable: !0
          } ), t.prototype.focus = function () {
            this.domNode.focus()
          }, Object.defineProperty( t.prototype, "checked", {
            get() {
              return this._checked
            },
            set( e ) {
              this._checked = e, this.domNode.setAttribute( "aria-checked", String( this._checked ) ), this._checked ? this.domNode.classList.add( "checked" ) : this.domNode.classList.remove( "checked" ), this.applyStyles()
            },
            enumerable: !0,
            configurable: !0
          } ), t.prototype.width = () => {
            return 22
          }, t.prototype.style = function ( e ) {
            e.inputActiveOptionBorder && ( this._opts.inputActiveOptionBorder = e.inputActiveOptionBorder ), this.applyStyles()
          }, t.prototype.applyStyles = function () {
            this.domNode && ( this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder ? this._opts.inputActiveOptionBorder.toString() : "transparent" )
          }, t.prototype.enable = function () {
            this.domNode.tabIndex = 0, this.domNode.setAttribute( "aria-disabled", String( !1 ) )
          }, t.prototype.disable = function () {
            z.H( this.domNode ), this.domNode.setAttribute( "aria-disabled", String( !0 ) )
          }, t;
        } )( U.a ),
        J = ( n( "qWra" ), ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )() ),
        ee = i.a( "caseDescription", "Match Case" ),
        te = i.a( "wordsDescription", "Match Whole Word" ),
        ne = i.a( "regexDescription", "Use Regular Expression" ),
        ie = ( e => {
          function t( t ) {
            return e.call( this, {
              actionClassName: "monaco-case-sensitive",
              title: ee + t.appendTitle,
              isChecked: t.isChecked,
              inputActiveOptionBorder: t.inputActiveOptionBorder
            } ) || this
          }
          return J( t, e ), t
        } )( Q ),
        oe = ( e => {
          function t( t ) {
            return e.call( this, {
              actionClassName: "monaco-whole-word",
              title: te + t.appendTitle,
              isChecked: t.isChecked,
              inputActiveOptionBorder: t.inputActiveOptionBorder
            } ) || this
          }
          return J( t, e ), t
        } )( Q ),
        re = ( e => {
          function t( t ) {
            return e.call( this, {
              actionClassName: "monaco-regex",
              title: ne + t.appendTitle,
              isChecked: t.isChecked,
              inputActiveOptionBorder: t.inputActiveOptionBorder
            } ) || this
          }
          return J( t, e ), t
        } )( Q ),
        se = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        ae = i.a( "defaultLabel", "input" ),
        ue = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            return o._onDidOptionChange = o._register( new T.a ), o.onDidOptionChange = o._onDidOptionChange.event, o._onKeyDown = o._register( new T.a ), o.onKeyDown = o._onKeyDown.event, o._onMouseDown = o._register( new T.a ), o.onMouseDown = o._onMouseDown.event, o._onInput = o._register( new T.a ), o._onKeyUp = o._register( new T.a ), o._onCaseSensitiveKeyDown = o._register( new T.a ), o.onCaseSensitiveKeyDown = o._onCaseSensitiveKeyDown.event, o._onRegexKeyDown = o._register( new T.a ), o._lastHighlightFindOptions = 0, o.contextViewProvider = n, o.width = i.width || 100, o.placeholder = i.placeholder || "", o.validation = i.validation, o.label = i.label || ae, o.inputActiveOptionBorder = i.inputActiveOptionBorder, o.inputBackground = i.inputBackground, o.inputForeground = i.inputForeground, o.inputBorder = i.inputBorder, o.inputValidationInfoBorder = i.inputValidationInfoBorder, o.inputValidationInfoBackground = i.inputValidationInfoBackground, o.inputValidationWarningBorder = i.inputValidationWarningBorder, o.inputValidationWarningBackground = i.inputValidationWarningBackground, o.inputValidationErrorBorder = i.inputValidationErrorBorder, o.inputValidationErrorBackground = i.inputValidationErrorBackground, o.regex = null, o.wholeWords = null, o.caseSensitive = null, o.domNode = null, o.inputBox = null, o.buildDomNode( i.appendCaseSensitiveLabel || "", i.appendWholeWordsLabel || "", i.appendRegexLabel || "", i.history ), Boolean( t ) && t.appendChild( o.domNode ), o.onkeydown( o.inputBox.inputElement, ( e => {
              return o._onKeyDown.fire( e )
            } ) ), o.onkeyup( o.inputBox.inputElement, ( e => {
              return o._onKeyUp.fire( e )
            } ) ), o.oninput( o.inputBox.inputElement, ( e => {
              return o._onInput.fire()
            } ) ), o.onmousedown( o.inputBox.inputElement, ( e => {
              return o._onMouseDown.fire( e )
            } ) ), o;
          }
          return se( t, e ), t.prototype.enable = function () {
            z.G( this.domNode, "disabled" ), this.inputBox.enable(), this.regex.enable(), this.wholeWords.enable(), this.caseSensitive.enable()
          }, t.prototype.disable = function () {
            z.f( this.domNode, "disabled" ), this.inputBox.disable(), this.regex.disable(), this.wholeWords.disable(), this.caseSensitive.disable()
          }, t.prototype.setEnabled = function ( e ) {
            e ? this.enable() : this.disable()
          }, t.prototype.getValue = function () {
            return this.inputBox.value
          }, t.prototype.setValue = function ( e ) {
            this.inputBox.value !== e && ( this.inputBox.value = e )
          }, t.prototype.style = function ( e ) {
            this.inputActiveOptionBorder = e.inputActiveOptionBorder, this.inputBackground = e.inputBackground, this.inputForeground = e.inputForeground, this.inputBorder = e.inputBorder, this.inputValidationInfoBackground = e.inputValidationInfoBackground, this.inputValidationInfoBorder = e.inputValidationInfoBorder, this.inputValidationWarningBackground = e.inputValidationWarningBackground, this.inputValidationWarningBorder = e.inputValidationWarningBorder, this.inputValidationErrorBackground = e.inputValidationErrorBackground, this.inputValidationErrorBorder = e.inputValidationErrorBorder, this.applyStyles()
          }, t.prototype.applyStyles = function () {
            if ( this.domNode ) {
              const e = {
                inputActiveOptionBorder: this.inputActiveOptionBorder
              };
              this.regex.style( e ), this.wholeWords.style( e ), this.caseSensitive.style( e );
              const t = {
                inputBackground: this.inputBackground,
                inputForeground: this.inputForeground,
                inputBorder: this.inputBorder,
                inputValidationInfoBackground: this.inputValidationInfoBackground,
                inputValidationInfoBorder: this.inputValidationInfoBorder,
                inputValidationWarningBackground: this.inputValidationWarningBackground,
                inputValidationWarningBorder: this.inputValidationWarningBorder,
                inputValidationErrorBackground: this.inputValidationErrorBackground,
                inputValidationErrorBorder: this.inputValidationErrorBorder
              };
              this.inputBox.style( t )
            }
          }, t.prototype.select = function () {
            this.inputBox.select()
          }, t.prototype.focus = function () {
            this.inputBox.focus()
          }, t.prototype.getCaseSensitive = function () {
            return this.caseSensitive.checked
          }, t.prototype.setCaseSensitive = function ( e ) {
            this.caseSensitive.checked = e, this.setInputWidth()
          }, t.prototype.getWholeWords = function () {
            return this.wholeWords.checked
          }, t.prototype.setWholeWords = function ( e ) {
            this.wholeWords.checked = e, this.setInputWidth()
          }, t.prototype.getRegex = function () {
            return this.regex.checked
          }, t.prototype.setRegex = function ( e ) {
            this.regex.checked = e, this.setInputWidth(), this.validate()
          }, t.prototype.focusOnCaseSensitive = function () {
            this.caseSensitive.focus()
          }, t.prototype.highlightFindOptions = function () {
            z.G( this.domNode, "highlight-" + this._lastHighlightFindOptions ), this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions, z.f( this.domNode, "highlight-" + this._lastHighlightFindOptions )
          }, t.prototype.setInputWidth = function () {
            const e = this.width - this.caseSensitive.width() - this.wholeWords.width() - this.regex.width();
            this.inputBox.width = e
          }, t.prototype.buildDomNode = function ( e, t, n, i ) {
            const o = this;
            this.domNode = document.createElement( "div" ), this.domNode.style.width = this.width + "px", z.f( this.domNode, "monaco-findInput" ), this.inputBox = this._register( new G.a( this.domNode, this.contextViewProvider, {
              placeholder: this.placeholder || "",
              ariaLabel: this.label || "",
              validationOptions: {
                validation: this.validation || null
              },
              inputBackground: this.inputBackground,
              inputForeground: this.inputForeground,
              inputBorder: this.inputBorder,
              inputValidationInfoBackground: this.inputValidationInfoBackground,
              inputValidationInfoBorder: this.inputValidationInfoBorder,
              inputValidationWarningBackground: this.inputValidationWarningBackground,
              inputValidationWarningBorder: this.inputValidationWarningBorder,
              inputValidationErrorBackground: this.inputValidationErrorBackground,
              inputValidationErrorBorder: this.inputValidationErrorBorder,
              history: i
            } ) ), this.regex = this._register( new re( {
              appendTitle: n,
              isChecked: !1,
              inputActiveOptionBorder: this.inputActiveOptionBorder
            } ) ), this._register( this.regex.onChange( ( e => {
              o._onDidOptionChange.fire( e ), e || o.inputBox.focus(), o.setInputWidth(), o.validate()
            } ) ) ), this._register( this.regex.onKeyDown( ( e => {
              o._onRegexKeyDown.fire( e )
            } ) ) ), this.wholeWords = this._register( new oe( {
              appendTitle: t,
              isChecked: !1,
              inputActiveOptionBorder: this.inputActiveOptionBorder
            } ) ), this._register( this.wholeWords.onChange( ( e => {
              o._onDidOptionChange.fire( e ), e || o.inputBox.focus(), o.setInputWidth(), o.validate()
            } ) ) ), this.caseSensitive = this._register( new ie( {
              appendTitle: e,
              isChecked: !1,
              inputActiveOptionBorder: this.inputActiveOptionBorder
            } ) ), this._register( this.caseSensitive.onChange( ( e => {
              o._onDidOptionChange.fire( e ), e || o.inputBox.focus(), o.setInputWidth(), o.validate()
            } ) ) ), this._register( this.caseSensitive.onKeyDown( ( e => {
              o._onCaseSensitiveKeyDown.fire( e )
            } ) ) );
            const r = [ this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode ];
            this.onkeydown( this.domNode, ( e => {
              if ( e.equals( 15 ) || e.equals( 17 ) || e.equals( 9 ) ) {
                const t = r.indexOf( document.activeElement );
                if ( t >= 0 ) {
                  let n = void 0;
                  e.equals( 17 ) ? n = ( t + 1 ) % r.length : e.equals( 15 ) && ( n = 0 === t ? r.length - 1 : t - 1 ), e.equals( 9 ) ? r[ t ].blur() : n >= 0 && r[ n ].focus(), z.c.stop( e, !0 )
                }
              }
            } ) ), this.setInputWidth();
            const s = document.createElement( "div" );
            s.className = "controls", s.appendChild( this.caseSensitive.domNode ), s.appendChild( this.wholeWords.domNode ), s.appendChild( this.regex.domNode ), this.domNode.appendChild( s )
          }, t.prototype.validate = function () {
            this.inputBox.validate()
          }, t.prototype.dispose = function () {
            e.prototype.dispose.call( this )
          }, t;
        } )( U.a );

      function le( e, t ) {
        return e.getContext( document.activeElement ).getValue( t )
      }
      const ce = n( "nrhi" ),
        de = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        he = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        pe = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        },
        fe = "historyNavigationWidget",
        ge = "historyNavigationEnabled";

      function me( e, t ) {
        const n = ( ( e, t ) => {
          return e.createScoped( t.target )
        } )( e, t );
        return ( ( e, t, n ) => {
          new r.f( n, t ).bindTo( e )
        } )( n, t, fe ), {
          scopedContextKeyService: n,
          historyNavigationEnablement: new r.f( ge, !0 ).bindTo( n )
        };
      }
      const _e = ( e => {
          function t( t, n, i, o ) {
            const r = e.call( this, t, n, i ) || this;
            return r._register( me( o, {
              target: r.element,
              historyNavigator: r
            } ).scopedContextKeyService ), r
          }
          return de( t, e ), t = he( [ pe( 3, r.e ) ], t )
        } )( G.a ),
        ve = ( e => {
          function t( t, n, i, o ) {
            const r = e.call( this, t, n, i ) || this;
            return r._register( me( o, {
              target: r.inputBox.element,
              historyNavigator: r.inputBox
            } ).scopedContextKeyService ), r
          }
          return de( t, e ), t = he( [ pe( 3, r.e ) ], t )
        } )( ue );
      ce.a.registerCommandAndKeybindingRule( {
        id: "history.showPrevious",
        weight: 200,
        when: r.d.and( new r.b( fe ), new r.c( ge, !0 ) ),
        primary: 16,
        secondary: [ 528 ],
        handler( e, t ) {
          le( e.get( r.e ), fe ).historyNavigator.showPreviousValue()
        }
      } ), ce.a.registerCommandAndKeybindingRule( {
        id: "history.showNext",
        weight: 200,
        when: new r.a( [ new r.b( fe ), new r.c( ge, !0 ) ] ),
        primary: 18,
        secondary: [ 530 ],
        handler( e, t ) {
          le( e.get( r.e ), fe ).historyNavigator.showNextValue()
        }
      } );
      const ye = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const be = i.a( "label.find", "Find" );
      const Ce = i.a( "placeholder.find", "Find" );
      const we = i.a( "label.previousMatchButton", "Previous match" );
      const Se = i.a( "label.nextMatchButton", "Next match" );
      const Oe = i.a( "label.toggleSelectionFind", "Find in selection" );
      const Le = i.a( "label.closeButton", "Close" );
      const xe = i.a( "label.replace", "Replace" );
      const Ne = i.a( "placeholder.replace", "Replace" );
      const Ee = i.a( "label.replaceButton", "Replace" );
      const ke = i.a( "label.replaceAllButton", "Replace All" );
      const Ie = i.a( "label.toggleReplaceButton", "Toggle Replace mode" );
      const De = i.a( "title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", 19999 );
      const Me = i.a( "label.matchesLocation", "{0} of {1}" );
      const Te = i.a( "label.noResults", "No Results" );
      let Re = 69;
      const Pe = 17 + ( Re + 3 + 1 ) + 92 + 2;
      const Ae = 34;
      const Fe = function ( e ) {
        this.afterLineNumber = e, this.heightInPx = Ae, this.suppressMouseDown = !1, this.domNode = document.createElement( "div" ), this.domNode.className = "dock-find-viewzone"
      };

      const We = ( e => {
        function t( t, n, i, o, r, s, a ) {
          const l = e.call( this ) || this;
          return l._codeEditor = t, l._controller = n, l._state = i, l._contextViewProvider = o, l._keybindingService = r, l._contextKeyService = s, l._isVisible = !1, l._isReplaceVisible = !1, l._updateHistoryDelayer = new u.a( 500 ), l._register( l._state.onFindReplaceStateChange( ( e => {
            return l._onStateChanged( e )
          } ) ) ), l._buildDomNode(), l._updateButtons(), l._tryUpdateWidgetWidth(), l._register( l._codeEditor.onDidChangeConfiguration( ( e => {
            e.readOnly && ( l._codeEditor.getConfiguration().readOnly && l._state.change( {
              isReplaceRevealed: !1
            }, !1 ), l._updateButtons() ), e.layoutInfo && l._tryUpdateWidgetWidth()
          } ) ) ), l._register( l._codeEditor.onDidChangeCursorSelection( ( () => {
            l._isVisible && l._updateToggleSelectionFindButton()
          } ) ) ), l._register( l._codeEditor.onDidFocusEditorWidget( ( () => {
            if ( l._isVisible ) {
              const e = l._controller.getGlobalBufferTerm();
              e && e !== l._state.searchString && ( l._state.change( {
                searchString: e
              }, !0 ), l._findInput.select() )
            }
          } ) ) ), l._findInputFocused = L.bindTo( s ), l._findFocusTracker = l._register( z.O( l._findInput.inputBox.inputElement ) ), l._register( l._findFocusTracker.onDidFocus( ( () => {
            l._findInputFocused.set( !0 ), l._updateSearchScope()
          } ) ) ), l._register( l._findFocusTracker.onDidBlur( ( () => {
            l._findInputFocused.set( !1 )
          } ) ) ), l._replaceInputFocused = x.bindTo( s ), l._replaceFocusTracker = l._register( z.O( l._replaceInputBox.inputElement ) ), l._register( l._replaceFocusTracker.onDidFocus( ( () => {
            l._replaceInputFocused.set( !0 ), l._updateSearchScope()
          } ) ) ), l._register( l._replaceFocusTracker.onDidBlur( ( () => {
            l._replaceInputFocused.set( !1 )
          } ) ) ), l._codeEditor.addOverlayWidget( l ), l._viewZone = new Fe( 0 ), l._applyTheme( a.getTheme() ), l._register( a.onThemeChange( l._applyTheme.bind( l ) ) ), l._register( l._codeEditor.onDidChangeModel( ( e => {
            l._isVisible && void 0 !== l._viewZoneId && l._codeEditor.changeViewZones( ( e => {
              e.removeZone( l._viewZoneId ), l._viewZoneId = void 0
            } ) )
          } ) ) ), l._register( l._codeEditor.onDidScrollChange( ( e => {
            e.scrollTopChanged ? l._layoutViewZone() : setTimeout( ( () => {
              l._layoutViewZone()
            } ), 0 )
          } ) ) ), l;
        }
        return ye( t, e ), t.prototype.getId = () => {
          return t.ID
        }, t.prototype.getDomNode = function () {
          return this._domNode
        }, t.prototype.getPosition = function () {
          return this._isVisible ? {
            preference: q.c.TOP_RIGHT_CORNER
          } : null
        }, t.prototype._onStateChanged = function ( e ) {
          if ( e.searchString && ( this._findInput.setValue( this._state.searchString ), this._updateButtons() ), e.replaceString && ( this._replaceInputBox.value = this._state.replaceString ), e.isRevealed && ( this._state.isRevealed ? this._reveal( !0 ) : this._hide( !0 ) ), e.isReplaceRevealed && ( this._state.isReplaceRevealed ? this._codeEditor.getConfiguration().readOnly || this._isReplaceVisible || ( this._isReplaceVisible = !0, this._replaceInputBox.width = this._findInput.inputBox.width, this._updateButtons() ) : this._isReplaceVisible && ( this._isReplaceVisible = !1, this._updateButtons() ) ), e.isRegex && this._findInput.setRegex( this._state.isRegex ), e.wholeWord && this._findInput.setWholeWords( this._state.wholeWord ), e.matchCase && this._findInput.setCaseSensitive( this._state.matchCase ), e.searchScope && ( this._state.searchScope ? this._toggleSelectionFind.checked = !0 : this._toggleSelectionFind.checked = !1, this._updateToggleSelectionFindButton() ), e.searchString || e.matchesCount || e.matchesPosition ) {
            const t = this._state.searchString.length > 0 && 0 === this._state.matchesCount;
            z.N( this._domNode, "no-results", t ), this._updateMatchesCount()
          }( e.searchString || e.currentMatch ) && this._layoutViewZone(), e.updateHistory && this._delayedUpdateHistory()
        }, t.prototype._delayedUpdateHistory = function () {
          this._updateHistoryDelayer.trigger( this._updateHistory.bind( this ) )
        }, t.prototype._updateHistory = function () {
          this._state.searchString && this._findInput.inputBox.addToHistory(), this._state.replaceString && this._replaceInputBox.addToHistory()
        }, t.prototype._updateMatchesCount = function () {
          let e;
          if ( this._matchesCount.style.minWidth = Re + "px", this._state.matchesCount >= 19999 ? this._matchesCount.title = De : this._matchesCount.title = "", this._matchesCount.firstChild && this._matchesCount.removeChild( this._matchesCount.firstChild ), this._state.matchesCount > 0 ) {
            let t = String( this._state.matchesCount );
            this._state.matchesCount >= 19999 && ( t += "+" );
            let n = String( this._state.matchesPosition );
            "0" === n && ( n = "?" ), e = s.format( Me, n, t )
          } else e = Te;
          this._matchesCount.appendChild( document.createTextNode( e ) ), Re = Math.max( Re, this._matchesCount.clientWidth )
        }, t.prototype._updateToggleSelectionFindButton = function () {
          const e = this._codeEditor.getSelection(),
            t = !!e && ( e.startLineNumber !== e.endLineNumber || e.startColumn !== e.endColumn ),
            n = this._toggleSelectionFind.checked;
          this._toggleSelectionFind.setEnabled( this._isVisible && ( n || t ) )
        }, t.prototype._updateButtons = function () {
          this._findInput.setEnabled( this._isVisible ), this._replaceInputBox.setEnabled( this._isVisible && this._isReplaceVisible ), this._updateToggleSelectionFindButton(), this._closeBtn.setEnabled( this._isVisible );
          const e = this._state.searchString.length > 0;
          this._prevBtn.setEnabled( this._isVisible && e ), this._nextBtn.setEnabled( this._isVisible && e ), this._replaceBtn.setEnabled( this._isVisible && this._isReplaceVisible && e ), this._replaceAllBtn.setEnabled( this._isVisible && this._isReplaceVisible && e ), z.N( this._domNode, "replaceToggled", this._isReplaceVisible ), this._toggleReplaceBtn.toggleClass( "collapse", !this._isReplaceVisible ), this._toggleReplaceBtn.toggleClass( "expand", this._isReplaceVisible ), this._toggleReplaceBtn.setExpanded( this._isReplaceVisible );
          const t = !this._codeEditor.getConfiguration().readOnly;
          this._toggleReplaceBtn.setEnabled( this._isVisible && t )
        }, t.prototype._reveal = function ( e ) {
          const t = this;
          if ( !this._isVisible ) {
            this._isVisible = !0;
            const n = this._codeEditor.getSelection();
            !!n && ( n.startLineNumber !== n.endLineNumber || n.startColumn !== n.endColumn ) && this._codeEditor.getConfiguration().contribInfo.find.autoFindInSelection ? this._toggleSelectionFind.checked = !0 : this._toggleSelectionFind.checked = !1, this._tryUpdateWidgetWidth(), this._updateButtons(), setTimeout( ( () => {
              z.f( t._domNode, "visible" ), t._domNode.setAttribute( "aria-hidden", "false" )
            } ), 0 ), this._codeEditor.layoutOverlayWidget( this );
            let i = !0;
            if ( this._codeEditor.getConfiguration().contribInfo.find.seedSearchStringFromSelection && n ) {
              const o = z.u( this._codeEditor.getDomNode() ),
                r = this._codeEditor.getScrolledVisiblePosition( n.getStartPosition() ),
                s = o.left + r.left;
              if ( r.top < this._viewZone.heightInPx ) {
                n.endLineNumber > n.startLineNumber && ( i = !1 );
                const a = z.w( this._domNode ).left;
                s > a && ( i = !1 );
                const u = this._codeEditor.getScrolledVisiblePosition( n.getEndPosition() );
                o.left + u.left > a && ( i = !1 )
              }
            }
            this._showViewZone( i )
          }
        }, t.prototype._hide = function ( e ) {
          const t = this;
          this._isVisible && ( this._isVisible = !1, this._updateButtons(), z.G( this._domNode, "visible" ), this._domNode.setAttribute( "aria-hidden", "true" ), e && this._codeEditor.focus(), this._codeEditor.layoutOverlayWidget( this ), this._codeEditor.changeViewZones( ( e => {
            void 0 !== t._viewZoneId && ( e.removeZone( t._viewZoneId ), t._viewZoneId = void 0, t._codeEditor.setScrollTop( t._codeEditor.getScrollTop() - t._viewZone.heightInPx ) )
          } ) ) )
        }, t.prototype._layoutViewZone = function () {
          const e = this;
          this._isVisible && void 0 === this._viewZoneId && this._codeEditor.changeViewZones( ( t => {
            e._state.isReplaceRevealed ? e._viewZone.heightInPx = 64 : e._viewZone.heightInPx = Ae, e._viewZoneId = t.addZone( e._viewZone ), e._codeEditor.setScrollTop( e._codeEditor.getScrollTop() + e._viewZone.heightInPx )
          } ) )
        }, t.prototype._showViewZone = function ( e ) {
          const t = this;
          void 0 === e && ( e = !0 ), this._isVisible && this._codeEditor.changeViewZones( ( n => {
            let i = Ae;
            void 0 !== t._viewZoneId ? ( t._state.isReplaceRevealed ? ( t._viewZone.heightInPx = 64, i = 64 - Ae ) : ( t._viewZone.heightInPx = Ae, i = Ae - 64 ), n.removeZone( t._viewZoneId ) ) : t._viewZone.heightInPx = Ae, t._viewZoneId = n.addZone( t._viewZone ), e && t._codeEditor.setScrollTop( t._codeEditor.getScrollTop() + i )
          } ) )
        }, t.prototype._applyTheme = function ( e ) {
          const t = {
            inputActiveOptionBorder: e.getColor( m.J ),
            inputBackground: e.getColor( m.K ),
            inputForeground: e.getColor( m.M ),
            inputBorder: e.getColor( m.L ),
            inputValidationInfoBackground: e.getColor( m.P ),
            inputValidationInfoBorder: e.getColor( m.Q ),
            inputValidationWarningBackground: e.getColor( m.R ),
            inputValidationWarningBorder: e.getColor( m.S ),
            inputValidationErrorBackground: e.getColor( m.N ),
            inputValidationErrorBorder: e.getColor( m.O )
          };
          this._findInput.style( t ), this._replaceInputBox.style( t )
        }, t.prototype._tryUpdateWidgetWidth = function () {
          if ( this._isVisible ) {
            const e = this._codeEditor.getConfiguration().layoutInfo.width;
            const t = this._codeEditor.getConfiguration().layoutInfo.minimapWidth;
            let n = !1;
            let i = !1;
            let o = !1;
            if ( this._resized )
              if ( z.y( this._domNode ) > 411 ) return this._domNode.style.maxWidth = e - 28 - t - 15 + "px", void( this._replaceInputBox.inputElement.style.width = z.y( this._findInput.inputBox.inputElement ) + "px" );
            if ( 439 + t >= e && ( i = !0 ), 439 + t - Re >= e && ( o = !0 ), 439 + t - Re >= e + 50 && ( n = !0 ), z.N( this._domNode, "collapsed-find-widget", n ), z.N( this._domNode, "narrow-find-widget", o ), z.N( this._domNode, "reduced-find-widget", i ), o || n || ( this._domNode.style.maxWidth = e - 28 - t - 15 + "px" ), this._resized ) {
              const r = z.y( this._findInput.inputBox.inputElement );
              r > 0 && ( this._replaceInputBox.inputElement.style.width = r + "px" )
            }
          }
        }, t.prototype.focusFindInput = function () {
          this._findInput.select(), this._findInput.focus()
        }, t.prototype.focusReplaceInput = function () {
          this._replaceInputBox.select(), this._replaceInputBox.focus()
        }, t.prototype.highlightFindOptions = function () {
          this._findInput.highlightFindOptions()
        }, t.prototype._updateSearchScope = function () {
          if ( this._toggleSelectionFind.checked ) {
            let e = this._codeEditor.getSelection();
            1 === e.endColumn && e.endLineNumber > e.startLineNumber && ( e = e.setEndPosition( e.endLineNumber - 1, 1 ) );
            const t = this._state.currentMatch;
            e.startLineNumber !== e.endLineNumber && ( f.a.equalsRange( e, t ) || this._state.change( {
              searchScope: e
            }, !0 ) )
          }
        }, t.prototype._onFindInputMouseDown = e => {
          e.middleButton && e.stopPropagation()
        }, t.prototype._onFindInputKeyDown = function ( e ) {
          return e.equals( 3 ) ? ( this._codeEditor.getAction( D.NextMatchFindAction ).run().done( null, B.e ), void e.preventDefault() ) : e.equals( 1027 ) ? ( this._codeEditor.getAction( D.PreviousMatchFindAction ).run().done( null, B.e ), void e.preventDefault() ) : e.equals( 2 ) ? ( this._isReplaceVisible ? this._replaceInputBox.focus() : this._findInput.focusOnCaseSensitive(), void e.preventDefault() ) : e.equals( 2066 ) ? ( this._codeEditor.focus(), void e.preventDefault() ) : void 0
        }, t.prototype._onReplaceInputKeyDown = function ( e ) {
          return e.equals( 3 ) ? ( this._controller.replace(), void e.preventDefault() ) : e.equals( 2051 ) ? ( this._controller.replaceAll(), void e.preventDefault() ) : e.equals( 2 ) ? ( this._findInput.focusOnCaseSensitive(), void e.preventDefault() ) : e.equals( 1026 ) ? ( this._findInput.focus(), void e.preventDefault() ) : e.equals( 2066 ) ? ( this._codeEditor.focus(), void e.preventDefault() ) : void 0
        }, t.prototype.getHorizontalSashTop = e => {
          return 0
        }, t.prototype.getHorizontalSashLeft = e => {
          return 0
        }, t.prototype.getHorizontalSashWidth = e => {
          return 500
        }, t.prototype._keybindingLabelFor = function ( e ) {
          const t = this._keybindingService.lookupKeybinding( e );
          return t ? " (" + t.getLabel() + ")" : ""
        }, t.prototype._buildFindPart = function () {
          const e = this;
          this._findInput = this._register( new ve( null, this._contextViewProvider, {
            width: 221,
            label: be,
            placeholder: Ce,
            appendCaseSensitiveLabel: this._keybindingLabelFor( D.ToggleCaseSensitiveCommand ),
            appendWholeWordsLabel: this._keybindingLabelFor( D.ToggleWholeWordCommand ),
            appendRegexLabel: this._keybindingLabelFor( D.ToggleRegexCommand ),
            validation( t ) {
              if ( 0 === t.length ) return null;
              if ( !e._findInput.getRegex() ) return null;
              try {
                return new RegExp( t ), null
              } catch ( n ) {
                return {
                  content: n.message
                }
              }
            }
          }, this._contextKeyService ) ), this._findInput.setRegex( !!this._state.isRegex ), this._findInput.setCaseSensitive( !!this._state.matchCase ), this._findInput.setWholeWords( !!this._state.wholeWord ), this._register( this._findInput.onKeyDown( ( t => {
            return e._onFindInputKeyDown( t )
          } ) ) ), this._register( this._findInput.inputBox.onDidChange( ( () => {
            e._state.change( {
              searchString: e._findInput.getValue()
            }, !0 )
          } ) ) ), this._register( this._findInput.onDidOptionChange( ( () => {
            e._state.change( {
              isRegex: e._findInput.getRegex(),
              wholeWord: e._findInput.getWholeWords(),
              matchCase: e._findInput.getCaseSensitive()
            }, !0 )
          } ) ) ), this._register( this._findInput.onCaseSensitiveKeyDown( ( t => {
            t.equals( 1026 ) && e._isReplaceVisible && ( e._replaceInputBox.focus(), t.preventDefault() )
          } ) ) ), H.c && this._register( this._findInput.onMouseDown( ( t => {
            return e._onFindInputMouseDown( t )
          } ) ) ), this._matchesCount = document.createElement( "div" ), this._matchesCount.className = "matchesCount", this._updateMatchesCount(), this._prevBtn = this._register( new Ve( {
            label: we + this._keybindingLabelFor( D.PreviousMatchFindAction ),
            className: "previous",
            onTrigger() {
              e._codeEditor.getAction( D.PreviousMatchFindAction ).run().done( null, B.e )
            }
          } ) ), this._nextBtn = this._register( new Ve( {
            label: Se + this._keybindingLabelFor( D.NextMatchFindAction ),
            className: "next",
            onTrigger() {
              e._codeEditor.getAction( D.NextMatchFindAction ).run().done( null, B.e )
            }
          } ) );
          const t = document.createElement( "div" );
          return t.className = "find-part", t.appendChild( this._findInput.domNode ), t.appendChild( this._matchesCount ), t.appendChild( this._prevBtn.domNode ), t.appendChild( this._nextBtn.domNode ), this._toggleSelectionFind = this._register( new je( {
            parent: t,
            title: Oe + this._keybindingLabelFor( D.ToggleSearchScopeCommand ),
            onChange() {
              if ( e._toggleSelectionFind.checked ) {
                let t = e._codeEditor.getSelection();
                1 === t.endColumn && t.endLineNumber > t.startLineNumber && ( t = t.setEndPosition( t.endLineNumber - 1, 1 ) ), t.isEmpty() || e._state.change( {
                  searchScope: t
                }, !0 )
              } else e._state.change( {
                searchScope: null
              }, !0 )
            }
          } ) ), this._closeBtn = this._register( new Ve( {
            label: Le + this._keybindingLabelFor( D.CloseFindWidgetCommand ),
            className: "close-fw",
            onTrigger() {
              e._state.change( {
                isRevealed: !1,
                searchScope: null
              }, !1 )
            },
            onKeyDown( t ) {
              t.equals( 2 ) && e._isReplaceVisible && ( e._replaceBtn.isEnabled() ? e._replaceBtn.focus() : e._codeEditor.focus(), t.preventDefault() )
            }
          } ) ), t.appendChild( this._closeBtn.domNode ), t;
        }, t.prototype._buildReplacePart = function () {
          const e = this,
            t = document.createElement( "div" );
          t.className = "replace-input", t.style.width = "221px", this._replaceInputBox = this._register( new _e( t, null, {
            ariaLabel: xe,
            placeholder: Ne,
            history: []
          }, this._contextKeyService ) ), this._register( z.j( this._replaceInputBox.inputElement, "keydown", ( t => {
            return e._onReplaceInputKeyDown( t )
          } ) ) ), this._register( z.j( this._replaceInputBox.inputElement, "input", ( t => {
            e._state.change( {
              replaceString: e._replaceInputBox.value
            }, !1 )
          } ) ) ), this._replaceBtn = this._register( new Ve( {
            label: Ee + this._keybindingLabelFor( D.ReplaceOneAction ),
            className: "replace",
            onTrigger() {
              e._controller.replace()
            },
            onKeyDown( t ) {
              t.equals( 1026 ) && ( e._closeBtn.focus(), t.preventDefault() )
            }
          } ) ), this._replaceAllBtn = this._register( new Ve( {
            label: ke + this._keybindingLabelFor( D.ReplaceAllAction ),
            className: "replace-all",
            onTrigger() {
              e._controller.replaceAll()
            }
          } ) );
          const n = document.createElement( "div" );
          return n.className = "replace-part", n.appendChild( t ), n.appendChild( this._replaceBtn.domNode ), n.appendChild( this._replaceAllBtn.domNode ), n
        }, t.prototype._buildDomNode = function () {
          const e = this,
            t = this._buildFindPart(),
            n = this._buildReplacePart();
          this._toggleReplaceBtn = this._register( new Ve( {
            label: Ie,
            className: "toggle left",
            onTrigger() {
              e._state.change( {
                isReplaceRevealed: !e._isReplaceVisible
              }, !1 ), e._isReplaceVisible && ( e._replaceInputBox.width = e._findInput.inputBox.width ), e._showViewZone()
            }
          } ) ), this._toggleReplaceBtn.toggleClass( "expand", this._isReplaceVisible ), this._toggleReplaceBtn.toggleClass( "collapse", !this._isReplaceVisible ), this._toggleReplaceBtn.setExpanded( this._isReplaceVisible ), this._domNode = document.createElement( "div" ), this._domNode.className = "editor-widget find-widget", this._domNode.setAttribute( "aria-hidden", "true" ), this._domNode.style.width = "411px", this._domNode.appendChild( this._toggleReplaceBtn.domNode ), this._domNode.appendChild( t ), this._domNode.appendChild( n ), this._buildSash()
        }, t.prototype._buildSash = function () {
          const e = this;
          this._resizeSash = new K.b( this._domNode, this, {
            orientation: K.a.VERTICAL
          } ), this._resized = !1;
          let t = 411;
          this._register( this._resizeSash.onDidStart( ( n => {
            t = z.y( e._domNode )
          } ) ) ), this._register( this._resizeSash.onDidChange( ( n => {
            e._resized = !0;
            const i = t + n.startX - n.currentX;
            if ( !( i < 411 ) ) {
              const o = i - Pe;
              i > ( parseFloat( z.r( e._domNode ).maxWidth ) || 0 ) || ( e._domNode.style.width = i + "px", e._isReplaceVisible && ( e._replaceInputBox.width = o ) )
            }
          } ) ) )
        }, t.ID = "editor.contrib.findWidget", t;
      } )( U.a );

      const je = ( e => {
        function t( n ) {
          const i = e.call( this ) || this;
          return i._opts = n, i._domNode = document.createElement( "div" ), i._domNode.className = "monaco-checkbox", i._domNode.title = i._opts.title, i._domNode.tabIndex = 0, i._checkbox = document.createElement( "input" ), i._checkbox.type = "checkbox", i._checkbox.className = "checkbox", i._checkbox.id = "checkbox-" + t._COUNTER++, i._checkbox.tabIndex = -1, i._label = document.createElement( "label" ), i._label.className = "label", i._label.htmlFor = i._checkbox.id, i._label.tabIndex = -1, i._domNode.appendChild( i._checkbox ), i._domNode.appendChild( i._label ), i._opts.parent.appendChild( i._domNode ), i.onchange( i._checkbox, ( e => {
            i._opts.onChange()
          } ) ), i;
        }
        return ye( t, e ), Object.defineProperty( t.prototype, "domNode", {
          get() {
            return this._domNode
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( t.prototype, "checked", {
          get() {
            return this._checkbox.checked
          },
          set( e ) {
            this._checkbox.checked = e
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.enable = function () {
          this._checkbox.removeAttribute( "disabled" )
        }, t.prototype.disable = function () {
          this._checkbox.disabled = !0
        }, t.prototype.setEnabled = function ( e ) {
          e ? ( this.enable(), this.domNode.tabIndex = 0 ) : ( this.disable(), this.domNode.tabIndex = -1 )
        }, t._COUNTER = 0, t;
      } )( U.a );
      const Ve = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n._opts = t, n._domNode = document.createElement( "div" ), n._domNode.title = n._opts.label, n._domNode.tabIndex = 0, n._domNode.className = "button " + n._opts.className, n._domNode.setAttribute( "role", "button" ), n._domNode.setAttribute( "aria-label", n._opts.label ), n.onclick( n._domNode, ( e => {
            n._opts.onTrigger(), e.preventDefault()
          } ) ), n.onkeydown( n._domNode, ( e => {
            if ( e.equals( 10 ) || e.equals( 3 ) ) return n._opts.onTrigger(), void e.preventDefault();
            n._opts.onKeyDown && n._opts.onKeyDown( e )
          } ) ), n;
        }
        return ye( t, e ), Object.defineProperty( t.prototype, "domNode", {
          get() {
            return this._domNode
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.isEnabled = function () {
          return this._domNode.tabIndex >= 0
        }, t.prototype.focus = function () {
          this._domNode.focus()
        }, t.prototype.setEnabled = function ( e ) {
          z.N( this._domNode, "disabled", !e ), this._domNode.setAttribute( "aria-disabled", String( !e ) ), this._domNode.tabIndex = e ? 0 : -1
        }, t.prototype.setExpanded = function ( e ) {
          this._domNode.setAttribute( "aria-expanded", String( !!e ) )
        }, t.prototype.toggleClass = function ( e, t ) {
          z.N( this._domNode, e, t )
        }, t;
      } )( U.a );
      Object( _.e )( ( ( e, t ) => {
        const n = ( e, n ) => {
          n && t.addRule( ".monaco-editor " + e + " { background-color: " + n + "; }" )
        };
        n( ".findMatch", e.getColor( m.q ) ), n( ".currentFindMatch", e.getColor( m.o ) ), n( ".findScope", e.getColor( m.s ) ), n( ".find-widget", e.getColor( m.D ) );
        const i = e.getColor( m.rb );
        i && t.addRule( ".monaco-editor .find-widget { box-shadow: 0 2px 8px " + i + "; }" );
        const o = e.getColor( m.r );
        o && t.addRule( ".monaco-editor .findMatch { border: 1px " + ( "hc" === e.type ? "dotted" : "solid" ) + " " + o + "; box-sizing: border-box; }" );
        const r = e.getColor( m.p );
        r && t.addRule( ".monaco-editor .currentFindMatch { border: 2px solid " + r + "; padding: 1px; box-sizing: border-box; }" );
        const s = e.getColor( m.t );
        s && t.addRule( ".monaco-editor .findScope { border: 1px " + ( "hc" === e.type ? "dashed" : "solid" ) + " " + s + "; }" );
        const a = e.getColor( m.e );
        a && t.addRule( ".monaco-editor .find-widget { border: 2px solid " + a + "; }" );
        const u = e.getColor( m.G );
        u && t.addRule( ".monaco-editor .find-widget.no-results .matchesCount { color: " + u + "; }" );
        const l = e.getColor( m.F );
        if ( l ) t.addRule( ".monaco-editor .find-widget .monaco-sash { background-color: " + l + "; width: 3px !important; margin-left: -4px;}" );
        else {
          const c = e.getColor( m.E );
          c && t.addRule( ".monaco-editor .find-widget .monaco-sash { background-color: " + c + "; width: 3px !important; margin-left: -4px;}" )
        }
      } ) );
      const Be = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        He = ( e => {
          function t( t, n, i, o ) {
            const r = e.call( this ) || this;
            r._hideSoon = r._register( new u.c( ( () => {
              return r._hide()
            } ), 2e3 ) ), r._isVisible = !1, r._editor = t, r._state = n, r._keybindingService = i, r._domNode = document.createElement( "div" ), r._domNode.className = "findOptionsWidget", r._domNode.style.display = "none", r._domNode.style.top = "10px", r._domNode.setAttribute( "role", "presentation" ), r._domNode.setAttribute( "aria-hidden", "true" );
            const s = o.getTheme().getColor( m.J );
            return r.caseSensitive = r._register( new ie( {
              appendTitle: r._keybindingLabelFor( D.ToggleCaseSensitiveCommand ),
              isChecked: r._state.matchCase,
              inputActiveOptionBorder: s
            } ) ), r._domNode.appendChild( r.caseSensitive.domNode ), r._register( r.caseSensitive.onChange( ( () => {
              r._state.change( {
                matchCase: r.caseSensitive.checked
              }, !1 )
            } ) ) ), r.wholeWords = r._register( new oe( {
              appendTitle: r._keybindingLabelFor( D.ToggleWholeWordCommand ),
              isChecked: r._state.wholeWord,
              inputActiveOptionBorder: s
            } ) ), r._domNode.appendChild( r.wholeWords.domNode ), r._register( r.wholeWords.onChange( ( () => {
              r._state.change( {
                wholeWord: r.wholeWords.checked
              }, !1 )
            } ) ) ), r.regex = r._register( new re( {
              appendTitle: r._keybindingLabelFor( D.ToggleRegexCommand ),
              isChecked: r._state.isRegex,
              inputActiveOptionBorder: s
            } ) ), r._domNode.appendChild( r.regex.domNode ), r._register( r.regex.onChange( ( () => {
              r._state.change( {
                isRegex: r.regex.checked
              }, !1 )
            } ) ) ), r._editor.addOverlayWidget( r ), r._register( r._state.onFindReplaceStateChange( ( e => {
              let t = !1;
              e.isRegex && ( r.regex.checked = r._state.isRegex, t = !0 ), e.wholeWord && ( r.wholeWords.checked = r._state.wholeWord, t = !0 ), e.matchCase && ( r.caseSensitive.checked = r._state.matchCase, t = !0 ), !r._state.isRevealed && t && r._revealTemporarily()
            } ) ) ), r._register( z.h( r._domNode, ( e => {
              return r._onMouseOut()
            } ) ) ), r._register( z.g( r._domNode, "mouseover", ( e => {
              return r._onMouseOver()
            } ) ) ), r._applyTheme( o.getTheme() ), r._register( o.onThemeChange( r._applyTheme.bind( r ) ) ), r;
          }
          return Be( t, e ), t.prototype._keybindingLabelFor = function ( e ) {
            const t = this._keybindingService.lookupKeybinding( e );
            return t ? " (" + t.getLabel() + ")" : ""
          }, t.prototype.dispose = function () {
            this._editor.removeOverlayWidget( this ), e.prototype.dispose.call( this )
          }, t.prototype.getId = () => {
            return t.ID
          }, t.prototype.getDomNode = function () {
            return this._domNode
          }, t.prototype.getPosition = () => {
            return {
              preference: q.c.TOP_RIGHT_CORNER
            }
          }, t.prototype.highlightFindOptions = function () {
            this._revealTemporarily()
          }, t.prototype._revealTemporarily = function () {
            this._show(), this._hideSoon.schedule()
          }, t.prototype._onMouseOut = function () {
            this._hideSoon.schedule()
          }, t.prototype._onMouseOver = function () {
            this._hideSoon.cancel()
          }, t.prototype._show = function () {
            this._isVisible || ( this._isVisible = !0, this._domNode.style.display = "block" )
          }, t.prototype._hide = function () {
            this._isVisible && ( this._isVisible = !1, this._domNode.style.display = "none" )
          }, t.prototype._applyTheme = function ( e ) {
            const t = {
              inputActiveOptionBorder: e.getColor( m.J )
            };
            this.caseSensitive.style( t ), this.wholeWords.style( t ), this.regex.style( t )
          }, t.ID = "editor.contrib.findOptionsWidget", t;
        } )( U.a );
      Object( _.e )( ( ( e, t ) => {
        const n = e.getColor( m.D );
        n && t.addRule( ".monaco-editor .findOptionsWidget { background-color: " + n + "; }" );
        const i = e.getColor( m.rb );
        i && t.addRule( ".monaco-editor .findOptionsWidget { box-shadow: 0 2px 8px " + i + "; }" );
        const o = e.getColor( m.e );
        o && t.addRule( ".monaco-editor .findOptionsWidget { border: 2px solid " + o + "; }" )
      } ) );
      const ze = n( "Cg/j" ),
        Ue = n( "fjLI" );
      n.d( t, "getSelectionSearchString", ( () => {
        return Ye
      } ) ), n.d( t, "CommonFindController", ( () => {
        return Xe
      } ) ), n.d( t, "FindController", ( () => {
        return $e
      } ) ), n.d( t, "StartFindAction", ( () => {
        return Ze
      } ) ), n.d( t, "StartFindWithSelectionAction", ( () => {
        return Qe
      } ) ), n.d( t, "MatchFindAction", ( () => {
        return Je
      } ) ), n.d( t, "NextMatchFindAction", ( () => {
        return et
      } ) ), n.d( t, "PreviousMatchFindAction", ( () => {
        return tt
      } ) ), n.d( t, "SelectionMatchFindAction", ( () => {
        return nt
      } ) ), n.d( t, "NextSelectionMatchFindAction", ( () => {
        return it
      } ) ), n.d( t, "PreviousSelectionMatchFindAction", ( () => {
        return ot
      } ) ), n.d( t, "StartFindReplaceAction", ( () => {
        return rt
      } ) );
      const Ke = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        qe = function ( e, t, n, i ) {
          let o;
          const r = arguments.length;
          let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
          if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
          else
            for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
          return r > 3 && s && Object.defineProperty( t, n, s ), s
        },
        Ge = ( e, t ) => {
          return ( n, i ) => {
            t( n, i, e )
          };
        };

      function Ye( e ) {
        const t = e.getSelection();
        if ( t.startLineNumber === t.endLineNumber ) {
          if ( !t.isEmpty() ) return e.getModel().getValueInRange( t );
          const n = e.getModel().getWordAtPosition( t.getStartPosition() );
          if ( n ) return n.word
        }
        return null
      }
      var Xe = ( e => {
          function t( t, n, i, o ) {
            const r = e.call( this ) || this;
            return r._editor = t, r._findWidgetVisible = O.bindTo( n ), r._storageService = i, r._clipboardService = o, r._updateHistoryDelayer = new u.a( 500 ), r._state = r._register( new P ), r.loadQueryState(), r._register( r._state.onFindReplaceStateChange( ( e => {
              return r._onStateChanged( e )
            } ) ) ), r._model = null, r._register( r._editor.onDidChangeModel( ( () => {
              const e = r._editor.getModel() && r._state.isRevealed;
              r.disposeModel(), r._state.change( {
                searchScope: null,
                matchCase: r._storageService.getBoolean( "editor.matchCase", F.c.WORKSPACE, !1 ),
                wholeWord: r._storageService.getBoolean( "editor.wholeWord", F.c.WORKSPACE, !1 ),
                isRegex: r._storageService.getBoolean( "editor.isRegex", F.c.WORKSPACE, !1 )
              }, !1 ), e && r._start( {
                forceRevealReplace: !1,
                seedSearchStringFromSelection: !1,
                seedSearchStringFromGlobalClipboard: !1,
                shouldFocus: 0,
                shouldAnimate: !1
              } )
            } ) ) ), r;
          }
          return Ke( t, e ), t.get = e => {
            return e.getContribution( t.ID )
          }, t.prototype.dispose = function () {
            this.disposeModel(), e.prototype.dispose.call( this )
          }, t.prototype.disposeModel = function () {
            this._model && ( this._model.dispose(), this._model = null )
          }, t.prototype.getId = () => {
            return t.ID
          }, t.prototype._onStateChanged = function ( e ) {
            this.saveQueryState( e ), e.isRevealed && ( this._state.isRevealed ? this._findWidgetVisible.set( !0 ) : ( this._findWidgetVisible.reset(), this.disposeModel() ) ), e.searchString && this.setGlobalBufferTerm( this._state.searchString )
          }, t.prototype.saveQueryState = function ( e ) {
            e.isRegex && this._storageService.store( "editor.isRegex", this._state.actualIsRegex, F.c.WORKSPACE ), e.wholeWord && this._storageService.store( "editor.wholeWord", this._state.actualWholeWord, F.c.WORKSPACE ), e.matchCase && this._storageService.store( "editor.matchCase", this._state.actualMatchCase, F.c.WORKSPACE )
          }, t.prototype.loadQueryState = function () {
            this._state.change( {
              matchCase: this._storageService.getBoolean( "editor.matchCase", F.c.WORKSPACE, this._state.matchCase ),
              wholeWord: this._storageService.getBoolean( "editor.wholeWord", F.c.WORKSPACE, this._state.wholeWord ),
              isRegex: this._storageService.getBoolean( "editor.isRegex", F.c.WORKSPACE, this._state.isRegex )
            }, !1 )
          }, t.prototype.getState = function () {
            return this._state
          }, t.prototype.closeFindWidget = function () {
            this._state.change( {
              isRevealed: !1,
              searchScope: null
            }, !1 ), this._editor.focus()
          }, t.prototype.toggleCaseSensitive = function () {
            this._state.change( {
              matchCase: !this._state.matchCase
            }, !1 )
          }, t.prototype.toggleWholeWords = function () {
            this._state.change( {
              wholeWord: !this._state.wholeWord
            }, !1 )
          }, t.prototype.toggleRegex = function () {
            this._state.change( {
              isRegex: !this._state.isRegex
            }, !1 )
          }, t.prototype.toggleSearchScope = function () {
            if ( this._state.searchScope ) this._state.change( {
              searchScope: null
            }, !0 );
            else {
              let e = this._editor.getSelection();
              1 === e.endColumn && e.endLineNumber > e.startLineNumber && ( e = e.setEndPosition( e.endLineNumber - 1, 1 ) ), e.isEmpty() || this._state.change( {
                searchScope: e
              }, !0 )
            }
          }, t.prototype.setSearchString = function ( e ) {
            this._state.isRegex && ( e = s.escapeRegExpCharacters( e ) ), this._state.change( {
              searchString: e
            }, !1 )
          }, t.prototype.highlightFindOptions = () => {}, t.prototype._start = function ( e ) {
            if ( this.disposeModel(), this._editor.getModel() ) {
              let t;
              const n = {
                isRevealed: !0
              };
              if ( e.seedSearchStringFromSelection )( t = Ye( this._editor ) ) && ( this._state.isRegex ? n.searchString = s.escapeRegExpCharacters( t ) : n.searchString = t );
              if ( !n.searchString && e.seedSearchStringFromGlobalClipboard )( t = this.getGlobalBufferTerm() ) && ( n.searchString = t );
              e.forceRevealReplace ? n.isReplaceRevealed = !0 : this._findWidgetVisible.get() || ( n.isReplaceRevealed = !1 ), this._state.change( n, !1 ), this._model || ( this._model = new M( this._editor, this._state ) )
            }
          }, t.prototype.start = function ( e ) {
            this._start( e )
          }, t.prototype.moveToNextMatch = function () {
            return !!this._model && ( this._model.moveToNextMatch(), !0 )
          }, t.prototype.moveToPrevMatch = function () {
            return !!this._model && ( this._model.moveToPrevMatch(), !0 )
          }, t.prototype.replace = function () {
            return !!this._model && ( this._model.replace(), !0 )
          }, t.prototype.replaceAll = function () {
            return !!this._model && ( this._model.replaceAll(), !0 )
          }, t.prototype.selectAllMatches = function () {
            return !!this._model && ( this._model.selectAllMatches(), this._editor.focus(), !0 )
          }, t.prototype.getGlobalBufferTerm = function () {
            return this._editor.getConfiguration().contribInfo.find.globalFindClipboard && this._clipboardService && !this._editor.getModel().isTooLargeForSyncing() ? this._clipboardService.readFindText() : ""
          }, t.prototype.setGlobalBufferTerm = function ( e ) {
            this._editor.getConfiguration().contribInfo.find.globalFindClipboard && this._clipboardService && !this._editor.getModel().isTooLargeForSyncing() && this._clipboardService.writeFindText( e )
          }, t.ID = "editor.contrib.findController", t = qe( [ Ge( 1, r.e ), Ge( 2, F.a ), Ge( 3, W.a ) ], t );
        } )( o.a ),
        $e = ( e => {
          function t( t, n, i, o, r, s, a ) {
            const u = e.call( this, t, i, s, a ) || this;
            return u._contextViewService = n, u._contextKeyService = i, u._keybindingService = o, u._themeService = r, u
          }
          return Ke( t, e ), t.prototype._start = function ( t ) {
            this._widget || this._createFindWidget(), e.prototype._start.call( this, t ), 2 === t.shouldFocus ? this._widget.focusReplaceInput() : 1 === t.shouldFocus && this._widget.focusFindInput()
          }, t.prototype.highlightFindOptions = function () {
            this._widget || this._createFindWidget(), this._state.isRevealed ? this._widget.highlightFindOptions() : this._findOptionsWidget.highlightFindOptions()
          }, t.prototype._createFindWidget = function () {
            this._widget = this._register( new We( this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService ) ), this._findOptionsWidget = this._register( new He( this._editor, this._state, this._keybindingService, this._themeService ) )
          }, t = qe( [ Ge( 1, j.b ), Ge( 2, r.e ), Ge( 3, V.a ), Ge( 4, _.c ), Ge( 5, F.a ), Ge( 6, Object( ze.d )( W.a ) ) ], t )
        } )( Xe ),
        Ze = ( e => {
          function t() {
            return e.call( this, {
              id: D.StartFindAction,
              label: i.a( "startFindAction", "Find" ),
              alias: "Find",
              precondition: null,
              kbOpts: {
                kbExpr: null,
                primary: 2084,
                weight: 100
              },
              menubarOpts: {
                menuId: Ue.b.MenubarEditMenu,
                group: "3_find",
                title: i.a( {
                  key: "miFind",
                  comment: [ "&& denotes a mnemonic" ]
                }, "&&Find" ),
                order: 1
              }
            } ) || this
          }
          return Ke( t, e ), t.prototype.run = ( e, t ) => {
            const n = Xe.get( t );
            n && n.start( {
              forceRevealReplace: !1,
              seedSearchStringFromSelection: t.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
              seedSearchStringFromGlobalClipboard: t.getConfiguration().contribInfo.find.globalFindClipboard,
              shouldFocus: 1,
              shouldAnimate: !0
            } )
          }, t;
        } )( a.b ),
        Qe = ( e => {
          function t() {
            return e.call( this, {
              id: D.StartFindWithSelection,
              label: i.a( "startFindWithSelectionAction", "Find With Selection" ),
              alias: "Find With Selection",
              precondition: null,
              kbOpts: {
                kbExpr: null,
                primary: null,
                mac: {
                  primary: 2083
                },
                weight: 100
              }
            } ) || this
          }
          return Ke( t, e ), t.prototype.run = ( e, t ) => {
            const n = Xe.get( t );
            n && ( n.start( {
              forceRevealReplace: !1,
              seedSearchStringFromSelection: !0,
              seedSearchStringFromGlobalClipboard: !1,
              shouldFocus: 1,
              shouldAnimate: !0
            } ), n.setGlobalBufferTerm( n.getState().searchString ) )
          }, t;
        } )( a.b ),
        Je = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return Ke( t, e ), t.prototype.run = function ( e, t ) {
            const n = Xe.get( t );
            n && !this._run( n ) && ( n.start( {
              forceRevealReplace: !1,
              seedSearchStringFromSelection: 0 === n.getState().searchString.length && t.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
              seedSearchStringFromGlobalClipboard: !0,
              shouldFocus: 0,
              shouldAnimate: !0
            } ), this._run( n ) )
          }, t;
        } )( a.b ),
        et = ( e => {
          function t() {
            return e.call( this, {
              id: D.NextMatchFindAction,
              label: i.a( "findNextMatchAction", "Find Next" ),
              alias: "Find Next",
              precondition: null,
              kbOpts: {
                kbExpr: A.a.focus,
                primary: 61,
                mac: {
                  primary: 2085,
                  secondary: [ 61 ]
                },
                weight: 100
              }
            } ) || this
          }
          return Ke( t, e ), t.prototype._run = e => {
            return e.moveToNextMatch()
          }, t;
        } )( Je ),
        tt = ( e => {
          function t() {
            return e.call( this, {
              id: D.PreviousMatchFindAction,
              label: i.a( "findPreviousMatchAction", "Find Previous" ),
              alias: "Find Previous",
              precondition: null,
              kbOpts: {
                kbExpr: A.a.focus,
                primary: 1085,
                mac: {
                  primary: 3109,
                  secondary: [ 1085 ]
                },
                weight: 100
              }
            } ) || this
          }
          return Ke( t, e ), t.prototype._run = e => {
            return e.moveToPrevMatch()
          }, t;
        } )( Je ),
        nt = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return Ke( t, e ), t.prototype.run = function ( e, t ) {
            const n = Xe.get( t );
            if ( n ) {
              const i = Ye( t );
              i && n.setSearchString( i ), this._run( n ) || ( n.start( {
                forceRevealReplace: !1,
                seedSearchStringFromSelection: t.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
                seedSearchStringFromGlobalClipboard: !1,
                shouldFocus: 0,
                shouldAnimate: !0
              } ), this._run( n ) )
            }
          }, t;
        } )( a.b ),
        it = ( e => {
          function t() {
            return e.call( this, {
              id: D.NextSelectionMatchFindAction,
              label: i.a( "nextSelectionMatchFindAction", "Find Next Selection" ),
              alias: "Find Next Selection",
              precondition: null,
              kbOpts: {
                kbExpr: A.a.focus,
                primary: 2109,
                weight: 100
              }
            } ) || this
          }
          return Ke( t, e ), t.prototype._run = e => {
            return e.moveToNextMatch()
          }, t;
        } )( nt ),
        ot = ( e => {
          function t() {
            return e.call( this, {
              id: D.PreviousSelectionMatchFindAction,
              label: i.a( "previousSelectionMatchFindAction", "Find Previous Selection" ),
              alias: "Find Previous Selection",
              precondition: null,
              kbOpts: {
                kbExpr: A.a.focus,
                primary: 3133,
                weight: 100
              }
            } ) || this
          }
          return Ke( t, e ), t.prototype._run = e => {
            return e.moveToPrevMatch()
          }, t;
        } )( nt ),
        rt = ( e => {
          function t() {
            return e.call( this, {
              id: D.StartFindReplaceAction,
              label: i.a( "startReplace", "Replace" ),
              alias: "Replace",
              precondition: null,
              kbOpts: {
                kbExpr: null,
                primary: 2086,
                mac: {
                  primary: 2596
                },
                weight: 100
              },
              menubarOpts: {
                menuId: Ue.b.MenubarEditMenu,
                group: "3_find",
                title: i.a( {
                  key: "miReplace",
                  comment: [ "&& denotes a mnemonic" ]
                }, "&&Replace" ),
                order: 2
              }
            } ) || this
          }
          return Ke( t, e ), t.prototype.run = ( e, t ) => {
            if ( !t.getConfiguration().readOnly ) {
              const n = Xe.get( t ),
                i = t.getSelection(),
                o = !i.isEmpty() && i.startLineNumber === i.endLineNumber && t.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
                r = n.getState().searchString || o ? 2 : 1;
              n && n.start( {
                forceRevealReplace: !0,
                seedSearchStringFromSelection: o,
                seedSearchStringFromGlobalClipboard: t.getConfiguration().contribInfo.find.seedSearchStringFromSelection,
                shouldFocus: r,
                shouldAnimate: !0
              } )
            }
          }, t;
        } )( a.b );
      Object( a.h )( $e ), Object( a.f )( Ze ), Object( a.f )( Qe ), Object( a.f )( et ), Object( a.f )( tt ), Object( a.f )( it ), Object( a.f )( ot ), Object( a.f )( rt );
      const st = a.c.bindToContribution( Xe.get );
      Object( a.g )( new st( {
        id: D.CloseFindWidgetCommand,
        precondition: O,
        handler( e ) {
          return e.closeFindWidget()
        },
        kbOpts: {
          weight: 105,
          kbExpr: A.a.focus,
          primary: 9,
          secondary: [ 1033 ]
        }
      } ) ), Object( a.g )( new st( {
        id: D.ToggleCaseSensitiveCommand,
        precondition: null,
        handler( e ) {
          return e.toggleCaseSensitive()
        },
        kbOpts: {
          weight: 105,
          kbExpr: A.a.focus,
          primary: N.primary,
          mac: N.mac,
          win: N.win,
          linux: N.linux
        }
      } ) ), Object( a.g )( new st( {
        id: D.ToggleWholeWordCommand,
        precondition: null,
        handler( e ) {
          return e.toggleWholeWords()
        },
        kbOpts: {
          weight: 105,
          kbExpr: A.a.focus,
          primary: E.primary,
          mac: E.mac,
          win: E.win,
          linux: E.linux
        }
      } ) ), Object( a.g )( new st( {
        id: D.ToggleRegexCommand,
        precondition: null,
        handler( e ) {
          return e.toggleRegex()
        },
        kbOpts: {
          weight: 105,
          kbExpr: A.a.focus,
          primary: k.primary,
          mac: k.mac,
          win: k.win,
          linux: k.linux
        }
      } ) ), Object( a.g )( new st( {
        id: D.ToggleSearchScopeCommand,
        precondition: null,
        handler( e ) {
          return e.toggleSearchScope()
        },
        kbOpts: {
          weight: 105,
          kbExpr: A.a.focus,
          primary: I.primary,
          mac: I.mac,
          win: I.win,
          linux: I.linux
        }
      } ) ), Object( a.g )( new st( {
        id: D.ReplaceOneAction,
        precondition: O,
        handler( e ) {
          return e.replace()
        },
        kbOpts: {
          weight: 105,
          kbExpr: A.a.focus,
          primary: 3094
        }
      } ) ), Object( a.g )( new st( {
        id: D.ReplaceAllAction,
        precondition: O,
        handler( e ) {
          return e.replaceAll()
        },
        kbOpts: {
          weight: 105,
          kbExpr: A.a.focus,
          primary: 2563
        }
      } ) ), Object( a.g )( new st( {
        id: D.SelectAllMatchesAction,
        precondition: O,
        handler( e ) {
          return e.selectAllMatches()
        },
        kbOpts: {
          weight: 105,
          kbExpr: A.a.focus,
          primary: 515
        }
      } ) )
    },
    oiKk( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "IPadShowKeyboard", ( () => {
        return u
      } ) );
      n( "ci+S" );
      const i = n( "pmY6" );
      const o = n( "D3Dy" );
      const r = n( "EffR" );
      const s = n( "sFUC" );
      const a = n( "sswD" );
      var u = ( () => {
        function e( e ) {
          const t = this;
          this.editor = e, this.toDispose = [], o.l && ( this.toDispose.push( e.onDidChangeConfiguration( ( () => {
            return t.update()
          } ) ) ), this.update() )
        }
        return e.prototype.update = function () {
          const e = !!this.widget,
            t = !this.editor.getConfiguration().readOnly;
          !e && t ? this.widget = new l( this.editor ) : e && !t && ( this.widget.dispose(), this.widget = null )
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.dispose = function () {
          this.toDispose = Object( i.d )( this.toDispose ), this.widget && ( this.widget.dispose(), this.widget = null )
        }, e.ID = "editor.contrib.iPadShowKeyboard", e;
      } )();
      const l = ( () => {
        function e( e ) {
          const t = this;
          this.editor = e, this._domNode = document.createElement( "textarea" ), this._domNode.className = "iPadShowKeyboard", this._toDispose = [], this._toDispose.push( r.g( this._domNode, "touchstart", ( e => {
            t.editor.focus()
          } ) ) ), this._toDispose.push( r.g( this._domNode, "focus", ( e => {
            t.editor.focus()
          } ) ) ), this.editor.addOverlayWidget( this )
        }
        return e.prototype.dispose = function () {
          this.editor.removeOverlayWidget( this ), this._toDispose = Object( i.d )( this._toDispose )
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.getDomNode = function () {
          return this._domNode
        }, e.prototype.getPosition = () => {
          return {
            preference: s.c.BOTTOM_RIGHT_CORNER
          }
        }, e.ID = "editor.contrib.ShowKeyboardWidget", e;
      } )();
      Object( a.h )( u )
    },
    p3Ex( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "csharp",
        extensions: [ ".cs", ".csx", ".cake" ],
        aliases: [ "C#", "csharp" ],
        loader() {
          return o.Promise.wrap( n.e( 261 ).then( n.bind( null, "/Om3" ) ) )
        }
      } )
    },
    p5tG( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "LanguageServiceDefaultsImpl", ( () => {
        return o
      } ) );
      n( "M/lh" );
      const i = monaco.Emitter;
      var o = ( () => {
        function e( e, t ) {
          this._onDidChange = new i, this._languageId = e, this.setDiagnosticsOptions( t )
        }
        return Object.defineProperty( e.prototype, "onDidChange", {
          get() {
            return this._onDidChange.event
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "languageId", {
          get() {
            return this._languageId
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "diagnosticsOptions", {
          get() {
            return this._diagnosticsOptions
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.setDiagnosticsOptions = function ( e ) {
          this._diagnosticsOptions = e || Object.create( null ), this._onDidChange.fire( this )
        }, e;
      } )();
      const r = new o( "json", {
        validate: !0,
        allowComments: !0,
        schemas: []
      } );
      monaco.languages.json = {
        jsonDefaults: r
      }, monaco.languages.register( {
        id: "json",
        extensions: [ ".json", ".bowerrc", ".jshintrc", ".jscsrc", ".eslintrc", ".babelrc" ],
        aliases: [ "JSON", "json" ],
        mimetypes: [ "application/json" ]
      } ), monaco.languages.onLanguage( "json", ( () => {
        monaco.Promise.wrap( n.e( 317 ).then( n.bind( null, "R7lK" ) ) ).then( ( e => {
          return e.setupMode( r )
        } ) )
      } ) )
    },
    pAvP( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "editorWorkerService" );
    },
    pI2L( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "redshift",
        extensions: [],
        aliases: [ "Redshift", "redshift" ],
        loader() {
          return o.Promise.wrap( n.e( 296 ).then( n.bind( null, "KpXS" ) ) )
        }
      } )
    },
    pg8w( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "b", ( () => {
        return l
      } ) );
      var i;
      const o = n( "6OMU" );
      const r = n( "pmY6" );
      const s = n( "EffR" );
      const a = n( "ZCR3" );

      const u = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      !( e => {
        e.Tap = "-monaco-gesturetap", e.Change = "-monaco-gesturechange", e.Start = "-monaco-gesturestart", e.End = "-monaco-gesturesend", e.Contextmenu = "-monaco-gesturecontextmenu"
      } )( i || ( i = {} ) );
      var l = ( () => {
        function e() {
          const e = this;
          this.toDispose = [], this.activeTouches = {}, this.handle = null, this.targets = [], this.toDispose.push( s.g( document, "touchstart", ( t => {
            return e.onTouchStart( t )
          } ) ) ), this.toDispose.push( s.g( document, "touchend", ( t => {
            return e.onTouchEnd( t )
          } ) ) ), this.toDispose.push( s.g( document, "touchmove", ( t => {
            return e.onTouchMove( t )
          } ) ) )
        }
        return e.addTarget = t => {
          e.isTouchDevice() && ( e.INSTANCE || ( e.INSTANCE = new e ), e.INSTANCE.targets.push( t ) )
        }, e.isTouchDevice = () => {
          return "ontouchstart" in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0
        }, e.prototype.dispose = function () {
          this.handle && ( this.handle.dispose(), Object( r.d )( this.toDispose ), this.handle = null )
        }, e.prototype.onTouchStart = function ( e ) {
          const t = Date.now();
          this.handle && ( this.handle.dispose(), this.handle = null );
          for ( let n = 0, o = e.targetTouches.length; n < o; n++ ) {
            const r = e.targetTouches.item( n );
            this.activeTouches[ r.identifier ] = {
              id: r.identifier,
              initialTarget: r.target,
              initialTimeStamp: t,
              initialPageX: r.pageX,
              initialPageY: r.pageY,
              rollingTimestamps: [ t ],
              rollingPageX: [ r.pageX ],
              rollingPageY: [ r.pageY ]
            };
            const s = this.newGestureEvent( i.Start, r.target );
            s.pageX = r.pageX, s.pageY = r.pageY, this.dispatchEvent( s )
          }
          this.dispatched && ( e.preventDefault(), e.stopPropagation(), this.dispatched = !1 )
        }, e.prototype.onTouchEnd = function ( t ) {
          for ( let n = Date.now(), r = Object.keys( this.activeTouches ).length, s = ( s, u ) => {
              const l = t.changedTouches.item( s );
              if ( !a.activeTouches.hasOwnProperty( String( l.identifier ) ) ) return console.warn( "move of an UNKNOWN touch", l ), "continue";
              const c = a.activeTouches[ l.identifier ],
                d = Date.now() - c.initialTimeStamp;
              if ( d < e.HOLD_DELAY && Math.abs( c.initialPageX - o.n( c.rollingPageX ) ) < 30 && Math.abs( c.initialPageY - o.n( c.rollingPageY ) ) < 30 )( h = a.newGestureEvent( i.Tap, c.initialTarget ) ).pageX = o.n( c.rollingPageX ), h.pageY = o.n( c.rollingPageY ), a.dispatchEvent( h );
              else if ( d >= e.HOLD_DELAY && Math.abs( c.initialPageX - o.n( c.rollingPageX ) ) < 30 && Math.abs( c.initialPageY - o.n( c.rollingPageY ) ) < 30 ) {
                var h;
                ( h = a.newGestureEvent( i.Contextmenu, c.initialTarget ) ).pageX = o.n( c.rollingPageX ), h.pageY = o.n( c.rollingPageY ), a.dispatchEvent( h )
              } else if ( 1 === r ) {
                const p = o.n( c.rollingPageX ),
                  f = o.n( c.rollingPageY ),
                  g = o.n( c.rollingTimestamps ) - c.rollingTimestamps[ 0 ],
                  m = p - c.rollingPageX[ 0 ],
                  _ = f - c.rollingPageY[ 0 ],
                  v = a.targets.filter( ( e => {
                    return c.initialTarget instanceof Node && e.contains( c.initialTarget )
                  } ) );
                a.inertia( v, n, Math.abs( m ) / g, m > 0 ? 1 : -1, p, Math.abs( _ ) / g, _ > 0 ? 1 : -1, f )
              }
              a.dispatchEvent( a.newGestureEvent( i.End, c.initialTarget ) ), delete a.activeTouches[ l.identifier ]
            }, a = this, u = 0, l = t.changedTouches.length; u < l; u++ ) s( u );
          this.dispatched && ( t.preventDefault(), t.stopPropagation(), this.dispatched = !1 )
        }, e.prototype.newGestureEvent = ( e, t ) => {
          const n = document.createEvent( "CustomEvent" );
          return n.initEvent( e, !1, !0 ), n.initialTarget = t, n
        }, e.prototype.dispatchEvent = function ( e ) {
          const t = this;
          this.targets.forEach( ( n => {
            e.initialTarget instanceof Node && n.contains( e.initialTarget ) && ( n.dispatchEvent( e ), t.dispatched = !0 )
          } ) )
        }, e.prototype.inertia = function ( t, n, o, r, a, u, l, c ) {
          const d = this;
          this.handle = s.L( ( () => {
            const s = Date.now();
            const h = s - n;
            let p = 0;
            let f = 0;
            let g = !0;
            o += e.SCROLL_FRICTION * h, u += e.SCROLL_FRICTION * h, o > 0 && ( g = !1, p = r * o * h ), u > 0 && ( g = !1, f = l * u * h );
            const m = d.newGestureEvent( i.Change );
            m.translationX = p, m.translationY = f, t.forEach( ( e => {
              return e.dispatchEvent( m )
            } ) ), g || d.inertia( t, s, o, r, a + p, u, l, c + f )
          } ) )
        }, e.prototype.onTouchMove = function ( e ) {
          for ( let t = Date.now(), n = 0, r = e.changedTouches.length; n < r; n++ ) {
            const s = e.changedTouches.item( n );
            if ( this.activeTouches.hasOwnProperty( String( s.identifier ) ) ) {
              const a = this.activeTouches[ s.identifier ],
                u = this.newGestureEvent( i.Change, a.initialTarget );
              u.translationX = s.pageX - o.n( a.rollingPageX ), u.translationY = s.pageY - o.n( a.rollingPageY ), u.pageX = s.pageX, u.pageY = s.pageY, this.dispatchEvent( u ), a.rollingPageX.length > 3 && ( a.rollingPageX.shift(), a.rollingPageY.shift(), a.rollingTimestamps.shift() ), a.rollingPageX.push( s.pageX ), a.rollingPageY.push( s.pageY ), a.rollingTimestamps.push( t )
            } else console.warn( "end of an UNKNOWN touch", s )
          }
          this.dispatched && ( e.preventDefault(), e.stopPropagation(), this.dispatched = !1 )
        }, e.SCROLL_FRICTION = -.005, e.HOLD_DELAY = 700, u( [ a.a ], e, "isTouchDevice", null ), e;
      } )()
    },
    pmY6( e, t, n ) {
      "use strict";

      function i( e ) {
        return "function" === typeof e.dispose && 0 === e.dispose.length
      }

      function o( e ) {
        for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
        return Array.isArray( e ) ? ( e.forEach( ( e => {
          return e && e.dispose()
        } ) ), [] ) : 0 === t.length ? e ? ( e.dispose(), e ) : void 0 : ( o( e ), o( t ), [] );
      }

      function r( e ) {
        return {
          dispose() {
            return o( e )
          }
        };
      }

      function s( e ) {
        return {
          dispose() {
            e()
          }
        };
      }
      n.d( t, "e", ( () => {
        return i
      } ) ), n.d( t, "d", ( () => {
        return o
      } ) ), n.d( t, "c", ( () => {
        return r
      } ) ), n.d( t, "f", ( () => {
        return s
      } ) ), n.d( t, "a", ( () => {
        return a
      } ) ), n.d( t, "b", ( () => {
        return u
      } ) );
      var a = ( () => {
          function e() {
            this._toDispose = []
          }
          return Object.defineProperty( e.prototype, "toDispose", {
            get() {
              return this._toDispose
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.dispose = function () {
            this._toDispose = o( this._toDispose )
          }, e.prototype._register = function ( e ) {
            return this._toDispose.push( e ), e
          }, e.None = Object.freeze( {
            dispose() {}
          } ), e;
        } )(),
        u = ( () => {
          function e( e ) {
            this.object = e
          }
          return e.prototype.dispose = () => {}, e;
        } )()
    },
    ptcw( e, t, n ) {
      "use strict";
      n.d( t, "d", ( () => {
        return r
      } ) ), n.d( t, "a", ( () => {
        return a
      } ) ), n.d( t, "c", ( () => {
        return u
      } ) ), n.d( t, "b", ( () => {
        return l
      } ) ), n.d( t, "e", ( () => {
        return c
      } ) );
      const i = n( "MD5Z" ),
        o = n( "qj0h" );

      function r( e, t ) {
        const n = Object.create( null );
        for ( const i in t ) {
          const o = t[ i ];
          "string" === typeof o ? n[ i ] = e.getColor( o ) : "function" === typeof o && ( n[ i ] = o( e ) )
        }
        return n
      }

      function s( e, t, n ) {
        function i( i ) {
          const o = r( e.getTheme(), t );
          "function" === typeof n ? n( o ) : n.style( o )
        }
        return i( e.getTheme() ), e.onThemeChange( i )
      }

      function a( e, t, n ) {
        return s( t, {
          badgeBackground: n && n.badgeBackground || i.c,
          badgeForeground: n && n.badgeForeground || i.d,
          badgeBorder: i.e
        }, e )
      }

      function u( e, t, n ) {
        return s( t, {
          foreground: n && n.foreground || i.I,
          background: n && n.background || i.n,
          borderColor: n && n.borderColor || i.e,
          widgetShadow: n && n.widgetShadow || i.rb,
          progressBarBackground: n && n.progressBarBackground || i.jb,
          pickerGroupForeground: n && n.pickerGroupForeground || i.ib,
          pickerGroupBorder: n && n.pickerGroupBorder || i.hb,
          inputBackground: n && n.inputBackground || i.K,
          inputForeground: n && n.inputForeground || i.M,
          inputBorder: n && n.inputBorder || i.L,
          inputValidationInfoBorder: n && n.inputValidationInfoBorder || i.Q,
          inputValidationInfoBackground: n && n.inputValidationInfoBackground || i.P,
          inputValidationWarningBorder: n && n.inputValidationWarningBorder || i.S,
          inputValidationWarningBackground: n && n.inputValidationWarningBackground || i.R,
          inputValidationErrorBorder: n && n.inputValidationErrorBorder || i.O,
          inputValidationErrorBackground: n && n.inputValidationErrorBackground || i.N,
          listFocusBackground: n && n.listFocusBackground || i.W,
          listFocusForeground: n && n.listFocusForeground || i.X,
          listActiveSelectionBackground: n && n.listActiveSelectionBackground || i.T,
          listActiveSelectionForeground: n && n.listActiveSelectionForeground || i.U,
          listFocusAndSelectionBackground: n && n.listFocusAndSelectionBackground || i.T,
          listFocusAndSelectionForeground: n && n.listFocusAndSelectionForeground || i.U,
          listInactiveSelectionBackground: n && n.listInactiveSelectionBackground || i.cb,
          listInactiveSelectionForeground: n && n.listInactiveSelectionForeground || i.db,
          listInactiveFocusBackground: n && n.listInactiveFocusBackground || i.bb,
          listHoverBackground: n && n.listHoverBackground || i.Z,
          listHoverForeground: n && n.listHoverForeground || i.ab,
          listDropBackground: n && n.listDropBackground || i.V,
          listFocusOutline: n && n.listFocusOutline || i.b,
          listSelectionOutline: n && n.listSelectionOutline || i.b,
          listHoverOutline: n && n.listHoverOutline || i.b
        }, e )
      }

      function l( e, t, n ) {
        return s( t, Object( o.g )( n || Object.create( null ), c, !1 ), e )
      }
      var c = {
        listFocusBackground: i.W,
        listFocusForeground: i.X,
        listActiveSelectionBackground: i.T,
        listActiveSelectionForeground: i.U,
        listFocusAndSelectionBackground: i.T,
        listFocusAndSelectionForeground: i.U,
        listInactiveSelectionBackground: i.cb,
        listInactiveSelectionForeground: i.db,
        listInactiveFocusBackground: i.bb,
        listHoverBackground: i.Z,
        listHoverForeground: i.ab,
        listDropBackground: i.V,
        listFocusOutline: i.b,
        listSelectionOutline: i.b,
        listHoverOutline: i.b
      }
    },
    "q/I2": function ( e, t, n ) {},
    q8qy( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "pascaligo",
        extensions: [ ".ligo" ],
        aliases: [ "Pascaligo", "ligo" ],
        loader() {
          return o.Promise.wrap( n.e( 283 ).then( n.bind( null, "ywQP" ) ) )
        }
      } )
    },
    qNAo( e, t, n ) {
      "use strict";
      n.d( t, "f", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) ), n.d( t, "c", ( () => {
        return s
      } ) ), n.d( t, "d", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) ), n.d( t, "e", ( () => {
        return l
      } ) );
      const i = n( "N0LK" );
      var o = function ( e, t, n, i ) {
        this.top = 0 | e, this.left = 0 | t, this.width = 0 | n, this.height = 0 | i
      };
      var r = function ( e, t ) {
        this.tabSize = e, this.data = t
      };
      var s = function ( e, t, n, i, o ) {
        this.content = e, this.continuesWithWrappedLine = t, this.minColumn = n, this.maxColumn = i, this.tokens = o
      };
      var a = ( () => {
        function e( t, n, i, o, r, s, a, u, l ) {
          this.minColumn = t, this.maxColumn = n, this.content = i, this.continuesWithWrappedLine = o, this.isBasicASCII = e.isBasicASCII( i, s ), this.containsRTL = e.containsRTL( i, this.isBasicASCII, r ), this.tokens = a, this.inlineDecorations = u, this.tabSize = l
        }
        return e.isBasicASCII = ( e, t ) => {
          return !t || i.isBasicASCII( e )
        }, e.containsRTL = ( e, t, n ) => {
          return !( t || !n ) && i.containsRTL( e )
        }, e;
      } )();
      var u = function ( e, t, n ) {
        this.range = e, this.inlineClassName = t, this.type = n
      };
      var l = function ( e, t ) {
        this.range = e, this.options = t
      };
    },
    qWra( e, t, n ) {},
    qj0h( e, t, n ) {
      "use strict";
      n.d( t, "c", ( () => {
        return o
      } ) ), n.d( t, "d", ( () => {
        return r
      } ) ), n.d( t, "g", ( () => {
        return a
      } ) ), n.d( t, "a", ( () => {
        return u
      } ) ), n.d( t, "e", ( () => {
        return l
      } ) ), n.d( t, "b", ( () => {
        return c
      } ) ), n.d( t, "f", ( () => {
        return d
      } ) );
      const i = n( "746U" );

      function o( e ) {
        if ( !e || "object" !== typeof e ) return e;
        if ( e instanceof RegExp ) return e;
        const t = Array.isArray( e ) ? [] : {};
        return Object.keys( e ).forEach( ( n => {
          e[ n ] && "object" === typeof e[ n ] ? t[ n ] = o( e[ n ] ) : t[ n ] = e[ n ]
        } ) ), t;
      }

      function r( e ) {
        if ( !e || "object" !== typeof e ) return e;
        for ( const t = [ e ]; t.length > 0; ) {
          const n = t.shift();
          for ( const i in ( Object.freeze( n ), n ) )
            if ( s.call( n, i ) ) {
              const o = n[ i ];
              "object" !== typeof o || Object.isFrozen( o ) || t.push( o )
            }
        }
        return e
      }
      var s = Object.prototype.hasOwnProperty;

      function a( e, t, n ) {
        return void 0 === n && ( n = !0 ), Object( i.g )( e ) ? ( Object( i.g )( t ) && Object.keys( t ).forEach( ( o => {
          o in e ? n && ( Object( i.g )( e[ o ] ) && Object( i.g )( t[ o ] ) ? a( e[ o ], t[ o ], n ) : e[ o ] = t[ o ] ) : e[ o ] = t[ o ]
        } ) ), e ) : t;
      }

      function u( e ) {
        for ( var t = [], n = 1; n < arguments.length; n++ ) t[ n - 1 ] = arguments[ n ];
        return t.forEach( ( t => {
          return Object.keys( t ).forEach( ( n => {
            return e[ n ] = t[ n ]
          } ) );
        } ) ), e;
      }

      function l( e, t ) {
        if ( e === t ) return !0;
        if ( null === e || void 0 === e || null === t || void 0 === t ) return !1;
        if ( typeof e !== typeof t ) return !1;
        if ( "object" !== typeof e ) return !1;
        if ( Array.isArray( e ) !== Array.isArray( t ) ) return !1;
        let n, i;
        if ( Array.isArray( e ) ) {
          if ( e.length !== t.length ) return !1;
          for ( n = 0; n < e.length; n++ )
            if ( !l( e[ n ], t[ n ] ) ) return !1
        } else {
          const o = [];
          for ( i in e ) o.push( i );
          o.sort();
          const r = [];
          for ( i in t ) r.push( i );
          if ( r.sort(), !l( o, r ) ) return !1;
          for ( n = 0; n < o.length; n++ )
            if ( !l( e[ o[ n ] ], t[ o[ n ] ] ) ) return !1
        }
        return !0
      }

      function c( e, t ) {
        void 0 === t && ( t = !1 ), t && ( e = e.map( ( e => {
          return e.toLowerCase()
        } ) ) );
        const n = ( e => {
          for ( var t = {}, n = 0; n < e.length; ++n ) t[ e[ n ] ] = !0;
          return t
        } )( e );
        return t ? e => {
          return void 0 !== n[ e.toLowerCase() ] && n.hasOwnProperty( e.toLowerCase() )
        } : e => {
          return void 0 !== n[ e ] && n.hasOwnProperty( e )
        };
      }

      function d( e, t, n ) {
        void 0 === n && ( n = null );
        const i = t( e );
        return "undefined" === typeof i ? n : i
      }
    },
    qkNm( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return y
      } ) ), n.d( t, "a", ( () => {
        return b
      } ) );
      const i = n( "3/fG" );
      const o = n( "/cxE" );
      const r = n( "pmY6" );
      const s = n( "Vxe3" );
      const a = n( "Cg/j" );
      const u = n( "T8No" );
      const l = n( "+7oY" );
      const c = n( "A+jI" );
      const d = n( "cSGN" );
      const h = n( "aokT" );
      const p = n( "cGHE" );
      const f = n( "sM1p" );

      const g = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const m = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      const _ = ( e, t, n, i ) => {
        return new( n || ( n = Promise ) )( ( ( o, r ) => {
          function s( e ) {
            try {
              u( i.next( e ) )
            } catch ( t ) {
              r( t )
            }
          }

          function a( e ) {
            try {
              u( i.throw( e ) )
            } catch ( t ) {
              r( t )
            }
          }

          function u( e ) {
            e.done ? o( e.value ) : new n( ( t => {
              t( e.value )
            } ) ).then( s, a )
          }
          u( ( i = i.apply( e, t || [] ) ).next() )
        } ) );
      };
      const v = ( e, t ) => {
        let n, i, o, r, s = {
          label: 0,
          sent() {
            if ( 1 & o[ 0 ] ) throw o[ 1 ];
            return o[ 1 ]
          },
          trys: [],
          ops: []
        };
        return r = {
          next: a( 0 ),
          throw: a( 1 ),
          return: a( 2 )
        }, "function" === typeof Symbol && ( r[ Symbol.iterator ] = function () {
          return this
        } ), r;

        function a( r ) {
          return a => {
            return ( r => {
              if ( n ) throw new TypeError( "Generator is already executing." );
              for ( ; s; ) try {
                if ( n = 1, i && ( o = 2 & r[ 0 ] ? i.return : r[ 0 ] ? i.throw || ( ( o = i.return ) && o.call( i ), 0 ) : i.next ) && !( o = o.call( i, r[ 1 ] ) ).done ) return o;
                switch ( i = 0, o && ( r = [ 2 & r[ 0 ], o.value ] ), r[ 0 ] ) {
                  case 0:
                  case 1:
                    o = r;
                    break;
                  case 4:
                    return s.label++, {
                      value: r[ 1 ],
                      done: !1
                    };
                  case 5:
                    s.label++, i = r[ 1 ], r = [ 0 ];
                    continue;
                  case 7:
                    r = s.ops.pop(), s.trys.pop();
                    continue;
                  default:
                    if ( !( o = ( o = s.trys ).length > 0 && o[ o.length - 1 ] ) && ( 6 === r[ 0 ] || 2 === r[ 0 ] ) ) {
                      s = 0;
                      continue
                    }
                    if ( 3 === r[ 0 ] && ( !o || r[ 1 ] > o[ 0 ] && r[ 1 ] < o[ 3 ] ) ) {
                      s.label = r[ 1 ];
                      break
                    }
                    if ( 6 === r[ 0 ] && s.label < o[ 1 ] ) {
                      s.label = o[ 1 ], o = r;
                      break
                    }
                    if ( o && s.label < o[ 2 ] ) {
                      s.label = o[ 2 ], s.ops.push( r );
                      break
                    }
                    o[ 2 ] && s.ops.pop(), s.trys.pop();
                    continue
                }
                r = t.call( e, s )
              } catch ( a ) {
                r = [ 6, a ], i = 0
              } finally {
                n = o = 0
              }
              if ( 5 & r[ 0 ] ) throw r[ 1 ];
              return {
                value: r[ 0 ] ? r[ 1 ] : void 0,
                done: !0
              }
            } )( [ r, a ] );
          };
        }
      };
      var y = new u.f( "referenceSearchVisible", !1 );

      var b = ( () => {
        function e( e, t, n, i, o, r, s, a ) {
          this._defaultTreeKeyboardSupport = e, this._editorService = i, this._notificationService = o, this._instantiationService = r, this._storageService = s, this._configurationService = a, this._requestIdPool = 0, this._disposables = [], this._ignoreModelChangeEvent = !1, this._editor = t, this._referenceSearchVisible = y.bindTo( n )
        }
        return e.get = t => {
          return t.getContribution( e.ID )
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.dispose = function () {
          this._referenceSearchVisible.reset(), Object( r.d )( this._disposables ), Object( r.d )( this._widget ), Object( r.d )( this._model ), this._widget = null, this._model = null, this._editor = null
        }, e.prototype.toggleWidget = function ( e, t, n ) {
          let o;
          const r = this;
          if ( this._widget && ( o = this._widget.position ), this.closeWidget(), o && e.containsPosition( o ) ) return null;
          this._referenceSearchVisible.set( !0 ), this._disposables.push( this._editor.onDidChangeModelLanguage( ( () => {
            r.closeWidget()
          } ) ) ), this._disposables.push( this._editor.onDidChangeModel( ( () => {
            r._ignoreModelChangeEvent || r.closeWidget()
          } ) ) );
          const s = JSON.parse( this._storageService.get( "peekViewLayout", void 0, "{}" ) );
          this._widget = this._instantiationService.createInstance( d.a, this._editor, this._defaultTreeKeyboardSupport, s ), this._widget.setTitle( i.a( "labelLoading", "Loading..." ) ), this._widget.show( e ), this._disposables.push( this._widget.onDidClose( ( () => {
            t.cancel(), r._storageService.store( "peekViewLayout", JSON.stringify( r._widget.layoutData ) ), r._widget = null, r.closeWidget()
          } ) ) ), this._disposables.push( this._widget.onDidSelectReference( ( e => {
            const t = e.element,
              i = e.kind;
            switch ( i ) {
              case "open":
                if ( "editor" === e.source && r._configurationService.getValue( "editor.stablePeek" ) ) break;
              case "side":
                r.openReference( t, "side" === i );
                break;
              case "goto":
                n.onGoto ? n.onGoto( t ) : r._gotoReference( t )
            }
          } ) ) );
          const a = ++this._requestIdPool;
          t.then( ( t => {
            if ( a === r._requestIdPool && r._widget ) return r._model && r._model.dispose(), r._model = t, r._widget.setModel( r._model ).then( ( () => {
              if ( r._widget ) {
                r._widget.setMetaTitle( n.getMetaTitle( r._model ) );
                const t = r._editor.getModel().uri,
                  i = new p.a( e.startLineNumber, e.startColumn ),
                  o = r._model.nearestReference( t, i );
                if ( o ) return r._widget.setSelection( o )
              }
            } ) );
          } ), ( e => {
            r._notificationService.error( e )
          } ) )
        }, e.prototype.goToNextOrPreviousReference = function ( e ) {
          return _( this, void 0, void 0, ( function () {
            let t, n, i;
            return v( this, ( function ( o ) {
              switch ( o.label ) {
                case 0:
                  return this._model ? ( t = this._model.nearestReference( this._editor.getModel().uri, this._widget.position ), n = this._model.nextOrPreviousReference( t, e ), i = this._editor.hasTextFocus(), [ 4, this._widget.setSelection( n ) ] ) : [ 3, 3 ];
                case 1:
                  return o.sent(), [ 4, this._gotoReference( n ) ];
                case 2:
                  o.sent(), i && this._editor.focus(), o.label = 3;
                case 3:
                  return [ 2 ]
              }
            } ) )
          } ) );
        }, e.prototype.closeWidget = function () {
          Object( r.d )( this._widget ), this._widget = null, this._referenceSearchVisible.reset(), this._disposables = Object( r.d )( this._disposables ), Object( r.d )( this._model ), this._model = null, this._editor.focus(), this._requestIdPool += 1
        }, e.prototype._gotoReference = function ( e ) {
          const t = this;
          this._widget.hide(), this._ignoreModelChangeEvent = !0;
          const n = h.a.lift( e.range ).collapseToStart();
          return this._editorService.openCodeEditor( {
            resource: e.uri,
            options: {
              selection: n
            }
          }, this._editor ).then( ( e => {
            t._ignoreModelChangeEvent = !1, e && e === t._editor ? ( t._widget.show( n ), t._widget.focus() ) : t.closeWidget()
          } ), ( e => {
            t._ignoreModelChangeEvent = !1, Object( o.e )( e )
          } ) );
        }, e.prototype.openReference = function ( e, t ) {
          const n = e.uri,
            i = e.range;
          this._editorService.openCodeEditor( {
            resource: n,
            options: {
              selection: i
            }
          }, this._editor, t ), t || this.closeWidget()
        }, e.ID = "editor.contrib.referencesController", e = g( [ m( 2, u.e ), m( 3, s.a ), m( 4, f.a ), m( 5, a.a ), m( 6, c.a ), m( 7, l.b ) ], e );
      } )();
    },
    rugR( e, t, n ) {
      "use strict";
      n.r( t );
      n( "uAX5" );
      const i = n( "3/fG" ),
        o = n( "/kV6" ),
        r = n( "MNsG" ),
        s = n( "W9cx" ),
        a = n( "WBhO" ),
        u = n( "aokT" ),
        l = n( "sswD" ),
        c = n( "sFUC" ),
        d = n( "EffR" ),
        h = n( "cGHE" ),
        p = n( "twdY" ),
        f = n( "6OMU" ),
        g = n( "/cxE" ),
        m = n( "JQT/" );

      function _( e, t, n ) {
        const i = p.m.ordered( e ).map( ( i => {
          return Promise.resolve( i.provideHover( e, t, n ) ).then( ( e => {
            return e && ( e => {
              const t = "undefined" !== typeof e.range,
                n = "undefined" !== typeof e.contents && e.contents && e.contents.length > 0;
              return t && n
            } )( e ) ? e : void 0;
          } ), ( e => {
            Object( g.f )( e )
          } ) );
        } ) );
        return Promise.all( i ).then( ( e => {
          return Object( f.c )( e )
        } ) );
      }
      Object( l.e )( "_executeHoverProvider", ( ( e, t ) => {
        return _( e, t, m.a.None )
      } ) );
      const v = n( "X+cX" ),
        y = ( () => {
          function e( t, n, i, o ) {
            const r = this;
            this._computer = t, this._state = 0, this._hoverTime = e.HOVER_TIME, this._firstWaitScheduler = new v.c( ( () => {
              return r._triggerAsyncComputation()
            } ), 0 ), this._secondWaitScheduler = new v.c( ( () => {
              return r._triggerSyncComputation()
            } ), 0 ), this._loadingMessageScheduler = new v.c( ( () => {
              return r._showLoadingMessage()
            } ), 0 ), this._asyncComputationPromise = null, this._asyncComputationPromiseDone = !1, this._completeCallback = n, this._errorCallback = i, this._progressCallback = o
          }
          return e.prototype.setHoverTime = function ( e ) {
            this._hoverTime = e
          }, e.prototype._firstWaitTime = function () {
            return this._hoverTime / 2
          }, e.prototype._secondWaitTime = function () {
            return this._hoverTime / 2
          }, e.prototype._loadingMessageTime = function () {
            return 3 * this._hoverTime
          }, e.prototype._triggerAsyncComputation = function () {
            const e = this;
            this._state = 2, this._secondWaitScheduler.schedule( this._secondWaitTime() ), this._computer.computeAsync ? ( this._asyncComputationPromiseDone = !1, this._asyncComputationPromise = Object( v.i )( ( t => {
              return e._computer.computeAsync( t )
            } ) ), this._asyncComputationPromise.then( ( t => {
              e._asyncComputationPromiseDone = !0, e._withAsyncResult( t )
            } ), ( t => {
              return e._onError( t )
            } ) ) ) : this._asyncComputationPromiseDone = !0
          }, e.prototype._triggerSyncComputation = function () {
            this._computer.computeSync && this._computer.onResult( this._computer.computeSync(), !0 ), this._asyncComputationPromiseDone ? ( this._state = 0, this._onComplete( this._computer.getResult() ) ) : ( this._state = 3, this._onProgress( this._computer.getResult() ) )
          }, e.prototype._showLoadingMessage = function () {
            3 === this._state && this._onProgress( this._computer.getResultWithLoadingMessage() )
          }, e.prototype._withAsyncResult = function ( e ) {
            e && this._computer.onResult( e, !1 ), 3 === this._state && ( this._state = 0, this._onComplete( this._computer.getResult() ) )
          }, e.prototype._onComplete = function ( e ) {
            this._completeCallback && this._completeCallback( e )
          }, e.prototype._onError = function ( e ) {
            this._errorCallback ? this._errorCallback( e ) : Object( g.e )( e )
          }, e.prototype._onProgress = function ( e ) {
            this._progressCallback && this._progressCallback( e )
          }, e.prototype.start = function ( e ) {
            if ( 0 === e ) 0 === this._state && ( this._state = 1, this._firstWaitScheduler.schedule( this._firstWaitTime() ), this._loadingMessageScheduler.schedule( this._loadingMessageTime() ) );
            else switch ( this._state ) {
              case 0:
                this._triggerAsyncComputation(), this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
                break;
              case 2:
                this._secondWaitScheduler.cancel(), this._triggerSyncComputation()
            }
          }, e.prototype.cancel = function () {
            this._loadingMessageScheduler.cancel(), 1 === this._state && this._firstWaitScheduler.cancel(), 2 === this._state && ( this._secondWaitScheduler.cancel(), this._asyncComputationPromise && ( this._asyncComputationPromise.cancel(), this._asyncComputationPromise = null ) ), 3 === this._state && this._asyncComputationPromise && ( this._asyncComputationPromise.cancel(), this._asyncComputationPromise = null ), this._state = 0
          }, e.HOVER_TIME = 300, e;
        } )(),
        b = n( "G300" ),
        C = n( "GJhM" ),
        w = n( "pmY6" ),
        S = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        O = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            return i.disposables = [], i.allowEditorOverflow = !0, i._id = t, i._editor = n, i._isVisible = !1, i._containerDomNode = document.createElement( "div" ), i._containerDomNode.className = "monaco-editor-hover hidden", i._containerDomNode.tabIndex = 0, i._domNode = document.createElement( "div" ), i._domNode.className = "monaco-editor-hover-content", i.scrollbar = new C.a( i._domNode, {} ), i.disposables.push( i.scrollbar ), i._containerDomNode.appendChild( i.scrollbar.getDomNode() ), i.onkeydown( i._containerDomNode, ( e => {
              e.equals( 9 ) && i.hide()
            } ) ), i._register( i._editor.onDidChangeConfiguration( ( e => {
              e.fontInfo && i.updateFont()
            } ) ) ), i._editor.onDidLayoutChange( ( e => {
              return i.updateMaxHeight()
            } ) ), i.updateMaxHeight(), i._editor.addContentWidget( i ), i._showAtPosition = null, i;
          }
          return S( t, e ), Object.defineProperty( t.prototype, "isVisible", {
            get() {
              return this._isVisible
            },
            set( e ) {
              this._isVisible = e, Object( d.N )( this._containerDomNode, "hidden", !this._isVisible )
            },
            enumerable: !0,
            configurable: !0
          } ), t.prototype.getId = function () {
            return this._id
          }, t.prototype.getDomNode = function () {
            return this._containerDomNode
          }, t.prototype.showAt = function ( e, t ) {
            this._showAtPosition = new h.a( e.lineNumber, e.column ), this.isVisible = !0, this._editor.layoutContentWidget( this ), this._editor.render(), this._stoleFocus = t, t && this._containerDomNode.focus()
          }, t.prototype.hide = function () {
            this.isVisible && ( this.isVisible = !1, this._editor.layoutContentWidget( this ), this._stoleFocus && this._editor.focus() )
          }, t.prototype.getPosition = function () {
            return this.isVisible ? {
              position: this._showAtPosition,
              preference: [ c.a.ABOVE, c.a.BELOW ]
            } : null
          }, t.prototype.dispose = function () {
            this._editor.removeContentWidget( this ), this.disposables = Object( w.d )( this.disposables ), e.prototype.dispose.call( this )
          }, t.prototype.updateFont = function () {
            const e = this;
            Array.prototype.slice.call( this._domNode.getElementsByClassName( "code" ) ).forEach( ( t => {
              return e._editor.applyFontInfo( t )
            } ) )
          }, t.prototype.updateContents = function ( e ) {
            this._domNode.textContent = "", this._domNode.appendChild( e ), this.updateFont(), this._editor.layoutContentWidget( this ), this.onContentsChange()
          }, t.prototype.onContentsChange = function () {
            this.scrollbar.scanDomNode()
          }, t.prototype.updateMaxHeight = function () {
            const e = Math.max( this._editor.getLayoutInfo().height / 4, 250 ),
              t = this._editor.getConfiguration().fontInfo,
              n = t.fontSize,
              i = t.lineHeight;
            this._domNode.style.fontSize = n + "px", this._domNode.style.lineHeight = i + "px", this._domNode.style.maxHeight = e + "px"
          }, t;
        } )( b.a ),
        L = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            return i._id = t, i._editor = n, i._isVisible = !1, i._domNode = document.createElement( "div" ), i._domNode.className = "monaco-editor-hover hidden", i._domNode.setAttribute( "aria-hidden", "true" ), i._domNode.setAttribute( "role", "presentation" ), i._showAtLineNumber = -1, i._register( i._editor.onDidChangeConfiguration( ( e => {
              e.fontInfo && i.updateFont()
            } ) ) ), i._editor.addOverlayWidget( i ), i;
          }
          return S( t, e ), Object.defineProperty( t.prototype, "isVisible", {
            get() {
              return this._isVisible
            },
            set( e ) {
              this._isVisible = e, Object( d.N )( this._domNode, "hidden", !this._isVisible )
            },
            enumerable: !0,
            configurable: !0
          } ), t.prototype.getId = function () {
            return this._id
          }, t.prototype.getDomNode = function () {
            return this._domNode
          }, t.prototype.showAt = function ( e ) {
            this._showAtLineNumber = e, this.isVisible || ( this.isVisible = !0 );
            const t = this._editor.getLayoutInfo(),
              n = this._editor.getTopForLineNumber( this._showAtLineNumber ),
              i = this._editor.getScrollTop(),
              o = this._editor.getConfiguration().lineHeight,
              r = n - i - ( this._domNode.clientHeight - o ) / 2;
            this._domNode.style.left = t.glyphMarginLeft + t.glyphMarginWidth + "px", this._domNode.style.top = Math.max( Math.round( r ), 0 ) + "px"
          }, t.prototype.hide = function () {
            this.isVisible && ( this.isVisible = !1 )
          }, t.prototype.getPosition = () => {
            return null
          }, t.prototype.dispose = function () {
            this._editor.removeOverlayWidget( this ), e.prototype.dispose.call( this )
          }, t.prototype.updateFont = function () {
            const e = this,
              t = Array.prototype.slice.call( this._domNode.getElementsByTagName( "code" ) ),
              n = Array.prototype.slice.call( this._domNode.getElementsByClassName( "code" ) );
            t.concat( n ).forEach( ( t => {
              return e._editor.applyFontInfo( t )
            } ) )
          }, t.prototype.updateContents = function ( e ) {
            this._domNode.textContent = "", this._domNode.appendChild( e ), this.updateFont()
          }, t;
        } )( b.a ),
        x = n( "eLzo" ),
        N = n( "tX9W" ),
        E = n( "MI8n" ),
        k = ( () => {
          function e( e, t, n ) {
            this.presentationIndex = n, this._onColorFlushed = new E.a, this.onColorFlushed = this._onColorFlushed.event, this._onDidChangeColor = new E.a, this.onDidChangeColor = this._onDidChangeColor.event, this._onDidChangePresentation = new E.a, this.onDidChangePresentation = this._onDidChangePresentation.event, this.originalColor = e, this._color = e, this._colorPresentations = t
          }
          return Object.defineProperty( e.prototype, "color", {
            get() {
              return this._color
            },
            set( e ) {
              this._color.equals( e ) || ( this._color = e, this._onDidChangeColor.fire( e ) )
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "presentation", {
            get() {
              return this.colorPresentations[ this.presentationIndex ]
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "colorPresentations", {
            get() {
              return this._colorPresentations
            },
            set( e ) {
              this._colorPresentations = e, this.presentationIndex > e.length - 1 && ( this.presentationIndex = 0 ), this._onDidChangePresentation.fire( this.presentation )
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.selectNextColorPresentation = function () {
            this.presentationIndex = ( this.presentationIndex + 1 ) % this.colorPresentations.length, this.flushColor(), this._onDidChangePresentation.fire( this.presentation )
          }, e.prototype.guessColorPresentation = function ( e, t ) {
            for ( let n = 0; n < this.colorPresentations.length; n++ )
              if ( t === this.colorPresentations[ n ].label ) {
                this.presentationIndex = n, this._onDidChangePresentation.fire( this.presentation );
                break
              }
          }, e.prototype.flushColor = function () {
            this._onColorFlushed.fire( this._color )
          }, e;
        } )(),
        I = ( n( "EPS+" ), n( "D3Dy" ) ),
        D = n( "AKMP" ),
        M = n( "zrhQ" ),
        T = n( "MD5Z" ),
        R = n( "t9D7" ),
        P = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        A = d.a,
        F = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            o.model = n, o.domNode = A( ".colorpicker-header" ), d.k( t, o.domNode ), o.pickedColorNode = d.k( o.domNode, A( ".picked-color" ) );
            const r = d.k( o.domNode, A( ".original-color" ) );
            return r.style.backgroundColor = M.a.Format.CSS.format( o.model.originalColor ), o.backgroundColor = i.getTheme().getColor( T.v ) || M.a.white, o._register( Object( R.e )( ( ( e, t ) => {
              o.backgroundColor = e.getColor( T.v ) || M.a.white
            } ) ) ), o._register( d.g( o.pickedColorNode, d.d.CLICK, ( () => {
              return o.model.selectNextColorPresentation()
            } ) ) ), o._register( d.g( r, d.d.CLICK, ( () => {
              o.model.color = o.model.originalColor, o.model.flushColor()
            } ) ) ), o._register( n.onDidChangeColor( o.onDidChangeColor, o ) ), o._register( n.onDidChangePresentation( o.onDidChangePresentation, o ) ), o.pickedColorNode.style.backgroundColor = M.a.Format.CSS.format( n.color ), d.N( o.pickedColorNode, "light", n.color.rgba.a < .5 ? o.backgroundColor.isLighter() : n.color.isLighter() ), o;
          }
          return P( t, e ), t.prototype.onDidChangeColor = function ( e ) {
            this.pickedColorNode.style.backgroundColor = M.a.Format.CSS.format( e ), d.N( this.pickedColorNode, "light", e.rgba.a < .5 ? this.backgroundColor.isLighter() : e.isLighter() ), this.onDidChangePresentation()
          }, t.prototype.onDidChangePresentation = function () {
            this.pickedColorNode.textContent = this.model.presentation ? this.model.presentation.label : ""
          }, t
        } )( w.a ),
        W = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            return o.model = n, o.pixelRatio = i, o.domNode = A( ".colorpicker-body" ), d.k( t, o.domNode ), o.saturationBox = new j( o.domNode, o.model, o.pixelRatio ), o._register( o.saturationBox ), o._register( o.saturationBox.onDidChange( o.onDidSaturationValueChange, o ) ), o._register( o.saturationBox.onColorFlushed( o.flushColor, o ) ), o.opacityStrip = new B( o.domNode, o.model ), o._register( o.opacityStrip ), o._register( o.opacityStrip.onDidChange( o.onDidOpacityChange, o ) ), o._register( o.opacityStrip.onColorFlushed( o.flushColor, o ) ), o.hueStrip = new H( o.domNode, o.model ), o._register( o.hueStrip ), o._register( o.hueStrip.onDidChange( o.onDidHueChange, o ) ), o._register( o.hueStrip.onColorFlushed( o.flushColor, o ) ), o
          }
          return P( t, e ), t.prototype.flushColor = function () {
            this.model.flushColor()
          }, t.prototype.onDidSaturationValueChange = function ( e ) {
            const t = e.s,
              n = e.v,
              i = this.model.color.hsva;
            this.model.color = new M.a( new M.b( i.h, t, n, i.a ) )
          }, t.prototype.onDidOpacityChange = function ( e ) {
            const t = this.model.color.hsva;
            this.model.color = new M.a( new M.b( t.h, t.s, t.v, e ) )
          }, t.prototype.onDidHueChange = function ( e ) {
            const t = this.model.color.hsva,
              n = 360 * ( 1 - e );
            this.model.color = new M.a( new M.b( 360 === n ? 0 : n, t.s, t.v, t.a ) )
          }, t.prototype.layout = function () {
            this.saturationBox.layout(), this.opacityStrip.layout(), this.hueStrip.layout()
          }, t;
        } )( w.a ),
        j = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            return o.model = n, o.pixelRatio = i, o._onDidChange = new E.a, o.onDidChange = o._onDidChange.event, o._onColorFlushed = new E.a, o.onColorFlushed = o._onColorFlushed.event, o.domNode = A( ".saturation-wrap" ), d.k( t, o.domNode ), o.canvas = document.createElement( "canvas" ), o.canvas.className = "saturation-box", d.k( o.domNode, o.canvas ), o.selection = A( ".saturation-selection" ), d.k( o.domNode, o.selection ), o.layout(), o._register( d.g( o.domNode, d.d.MOUSE_DOWN, ( e => {
              return o.onMouseDown( e )
            } ) ) ), o._register( o.model.onDidChangeColor( o.onDidChangeColor, o ) ), o.monitor = null, o;
          }
          return P( t, e ), t.prototype.onMouseDown = function ( e ) {
            const t = this;
            this.monitor = this._register( new D.a );
            const n = d.u( this.domNode );
            e.target !== this.selection && this.onDidChangePosition( e.offsetX, e.offsetY ), this.monitor.startMonitoring( D.b, ( e => {
              return t.onDidChangePosition( e.posx - n.left, e.posy - n.top )
            } ), ( () => {
              return null
            } ) );
            const i = d.g( document, d.d.MOUSE_UP, ( () => {
              t._onColorFlushed.fire(), i.dispose(), t.monitor.stopMonitoring( !0 ), t.monitor = null
            } ), !0 );
          }, t.prototype.onDidChangePosition = function ( e, t ) {
            const n = Math.max( 0, Math.min( 1, e / this.width ) ),
              i = Math.max( 0, Math.min( 1, 1 - t / this.height ) );
            this.paintSelection( n, i ), this._onDidChange.fire( {
              s: n,
              v: i
            } )
          }, t.prototype.layout = function () {
            this.width = this.domNode.offsetWidth, this.height = this.domNode.offsetHeight, this.canvas.width = this.width * this.pixelRatio, this.canvas.height = this.height * this.pixelRatio, this.paint();
            const e = this.model.color.hsva;
            this.paintSelection( e.s, e.v )
          }, t.prototype.paint = function () {
            const e = this.model.color.hsva,
              t = new M.a( new M.b( e.h, 1, 1, 1 ) ),
              n = this.canvas.getContext( "2d" ),
              i = n.createLinearGradient( 0, 0, this.canvas.width, 0 );
            i.addColorStop( 0, "rgba(255, 255, 255, 1)" ), i.addColorStop( .5, "rgba(255, 255, 255, 0.5)" ), i.addColorStop( 1, "rgba(255, 255, 255, 0)" );
            const o = n.createLinearGradient( 0, 0, 0, this.canvas.height );
            o.addColorStop( 0, "rgba(0, 0, 0, 0)" ), o.addColorStop( 1, "rgba(0, 0, 0, 1)" ), n.rect( 0, 0, this.canvas.width, this.canvas.height ), n.fillStyle = M.a.Format.CSS.format( t ), n.fill(), n.fillStyle = i, n.fill(), n.fillStyle = o, n.fill()
          }, t.prototype.paintSelection = function ( e, t ) {
            this.selection.style.left = e * this.width + "px", this.selection.style.top = this.height - t * this.height + "px"
          }, t.prototype.onDidChangeColor = function () {
            this.monitor && this.monitor.isMonitoring() || this.paint()
          }, t;
        } )( w.a ),
        V = ( e => {
          function t( t, n ) {
            const i = e.call( this ) || this;
            return i.model = n, i._onDidChange = new E.a, i.onDidChange = i._onDidChange.event, i._onColorFlushed = new E.a, i.onColorFlushed = i._onColorFlushed.event, i.domNode = d.k( t, A( ".strip" ) ), i.overlay = d.k( i.domNode, A( ".overlay" ) ), i.slider = d.k( i.domNode, A( ".slider" ) ), i.slider.style.top = "0px", i._register( d.g( i.domNode, d.d.MOUSE_DOWN, ( e => {
              return i.onMouseDown( e )
            } ) ) ), i.layout(), i;
          }
          return P( t, e ), t.prototype.layout = function () {
            this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
            const e = this.getValue( this.model.color );
            this.updateSliderPosition( e )
          }, t.prototype.onMouseDown = function ( e ) {
            const t = this,
              n = this._register( new D.a ),
              i = d.u( this.domNode );
            d.f( this.domNode, "grabbing" ), e.target !== this.slider && this.onDidChangeTop( e.offsetY ), n.startMonitoring( D.b, ( e => {
              return t.onDidChangeTop( e.posy - i.top )
            } ), ( () => {
              return null
            } ) );
            const o = d.g( document, d.d.MOUSE_UP, ( () => {
              t._onColorFlushed.fire(), o.dispose(), n.stopMonitoring( !0 ), d.G( t.domNode, "grabbing" )
            } ), !0 );
          }, t.prototype.onDidChangeTop = function ( e ) {
            const t = Math.max( 0, Math.min( 1, 1 - e / this.height ) );
            this.updateSliderPosition( t ), this._onDidChange.fire( t )
          }, t.prototype.updateSliderPosition = function ( e ) {
            this.slider.style.top = ( 1 - e ) * this.height + "px"
          }, t;
        } )( w.a ),
        B = ( e => {
          function t( t, n ) {
            const i = e.call( this, t, n ) || this;
            return d.f( i.domNode, "opacity-strip" ), i._register( n.onDidChangeColor( i.onDidChangeColor, i ) ), i.onDidChangeColor( i.model.color ), i
          }
          return P( t, e ), t.prototype.onDidChangeColor = function ( e ) {
            const t = e.rgba,
              n = t.r,
              i = t.g,
              o = t.b,
              r = new M.a( new M.c( n, i, o, 1 ) ),
              s = new M.a( new M.c( n, i, o, 0 ) );
            this.overlay.style.background = "linear-gradient(to bottom, " + r + " 0%, " + s + " 100%)"
          }, t.prototype.getValue = e => {
            return e.hsva.a
          }, t;
        } )( V ),
        H = ( e => {
          function t( t, n ) {
            const i = e.call( this, t, n ) || this;
            return d.f( i.domNode, "hue-strip" ), i
          }
          return P( t, e ), t.prototype.getValue = e => {
            return 1 - e.hsva.h / 360
          }, t;
        } )( V ),
        z = ( e => {
          function t( t, n, i, o ) {
            const r = e.call( this ) || this;
            r.model = n, r.pixelRatio = i, r._register( Object( I.p )( ( () => {
              return r.layout()
            } ) ) );
            const s = A( ".colorpicker-widget" );
            t.appendChild( s );
            const a = new F( s, r.model, o );
            return r.body = new W( s, r.model, r.pixelRatio ), r._register( a ), r._register( r.body ), r
          }
          return P( t, e ), t.prototype.layout = function () {
            this.body.layout()
          }, t
        } )( b.a ),
        U = n( "kqbb" ),
        K = n( "ZIMw" ),
        q = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        G = d.a,
        Y = function ( e, t, n ) {
          this.range = e, this.color = t, this.provider = n
        },
        X = ( () => {
          function e( e ) {
            this._editor = e, this._range = null
          }
          return e.prototype.setRange = function ( e ) {
            this._range = e, this._result = []
          }, e.prototype.clearResult = function () {
            this._result = []
          }, e.prototype.computeAsync = function ( e ) {
            const t = this._editor.getModel();
            return p.m.has( t ) ? _( t, new h.a( this._range.startLineNumber, this._range.startColumn ), e ) : Promise.resolve( null )
          }, e.prototype.computeSync = function () {
            const e = this,
              t = this._range.startLineNumber;
            if ( t > this._editor.getModel().getLineCount() ) return [];
            const n = U.ColorDetector.get( this._editor );
            const i = this._editor.getModel().getLineMaxColumn( t );
            const o = this._editor.getLineDecorations( t );
            let r = !1;
            return o.map( ( o => {
              const s = o.range.startLineNumber === t ? o.range.startColumn : 1,
                a = o.range.endLineNumber === t ? o.range.endColumn : i;
              if ( s > e._range.startColumn || e._range.endColumn > a ) return null;
              const l = new u.a( e._range.startLineNumber, s, e._range.startLineNumber, a ),
                c = n.getColorData( o.range.getStartPosition() );
              if ( !r && c ) {
                r = !0;
                const d = c.colorInfo,
                  h = d.color,
                  p = d.range;
                return new Y( p, h, c.provider )
              }
              if ( Object( x.b )( o.options.hoverMessage ) ) return null;
              let f = void 0;
              return o.options.hoverMessage && ( f = Array.isArray( o.options.hoverMessage ) ? o.options.hoverMessage.slice() : [ o.options.hoverMessage ] ), {
                contents: f,
                range: l
              }
            } ) ).filter( ( e => {
              return !!e
            } ) );
          }, e.prototype.onResult = function ( e, t ) {
            this._result = t ? e.concat( this._result.sort( ( ( e, t ) => {
              return e instanceof Y ? -1 : t instanceof Y ? 1 : 0
            } ) ) ) : this._result.concat( e )
          }, e.prototype.getResult = function () {
            return this._result.slice( 0 )
          }, e.prototype.getResultWithLoadingMessage = function () {
            return this._result.slice( 0 ).concat( [ this._getLoadingMessage() ] )
          }, e.prototype._getLoadingMessage = function () {
            return {
              range: this._range,
              contents: [ ( new x.a ).appendText( i.a( "modesContentHover.loading", "Loading..." ) ) ]
            }
          }, e;
        } )(),
        $ = ( e => {
          function t( n, i, o ) {
            const r = e.call( this, t.ID, n ) || this;
            return r._themeService = o, r.renderDisposable = w.a.None, r._computer = new X( r._editor ), r._highlightDecorations = [], r._isChangingDecorations = !1, r._markdownRenderer = i, r._register( i.onDidRenderCodeBlock( r.onContentsChange, r ) ), r._hoverOperation = new y( r._computer, ( e => {
              return r._withResult( e, !0 )
            } ), null, ( e => {
              return r._withResult( e, !1 )
            } ) ), r._register( d.j( r.getDomNode(), d.d.FOCUS, ( () => {
              r._colorPicker && d.f( r.getDomNode(), "colorpicker-hover" )
            } ) ) ), r._register( d.j( r.getDomNode(), d.d.BLUR, ( () => {
              d.G( r.getDomNode(), "colorpicker-hover" )
            } ) ) ), r._register( n.onDidChangeConfiguration( ( e => {
              r._hoverOperation.setHoverTime( r._editor.getConfiguration().contribInfo.hover.delay )
            } ) ) ), r;
          }
          return q( t, e ), t.prototype.dispose = function () {
            this.renderDisposable.dispose(), this.renderDisposable = w.a.None, this._hoverOperation.cancel(), e.prototype.dispose.call( this )
          }, t.prototype.onModelDecorationsChanged = function () {
            this._isChangingDecorations || this.isVisible && ( this._hoverOperation.cancel(), this._computer.clearResult(), this._colorPicker || this._hoverOperation.start( 0 ) )
          }, t.prototype.startShowingAt = function ( e, t, n ) {
            if ( !this._lastRange || !this._lastRange.equalsRange( e ) ) {
              if ( this._hoverOperation.cancel(), this.isVisible )
                if ( this._showAtPosition.lineNumber !== e.startLineNumber ) this.hide();
                else {
                  for ( var i = [], o = 0, r = this._messages.length; o < r; o++ ) {
                    const s = this._messages[ o ],
                      a = s.range;
                    a.startColumn <= e.startColumn && a.endColumn >= e.endColumn && i.push( s )
                  }
                  if ( i.length > 0 ) {
                    if ( ( ( e, t ) => {
                        if ( !e && t || e && !t || e.length !== t.length ) return !1;
                        for ( let n = 0; n < e.length; n++ ) {
                          const i = e[ n ],
                            o = t[ n ];
                          if ( i instanceof Y ) return !1;
                          if ( o instanceof Y ) return !1;
                          if ( !Object( x.c )( i.contents, o.contents ) ) return !1
                        }
                        return !0
                      } )( i, this._messages ) )
                      return;
                    this._renderMessages( e, i )
                  } else this.hide()
                } this._lastRange = e, this._computer.setRange( e ), this._shouldFocus = n, this._hoverOperation.start( t )
            }
          }, t.prototype.hide = function () {
            this._lastRange = null, this._hoverOperation.cancel(), e.prototype.hide.call( this ), this._isChangingDecorations = !0, this._highlightDecorations = this._editor.deltaDecorations( this._highlightDecorations, [] ), this._isChangingDecorations = !1, this.renderDisposable.dispose(), this.renderDisposable = w.a.None, this._colorPicker = null
          }, t.prototype.isColorPickerVisible = function () {
            return !!this._colorPicker
          }, t.prototype._withResult = function ( e, t ) {
            this._messages = e, this._lastRange && this._messages.length > 0 ? this._renderMessages( this._lastRange, this._messages ) : t && this.hide()
          }, t.prototype._renderMessages = function ( e, n ) {
            const i = this;
            this.renderDisposable.dispose(), this._colorPicker = null;
            let o;
            let r = Number.MAX_VALUE;
            let s = n[ 0 ].range;
            const a = document.createDocumentFragment();
            let l = !0;
            let c = !1;
            n.forEach( ( t => {
              if ( t.range )
                if ( r = Math.min( r, t.range.startColumn ), s = u.a.plusRange( s, t.range ), t instanceof Y ) {
                  c = !0;
                  const n = t.color;
                  const d = n.red;
                  const p = n.green;
                  const f = n.blue;
                  const g = n.alpha;
                  const _ = new M.c( 255 * d, 255 * p, 255 * f, g );
                  const v = new M.a( _ );
                  const y = i._editor.getModel();
                  let b = new u.a( t.range.startLineNumber, t.range.startColumn, t.range.endLineNumber, t.range.endColumn );
                  const C = {
                    range: t.range,
                    color: t.color
                  };
                  const S = new k( v, [], 0 );
                  const O = new z( a, S, i._editor.getConfiguration().pixelRatio, i._themeService );
                  Object( K.a )( y, C, t.provider, m.a.None ).then( ( n => {
                    S.colorPresentations = n;
                    const s = i._editor.getModel().getValueInRange( t.range );
                    S.guessColorPresentation( v, s );
                    const l = () => {
                        let e, t;
                        S.presentation.textEdit ? ( e = [ S.presentation.textEdit ], t = ( t = new u.a( S.presentation.textEdit.range.startLineNumber, S.presentation.textEdit.range.startColumn, S.presentation.textEdit.range.endLineNumber, S.presentation.textEdit.range.endColumn ) ).setEndPosition( t.endLineNumber, t.startColumn + S.presentation.textEdit.text.length ) ) : ( e = [ {
                          identifier: null,
                          range: b,
                          text: S.presentation.label,
                          forceMoveMarkers: !1
                        } ], t = b.setEndPosition( b.endLineNumber, b.startColumn + S.presentation.label.length ) ), i._editor.executeEdits( "colorpicker", e ), S.presentation.additionalTextEdits && ( e = S.presentation.additionalTextEdits.slice(), i._editor.executeEdits( "colorpicker", e ), i.hide() ), i._editor.pushUndoStop(), b = t
                      },
                      c = e => {
                        return Object( K.a )( y, {
                          range: b,
                          color: {
                            red: e.rgba.r / 255,
                            green: e.rgba.g / 255,
                            blue: e.rgba.b / 255,
                            alpha: e.rgba.a
                          }
                        }, t.provider, m.a.None ).then( ( e => {
                          S.colorPresentations = e
                        } ) );
                      },
                      d = S.onColorFlushed( ( e => {
                        c( e ).then( l )
                      } ) ),
                      p = S.onDidChangeColor( c );
                    i._colorPicker = O, i.showAt( new h.a( e.startLineNumber, r ), i._shouldFocus ), i.updateContents( a ), i._colorPicker.layout(), i.renderDisposable = Object( w.c )( [ d, p, O, o ] )
                  } ) )
                } else t.contents.filter( ( e => {
                  return !Object( x.b )( e )
                } ) ).forEach( ( e => {
                  const t = i._markdownRenderer.render( e );
                  o = t, a.appendChild( G( "div.hover-row", null, t.element ) ), l = !1
                } ) )
            } ) ), c || l || ( this.showAt( new h.a( e.startLineNumber, r ), this._shouldFocus ), this.updateContents( a ) ), this._isChangingDecorations = !0, this._highlightDecorations = this._editor.deltaDecorations( this._highlightDecorations, [ {
              range: s,
              options: t._DECORATION_OPTIONS
            } ] ), this._isChangingDecorations = !1
          }, t.ID = "editor.contrib.modesContentHoverWidget", t._DECORATION_OPTIONS = N.a.register( {
            className: "hoverHighlight"
          } ), t;
        } )( O );
      const Z = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        Q = ( () => {
          function e( e ) {
            this._editor = e, this._lineNumber = -1
          }
          return e.prototype.setLineNumber = function ( e ) {
            this._lineNumber = e, this._result = []
          }, e.prototype.clearResult = function () {
            this._result = []
          }, e.prototype.computeSync = function () {
            for ( var e = e => {
                return {
                  value: e
                }
              }, t = this._editor.getLineDecorations( this._lineNumber ), n = [], i = 0, o = t.length; i < o; i++ ) {
              const r = t[ i ];
              if ( r.options.glyphMarginClassName ) {
                const s = r.options.glyphMarginHoverMessage;
                Object( x.b )( s ) || ( Array.isArray( s ) ? n = n.concat( s.map( e ) ) : n.push( e( s ) ) )
              }
            }
            return n
          }, e.prototype.onResult = function ( e, t ) {
            this._result = this._result.concat( e )
          }, e.prototype.getResult = function () {
            return this._result
          }, e.prototype.getResultWithLoadingMessage = function () {
            return this.getResult()
          }, e;
        } )(),
        J = ( e => {
          function t( n, i ) {
            const o = e.call( this, t.ID, n ) || this;
            return o._lastLineNumber = -1, o._markdownRenderer = i, o._computer = new Q( o._editor ), o._hoverOperation = new y( o._computer, ( e => {
              return o._withResult( e )
            } ), null, ( e => {
              return o._withResult( e )
            } ) ), o;
          }
          return Z( t, e ), t.prototype.dispose = function () {
            this._renderDisposeables = Object( w.d )( this._renderDisposeables ), this._hoverOperation.cancel(), e.prototype.dispose.call( this )
          }, t.prototype.onModelDecorationsChanged = function () {
            this.isVisible && ( this._hoverOperation.cancel(), this._computer.clearResult(), this._hoverOperation.start( 0 ) )
          }, t.prototype.startShowingAt = function ( e ) {
            this._lastLineNumber !== e && ( this._hoverOperation.cancel(), this.hide(), this._lastLineNumber = e, this._computer.setLineNumber( e ), this._hoverOperation.start( 0 ) )
          }, t.prototype.hide = function () {
            this._lastLineNumber = -1, this._hoverOperation.cancel(), e.prototype.hide.call( this )
          }, t.prototype._withResult = function ( e ) {
            this._messages = e, this._messages.length > 0 ? this._renderMessages( this._lastLineNumber, this._messages ) : this.hide()
          }, t.prototype._renderMessages = function ( e, t ) {
            const n = this;
            Object( w.d )( this._renderDisposeables ), this._renderDisposeables = [];
            const i = document.createDocumentFragment();
            t.forEach( ( e => {
              const t = n._markdownRenderer.render( e.value );
              n._renderDisposeables.push( t ), i.appendChild( Object( d.a )( "div.hover-row", null, t.element ) )
            } ) ), this.updateContents( i ), this.showAt( e )
          }, t.ID = "editor.contrib.modesGlyphHoverWidget", t;
        } )( L ),
        ee = n( "wQH0" ),
        te = n( "3qCu" );
      n.d( t, "ModesHoverController", ( () => {
        return re
      } ) );
      const ne = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const ie = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const oe = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };

      var re = ( () => {
        function e( e, t, n, i ) {
          const o = this;
          this._editor = e, this._openerService = t, this._modeService = n, this._themeService = i, this._toUnhook = [], this._isMouseDown = !1, this._hoverClicked = !1, this._hookEvents(), this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration( ( e => {
            e.contribInfo && ( o._hideWidgets(), o._unhookEvents(), o._hookEvents() )
          } ) )
        }
        return Object.defineProperty( e.prototype, "contentWidget", {
          get() {
            return this._contentWidget || this._createHoverWidget(), this._contentWidget
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "glyphWidget", {
          get() {
            return this._glyphWidget || this._createHoverWidget(), this._glyphWidget
          },
          enumerable: !0,
          configurable: !0
        } ), e.get = t => {
          return t.getContribution( e.ID )
        }, e.prototype._hookEvents = function () {
          const e = this,
            t = () => {
              return e._hideWidgets()
            },
            n = this._editor.getConfiguration().contribInfo.hover;
          this._isHoverEnabled = n.enabled, this._isHoverSticky = n.sticky, this._isHoverEnabled ? ( this._toUnhook.push( this._editor.onMouseDown( ( t => {
            return e._onEditorMouseDown( t )
          } ) ) ), this._toUnhook.push( this._editor.onMouseUp( ( t => {
            return e._onEditorMouseUp( t )
          } ) ) ), this._toUnhook.push( this._editor.onMouseMove( ( t => {
            return e._onEditorMouseMove( t )
          } ) ) ), this._toUnhook.push( this._editor.onKeyDown( ( t => {
            return e._onKeyDown( t )
          } ) ) ), this._toUnhook.push( this._editor.onDidChangeModelDecorations( ( () => {
            return e._onModelDecorationsChanged()
          } ) ) ) ) : this._toUnhook.push( this._editor.onMouseMove( t ) ), this._toUnhook.push( this._editor.onMouseLeave( t ) ), this._toUnhook.push( this._editor.onDidChangeModel( t ) ), this._toUnhook.push( this._editor.onDidScrollChange( ( t => {
            return e._onEditorScrollChanged( t )
          } ) ) )
        }, e.prototype._unhookEvents = function () {
          this._toUnhook = Object( w.d )( this._toUnhook )
        }, e.prototype._onModelDecorationsChanged = function () {
          this.contentWidget.onModelDecorationsChanged(), this.glyphWidget.onModelDecorationsChanged()
        }, e.prototype._onEditorScrollChanged = function ( e ) {
          ( e.scrollTopChanged || e.scrollLeftChanged ) && this._hideWidgets()
        }, e.prototype._onEditorMouseDown = function ( e ) {
          this._isMouseDown = !0;
          const t = e.target.type;
          t !== c.b.CONTENT_WIDGET || e.target.detail !== $.ID ? t === c.b.OVERLAY_WIDGET && e.target.detail === J.ID || ( t !== c.b.OVERLAY_WIDGET && e.target.detail !== J.ID && ( this._hoverClicked = !1 ), this._hideWidgets() ) : this._hoverClicked = !0
        }, e.prototype._onEditorMouseUp = function ( e ) {
          this._isMouseDown = !1
        }, e.prototype._onEditorMouseMove = function ( e ) {
          let t = e.target.type;
          const n = r.d ? e.event.metaKey : e.event.ctrlKey;
          if ( !( this._isMouseDown && this._hoverClicked && this.contentWidget.isColorPickerVisible() ) && ( !this._isHoverSticky || t !== c.b.CONTENT_WIDGET || e.target.detail !== $.ID || n ) && ( !this._isHoverSticky || t !== c.b.OVERLAY_WIDGET || e.target.detail !== J.ID || n ) ) {
            if ( t === c.b.CONTENT_EMPTY ) {
              const i = this._editor.getConfiguration().fontInfo.typicalHalfwidthCharacterWidth / 2,
                o = e.target.detail;
              o && !o.isAfterLines && "number" === typeof o.horizontalDistanceToText && o.horizontalDistanceToText < i && ( t = c.b.CONTENT_TEXT )
            }
            t === c.b.CONTENT_TEXT ? ( this.glyphWidget.hide(), this._isHoverEnabled && this.contentWidget.startShowingAt( e.target.range, 0, !1 ) ) : t === c.b.GUTTER_GLYPH_MARGIN ? ( this.contentWidget.hide(), this._isHoverEnabled && this.glyphWidget.startShowingAt( e.target.position.lineNumber ) ) : this._hideWidgets()
          }
        }, e.prototype._onKeyDown = function ( e ) {
          5 !== e.keyCode && 6 !== e.keyCode && 57 !== e.keyCode && this._hideWidgets()
        }, e.prototype._hideWidgets = function () {
          !this._contentWidget || this._isMouseDown && this._hoverClicked && this._contentWidget.isColorPickerVisible() || ( this._glyphWidget.hide(), this._contentWidget.hide() )
        }, e.prototype._createHoverWidget = function () {
          const e = new te.a( this._editor, this._modeService, this._openerService );
          this._contentWidget = new $( this._editor, e, this._themeService ), this._glyphWidget = new J( this._editor, e )
        }, e.prototype.showContentHover = function ( e, t, n ) {
          this.contentWidget.startShowingAt( e, t, n )
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.dispose = function () {
          this._unhookEvents(), this._didChangeConfigurationHandler.dispose(), this._glyphWidget && ( this._glyphWidget.dispose(), this._glyphWidget = null ), this._contentWidget && ( this._contentWidget.dispose(), this._contentWidget = null )
        }, e.ID = "editor.contrib.hover", e = ie( [ oe( 1, s.a ), oe( 2, a.a ), oe( 3, R.c ) ], e );
      } )();

      const se = ( e => {
        function t() {
          return e.call( this, {
            id: "editor.action.showHover",
            label: i.a( {
              key: "showHover",
              comment: [ "Label for action that will trigger the showing of a hover in the editor.", "This allows for users to show the hover without using the mouse." ]
            }, "Show Hover" ),
            alias: "Show Hover",
            precondition: null,
            kbOpts: {
              kbExpr: ee.a.editorTextFocus,
              primary: Object( o.a )( 2089, 2087 ),
              weight: 100
            }
          } ) || this
        }
        return ne( t, e ), t.prototype.run = ( e, t ) => {
          const n = re.get( t );
          if ( n ) {
            const i = t.getPosition(),
              o = new u.a( i.lineNumber, i.column, i.lineNumber, i.column );
            n.showContentHover( o, 1, !0 )
          }
        }, t;
      } )( l.b );
      Object( l.h )( re ), Object( l.f )( se ), Object( R.e )( ( ( e, t ) => {
        const n = e.getColor( T.x );
        n && t.addRule( ".monaco-editor .hoverHighlight { background-color: " + n + "; }" );
        const i = e.getColor( T.v );
        i && t.addRule( ".monaco-editor .monaco-editor-hover { background-color: " + i + "; }" );
        const o = e.getColor( T.w );
        o && ( t.addRule( ".monaco-editor .monaco-editor-hover { border: 1px solid " + o + "; }" ), t.addRule( ".monaco-editor .monaco-editor-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid " + o.transparent( .5 ) + "; }" ) );
        const r = e.getColor( T.qb );
        r && t.addRule( ".monaco-editor .monaco-editor-hover a { color: " + r + "; }" );
        const s = e.getColor( T.pb );
        s && t.addRule( ".monaco-editor .monaco-editor-hover code { background-color: " + s + "; }" )
      } ) )
    },
    rzPn( e, t, n ) {
      "use strict";
      n( "UsjR" );
      let i;
      const o = n( "3/fG" );
      const r = n( "VMIq" );
      const s = n( "MNsG" );
      const a = n( "746U" );
      const u = n( "/cxE" );
      const l = n( "ksmt" );
      const c = ( () => {
        function e( e ) {
          this.modelProvider = Object( a.e )( e.getModel ) ? e : {
            getModel() {
              return e
            }
          }
        }
        return e.prototype.getId = function ( e, t ) {
          if ( !t ) return null;
          const n = this.modelProvider.getModel();
          return n === t ? "__root__" : n.dataSource.getId( t )
        }, e.prototype.hasChildren = function ( e, t ) {
          const n = this.modelProvider.getModel();
          return n && n === t && n.entries.length > 0
        }, e.prototype.getChildren = function ( e, t ) {
          const n = this.modelProvider.getModel();
          return r.b.as( n === t ? n.entries : [] )
        }, e.prototype.getParent = ( e, t ) => {
          return r.b.as( null )
        }, e;
      } )();
      const d = ( () => {
        function e( e ) {
          this.modelProvider = e
        }
        return e.prototype.getAriaLabel = function ( e, t ) {
          const n = this.modelProvider.getModel();
          return n.accessibilityProvider && n.accessibilityProvider.getAriaLabel( t )
        }, e.prototype.getPosInSet = function ( e, t ) {
          const n = this.modelProvider.getModel();
          return String( n.entries.indexOf( t ) + 1 )
        }, e.prototype.getSetSize = function () {
          const e = this.modelProvider.getModel();
          return String( e.entries.length )
        }, e;
      } )();
      const h = ( () => {
        function e( e ) {
          this.modelProvider = e
        }
        return e.prototype.isVisible = function ( e, t ) {
          const n = this.modelProvider.getModel();
          return !n.filter || n.filter.isVisible( t )
        }, e;
      } )();
      const p = ( () => {
        function e( e, t ) {
          this.modelProvider = e, this.styles = t
        }
        return e.prototype.updateStyles = function ( e ) {
          this.styles = e
        }, e.prototype.getHeight = function ( e, t ) {
          return this.modelProvider.getModel().renderer.getHeight( t )
        }, e.prototype.getTemplateId = function ( e, t ) {
          return this.modelProvider.getModel().renderer.getTemplateId( t )
        }, e.prototype.renderTemplate = function ( e, t, n ) {
          return this.modelProvider.getModel().renderer.renderTemplate( t, n, this.styles )
        }, e.prototype.renderElement = function ( e, t, n, i ) {
          this.modelProvider.getModel().renderer.renderElement( t, n, i, this.styles )
        }, e.prototype.disposeTemplate = function ( e, t, n ) {
          this.modelProvider.getModel().renderer.disposeTemplate( t, n )
        }, e
      } )();
      const f = n( "lCHf" );
      const g = n( "0+8E" );
      const m = n( "6rrl" );
      const _ = ( n( "HyZH" ), n( "EffR" ) );
      const v = n( "pmY6" );
      const y = n( "zrhQ" );
      const b = n( "qj0h" );
      const C = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const w = {
        progressBarBackground: y.a.fromHex( "#0E70C0" )
      };
      const S = ( e => {
        function t( t, n ) {
          const i = e.call( this ) || this;
          return i.options = n || Object.create( null ), Object( b.g )( i.options, w, !1 ), i.workedVal = 0, i.progressBarBackground = i.options.progressBarBackground, i.create( t ), i
        }
        return C( t, e ), t.prototype.create = function ( e ) {
          const t = this;
          Object( f.a )( e ).div( {
            class: "monaco-progress-container"
          }, ( e => {
            t.element = e.clone(), e.div( {
              class: "progress-bit"
            } ).on( [ _.d.ANIMATION_START, _.d.ANIMATION_END, _.d.ANIMATION_ITERATION ], ( e => {
              switch ( e.type ) {
                case _.d.ANIMATION_ITERATION:
                  t.animationStopToken && t.animationStopToken( null )
              }
            } ), t.toDispose ), t.bit = e.getHTMLElement()
          } ) ), this.applyStyles()
        }, t.prototype.off = function () {
          this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.removeClass( "active" ), this.element.removeClass( "infinite" ), this.element.removeClass( "discrete" ), this.workedVal = 0, this.totalWork = void 0
        }, t.prototype.stop = function () {
          return this.doDone( !1 )
        }, t.prototype.doDone = function ( e ) {
          const t = this;
          return this.element.addClass( "done" ), this.element.hasClass( "infinite" ) ? ( this.bit.style.opacity = "0", e ? r.b.timeout( 200 ).then( ( () => {
            return t.off()
          } ) ) : this.off() ) : ( this.bit.style.width = "inherit", e ? r.b.timeout( 200 ).then( ( () => {
            return t.off()
          } ) ) : this.off() ), this;
        }, t.prototype.hide = function () {
          this.element.hide()
        }, t.prototype.style = function ( e ) {
          this.progressBarBackground = e.progressBarBackground, this.applyStyles()
        }, t.prototype.applyStyles = function () {
          if ( this.bit ) {
            const e = this.progressBarBackground ? this.progressBarBackground.toString() : null;
            this.bit.style.backgroundColor = e
          }
        }, t;
      } )( v.a );
      const O = n( "uDWl" );
      const L = n( "X8W9" );
      const x = n( "QuOb" );
      const N = n( "XSiN" );
      const E = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const k = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return E( t, e ), t.prototype.onContextMenu = function ( t, n, i ) {
          return s.d ? this.onLeftClick( t, n, i ) : e.prototype.onContextMenu.call( this, t, n, i )
        }, t
      } )( L.c );
      !( e => {
        e[ e.ELEMENT_SELECTED = 0 ] = "ELEMENT_SELECTED", e[ e.FOCUS_LOST = 1 ] = "FOCUS_LOST", e[ e.CANCELED = 2 ] = "CANCELED"
      } )( i || ( i = {} ) );
      const I = {
          background: y.a.fromHex( "#1E1E1E" ),
          foreground: y.a.fromHex( "#CCCCCC" ),
          pickerGroupForeground: y.a.fromHex( "#0097FB" ),
          pickerGroupBorder: y.a.fromHex( "#3F3F46" ),
          widgetShadow: y.a.fromHex( "#000000" ),
          progressBarBackground: y.a.fromHex( "#0E70C0" )
        },
        D = o.a( "quickOpenAriaLabel", "Quick picker. Type to narrow down results." ),
        M = ( e => {
          function t( t, n, i ) {
            const o = e.call( this ) || this;
            return o.isDisposed = !1, o.container = t, o.callbacks = n, o.options = i, o.styles = i || Object.create( null ), Object( b.g )( o.styles, I, !1 ), o.model = null, o
          }
          return E( t, e ), t.prototype.getModel = function () {
            return this.model
          }, t.prototype.create = function () {
            const e = this;
            return this.builder = Object( f.a )().div( ( t => {
              t.on( _.d.KEY_DOWN, ( t => {
                const n = new O.a( t );
                if ( 9 === n.keyCode ) _.c.stop( t, !0 ), e.hide( i.CANCELED );
                else if ( 2 === n.keyCode && !n.altKey && !n.ctrlKey && !n.metaKey ) {
                  const o = t.currentTarget.querySelectorAll( "input, .monaco-tree, .monaco-tree-row.focused .action-label.icon" );
                  n.shiftKey && n.target === o[ 0 ] ? ( _.c.stop( t, !0 ), o[ o.length - 1 ].focus() ) : n.shiftKey || n.target !== o[ o.length - 1 ] || ( _.c.stop( t, !0 ), o[ 0 ].focus() )
                }
              } ) ).on( _.d.CONTEXT_MENU, ( e => {
                return _.c.stop( e, !0 )
              } ) ).on( _.d.FOCUS, ( t => {
                return e.gainingFocus()
              } ), null, !0 ).on( _.d.BLUR, ( t => {
                return e.loosingFocus( t )
              } ), null, !0 ), e.progressBar = e._register( new S( t.clone(), {
                progressBarBackground: e.styles.progressBarBackground
              } ) ), e.progressBar.hide(), t.div( {
                class: "quick-open-input"
              }, ( t => {
                e.inputContainer = t, e.inputBox = e._register( new g.b( t.getHTMLElement(), null, {
                  placeholder: e.options.inputPlaceHolder || "",
                  ariaLabel: D,
                  inputBackground: e.styles.inputBackground,
                  inputForeground: e.styles.inputForeground,
                  inputBorder: e.styles.inputBorder,
                  inputValidationInfoBackground: e.styles.inputValidationInfoBackground,
                  inputValidationInfoBorder: e.styles.inputValidationInfoBorder,
                  inputValidationWarningBackground: e.styles.inputValidationWarningBackground,
                  inputValidationWarningBorder: e.styles.inputValidationWarningBorder,
                  inputValidationErrorBackground: e.styles.inputValidationErrorBackground,
                  inputValidationErrorBorder: e.styles.inputValidationErrorBorder
                } ) ), e.inputElement = e.inputBox.inputElement, e.inputElement.setAttribute( "role", "combobox" ), e.inputElement.setAttribute( "aria-haspopup", "false" ), e.inputElement.setAttribute( "aria-autocomplete", "list" ), _.g( e.inputBox.inputElement, _.d.KEY_DOWN, ( t => {
                  const n = new O.a( t ),
                    i = e.shouldOpenInBackground( n );
                  if ( 2 !== n.keyCode )
                    if ( 18 === n.keyCode || 16 === n.keyCode || 12 === n.keyCode || 11 === n.keyCode ) _.c.stop( t, !0 ), e.navigateInTree( n.keyCode, n.shiftKey ), e.inputBox.inputElement.selectionStart === e.inputBox.inputElement.selectionEnd && ( e.inputBox.inputElement.selectionStart = e.inputBox.value.length );
                    else if ( 3 === n.keyCode || i ) {
                    _.c.stop( t, !0 );
                    const o = e.tree.getFocus();
                    o && e.elementSelected( o, t, i ? l.a.OPEN_IN_BACKGROUND : l.a.OPEN )
                  }
                } ) ), _.g( e.inputBox.inputElement, _.d.INPUT, ( t => {
                  e.onType()
                } ) )
              } ) ), e.resultCount = t.div( {
                class: "quick-open-result-count",
                "aria-live": "polite"
              } ).clone(), e.treeContainer = t.div( {
                class: "quick-open-tree"
              }, ( t => {
                const n = e.options.treeCreator || ( ( e, t, n ) => {
                  return new m.a( e, t, n )
                } );
                e.tree = e._register( n( t.getHTMLElement(), {
                  dataSource: new c( e ),
                  controller: new k( {
                    clickBehavior: L.a.ON_MOUSE_UP,
                    keyboardSupport: e.options.keyboardSupport
                  } ),
                  renderer: e.renderer = new p( e, e.styles ),
                  filter: new h( e ),
                  accessibilityProvider: new d( e )
                }, {
                  twistiePixels: 11,
                  indentPixels: 0,
                  alwaysFocused: !0,
                  verticalScrollMode: x.b.Visible,
                  horizontalScrollMode: x.b.Hidden,
                  ariaLabel: o.a( "treeAriaLabel", "Quick Picker" ),
                  keyboardSupport: e.options.keyboardSupport,
                  preventRootFocus: !1
                } ) ), e.treeElement = e.tree.getHTMLElement(), e._register( e.tree.onDidChangeFocus( ( t => {
                  e.elementFocused( t.focus, t )
                } ) ) ), e._register( e.tree.onDidChangeSelection( ( t => {
                  if ( t.selection && t.selection.length > 0 ) {
                    const n = t.payload && t.payload.originalEvent instanceof N.b ? t.payload.originalEvent : void 0,
                      i = !!n && e.shouldOpenInBackground( n );
                    e.elementSelected( t.selection[ 0 ], t, i ? l.a.OPEN_IN_BACKGROUND : l.a.OPEN )
                  }
                } ) ) )
              } ) ).on( _.d.KEY_DOWN, ( t => {
                const n = new O.a( t );
                e.quickNavigateConfiguration && ( 18 !== n.keyCode && 16 !== n.keyCode && 12 !== n.keyCode && 11 !== n.keyCode || ( _.c.stop( t, !0 ), e.navigateInTree( n.keyCode ) ) )
              } ) ).on( _.d.KEY_UP, ( t => {
                const n = new O.a( t ),
                  i = n.keyCode;
                if ( e.quickNavigateConfiguration ) {
                  const o = e.quickNavigateConfiguration.keybindings;
                  if ( 3 === i || o.some( ( e => {
                      const t = e.getParts(),
                        o = t[ 0 ];
                      return !t[ 1 ] && ( o.shiftKey && 4 === i ? !( n.ctrlKey || n.altKey || n.metaKey ) : !( !o.altKey || 6 !== i ) || ( !( !o.ctrlKey || 5 !== i ) || !( !o.metaKey || 57 !== i ) ) )
                    } ) ) ) {
                    const r = e.tree.getFocus();
                    r && e.elementSelected( r, t )
                  }
                }
              } ) ).clone()
            } ) ).addClass( "monaco-quick-open-widget" ).build( this.container ), this.layoutDimensions && this.layout( this.layoutDimensions ), this.applyStyles(), _.g( this.treeContainer.getHTMLElement(), _.d.KEY_DOWN, ( t => {
              const n = new O.a( t );
              e.quickNavigateConfiguration || 18 !== n.keyCode && 16 !== n.keyCode && 12 !== n.keyCode && 11 !== n.keyCode || ( _.c.stop( t, !0 ), e.navigateInTree( n.keyCode, n.shiftKey ), e.treeElement.focus() )
            } ) ), this.builder.getHTMLElement();
          }, t.prototype.style = function ( e ) {
            this.styles = e, this.applyStyles()
          }, t.prototype.applyStyles = function () {
            if ( this.builder ) {
              const e = this.styles.foreground ? this.styles.foreground.toString() : null,
                t = this.styles.background ? this.styles.background.toString() : null,
                n = this.styles.borderColor ? this.styles.borderColor.toString() : null,
                i = this.styles.widgetShadow ? this.styles.widgetShadow.toString() : null;
              this.builder.style( "color", e ), this.builder.style( "background-color", t ), this.builder.style( "border-color", n ), this.builder.style( "border-width", n ? "1px" : null ), this.builder.style( "border-style", n ? "solid" : null ), this.builder.style( "box-shadow", i ? "0 5px 8px " + i : null )
            }
            this.progressBar && this.progressBar.style( {
              progressBarBackground: this.styles.progressBarBackground
            } ), this.inputBox && this.inputBox.style( {
              inputBackground: this.styles.inputBackground,
              inputForeground: this.styles.inputForeground,
              inputBorder: this.styles.inputBorder,
              inputValidationInfoBackground: this.styles.inputValidationInfoBackground,
              inputValidationInfoBorder: this.styles.inputValidationInfoBorder,
              inputValidationWarningBackground: this.styles.inputValidationWarningBackground,
              inputValidationWarningBorder: this.styles.inputValidationWarningBorder,
              inputValidationErrorBackground: this.styles.inputValidationErrorBackground,
              inputValidationErrorBorder: this.styles.inputValidationErrorBorder
            } ), this.tree && !this.options.treeCreator && this.tree.style( this.styles ), this.renderer && this.renderer.updateStyles( this.styles )
          }, t.prototype.shouldOpenInBackground = function ( e ) {
            if ( e instanceof O.a ) {
              if ( 17 !== e.keyCode ) return !1;
              if ( e.metaKey || e.ctrlKey || e.shiftKey || e.altKey ) return !1;
              const t = this.inputBox.inputElement;
              return t.selectionEnd === this.inputBox.value.length && t.selectionStart === t.selectionEnd
            }
            return e.middleButton
          }, t.prototype.onType = function () {
            const e = this.inputBox.value;
            this.helpText && ( e ? this.helpText.hide() : this.helpText.show() ), this.callbacks.onType( e )
          }, t.prototype.navigateInTree = function ( e, t ) {
            const n = this.tree.getInput(),
              i = n ? n.entries : [],
              o = this.tree.getFocus();
            switch ( e ) {
              case 18:
                this.tree.focusNext();
                break;
              case 16:
                this.tree.focusPrevious();
                break;
              case 12:
                this.tree.focusNextPage();
                break;
              case 11:
                this.tree.focusPreviousPage();
                break;
              case 2:
                t ? this.tree.focusPrevious() : this.tree.focusNext()
            }
            let r = this.tree.getFocus();
            i.length > 1 && o === r && ( 16 === e || 2 === e && t ? this.tree.focusLast() : ( 18 === e || 2 === e && !t ) && this.tree.focusFirst() ), ( r = this.tree.getFocus() ) && this.tree.reveal( r ).done( null, u.e )
          }, t.prototype.elementFocused = function ( e, t ) {
            if ( e && this.isVisible() ) {
              this.inputElement.setAttribute( "aria-activedescendant", this.treeElement.getAttribute( "aria-activedescendant" ) );
              const n = {
                event: t,
                keymods: this.extractKeyMods( t ),
                quickNavigateConfiguration: this.quickNavigateConfiguration
              };
              this.model.runner.run( e, l.a.PREVIEW, n )
            }
          }, t.prototype.elementSelected = function ( e, t, n ) {
            let o = !0;
            if ( this.isVisible() ) {
              const r = n || l.a.OPEN,
                s = {
                  event: t,
                  keymods: this.extractKeyMods( t ),
                  quickNavigateConfiguration: this.quickNavigateConfiguration
                };
              o = this.model.runner.run( e, r, s )
            }
            o && this.hide( i.ELEMENT_SELECTED )
          }, t.prototype.extractKeyMods = e => {
            return {
              ctrlCmd: e && ( e.ctrlKey || e.metaKey || e.payload && e.payload.originalEvent && ( e.payload.originalEvent.ctrlKey || e.payload.originalEvent.metaKey ) ),
              alt: e && ( e.altKey || e.payload && e.payload.originalEvent && e.payload.originalEvent.altKey )
            }
          }, t.prototype.show = function ( e, t ) {
            this.visible = !0, this.isLoosingFocus = !1, this.quickNavigateConfiguration = t ? t.quickNavigateConfiguration : void 0, this.quickNavigateConfiguration ? ( this.inputContainer.hide(), this.builder.show(), this.tree.domFocus() ) : ( this.inputContainer.show(), this.builder.show(), this.inputBox.focus() ), this.helpText && ( this.quickNavigateConfiguration || a.h( e ) ? this.helpText.hide() : this.helpText.show() ), a.h( e ) ? this.doShowWithPrefix( e ) : this.doShowWithInput( e, t && t.autoFocus ? t.autoFocus : {} ), t && t.inputSelection && !this.quickNavigateConfiguration && this.inputBox.select( t.inputSelection ), this.callbacks.onShow && this.callbacks.onShow()
          }, t.prototype.doShowWithPrefix = function ( e ) {
            this.inputBox.value = e, this.callbacks.onType( e )
          }, t.prototype.doShowWithInput = function ( e, t ) {
            this.setInput( e, t )
          }, t.prototype.setInputAndLayout = function ( e, t ) {
            const n = this;
            this.treeContainer.style( {
              height: this.getHeight( e ) + "px"
            } ), this.tree.setInput( null ).then( ( () => {
              return n.model = e, n.inputElement.setAttribute( "aria-haspopup", String( e && e.entries && e.entries.length > 0 ) ), n.tree.setInput( e )
            } ) ).done( ( () => {
              n.tree.layout();
              const i = e ? e.entries.filter( ( t => {
                return n.isElementVisible( e, t )
              } ) ) : [];
              n.updateResultCount( i.length ), i.length && n.autoFocus( e, i, t )
            } ), u.e )
          }, t.prototype.isElementVisible = ( e, t ) => {
            return !e.filter || e.filter.isVisible( t )
          }, t.prototype.autoFocus = function ( e, t, n ) {
            if ( void 0 === n && ( n = {} ), n.autoFocusPrefixMatch ) {
              for ( var i = void 0, o = void 0, r = n.autoFocusPrefixMatch, s = r.toLowerCase(), a = 0; a < t.length; a++ ) {
                const l = t[ a ],
                  c = e.dataSource.getLabel( l );
                if ( i || 0 !== c.indexOf( r ) ? o || 0 !== c.toLowerCase().indexOf( s ) || ( o = l ) : i = l, i && o ) break
              }
              const d = i || o;
              if ( d ) return this.tree.setFocus( d ), void this.tree.reveal( d, .5 ).done( null, u.e )
            }
            n.autoFocusFirstEntry ? ( this.tree.focusFirst(), this.tree.reveal( this.tree.getFocus() ).done( null, u.e ) ) : "number" === typeof n.autoFocusIndex ? t.length > n.autoFocusIndex && ( this.tree.focusNth( n.autoFocusIndex ), this.tree.reveal( this.tree.getFocus() ).done( null, u.e ) ) : n.autoFocusSecondEntry ? t.length > 1 && this.tree.focusNth( 1 ) : n.autoFocusLastEntry && t.length > 1 && this.tree.focusLast()
          }, t.prototype.getHeight = function ( e ) {
            const n = this,
              i = e.renderer;
            if ( !e ) {
              const o = i.getHeight( null );
              return this.options.minItemsToShow ? this.options.minItemsToShow * o : 0
            }
            let r, s = 0;
            this.layoutDimensions && this.layoutDimensions.height && ( r = .4 * ( this.layoutDimensions.height - 50 ) ), ( !r || r > t.MAX_ITEMS_HEIGHT ) && ( r = t.MAX_ITEMS_HEIGHT );
            for ( let a = e.entries.filter( ( t => {
                return n.isElementVisible( e, t )
              } ) ), u = this.options.maxItemsToShow || a.length, l = 0; l < u && l < a.length; l++ ) {
              const c = i.getHeight( a[ l ] );
              if ( !( s + c <= r ) ) break;
              s += c
            }
            return s
          }, t.prototype.updateResultCount = function ( e ) {
            this.resultCount.text( o.a( {
              key: "quickInput.visibleCount",
              comment: [ "This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers." ]
            }, "{0} Results", e ) )
          }, t.prototype.hide = function ( e ) {
            this.isVisible() && ( this.visible = !1, this.builder.hide(), this.builder.domBlur(), this.inputBox.value = "", this.tree.setInput( null ), this.inputElement.setAttribute( "aria-haspopup", "false" ), this.treeContainer.style( {
              height: ( this.options.minItemsToShow ? 22 * this.options.minItemsToShow : 0 ) + "px"
            } ), this.progressBar.stop().hide(), this.tree.isDOMFocused() ? this.tree.domBlur() : this.inputBox.hasFocus() && this.inputBox.blur(), e === i.ELEMENT_SELECTED ? this.callbacks.onOk() : this.callbacks.onCancel(), this.callbacks.onHide && this.callbacks.onHide( e ) )
          }, t.prototype.setInput = function ( e, t, n ) {
            this.isVisible() && ( this.getInput() && this.onInputChanging(), this.setInputAndLayout( e, t ), this.inputBox && this.inputBox.setAriaLabel( n || D ) )
          }, t.prototype.onInputChanging = function () {
            const e = this;
            this.inputChangingTimeoutHandle && ( clearTimeout( this.inputChangingTimeoutHandle ), this.inputChangingTimeoutHandle = null ), this.builder.addClass( "content-changing" ), this.inputChangingTimeoutHandle = setTimeout( ( () => {
              e.builder.removeClass( "content-changing" )
            } ), 500 )
          }, t.prototype.getInput = function () {
            return this.tree.getInput()
          }, t.prototype.isVisible = function () {
            return this.visible
          }, t.prototype.layout = function ( e ) {
            this.layoutDimensions = e;
            const n = Math.min( .62 * this.layoutDimensions.width, t.MAX_WIDTH );
            this.builder && ( this.builder.style( {
              width: n + "px",
              marginLeft: "-" + n / 2 + "px"
            } ), this.inputContainer.style( {
              width: n - 12 + "px"
            } ) )
          }, t.prototype.gainingFocus = function () {
            this.isLoosingFocus = !1
          }, t.prototype.loosingFocus = function ( e ) {
            const t = this;
            if ( this.isVisible() ) {
              const n = e.relatedTarget;
              !this.quickNavigateConfiguration && _.B( n, this.builder.getHTMLElement() ) || ( this.isLoosingFocus = !0, r.b.timeout( 0 ).then( ( () => {
                t.isLoosingFocus && ( t.isDisposed || t.callbacks.onFocusLost && t.callbacks.onFocusLost() || t.hide( i.FOCUS_LOST ) )
              } ) ) )
            }
          }, t.prototype.dispose = function () {
            e.prototype.dispose.call( this ), this.isDisposed = !0
          }, t.MAX_WIDTH = 600, t.MAX_ITEMS_HEIGHT = 440, t;
        } )( v.a ),
        T = n( "sFUC" ),
        R = n( "ptcw" ),
        P = n( "MD5Z" ),
        A = ( () => {
          function e( e, t, n, i, o, r ) {
            this.codeEditor = e, this.themeService = r, this.create( t, n, i, o )
          }
          return e.prototype.create = function ( e, t, n, i ) {
            this.domNode = document.createElement( "div" ), this.quickOpenWidget = new M( this.domNode, {
              onOk: e,
              onCancel: t,
              onType: n
            }, {
              inputPlaceHolder: null,
              inputAriaLabel: i.inputAriaLabel,
              keyboardSupport: !0
            } ), this.styler = Object( R.c )( this.quickOpenWidget, this.themeService, {
              pickerGroupForeground: P.I
            } ), this.quickOpenWidget.create(), this.codeEditor.addOverlayWidget( this )
          }, e.prototype.setInput = function ( e, t ) {
            this.quickOpenWidget.setInput( e, t )
          }, e.prototype.getId = () => {
            return e.ID
          }, e.prototype.getDomNode = function () {
            return this.domNode
          }, e.prototype.destroy = function () {
            this.codeEditor.removeOverlayWidget( this ), this.quickOpenWidget.dispose(), this.styler.dispose()
          }, e.prototype.show = function ( e ) {
            this.visible = !0;
            const t = this.codeEditor.getLayoutInfo();
            t && this.quickOpenWidget.layout( new _.b( t.width, t.height ) ), this.quickOpenWidget.show( e ), this.codeEditor.layoutOverlayWidget( this )
          }, e.prototype.getPosition = function () {
            return this.visible ? {
              preference: T.c.TOP_CENTER
            } : null
          }, e.ID = "editor.contrib.quickOpenEditorWidget", e;
        } )(),
        F = n( "sswD" ),
        W = n( "t9D7" ),
        j = n( "tX9W" );
      n.d( t, "a", ( () => {
        return U
      } ) );
      const V = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const B = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const H = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      const z = ( () => {
        function e( e, t ) {
          this.themeService = t, this.editor = e
        }
        return e.get = t => {
          return t.getContribution( e.ID )
        }, e.prototype.getId = () => {
          return e.ID
        }, e.prototype.dispose = function () {
          this.widget && ( this.widget.destroy(), this.widget = null )
        }, e.prototype.run = function ( e ) {
          const t = this;
          this.widget && ( this.widget.destroy(), this.widget = null );
          const n = e => {
            t.clearDecorations(), e && t.lastKnownEditorSelection && ( t.editor.setSelection( t.lastKnownEditorSelection ), t.editor.revealRangeInCenterIfOutsideViewport( t.lastKnownEditorSelection, 0 ) ), t.lastKnownEditorSelection = null, t.editor.focus()
          };
          this.widget = new A( this.editor, ( () => {
            return n( !1 )
          } ), ( () => {
            return n( !0 )
          } ), ( n => {
            t.widget.setInput( e.getModel( n ), e.getAutoFocus( n ) )
          } ), {
            inputAriaLabel: e.inputAriaLabel
          }, this.themeService ), this.lastKnownEditorSelection || ( this.lastKnownEditorSelection = this.editor.getSelection() ), this.widget.show( "" )
        }, e.prototype.decorateLine = function ( t, n ) {
          const i = [];
          this.rangeHighlightDecorationId && ( i.push( this.rangeHighlightDecorationId ), this.rangeHighlightDecorationId = null );
          const o = [ {
              range: t,
              options: e._RANGE_HIGHLIGHT_DECORATION
            } ],
            r = n.deltaDecorations( i, o );
          this.rangeHighlightDecorationId = r[ 0 ]
        }, e.prototype.clearDecorations = function () {
          this.rangeHighlightDecorationId && ( this.editor.deltaDecorations( [ this.rangeHighlightDecorationId ], [] ), this.rangeHighlightDecorationId = null )
        }, e.ID = "editor.controller.quickOpenController", e._RANGE_HIGHLIGHT_DECORATION = j.a.register( {
          className: "rangeHighlight",
          isWholeLine: !0
        } ), e = B( [ H( 1, W.c ) ], e );
      } )();
      var U = ( e => {
        function t( t, n ) {
          const i = e.call( this, n ) || this;
          return i._inputAriaLabel = t, i
        }
        return V( t, e ), t.prototype.getController = e => {
          return z.get( e )
        }, t.prototype._show = function ( e, t ) {
          e.run( {
            inputAriaLabel: this._inputAriaLabel,
            getModel( e ) {
              return t.getModel( e )
            },
            getAutoFocus( e ) {
              return t.getAutoFocus( e )
            }
          } )
        }, t;
      } )( F.b );
      Object( F.h )( z )
    },
    s7Km( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "MoveWordCommand", ( () => {
        return f
      } ) ), n.d( t, "WordLeftCommand", ( () => {
        return g
      } ) ), n.d( t, "WordRightCommand", ( () => {
        return m
      } ) ), n.d( t, "CursorWordStartLeft", ( () => {
        return _
      } ) ), n.d( t, "CursorWordEndLeft", ( () => {
        return v
      } ) ), n.d( t, "CursorWordLeft", ( () => {
        return y
      } ) ), n.d( t, "CursorWordStartLeftSelect", ( () => {
        return b
      } ) ), n.d( t, "CursorWordEndLeftSelect", ( () => {
        return C
      } ) ), n.d( t, "CursorWordLeftSelect", ( () => {
        return w
      } ) ), n.d( t, "CursorWordStartRight", ( () => {
        return S
      } ) ), n.d( t, "CursorWordEndRight", ( () => {
        return O
      } ) ), n.d( t, "CursorWordRight", ( () => {
        return L
      } ) ), n.d( t, "CursorWordStartRightSelect", ( () => {
        return x
      } ) ), n.d( t, "CursorWordEndRightSelect", ( () => {
        return N
      } ) ), n.d( t, "CursorWordRightSelect", ( () => {
        return E
      } ) ), n.d( t, "DeleteWordCommand", ( () => {
        return k
      } ) ), n.d( t, "DeleteWordLeftCommand", ( () => {
        return I
      } ) ), n.d( t, "DeleteWordRightCommand", ( () => {
        return D
      } ) ), n.d( t, "DeleteWordStartLeft", ( () => {
        return M
      } ) ), n.d( t, "DeleteWordEndLeft", ( () => {
        return T
      } ) ), n.d( t, "DeleteWordLeft", ( () => {
        return R
      } ) ), n.d( t, "DeleteWordStartRight", ( () => {
        return P
      } ) ), n.d( t, "DeleteWordEndRight", ( () => {
        return A
      } ) ), n.d( t, "DeleteWordRight", ( () => {
        return F
      } ) );
      const i = n( "wQH0" );
      const o = n( "gCVg" );
      const r = n( "sswD" );
      const s = n( "cGHE" );
      const a = n( "aokT" );
      const u = n( "1I1M" );
      const l = n( "LCkn" );
      const c = n( "5v8Y" );
      const d = n( "Ll0s" );
      const h = n( "uzpd" );
      const p = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var f = ( e => {
        function t( t ) {
          const n = e.call( this, t ) || this;
          return n._inSelectionMode = t.inSelectionMode, n._wordNavigationType = t.wordNavigationType, n
        }
        return p( t, e ), t.prototype.runEditorCommand = function ( e, t, n ) {
          const i = this,
            o = t.getConfiguration(),
            r = Object( c.a )( o.wordSeparators ),
            a = t.getModel(),
            u = t.getSelections().map( ( e => {
              const t = new s.a( e.positionLineNumber, e.positionColumn ),
                n = i._move( r, a, t, i._wordNavigationType );
              return i._moveTo( e, n, i._inSelectionMode )
            } ) );
          if ( t._getCursors().setStates( "moveWordCommand", h.a.NotSet, u.map( ( e => {
              return d.d.fromModelSelection( e )
            } ) ) ), 1 === u.length ) {
            const l = new s.a( u[ 0 ].positionLineNumber, u[ 0 ].positionColumn );
            t.revealPosition( l, 0 )
          }
        }, t.prototype._moveTo = ( e, t, n ) => {
          return n ? new o.a( e.selectionStartLineNumber, e.selectionStartColumn, t.lineNumber, t.column ) : new o.a( t.lineNumber, t.column, t.lineNumber, t.column )
        }, t;
      } )( r.c );
      var g = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return p( t, e ), t.prototype._move = ( e, t, n, i ) => {
          return u.a.moveWordLeft( e, t, n, i )
        }, t;
      } )( f );
      var m = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return p( t, e ), t.prototype._move = ( e, t, n, i ) => {
          return u.a.moveWordRight( e, t, n, i )
        }, t;
      } )( f );
      var _ = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !1,
            wordNavigationType: 0,
            id: "cursorWordStartLeft",
            precondition: null,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 2063,
              mac: {
                primary: 527
              },
              weight: 100
            }
          } ) || this
        }
        return p( t, e ), t
      } )( g );
      var v = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !1,
            wordNavigationType: 1,
            id: "cursorWordEndLeft",
            precondition: null
          } ) || this
        }
        return p( t, e ), t
      } )( g );
      var y = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !1,
            wordNavigationType: 0,
            id: "cursorWordLeft",
            precondition: null
          } ) || this
        }
        return p( t, e ), t
      } )( g );
      var b = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !0,
            wordNavigationType: 0,
            id: "cursorWordStartLeftSelect",
            precondition: null,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 3087,
              mac: {
                primary: 1551
              },
              weight: 100
            }
          } ) || this
        }
        return p( t, e ), t
      } )( g );
      var C = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !0,
            wordNavigationType: 1,
            id: "cursorWordEndLeftSelect",
            precondition: null
          } ) || this
        }
        return p( t, e ), t
      } )( g );
      var w = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !0,
            wordNavigationType: 0,
            id: "cursorWordLeftSelect",
            precondition: null
          } ) || this
        }
        return p( t, e ), t
      } )( g );
      var S = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !1,
            wordNavigationType: 0,
            id: "cursorWordStartRight",
            precondition: null
          } ) || this
        }
        return p( t, e ), t
      } )( m );
      var O = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !1,
            wordNavigationType: 1,
            id: "cursorWordEndRight",
            precondition: null,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 2065,
              mac: {
                primary: 529
              },
              weight: 100
            }
          } ) || this
        }
        return p( t, e ), t
      } )( m );
      var L = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !1,
            wordNavigationType: 1,
            id: "cursorWordRight",
            precondition: null
          } ) || this
        }
        return p( t, e ), t
      } )( m );
      var x = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !0,
            wordNavigationType: 0,
            id: "cursorWordStartRightSelect",
            precondition: null
          } ) || this
        }
        return p( t, e ), t
      } )( m );
      var N = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !0,
            wordNavigationType: 1,
            id: "cursorWordEndRightSelect",
            precondition: null,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 3089,
              mac: {
                primary: 1553
              },
              weight: 100
            }
          } ) || this
        }
        return p( t, e ), t
      } )( m );
      var E = ( e => {
        function t() {
          return e.call( this, {
            inSelectionMode: !0,
            wordNavigationType: 1,
            id: "cursorWordRightSelect",
            precondition: null
          } ) || this
        }
        return p( t, e ), t
      } )( m );
      var k = ( e => {
        function t( t ) {
          const n = e.call( this, t ) || this;
          return n._whitespaceHeuristics = t.whitespaceHeuristics, n._wordNavigationType = t.wordNavigationType, n
        }
        return p( t, e ), t.prototype.runEditorCommand = function ( e, t, n ) {
          const i = this,
            o = t.getConfiguration(),
            r = Object( c.a )( o.wordSeparators ),
            s = t.getModel(),
            a = t.getSelections().map( ( e => {
              const t = i._delete( r, s, e, i._whitespaceHeuristics, i._wordNavigationType );
              return new l.a( t, "" )
            } ) );
          t.pushUndoStop(), t.executeCommands( this.id, a ), t.pushUndoStop()
        }, t;
      } )( r.c );
      var I = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return p( t, e ), t.prototype._delete = ( e, t, n, i, o ) => {
          const r = u.a.deleteWordLeft( e, t, n, i, o );
          return r || new a.a( 1, 1, 1, 1 )
        }, t;
      } )( k );
      var D = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return p( t, e ), t.prototype._delete = ( e, t, n, i, o ) => {
          const r = u.a.deleteWordRight( e, t, n, i, o );
          if ( r ) return r;
          const s = t.getLineCount(),
            l = t.getLineMaxColumn( s );
          return new a.a( s, l, s, l )
        }, t;
      } )( k );
      var M = ( e => {
        function t() {
          return e.call( this, {
            whitespaceHeuristics: !1,
            wordNavigationType: 0,
            id: "deleteWordStartLeft",
            precondition: i.a.writable
          } ) || this
        }
        return p( t, e ), t
      } )( I );
      var T = ( e => {
        function t() {
          return e.call( this, {
            whitespaceHeuristics: !1,
            wordNavigationType: 1,
            id: "deleteWordEndLeft",
            precondition: i.a.writable
          } ) || this
        }
        return p( t, e ), t
      } )( I );
      var R = ( e => {
        function t() {
          return e.call( this, {
            whitespaceHeuristics: !0,
            wordNavigationType: 0,
            id: "deleteWordLeft",
            precondition: i.a.writable,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 2049,
              mac: {
                primary: 513
              },
              weight: 100
            }
          } ) || this
        }
        return p( t, e ), t
      } )( I );
      var P = ( e => {
        function t() {
          return e.call( this, {
            whitespaceHeuristics: !1,
            wordNavigationType: 0,
            id: "deleteWordStartRight",
            precondition: i.a.writable
          } ) || this
        }
        return p( t, e ), t
      } )( D );
      var A = ( e => {
        function t() {
          return e.call( this, {
            whitespaceHeuristics: !1,
            wordNavigationType: 1,
            id: "deleteWordEndRight",
            precondition: i.a.writable
          } ) || this
        }
        return p( t, e ), t
      } )( D );
      var F = ( e => {
        function t() {
          return e.call( this, {
            whitespaceHeuristics: !0,
            wordNavigationType: 1,
            id: "deleteWordRight",
            precondition: i.a.writable,
            kbOpts: {
              kbExpr: i.a.textInputFocus,
              primary: 2068,
              mac: {
                primary: 532
              },
              weight: 100
            }
          } ) || this
        }
        return p( t, e ), t
      } )( D );
      Object( r.g )( new _ ), Object( r.g )( new v ), Object( r.g )( new y ), Object( r.g )( new b ), Object( r.g )( new C ), Object( r.g )( new w ), Object( r.g )( new S ), Object( r.g )( new O ), Object( r.g )( new L ), Object( r.g )( new x ), Object( r.g )( new N ), Object( r.g )( new E ), Object( r.g )( new M ), Object( r.g )( new T ), Object( r.g )( new R ), Object( r.g )( new P ), Object( r.g )( new A ), Object( r.g )( new F )
    },
    sFUC( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "c", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) ), n.d( t, "d", ( () => {
        return a
      } ) );
      var i;
      var o;
      var r;
      const s = n( "iuje" );

      function a( e ) {
        return !( !e || "function" !== typeof e.getEditorType ) && e.getEditorType() === s.a.ICodeEditor
      }!( e => {
        e[ e.EXACT = 0 ] = "EXACT", e[ e.ABOVE = 1 ] = "ABOVE", e[ e.BELOW = 2 ] = "BELOW"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.TOP_RIGHT_CORNER = 0 ] = "TOP_RIGHT_CORNER", e[ e.BOTTOM_RIGHT_CORNER = 1 ] = "BOTTOM_RIGHT_CORNER", e[ e.TOP_CENTER = 2 ] = "TOP_CENTER"
      } )( o || ( o = {} ) ), ( e => {
        e[ e.UNKNOWN = 0 ] = "UNKNOWN", e[ e.TEXTAREA = 1 ] = "TEXTAREA", e[ e.GUTTER_GLYPH_MARGIN = 2 ] = "GUTTER_GLYPH_MARGIN", e[ e.GUTTER_LINE_NUMBERS = 3 ] = "GUTTER_LINE_NUMBERS", e[ e.GUTTER_LINE_DECORATIONS = 4 ] = "GUTTER_LINE_DECORATIONS", e[ e.GUTTER_VIEW_ZONE = 5 ] = "GUTTER_VIEW_ZONE", e[ e.CONTENT_TEXT = 6 ] = "CONTENT_TEXT", e[ e.CONTENT_EMPTY = 7 ] = "CONTENT_EMPTY", e[ e.CONTENT_VIEW_ZONE = 8 ] = "CONTENT_VIEW_ZONE", e[ e.CONTENT_WIDGET = 9 ] = "CONTENT_WIDGET", e[ e.OVERVIEW_RULER = 10 ] = "OVERVIEW_RULER", e[ e.SCROLLBAR = 11 ] = "SCROLLBAR", e[ e.OVERLAY_WIDGET = 12 ] = "OVERLAY_WIDGET", e[ e.OUTSIDE_EDITOR = 13 ] = "OUTSIDE_EDITOR"
      } )( r || ( r = {} ) )
    },
    sM1p( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return r
      } ) ), n.d( t, "b", ( () => {
        return s
      } ) );
      const i = n( "S3by" );
      const o = n( "Cg/j" );
      var r = ( i.a, Object( o.c )( "notificationService" ) );
      var s = () => {};
    },
    sStQ( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "perl",
        extensions: [ ".pl", ".pm", ".t" ],
        aliases: [ "Perl", "pl" ],
        loader() {
          return o.Promise.wrap( n.e( 284 ).then( n.bind( null, "QKwv" ) ) )
        }
      } )
    },
    scqD( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "themeService" );
    },
    siPX( e, t, n ) {},
    snIX( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return u
      } ) );
      const i = n( "LCkn" );
      const o = n( "Ll0s" );
      const r = n( "aokT" );
      const s = n( "+Fos" );
      const a = n( "N0LK" );

      var u = ( () => {
        function e() {}
        return e.deleteRight = ( e, t, n, o ) => {
          for ( var a = [], u = 3 !== e, l = 0, c = o.length; l < c; l++ ) {
            const d = o[ l ];
            let h = d;
            if ( h.isEmpty() ) {
              const p = d.getPosition(),
                f = s.a.right( t, n, p.lineNumber, p.column );
              h = new r.a( f.lineNumber, f.column, p.lineNumber, p.column )
            }
            h.isEmpty() ? a[ l ] = null : ( h.startLineNumber !== h.endLineNumber && ( u = !0 ), a[ l ] = new i.a( h, "" ) )
          }
          return [ u, a ]
        }, e._isAutoClosingPairDelete = ( e, t, n ) => {
          if ( !e.autoClosingBrackets ) return !1;
          for ( let i = 0, o = n.length; i < o; i++ ) {
            const r = n[ i ],
              s = r.getPosition();
            if ( !r.isEmpty() ) return !1;
            const a = t.getLineContent( s.lineNumber ),
              u = a[ s.column - 2 ];
            if ( !e.autoClosingPairsOpen.hasOwnProperty( u ) ) return !1;
            if ( a[ s.column - 1 ] !== e.autoClosingPairsOpen[ u ] ) return !1
          }
          return !0
        }, e._runAutoClosingPairDelete = ( e, t, n ) => {
          for ( var o = [], s = 0, a = n.length; s < a; s++ ) {
            const u = n[ s ].getPosition(),
              l = new r.a( u.lineNumber, u.column - 1, u.lineNumber, u.column + 1 );
            o[ s ] = new i.a( l, "" )
          }
          return [ !0, o ]
        }, e.deleteLeft = function ( e, t, n, u ) {
          if ( this._isAutoClosingPairDelete( t, n, u ) ) return this._runAutoClosingPairDelete( t, n, u );
          for ( var l = [], c = 2 !== e, d = 0, h = u.length; d < h; d++ ) {
            const p = u[ d ];
            let f = p;
            if ( f.isEmpty() ) {
              const g = p.getPosition();
              if ( t.useTabStops && g.column > 1 ) {
                const m = n.getLineContent( g.lineNumber ),
                  _ = a.firstNonWhitespaceIndex( m ),
                  v = -1 === _ ? m.length + 1 : _ + 1;
                if ( g.column <= v ) {
                  const y = o.a.visibleColumnFromColumn2( t, n, g ),
                    b = o.a.prevTabStop( y, t.tabSize ),
                    C = o.a.columnFromVisibleColumn2( t, n, g.lineNumber, b );
                  f = new r.a( g.lineNumber, C, g.lineNumber, g.column )
                } else f = new r.a( g.lineNumber, g.column - 1, g.lineNumber, g.column )
              } else {
                const w = s.a.left( t, n, g.lineNumber, g.column );
                f = new r.a( w.lineNumber, w.column, g.lineNumber, g.column )
              }
            }
            f.isEmpty() ? l[ d ] = null : ( f.startLineNumber !== f.endLineNumber && ( c = !0 ), l[ d ] = new i.a( f, "" ) )
          }
          return [ c, l ]
        }, e.cut = ( e, t, n ) => {
          for ( var s = [], a = 0, u = n.length; a < u; a++ ) {
            const l = n[ a ];
            if ( l.isEmpty() )
              if ( e.emptySelectionClipboard ) {
                const c = l.getPosition();
                let d = void 0;
                let h = void 0;
                let p = void 0;
                let f = void 0;
                c.lineNumber < t.getLineCount() ? ( d = c.lineNumber, h = 1, p = c.lineNumber + 1, f = 1 ) : c.lineNumber > 1 ? ( d = c.lineNumber - 1, h = t.getLineMaxColumn( c.lineNumber - 1 ), p = c.lineNumber, f = t.getLineMaxColumn( c.lineNumber ) ) : ( d = c.lineNumber, h = 1, p = c.lineNumber, f = t.getLineMaxColumn( c.lineNumber ) );
                const g = new r.a( d, h, p, f );
                g.isEmpty() ? s[ a ] = null : s[ a ] = new i.a( g, "" )
              } else s[ a ] = null;
            else s[ a ] = new i.a( l, "" )
          }
          return new o.e( 0, s, {
            shouldPushStackElementBefore: !0,
            shouldPushStackElementAfter: !0
          } )
        }, e;
      } )();
    },
    sswD( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return _
      } ) ), n.d( t, "c", ( () => {
        return v
      } ) ), n.d( t, "b", ( () => {
        return y
      } ) ), n.d( t, "j", ( () => {
        return b
      } ) ), n.d( t, "e", ( () => {
        return C
      } ) ), n.d( t, "g", ( () => {
        return w
      } ) ), n.d( t, "f", ( () => {
        return S
      } ) ), n.d( t, "i", ( () => {
        return O
      } ) ), n.d( t, "h", ( () => {
        return L
      } ) ), n.d( t, "d", ( () => {
        return i
      } ) );
      var i;
      const o = n( "/cxE" );
      const r = n( "bY76" );
      const s = n( "nnTU" );
      const a = n( "nrhi" );
      const u = n( "ic2d" );
      const l = n( "XXUj" );
      const c = n( "cGHE" );
      const d = n( "G2kB" );
      const h = n( "fjLI" );
      const p = n( "T8No" );
      const f = n( "Vxe3" );
      const g = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const m = Object.assign || function ( e ) {
        for ( let t, n = 1, i = arguments.length; n < i; n++ )
          for ( const o in t = arguments[ n ] ) Object.prototype.hasOwnProperty.call( t, o ) && ( e[ o ] = t[ o ] );
        return e
      };
      var _ = ( () => {
        function e( e ) {
          this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menubarOpts = e.menubarOpts, this._description = e.description
        }
        return e.prototype.register = function () {
          const e = this;
          if ( this._menubarOpts && h.d.appendMenuItem( this._menubarOpts.menuId, {
              group: this._menubarOpts.group,
              command: {
                id: this.id,
                title: this._menubarOpts.title
              },
              when: this._menubarOpts.when,
              order: this._menubarOpts.order
            } ), this._kbOpts ) {
            let t = this._kbOpts.kbExpr;
            this.precondition && ( t = t ? p.d.and( t, this.precondition ) : this.precondition ), a.a.registerCommandAndKeybindingRule( {
              id: this.id,
              handler( t, n ) {
                return e.runCommand( t, n )
              },
              weight: this._kbOpts.weight,
              when: t,
              primary: this._kbOpts.primary,
              secondary: this._kbOpts.secondary,
              win: this._kbOpts.win,
              linux: this._kbOpts.linux,
              mac: this._kbOpts.mac,
              description: this._description
            } )
          } else s.a.registerCommand( {
            id: this.id,
            handler( t, n ) {
              return e.runCommand( t, n )
            },
            description: this._description
          } )
        }, e;
      } )();
      var v = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return g( t, e ), t.bindToContribution = e => {
          return ( t => {
            function n( e ) {
              const n = t.call( this, e ) || this;
              return n._callback = e.handler, n
            }
            return g( n, t ), n.prototype.runEditorCommand = function ( t, n, i ) {
              e( n ) && this._callback( e( n ) )
            }, n
          } )( t );
        }, t.prototype.runCommand = function ( e, t ) {
          const n = this,
            i = e.get( f.a ),
            o = i.getFocusedCodeEditor() || i.getActiveCodeEditor();
          if ( o ) return o.invokeWithinContext( ( e => {
            if ( e.get( p.e ).contextMatchesRules( n.precondition ) ) return n.runEditorCommand( e, o, t )
          } ) );
        }, t;
      } )( _ );
      var y = ( e => {
        function t( t ) {
          const n = e.call( this, t ) || this;
          return n.label = t.label, n.alias = t.alias, n.menuOpts = t.menuOpts, n
        }
        return g( t, e ), t.prototype.register = function () {
          this.menuOpts && h.d.appendMenuItem( h.b.EditorContext, {
            command: {
              id: this.id,
              title: this.label
            },
            when: p.d.and( this.precondition, this.menuOpts.when ),
            group: this.menuOpts.group,
            order: this.menuOpts.order
          } ), e.prototype.register.call( this )
        }, t.prototype.runEditorCommand = function ( e, t, n ) {
          return this.reportTelemetry( e, t ), this.run( e, t, n || {} )
        }, t.prototype.reportTelemetry = function ( e, t ) {
          e.get( l.a ).publicLog( "editorActionInvoked", m( {
            name: this.label,
            id: this.id
          }, t.getTelemetryData() ) )
        }, t
      } )( v );

      function b( e, t ) {
        s.a.registerCommand( e, ( ( e, n ) => {
          return t( e, n || {} )
        } ) )
      }

      function C( e, t ) {
        b( e, ( ( e, n ) => {
          const i = n.resource,
            s = n.position;
          if ( !( i instanceof r.a ) ) throw Object( o.b )( "resource" );
          if ( !c.a.isIPosition( s ) ) throw Object( o.b )( "position" );
          const a = e.get( d.a ).getModel( i );
          if ( !a ) throw Object( o.b )( "Can not find open model for " + i );
          const u = c.a.lift( s );
          return t( a, u, n )
        } ) )
      }

      function w( e ) {
        return x.INSTANCE.registerEditorCommand( e ), e
      }

      function S( e ) {
        x.INSTANCE.registerEditorAction( new e )
      }

      function O( e ) {
        x.INSTANCE.registerEditorAction( e )
      }

      function L( e ) {
        x.INSTANCE.registerEditorContribution( e )
      }!( e => {
        e.getEditorCommand = e => {
          return x.INSTANCE.getEditorCommand( e )
        }, e.getEditorActions = () => {
          return x.INSTANCE.getEditorActions()
        }, e.getEditorContributions = () => {
          return x.INSTANCE.getEditorContributions()
        }
      } )( i || ( i = {} ) );
      var x = ( () => {
        function e() {
          this.editorContributions = [], this.editorActions = [], this.editorCommands = Object.create( null )
        }
        return e.prototype.registerEditorContribution = function ( e ) {
          this.editorContributions.push( e )
        }, e.prototype.registerEditorAction = function ( e ) {
          e.register(), this.editorActions.push( e )
        }, e.prototype.getEditorContributions = function () {
          return this.editorContributions.slice( 0 )
        }, e.prototype.getEditorActions = function () {
          return this.editorActions.slice( 0 )
        }, e.prototype.registerEditorCommand = function ( e ) {
          e.register(), this.editorCommands[ e.id ] = e
        }, e.prototype.getEditorCommand = function ( e ) {
          return this.editorCommands[ e ] || null
        }, e.INSTANCE = new e, e
      } )();
      u.a.add( "editor.contributions", x.INSTANCE )
    },
    synD( e, t, n ) {},
    t2jz( e, t, n ) {},
    t49l( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "textModelService" );
    },
    t9D7( e, t, n ) {
      "use strict";
      n.d( t, "c", ( () => {
        return a
      } ) ), n.d( t, "f", ( () => {
        return u
      } ) ), n.d( t, "b", ( () => {
        return c
      } ) ), n.d( t, "d", ( () => {
        return d
      } ) ), n.d( t, "a", ( () => {
        return h
      } ) ), n.d( t, "e", ( () => {
        return f
      } ) );
      const i = n( "Cg/j" );
      const o = n( "pmY6" );
      const r = n( "ic2d" );
      const s = n( "MI8n" );
      var a = Object( i.c )( "themeService" );

      function u( e ) {
        return {
          id: e
        }
      }
      const l = "dark";
      var c = "hc";

      function d( e ) {
        switch ( e ) {
          case l:
            return "vs-dark";
          case c:
            return "hc-black";
          default:
            return "vs"
        }
      }
      var h = {
        ThemingContribution: "base.contributions.theming"
      };
      const p = new( ( () => {
        function e() {
          this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new s.a
        }
        return e.prototype.onThemeChange = function ( e ) {
          const t = this;
          return this.themingParticipants.push( e ), this.onThemingParticipantAddedEmitter.fire( e ), Object( o.f )( ( () => {
            const n = t.themingParticipants.indexOf( e );
            t.themingParticipants.splice( n, 1 )
          } ) );
        }, e.prototype.getThemingParticipants = function () {
          return this.themingParticipants
        }, e;
      } )() )();

      function f( e ) {
        return p.onThemeChange( e )
      }
      r.a.add( h.ThemingContribution, p )
    },
    tADe( e, t, n ) {
      "use strict";
      n.d( t, "c", ( () => {
        return i
      } ) ), n.d( t, "b", ( () => {
        return o
      } ) ), n.d( t, "a", ( () => {
        return l
      } ) );
      var i;
      var o;
      let r;
      const s = n( "Cg/j" );
      const a = n( "3/fG" );
      const u = n( "S3by" );
      !( e => {
        e[ e.Unnecessary = 1 ] = "Unnecessary"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.Hint = 1 ] = "Hint", e[ e.Info = 2 ] = "Info", e[ e.Warning = 4 ] = "Warning", e[ e.Error = 8 ] = "Error"
      } )( o || ( o = {} ) ), ( e => {
        e.compare = ( e, t ) => {
          return t - e
        };
        const t = Object.create( null );
        t[ e.Error ] = Object( a.a )( "sev.error", "Error" ), t[ e.Warning ] = Object( a.a )( "sev.warning", "Warning" ), t[ e.Info ] = Object( a.a )( "sev.info", "Info" ), e.toString = e => {
          return t[ e ] || ""
        }, e.fromSeverity = t => {
          switch ( t ) {
            case u.a.Error:
              return e.Error;
            case u.a.Warning:
              return e.Warning;
            case u.a.Info:
              return e.Info;
            case u.a.Ignore:
              return e.Hint
          }
        }
      } )( o || ( o = {} ) ), ( e => {
        const t = "";
        e.makeKey = e => {
          const n = [ t ];
          return e.source ? n.push( e.source.replace( "\xa6", "\xa6" ) ) : n.push( t ), e.code ? n.push( e.code.replace( "\xa6", "\xa6" ) ) : n.push( t ), void 0 !== e.severity && null !== e.severity ? n.push( o.toString( e.severity ) ) : n.push( t ), e.message ? n.push( e.message.replace( "\xa6", "\xa6" ) ) : n.push( t ), void 0 !== e.startLineNumber && null !== e.startLineNumber ? n.push( e.startLineNumber.toString() ) : n.push( t ), void 0 !== e.startColumn && null !== e.startColumn ? n.push( e.startColumn.toString() ) : n.push( t ), void 0 !== e.endLineNumber && null !== e.endLineNumber ? n.push( e.endLineNumber.toString() ) : n.push( t ), void 0 !== e.endColumn && null !== e.endColumn ? n.push( e.endColumn.toString() ) : n.push( t ), n.push( t ), n.join( "\xa6" )
        }
      } )( r || ( r = {} ) );
      var l = Object( s.c )( "markerService" )
    },
    tTk5( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "progressService" );
    },
    tX9W( e, t, n ) {
      "use strict";
      const i = n( "bY76" ),
        o = n( "MI8n" ),
        r = n( "M1Kb" ),
        s = n( "twdY" ),
        a = n( "/cxE" ),
        u = ( () => {
          function e( e, t ) {
            this.beforeVersionId = e, this.beforeCursorState = t, this.afterCursorState = null, this.afterVersionId = -1, this.editOperations = []
          }
          return e.prototype.undo = function ( e ) {
            for ( let t = this.editOperations.length - 1; t >= 0; t-- ) this.editOperations[ t ] = {
              operations: e.applyEdits( this.editOperations[ t ].operations )
            }
          }, e.prototype.redo = function ( e ) {
            for ( let t = 0; t < this.editOperations.length; t++ ) this.editOperations[ t ] = {
              operations: e.applyEdits( this.editOperations[ t ].operations )
            }
          }, e;
        } )();

      function l( e ) {
        return "\n" === e.getEOL() ? r.d.LF : r.d.CRLF
      }
      const c = ( () => {
          function e( e, t ) {
            this.beforeVersionId = e, this.beforeCursorState = null, this.afterCursorState = null, this.afterVersionId = -1, this.eol = t
          }
          return e.prototype.undo = function ( e ) {
            const t = l( e );
            e.setEOL( this.eol ), this.eol = t
          }, e.prototype.redo = function ( e ) {
            const t = l( e );
            e.setEOL( this.eol ), this.eol = t
          }, e;
        } )(),
        d = ( () => {
          function e( e ) {
            this.model = e, this.currentOpenStackElement = null, this.past = [], this.future = []
          }
          return e.prototype.pushStackElement = function () {
            null !== this.currentOpenStackElement && ( this.past.push( this.currentOpenStackElement ), this.currentOpenStackElement = null )
          }, e.prototype.clear = function () {
            this.currentOpenStackElement = null, this.past = [], this.future = []
          }, e.prototype.pushEOL = function ( e ) {
            this.future = [], this.currentOpenStackElement && this.pushStackElement();
            const t = l( this.model ),
              n = new c( this.model.getAlternativeVersionId(), t );
            this.model.setEOL( e ), n.afterVersionId = this.model.getVersionId(), this.currentOpenStackElement = n, this.pushStackElement()
          }, e.prototype.pushEditOperation = function ( t, n, i ) {
            this.future = [];
            let o = null;
            this.currentOpenStackElement && ( this.currentOpenStackElement instanceof u ? o = this.currentOpenStackElement : this.pushStackElement() ), this.currentOpenStackElement || ( o = new u( this.model.getAlternativeVersionId(), t ), this.currentOpenStackElement = o );
            const r = {
              operations: this.model.applyEdits( n )
            };
            return o.editOperations.push( r ), o.afterCursorState = e._computeCursorState( i, r.operations ), o.afterVersionId = this.model.getVersionId(), o.afterCursorState
          }, e._computeCursorState = ( e, t ) => {
            try {
              return e ? e( t ) : null
            } catch ( n ) {
              return Object( a.e )( n ), null
            }
          }, e.prototype.undo = function () {
            if ( this.pushStackElement(), this.past.length > 0 ) {
              const e = this.past.pop();
              try {
                e.undo( this.model )
              } catch ( t ) {
                return Object( a.e )( t ), this.clear(), null
              }
              return this.future.push( e ), {
                selections: e.beforeCursorState,
                recordedVersionId: e.beforeVersionId
              }
            }
            return null
          }, e.prototype.canUndo = function () {
            return this.past.length > 0
          }, e.prototype.redo = function () {
            if ( this.future.length > 0 ) {
              const e = this.future.pop();
              try {
                e.redo( this.model )
              } catch ( t ) {
                return Object( a.e )( t ), this.clear(), null
              }
              return this.past.push( e ), {
                selections: e.afterCursorState,
                recordedVersionId: e.afterVersionId
              }
            }
            return null
          }, e.prototype.canRedo = function () {
            return this.future.length > 0
          }, e;
        } )(),
        h = n( "aokT" ),
        p = n( "gCVg" ),
        f = function () {
          this.changeType = 1
        },
        g = function ( e, t ) {
          this.changeType = 2, this.lineNumber = e, this.detail = t
        },
        m = function ( e, t ) {
          this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t
        },
        _ = function ( e, t, n ) {
          this.changeType = 4, this.fromLineNumber = e, this.toLineNumber = t, this.detail = n
        },
        v = function () {
          this.changeType = 5
        },
        y = ( () => {
          function e( e, t, n, i ) {
            this.changes = e, this.versionId = t, this.isUndoing = n, this.isRedoing = i
          }
          return e.prototype.containsEvent = function ( e ) {
            for ( let t = 0, n = this.changes.length; t < n; t++ ) {
              if ( this.changes[ t ].changeType === e ) return !0
            }
            return !1
          }, e.merge = ( t, n ) => {
            return new e( [].concat( t.changes ).concat( n.changes ), n.versionId, t.isUndoing || n.isUndoing, t.isRedoing || n.isRedoing )
          }, e;
        } )(),
        b = ( () => {
          function e( e, t ) {
            this.rawContentChangedEvent = e, this.contentChangedEvent = t
          }
          return e.prototype.merge = function ( t ) {
            const n = y.merge( this.rawContentChangedEvent, t.rawContentChangedEvent ),
              i = e._mergeChangeEvents( this.contentChangedEvent, t.contentChangedEvent );
            return new e( n, i )
          }, e._mergeChangeEvents = ( e, t ) => {
            return {
              changes: [].concat( e.changes ).concat( t.changes ),
              eol: t.eol,
              versionId: t.versionId,
              isUndoing: e.isUndoing || t.isUndoing,
              isRedoing: e.isRedoing || t.isRedoing,
              isFlush: e.isFlush || t.isFlush
            }
          }, e;
        } )(),
        C = n( "N0LK" );

      function w( e ) {
        return ( 1 & e.metadata ) >>> 0
      }

      function S( e, t ) {
        e.metadata = 254 & e.metadata | t << 0
      }

      function O( e ) {
        return ( 2 & e.metadata ) >>> 1 === 1
      }

      function L( e, t ) {
        e.metadata = 253 & e.metadata | ( t ? 1 : 0 ) << 1
      }

      function x( e ) {
        return ( 4 & e.metadata ) >>> 2 === 1
      }

      function N( e, t ) {
        e.metadata = 251 & e.metadata | ( t ? 1 : 0 ) << 2
      }

      function E( e ) {
        return ( 8 & e.metadata ) >>> 3 === 1
      }

      function k( e, t ) {
        e.metadata = 247 & e.metadata | ( t ? 1 : 0 ) << 3
      }

      function I( e, t ) {
        e.metadata = 207 & e.metadata | t << 4
      }
      const D = ( () => {
          function e( e, t, n ) {
            this.metadata = 0, this.parent = null, this.left = null, this.right = null, S( this, 1 ), this.start = t, this.end = n, this.delta = 0, this.maxEnd = n, this.id = e, this.ownerId = 0, this.options = null, N( this, !1 ), I( this, 1 ), k( this, !1 ), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = n, this.range = null, L( this, !1 )
          }
          return e.prototype.reset = function ( e, t, n, i ) {
            this.start = t, this.end = n, this.maxEnd = n, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = n, this.range = i
          }, e.prototype.setOptions = function ( e ) {
            this.options = e;
            const t = this.options.className;
            N( this, "squiggly-error" === t || "squiggly-warning" === t || "squiggly-info" === t ), I( this, this.options.stickiness ), k( this, !!this.options.overviewRuler.color )
          }, e.prototype.setCachedOffsets = function ( e, t, n ) {
            this.cachedVersionId !== n && ( this.range = null ), this.cachedVersionId = n, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t
          }, e.prototype.detach = function () {
            this.parent = null, this.left = null, this.right = null
          }, e;
        } )(),
        M = new D( null, 0, 0 );
      M.parent = M, M.left = M, M.right = M, S( M, 0 );
      const T = ( () => {
        function e() {
          this.root = M, this.requestNormalizeDelta = !1
        }
        return e.prototype.intervalSearch = function ( e, t, n, i, o ) {
          return this.root === M ? [] : ( ( e, t, n, i, o, r ) => {
            let s = e.root;
            let a = 0;
            let u = 0;
            let l = 0;
            const c = [];
            let d = 0;
            for ( ; s !== M; )
              if ( O( s ) ) L( s.left, !1 ), L( s.right, !1 ), s === s.parent.right && ( a -= s.parent.delta ), s = s.parent;
              else {
                if ( !O( s.left ) ) {
                  if ( a + s.maxEnd < t ) {
                    L( s, !0 );
                    continue
                  }
                  if ( s.left !== M ) {
                    s = s.left;
                    continue
                  }
                }
                if ( ( u = a + s.start ) > n ) L( s, !0 );
                else {
                  if ( ( l = a + s.end ) >= t ) {
                    s.setCachedOffsets( u, l, r );
                    let h = !0;
                    i && s.ownerId && s.ownerId !== i && ( h = !1 ), o && x( s ) && ( h = !1 ), h && ( c[ d++ ] = s )
                  }
                  L( s, !0 ), s.right === M || O( s.right ) || ( a += s.delta, s = s.right )
                }
              } return L( e.root, !1 ), c
          } )( this, e, t, n, i, o );
        }, e.prototype.search = function ( e, t, n ) {
          return this.root === M ? [] : ( ( e, t, n, i ) => {
            let o = e.root;
            let r = 0;
            let s = 0;
            let a = 0;
            const u = [];
            let l = 0;
            for ( ; o !== M; )
              if ( O( o ) ) L( o.left, !1 ), L( o.right, !1 ), o === o.parent.right && ( r -= o.parent.delta ), o = o.parent;
              else if ( o.left === M || O( o.left ) ) {
              s = r + o.start, a = r + o.end, o.setCachedOffsets( s, a, i );
              let c = !0;
              t && o.ownerId && o.ownerId !== t && ( c = !1 ), n && x( o ) && ( c = !1 ), c && ( u[ l++ ] = o ), L( o, !0 ), o.right === M || O( o.right ) || ( r += o.delta, o = o.right )
            } else o = o.left;
            return L( e.root, !1 ), u
          } )( this, e, t, n );
        }, e.prototype.collectNodesFromOwner = function ( e ) {
          return ( ( e, t ) => {
            let n = e.root;
            const i = [];
            let o = 0;
            for ( ; n !== M; ) O( n ) ? ( L( n.left, !1 ), L( n.right, !1 ), n = n.parent ) : n.left === M || O( n.left ) ? ( n.ownerId === t && ( i[ o++ ] = n ), L( n, !0 ), n.right === M || O( n.right ) || ( n = n.right ) ) : n = n.left;
            return L( e.root, !1 ), i
          } )( this, e );
        }, e.prototype.collectNodesPostOrder = function () {
          return ( e => {
            let t = e.root;
            const n = [];
            let i = 0;
            for ( ; t !== M; ) O( t ) ? ( L( t.left, !1 ), L( t.right, !1 ), t = t.parent ) : t.left === M || O( t.left ) ? t.right === M || O( t.right ) ? ( n[ i++ ] = t, L( t, !0 ) ) : t = t.right : t = t.left;
            return L( e.root, !1 ), n
          } )( this );
        }, e.prototype.insert = function ( e ) {
          A( this, e ), this._normalizeDeltaIfNecessary()
        }, e.prototype.delete = function ( e ) {
          F( this, e ), this._normalizeDeltaIfNecessary()
        }, e.prototype.resolveNode = function ( e, t ) {
          for ( var n = e, i = 0; e !== this.root; ) e === e.parent.right && ( i += e.parent.delta ), e = e.parent;
          const o = n.start + i,
            r = n.end + i;
          n.setCachedOffsets( o, r, t )
        }, e.prototype.acceptReplace = function ( e, t, n, i ) {
          for ( var o = ( ( e, t, n ) => {
              let i = e.root;
              let o = 0;
              let r = 0;
              let s = 0;
              const a = [];
              let u = 0;
              for ( ; i !== M; )
                if ( O( i ) ) L( i.left, !1 ), L( i.right, !1 ), i === i.parent.right && ( o -= i.parent.delta ), i = i.parent;
                else {
                  if ( !O( i.left ) ) {
                    if ( o + i.maxEnd < t ) {
                      L( i, !0 );
                      continue
                    }
                    if ( i.left !== M ) {
                      i = i.left;
                      continue
                    }
                  }( r = o + i.start ) > n ? L( i, !0 ) : ( ( s = o + i.end ) >= t && ( i.setCachedOffsets( r, s, 0 ), a[ u++ ] = i ), L( i, !0 ), i.right === M || O( i.right ) || ( o += i.delta, i = i.right ) )
                } return L( e.root, !1 ), a
            } )( this, e, e + t ), r = 0, s = o.length; r < s; r++ ) {
            F( this, a = o[ r ] )
          }
          this._normalizeDeltaIfNecessary(), ( ( e, t, n, i ) => {
            let o = e.root;
            let r = 0;
            const s = i - ( n - t );
            for ( ; o !== M; )
              if ( O( o ) ) L( o.left, !1 ), L( o.right, !1 ), o === o.parent.right && ( r -= o.parent.delta ), H( o ), o = o.parent;
              else {
                if ( !O( o.left ) ) {
                  if ( r + o.maxEnd < t ) {
                    L( o, !0 );
                    continue
                  }
                  if ( o.left !== M ) {
                    o = o.left;
                    continue
                  }
                }
                r + o.start > n ? ( o.start += s, o.end += s, o.delta += s, ( o.delta < -1073741824 || o.delta > 1073741824 ) && ( e.requestNormalizeDelta = !0 ), L( o, !0 ) ) : ( L( o, !0 ), o.right === M || O( o.right ) || ( r += o.delta, o = o.right ) )
              } L( e.root, !1 )
          } )( this, e, e + t, n ), this._normalizeDeltaIfNecessary();
          for ( r = 0, s = o.length; r < s; r++ ) {
            var a;
            ( a = o[ r ] ).start = a.cachedAbsoluteStart, a.end = a.cachedAbsoluteEnd, P( a, e, e + t, n, i ), a.maxEnd = a.end, A( this, a )
          }
          this._normalizeDeltaIfNecessary()
        }, e.prototype._normalizeDeltaIfNecessary = function () {
          this.requestNormalizeDelta && ( this.requestNormalizeDelta = !1, ( e => {
            let t = e.root,
              n = 0;
            for ( ; t !== M; ) t.left === M || O( t.left ) ? t.right === M || O( t.right ) ? ( t.start = n + t.start, t.end = n + t.end, t.delta = 0, H( t ), L( t, !0 ), L( t.left, !1 ), L( t.right, !1 ), t === t.parent.right && ( n -= t.parent.delta ), t = t.parent ) : ( n += t.delta, t = t.right ) : t = t.left;
            L( e.root, !1 )
          } )( this ) )
        }, e;
      } )();

      function R( e, t, n, i ) {
        return e < n || !( e > n ) && ( 1 !== i && ( 2 === i || t ) )
      }

      function P( e, t, n, i, o ) {
        const r = ( e => {
          return ( 48 & e.metadata ) >>> 4
        } )( e );
        const s = 0 === r || 2 === r;
        const a = 1 === r || 2 === r;
        const u = n - t;
        const l = i;
        const c = Math.min( u, l );
        const d = e.start;
        let h = !1;
        const p = e.end;
        let f = !1;
        let g = o ? 1 : u > 0 ? 2 : 0;
        if ( !h && R( d, s, t, g ) && ( h = !0 ), !f && R( p, a, t, g ) && ( f = !0 ), c > 0 && !o ) {
          g = u > l ? 2 : 0;
          !h && R( d, s, t + c, g ) && ( h = !0 ), !f && R( p, a, t + c, g ) && ( f = !0 )
        }
        g = o ? 1 : 0;
        !h && R( d, s, n, g ) && ( e.start = t + l, h = !0 ), !f && R( p, a, n, g ) && ( e.end = t + l, f = !0 );
        const m = l - u;
        h || ( e.start = Math.max( 0, d + m ), h = !0 ), f || ( e.end = Math.max( 0, p + m ), f = !0 ), e.start > e.end && ( e.end = e.start )
      }

      function A( e, t ) {
        if ( e.root === M ) return t.parent = M, t.left = M, t.right = M, S( t, 0 ), e.root = t, e.root;
        !( ( e, t ) => {
          let n = 0;
          let i = e.root;
          const o = t.start;
          const r = t.end;
          for ( ;; ) {
            if ( U( o, r, i.start + n, i.end + n ) < 0 ) {
              if ( i.left === M ) {
                t.start -= n, t.end -= n, t.maxEnd -= n, i.left = t;
                break
              }
              i = i.left
            } else {
              if ( i.right === M ) {
                t.start -= n + i.delta, t.end -= n + i.delta, t.maxEnd -= n + i.delta, i.right = t;
                break
              }
              n += i.delta, i = i.right
            }
          }
          t.parent = i, t.left = M, t.right = M, S( t, 1 )
        } )( e, t ), z( t.parent );
        for ( let n = t; n !== e.root && 1 === w( n.parent ); ) {
          let i;
          if ( n.parent === n.parent.parent.left ) 1 === w( i = n.parent.parent.right ) ? ( S( n.parent, 0 ), S( i, 0 ), S( n.parent.parent, 1 ), n = n.parent.parent ) : ( n === n.parent.right && j( e, n = n.parent ), S( n.parent, 0 ), S( n.parent.parent, 1 ), V( e, n.parent.parent ) );
          else 1 === w( i = n.parent.parent.left ) ? ( S( n.parent, 0 ), S( i, 0 ), S( n.parent.parent, 1 ), n = n.parent.parent ) : ( n === n.parent.left && V( e, n = n.parent ), S( n.parent, 0 ), S( n.parent.parent, 1 ), j( e, n.parent.parent ) )
        }
        return S( e.root, 0 ), t
      }

      function F( e, t ) {
        let n, i;
        if ( t.left === M ? ( i = t, ( n = t.right ).delta += t.delta, ( n.delta < -1073741824 || n.delta > 1073741824 ) && ( e.requestNormalizeDelta = !0 ), n.start += t.delta, n.end += t.delta ) : t.right === M ? ( n = t.left, i = t ) : ( ( n = ( i = ( e => {
            for ( ; e.left !== M; ) e = e.left;
            return e
          } )( t.right ) ).right ).start += i.delta, n.end += i.delta, n.delta += i.delta, ( n.delta < -1073741824 || n.delta > 1073741824 ) && ( e.requestNormalizeDelta = !0 ), i.start += t.delta, i.end += t.delta, i.delta = t.delta, ( i.delta < -1073741824 || i.delta > 1073741824 ) && ( e.requestNormalizeDelta = !0 ) ), i === e.root ) return e.root = n, S( n, 0 ), t.detach(), W(), H( n ), void( e.root.parent = M );
        let o;
        const r = 1 === w( i );
        if ( i === i.parent.left ? i.parent.left = n : i.parent.right = n, i === t ? n.parent = i.parent : ( i.parent === t ? n.parent = i : n.parent = i.parent, i.left = t.left, i.right = t.right, i.parent = t.parent, S( i, w( t ) ), t === e.root ? e.root = i : t === t.parent.left ? t.parent.left = i : t.parent.right = i, i.left !== M && ( i.left.parent = i ), i.right !== M && ( i.right.parent = i ) ), t.detach(), r ) return z( n.parent ), i !== t && ( z( i ), z( i.parent ) ), void W();
        for ( z( n ), z( n.parent ), i !== t && ( z( i ), z( i.parent ) ); n !== e.root && 0 === w( n ); ) n === n.parent.left ? ( 1 === w( o = n.parent.right ) && ( S( o, 0 ), S( n.parent, 1 ), j( e, n.parent ), o = n.parent.right ), 0 === w( o.left ) && 0 === w( o.right ) ? ( S( o, 1 ), n = n.parent ) : ( 0 === w( o.right ) && ( S( o.left, 0 ), S( o, 1 ), V( e, o ), o = n.parent.right ), S( o, w( n.parent ) ), S( n.parent, 0 ), S( o.right, 0 ), j( e, n.parent ), n = e.root ) ) : ( 1 === w( o = n.parent.left ) && ( S( o, 0 ), S( n.parent, 1 ), V( e, n.parent ), o = n.parent.left ), 0 === w( o.left ) && 0 === w( o.right ) ? ( S( o, 1 ), n = n.parent ) : ( 0 === w( o.left ) && ( S( o.right, 0 ), S( o, 1 ), j( e, o ), o = n.parent.left ), S( o, w( n.parent ) ), S( n.parent, 0 ), S( o.left, 0 ), V( e, n.parent ), n = e.root ) );
        S( n, 0 ), W()
      }

      function W() {
        M.parent = M, M.delta = 0, M.start = 0, M.end = 0
      }

      function j( e, t ) {
        const n = t.right;
        n.delta += t.delta, ( n.delta < -1073741824 || n.delta > 1073741824 ) && ( e.requestNormalizeDelta = !0 ), n.start += t.delta, n.end += t.delta, t.right = n.left, n.left !== M && ( n.left.parent = t ), n.parent = t.parent, t.parent === M ? e.root = n : t === t.parent.left ? t.parent.left = n : t.parent.right = n, n.left = t, t.parent = n, H( t ), H( n )
      }

      function V( e, t ) {
        const n = t.left;
        t.delta -= n.delta, ( t.delta < -1073741824 || t.delta > 1073741824 ) && ( e.requestNormalizeDelta = !0 ), t.start -= n.delta, t.end -= n.delta, t.left = n.right, n.right !== M && ( n.right.parent = t ), n.parent = t.parent, t.parent === M ? e.root = n : t === t.parent.right ? t.parent.right = n : t.parent.left = n, n.right = t, t.parent = n, H( t ), H( n )
      }

      function B( e ) {
        let t = e.end;
        if ( e.left !== M ) {
          const n = e.left.maxEnd;
          n > t && ( t = n )
        }
        if ( e.right !== M ) {
          const i = e.right.maxEnd + e.delta;
          i > t && ( t = i )
        }
        return t
      }

      function H( e ) {
        e.maxEnd = B( e )
      }

      function z( e ) {
        for ( ; e !== M; ) {
          const t = B( e );
          if ( e.maxEnd === t ) return;
          e.maxEnd = t, e = e.parent
        }
      }

      function U( e, t, n, i ) {
        return e === n ? t - i : e - n
      }
      const K = n( "pmY6" ),
        q = n( "MNsG" ),
        G = q.b.performance && "function" === typeof q.b.performance.now,
        Y = ( () => {
          function e( e ) {
            this._highResolution = G && e, this._startTime = this._now(), this._stopTime = -1
          }
          return e.create = t => {
            return void 0 === t && ( t = !0 ), new e( t )
          }, e.prototype.elapsed = function () {
            return -1 !== this._stopTime ? this._stopTime - this._startTime : this._now() - this._startTime
          }, e.prototype._now = function () {
            return this._highResolution ? q.b.performance.now() : ( new Date ).getTime()
          }, e;
        } )(),
        X = n( "i/Ef" ),
        $ = n( "BFtn" ),
        Z = n( "EIAu" ),
        Q = n( "cGHE" ),
        J = n( "cMvZ" ),
        ee = n( "0JNc" ),
        te = n( "4bUh" ),
        ne = n( "6OMU" );

      function ie( e ) {
        return ( 16384 | e << 0 | 2 << 23 ) >>> 0
      }
      const oe = new Uint32Array( 0 ).buffer,
        re = ( () => {
          function e( e ) {
            this._state = e, this._lineTokens = null, this._invalid = !0
          }
          return e.prototype.deleteBeginning = function ( e ) {
            null !== this._lineTokens && this._lineTokens !== oe && this.delete( 0, e )
          }, e.prototype.deleteEnding = function ( e ) {
            if ( null !== this._lineTokens && this._lineTokens !== oe ) {
              const t = new Uint32Array( this._lineTokens ),
                n = t[ t.length - 2 ];
              this.delete( e, n )
            }
          }, e.prototype.delete = function ( e, t ) {
            if ( null !== this._lineTokens && this._lineTokens !== oe && e !== t ) {
              const n = new Uint32Array( this._lineTokens ),
                i = n.length >>> 1;
              if ( 0 !== e || n[ n.length - 2 ] !== t ) {
                const o = te.a.findIndexInTokensArray( n, e ),
                  r = o > 0 ? n[ o - 1 << 1 ] : 0;
                if ( t < n[ o << 1 ] )
                  for ( let s = t - e, a = o; a < i; a++ ) n[ a << 1 ] -= s;
                else {
                  let u, l;
                  r !== e ? ( n[ o << 1 ] = e, u = o + 1 << 1, l = e ) : ( u = o << 1, l = r );
                  for ( let c = t - e, d = o + 1; d < i; d++ ) {
                    const h = n[ d << 1 ] - c;
                    h > l && ( n[ u++ ] = h, n[ u++ ] = n[ 1 + ( d << 1 ) ], l = h )
                  }
                  if ( u !== n.length ) {
                    const p = new Uint32Array( u );
                    p.set( n.subarray( 0, u ), 0 ), this._lineTokens = p.buffer
                  }
                }
              } else this._lineTokens = oe
            }
          }, e.prototype.append = function ( e ) {
            if ( e !== oe )
              if ( this._lineTokens !== oe ) {
                if ( null !== this._lineTokens )
                  if ( null !== e ) {
                    const t = new Uint32Array( this._lineTokens ),
                      n = new Uint32Array( e ),
                      i = n.length >>> 1,
                      o = new Uint32Array( t.length + n.length );
                    o.set( t, 0 );
                    for ( let r = t.length, s = t[ t.length - 2 ], a = 0; a < i; a++ ) o[ r++ ] = n[ a << 1 ] + s, o[ r++ ] = n[ 1 + ( a << 1 ) ];
                    this._lineTokens = o.buffer
                  } else this._lineTokens = null
              } else this._lineTokens = e
          }, e.prototype.insert = function ( e, t ) {
            if ( this._lineTokens ) {
              const n = new Uint32Array( this._lineTokens );
              const i = n.length >>> 1;
              let o = te.a.findIndexInTokensArray( n, e );
              if ( o > 0 )( o > 0 ? n[ o - 1 << 1 ] : 0 ) === e && o--;
              for ( let r = o; r < i; r++ ) n[ r << 1 ] += t
            }
          }, e;
        } )(),
        se = ( () => {
          function e( e, t ) {
            if ( this.languageIdentifier = e, this.tokenizationSupport = t, this._tokens = [], this.tokenizationSupport ) {
              let n = null;
              try {
                n = this.tokenizationSupport.getInitialState()
              } catch ( i ) {
                Object( a.e )( i ), this.tokenizationSupport = null
              }
              n && ( this._tokens[ 0 ] = new re( n ) )
            }
            this._invalidLineStartIndex = 0, this._lastState = null
          }
          return Object.defineProperty( e.prototype, "inValidLineStartIndex", {
            get() {
              return this._invalidLineStartIndex
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.getTokens = function ( e, t, n ) {
            let i = null;
            if ( t < this._tokens.length && this._tokens[ t ] && ( i = this._tokens[ t ]._lineTokens ), null !== i && i !== oe ) return new te.a( new Uint32Array( i ), n );
            const o = new Uint32Array( 2 );
            return o[ 0 ] = n.length, o[ 1 ] = ie( e ), new te.a( o, n )
          }, e.prototype.isCheapToTokenize = function ( e ) {
            return this._invalidLineStartIndex + 1 >= e
          }, e.prototype.hasLinesToTokenize = function ( e ) {
            return this._invalidLineStartIndex < e.getLineCount()
          }, e.prototype.invalidateLine = function ( e ) {
            this._setIsInvalid( e, !0 ), e < this._invalidLineStartIndex && ( this._setIsInvalid( this._invalidLineStartIndex, !0 ), this._invalidLineStartIndex = e )
          }, e.prototype._setIsInvalid = function ( e, t ) {
            e < this._tokens.length && this._tokens[ e ] && ( this._tokens[ e ]._invalid = t )
          }, e.prototype._isInvalid = function ( e ) {
            return !( e < this._tokens.length && this._tokens[ e ] ) || this._tokens[ e ]._invalid
          }, e.prototype._getState = function ( e ) {
            return e < this._tokens.length && this._tokens[ e ] ? this._tokens[ e ]._state : null
          }, e.prototype._setTokens = function ( e, t, n, i ) {
            let o;
            t < this._tokens.length && this._tokens[ t ] ? o = this._tokens[ t ] : ( o = new re( null ), this._tokens[ t ] = o ), 0 !== n ? ( i && 0 !== i.length || ( ( i = new Uint32Array( 2 ) )[ 0 ] = 0, i[ 1 ] = ie( e ) ), te.a.convertToEndOffset( i, n ), o._lineTokens = i.buffer ) : o._lineTokens = oe
          }, e.prototype._setState = function ( e, t ) {
            if ( e < this._tokens.length && this._tokens[ e ] ) this._tokens[ e ]._state = t;
            else {
              const n = new re( t );
              this._tokens[ e ] = n
            }
          }, e.prototype.applyEdits = function ( e, t, n ) {
            for ( let i = e.endLineNumber - e.startLineNumber, o = t, r = Math.min( i, o ); r >= 0; r-- ) this.invalidateLine( e.startLineNumber + r - 1 );
            this._acceptDeleteRange( e ), this._acceptInsertText( new Q.a( e.startLineNumber, e.startColumn ), t, n )
          }, e.prototype._acceptDeleteRange = function ( e ) {
            const t = e.startLineNumber - 1;
            if ( !( t >= this._tokens.length ) )
              if ( e.startLineNumber !== e.endLineNumber ) {
                const n = this._tokens[ t ];
                n.deleteEnding( e.startColumn - 1 );
                const i = e.endLineNumber - 1;
                let o = null;
                if ( i < this._tokens.length ) {
                  const r = this._tokens[ i ];
                  r.deleteBeginning( e.endColumn - 1 ), o = r._lineTokens
                }
                n.append( o ), this._tokens.splice( e.startLineNumber, e.endLineNumber - e.startLineNumber )
              } else {
                if ( e.startColumn === e.endColumn ) return;
                this._tokens[ t ].delete( e.startColumn - 1, e.endColumn - 1 )
              }
          }, e.prototype._acceptInsertText = function ( e, t, n ) {
            if ( 0 !== t || 0 !== n ) {
              const i = e.lineNumber - 1;
              if ( !( i >= this._tokens.length ) )
                if ( 0 !== t ) {
                  const o = this._tokens[ i ];
                  o.deleteEnding( e.column - 1 ), o.insert( e.column - 1, n );
                  for ( var r = new Array( t ), s = t - 1; s >= 0; s-- ) r[ s ] = new re( null );
                  this._tokens = ne.a( this._tokens, e.lineNumber, r )
                } else this._tokens[ i ].insert( e.column - 1, n )
            }
          }, e.prototype._tokenizeOneLine = function ( e, t ) {
            if ( !this.hasLinesToTokenize( e ) ) return e.getLineCount() + 1;
            const n = this._invalidLineStartIndex + 1;
            return this._updateTokensUntilLine( e, t, n ), n
          }, e.prototype._tokenizeText = function ( e, t, n ) {
            let i = null;
            try {
              i = this.tokenizationSupport.tokenize2( t, n, 0 )
            } catch ( o ) {
              Object( a.e )( o )
            }
            return i || ( i = Object( X.e )( this.languageIdentifier.id, t, n, 0 ) ), i
          }, e.prototype._updateTokensUntilLine = function ( e, t, n ) {
            if ( this.tokenizationSupport ) {
              for ( var i = e.getLineCount(), o = n - 1, r = this._invalidLineStartIndex; r <= o; r++ ) {
                const s = r + 1;
                let u = null;
                const l = e.getLineContent( r + 1 );
                try {
                  const c = this._getState( r ).clone();
                  u = this.tokenizationSupport.tokenize2( l, c, 0 )
                } catch ( h ) {
                  Object( a.e )( h )
                }
                if ( u || ( u = Object( X.e )( this.languageIdentifier.id, l, this._getState( r ), 0 ) ), this._setTokens( this.languageIdentifier.id, r, l.length, u.tokens ), t.registerChangedTokens( r + 1 ), this._setIsInvalid( r, !1 ), s < i )
                  if ( null !== this._getState( s ) && u.endState.equals( this._getState( s ) ) ) {
                    for ( var d = r + 1; d < i && !this._isInvalid( d ); ) {
                      if ( d + 1 < i ) {
                        if ( null === this._getState( d + 1 ) ) break
                      } else if ( null === this._lastState ) break;
                      d++
                    }
                    this._invalidLineStartIndex = Math.max( this._invalidLineStartIndex, d ), r = d - 1
                  } else this._setState( s, u.endState );
                else this._lastState = u.endState
              }
              this._invalidLineStartIndex = Math.max( this._invalidLineStartIndex, o + 1 )
            } else this._invalidLineStartIndex = e.getLineCount()
          }, e;
        } )(),
        ae = ( () => {
          function e() {
            this._ranges = []
          }
          return e.prototype.registerChangedTokens = function ( e ) {
            const t = this._ranges,
              n = t.length,
              i = n > 0 ? t[ n - 1 ] : null;
            i && i.toLineNumber === e - 1 ? i.toLineNumber++ : t[ n ] = {
              fromLineNumber: e,
              toLineNumber: e
            }
          }, e.prototype.build = function () {
            return 0 === this._ranges.length ? null : {
              ranges: this._ranges
            }
          }, e;
        } )();

      function ue( e, t, n, i ) {
        let o;
        for ( o = 0; o < t && o < i; o++ ) {
          if ( e.charCodeAt( o ) !== n.charCodeAt( o ) ) break
        }
        for ( var r = 0, s = 0, a = o; a < t; a++ ) {
          32 === e.charCodeAt( a ) ? r++ : s++
        }
        let u = 0,
          l = 0;
        for ( a = o; a < i; a++ ) {
          32 === n.charCodeAt( a ) ? u++ : l++
        }
        if ( r > 0 && s > 0 ) return 0;
        if ( u > 0 && l > 0 ) return 0;
        const c = Math.abs( s - l ),
          d = Math.abs( r - u );
        return 0 === c ? d : d % c === 0 ? d / c : 0
      }

      function le( e, t, n ) {
        for ( var i = Math.min( e.getLineCount(), 1e4 ), o = 0, r = 0, s = "", a = 0, u = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ], l = 1; l <= i; l++ ) {
          for ( var c = e.getLineLength( l ), d = e.getLineContent( l ), h = c <= 65536, p = !1, f = 0, g = 0, m = 0, _ = 0, v = c; _ < v; _++ ) {
            const y = h ? d.charCodeAt( _ ) : e.getLineCharCode( l, _ );
            if ( 9 === y ) m++;
            else {
              if ( 32 !== y ) {
                p = !0, f = _;
                break
              }
              g++
            }
          }
          if ( p ) {
            m > 0 ? o++ : g > 1 && r++;
            const b = ue( s, a, d, f );
            b <= 8 && u[ b ]++, s = d, a = f
          }
        }
        let C = n;
        o !== r && ( C = o < r );
        let w = t,
          S = C ? 0 : .1 * i;
        return [ 2, 4, 6, 8 ].forEach( ( e => {
          const t = u[ e ];
          t > S && ( S = t, w = e )
        } ) ), {
          insertSpaces: C,
          tabSize: w
        };
      }
      const ce = n( "/UlZ" ),
        de = n( "jAJ/" ),
        he = ( () => {
          function e( e, t ) {
            this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = null, this.left = null, this.right = null
          }
          return e.prototype.next = function () {
            if ( this.right !== pe ) return fe( this.right );
            for ( var e = this; e.parent !== pe && e.parent.left !== e; ) e = e.parent;
            return e.parent === pe ? pe : e.parent
          }, e.prototype.prev = function () {
            if ( this.left !== pe ) return ge( this.left );
            for ( var e = this; e.parent !== pe && e.parent.right !== e; ) e = e.parent;
            return e.parent === pe ? pe : e.parent
          }, e.prototype.detach = function () {
            this.parent = null, this.left = null, this.right = null
          }, e
        } )(),
        pe = new he( null, 0 );

      function fe( e ) {
        for ( ; e.left !== pe; ) e = e.left;
        return e
      }

      function ge( e ) {
        for ( ; e.right !== pe; ) e = e.right;
        return e
      }

      function me( e ) {
        return e === pe ? 0 : e.size_left + e.piece.length + me( e.right )
      }

      function _e( e ) {
        return e === pe ? 0 : e.lf_left + e.piece.lineFeedCnt + _e( e.right )
      }

      function ve() {
        pe.parent = pe
      }

      function ye( e, t ) {
        const n = t.right;
        n.size_left += t.size_left + ( t.piece ? t.piece.length : 0 ), n.lf_left += t.lf_left + ( t.piece ? t.piece.lineFeedCnt : 0 ), t.right = n.left, n.left !== pe && ( n.left.parent = t ), n.parent = t.parent, t.parent === pe ? e.root = n : t.parent.left === t ? t.parent.left = n : t.parent.right = n, n.left = t, t.parent = n
      }

      function be( e, t ) {
        const n = t.left;
        t.left = n.right, n.right !== pe && ( n.right.parent = t ), n.parent = t.parent, t.size_left -= n.size_left + ( n.piece ? n.piece.length : 0 ), t.lf_left -= n.lf_left + ( n.piece ? n.piece.lineFeedCnt : 0 ), t.parent === pe ? e.root = n : t === t.parent.right ? t.parent.right = n : t.parent.left = n, n.right = t, t.parent = n
      }

      function Ce( e, t ) {
        let n, i;
        if ( n = t.left === pe ? ( i = t ).right : t.right === pe ? ( i = t ).left : ( i = fe( t.right ) ).right, i === e.root ) return e.root = n, n.color = 0, t.detach(), ve(), void( e.root.parent = pe );
        const o = 1 === i.color;
        if ( i === i.parent.left ? i.parent.left = n : i.parent.right = n, i === t ? ( n.parent = i.parent, Oe( e, n ) ) : ( i.parent === t ? n.parent = i : n.parent = i.parent, Oe( e, n ), i.left = t.left, i.right = t.right, i.parent = t.parent, i.color = t.color, t === e.root ? e.root = i : t === t.parent.left ? t.parent.left = i : t.parent.right = i, i.left !== pe && ( i.left.parent = i ), i.right !== pe && ( i.right.parent = i ), i.size_left = t.size_left, i.lf_left = t.lf_left, Oe( e, i ) ), t.detach(), n.parent.left === n ) {
          const r = me( n ),
            s = _e( n );
          if ( r !== n.parent.size_left || s !== n.parent.lf_left ) {
            const a = r - n.parent.size_left,
              u = s - n.parent.lf_left;
            n.parent.size_left = r, n.parent.lf_left = s, Se( e, n.parent, a, u )
          }
        }
        if ( Oe( e, n.parent ), o ) ve();
        else {
          for ( let l; n !== e.root && 0 === n.color; ) n === n.parent.left ? ( 1 === ( l = n.parent.right ).color && ( l.color = 0, n.parent.color = 1, ye( e, n.parent ), l = n.parent.right ), 0 === l.left.color && 0 === l.right.color ? ( l.color = 1, n = n.parent ) : ( 0 === l.right.color && ( l.left.color = 0, l.color = 1, be( e, l ), l = n.parent.right ), l.color = n.parent.color, n.parent.color = 0, l.right.color = 0, ye( e, n.parent ), n = e.root ) ) : ( 1 === ( l = n.parent.left ).color && ( l.color = 0, n.parent.color = 1, be( e, n.parent ), l = n.parent.left ), 0 === l.left.color && 0 === l.right.color ? ( l.color = 1, n = n.parent ) : ( 0 === l.left.color && ( l.right.color = 0, l.color = 1, ye( e, l ), l = n.parent.left ), l.color = n.parent.color, n.parent.color = 0, l.left.color = 0, be( e, n.parent ), n = e.root ) );
          n.color = 0, ve()
        }
      }

      function we( e, t ) {
        for ( Oe( e, t ); t !== e.root && 1 === t.parent.color; ) {
          let n;
          if ( t.parent === t.parent.parent.left ) 1 === ( n = t.parent.parent.right ).color ? ( t.parent.color = 0, n.color = 0, t.parent.parent.color = 1, t = t.parent.parent ) : ( t === t.parent.right && ye( e, t = t.parent ), t.parent.color = 0, t.parent.parent.color = 1, be( e, t.parent.parent ) );
          else 1 === ( n = t.parent.parent.left ).color ? ( t.parent.color = 0, n.color = 0, t.parent.parent.color = 1, t = t.parent.parent ) : ( t === t.parent.left && be( e, t = t.parent ), t.parent.color = 0, t.parent.parent.color = 1, ye( e, t.parent.parent ) )
        }
        e.root.color = 0
      }

      function Se( e, t, n, i ) {
        for ( ; t !== e.root && t !== pe; ) t.parent.left === t && ( t.parent.size_left += n, t.parent.lf_left += i ), t = t.parent
      }

      function Oe( e, t ) {
        let n = 0,
          i = 0;
        if ( t !== e.root ) {
          if ( 0 === n ) {
            for ( ; t !== e.root && t === t.parent.right; ) t = t.parent;
            if ( t === e.root ) return;
            n = me( ( t = t.parent ).left ) - t.size_left, i = _e( t.left ) - t.lf_left, t.size_left += n, t.lf_left += i
          }
          for ( ; t !== e.root && ( 0 !== n || 0 !== i ); ) t.parent.left === t && ( t.parent.size_left += n, t.parent.lf_left += i ), t = t.parent
        }
      }
      pe.parent = pe, pe.left = pe, pe.right = pe, pe.color = 0;

      function Le( e ) {
        let t;
        return ( t = e[ e.length - 1 ] < 65536 ? new Uint16Array( e.length ) : new Uint32Array( e.length ) ).set( e, 0 ), t
      }
      const xe = function ( e, t, n, i, o ) {
        this.lineStarts = e, this.cr = t, this.lf = n, this.crlf = i, this.isBasicASCII = o
      };

      function Ne( e, t ) {
        void 0 === t && ( t = !0 );
        for ( var n = [ 0 ], i = 1, o = 0, r = e.length; o < r; o++ ) {
          const s = e.charCodeAt( o );
          13 === s ? o + 1 < r && 10 === e.charCodeAt( o + 1 ) ? ( n[ i++ ] = o + 2, o++ ) : n[ i++ ] = o + 1 : 10 === s && ( n[ i++ ] = o + 1 )
        }
        return t ? Le( n ) : n
      }
      const Ee = function ( e, t, n, i, o ) {
          this.bufferIndex = e, this.start = t, this.end = n, this.lineFeedCnt = i, this.length = o
        },
        ke = function ( e, t ) {
          this.buffer = e, this.lineStarts = t
        },
        Ie = ( () => {
          function e( e ) {
            this._limit = e, this._cache = []
          }
          return e.prototype.get = function ( e ) {
            for ( let t = this._cache.length - 1; t >= 0; t-- ) {
              const n = this._cache[ t ];
              if ( n.nodeStartOffset <= e && n.nodeStartOffset + n.node.piece.length >= e ) return n
            }
            return null
          }, e.prototype.get2 = function ( e ) {
            for ( let t = this._cache.length - 1; t >= 0; t-- ) {
              const n = this._cache[ t ];
              if ( n.nodeStartLineNumber && n.nodeStartLineNumber < e && n.nodeStartLineNumber + n.node.piece.lineFeedCnt >= e ) return n
            }
            return null
          }, e.prototype.set = function ( e ) {
            this._cache.length >= this._limit && this._cache.shift(), this._cache.push( e )
          }, e.prototype.valdiate = function ( e ) {
            for ( var t = !1, n = 0; n < this._cache.length; n++ ) {
              const i = this._cache[ n ];
              ( null === i.node.parent || i.nodeStartOffset >= e ) && ( this._cache[ n ] = null, t = !0 )
            }
            if ( t ) {
              const o = [];
              for ( n = 0; n < this._cache.length; n++ ) null !== this._cache[ n ] && o.push( this._cache[ n ] );
              this._cache = o
            }
          }, e;
        } )(),
        De = ( () => {
          function e( e, t, n ) {
            this.create( e, t, n )
          }
          return e.prototype.create = function ( e, t, n ) {
            this._buffers = [ new ke( "", [ 0 ] ) ], this._lastChangeBufferPos = {
              line: 0,
              column: 0
            }, this.root = pe, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = n;
            for ( let i = null, o = 0, r = e.length; o < r; o++ )
              if ( e[ o ].buffer.length > 0 ) {
                e[ o ].lineStarts || ( e[ o ].lineStarts = Ne( e[ o ].buffer ) );
                const s = new Ee( o + 1, {
                  line: 0,
                  column: 0
                }, {
                  line: e[ o ].lineStarts.length - 1,
                  column: e[ o ].buffer.length - e[ o ].lineStarts[ e[ o ].lineStarts.length - 1 ]
                }, e[ o ].lineStarts.length - 1, e[ o ].buffer.length );
                this._buffers.push( e[ o ] ), i = this.rbInsertRight( i, s )
              } this._searchCache = new Ie( 1 ), this._lastVisitedLine = {
              lineNumber: 0,
              value: null
            }, this.computeBufferMetadata()
          }, e.prototype.normalizeEOL = function ( e ) {
            const t = this;
            const n = 65535 - Math.floor( 21845 );
            const i = 2 * n;
            let o = "";
            let r = 0;
            const s = [];
            if ( this.iterate( this.root, ( a => {
                const u = t.getNodeContent( a ),
                  l = u.length;
                if ( r <= n || r + l < i ) return o += u, r += l, !0;
                const c = o.replace( /\r\n|\r|\n/g, e );
                return s.push( new ke( c, Ne( c ) ) ), o = u, r = l, !0
              } ) ), r > 0 ) {
              const a = o.replace( /\r\n|\r|\n/g, e );
              s.push( new ke( a, Ne( a ) ) )
            }
            this.create( s, e, !0 )
          }, e.prototype.getEOL = function () {
            return this._EOL
          }, e.prototype.setEOL = function ( e ) {
            this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL( e )
          }, e.prototype.getOffsetAt = function ( e, t ) {
            for ( var n = 0, i = this.root; i !== pe; )
              if ( i.left !== pe && i.lf_left + 1 >= e ) i = i.left;
              else {
                if ( i.lf_left + i.piece.lineFeedCnt + 1 >= e ) return ( n += i.size_left ) + ( this.getAccumulatedValue( i, e - i.lf_left - 2 ) + t - 1 );
                e -= i.lf_left + i.piece.lineFeedCnt, n += i.size_left + i.piece.length, i = i.right
              } return n
          }, e.prototype.getPositionAt = function ( e ) {
            e = Math.floor( e ), e = Math.max( 0, e );
            for ( let t = this.root, n = 0, i = e; t !== pe; )
              if ( 0 !== t.size_left && t.size_left >= e ) t = t.left;
              else {
                if ( t.size_left + t.piece.length >= e ) {
                  const o = this.getIndexOf( t, e - t.size_left );
                  if ( n += t.lf_left + o.index, 0 === o.index ) {
                    var r = i - this.getOffsetAt( n + 1, 1 );
                    return new Q.a( n + 1, r + 1 )
                  }
                  return new Q.a( n + 1, o.remainder + 1 )
                }
                if ( e -= t.size_left + t.piece.length, n += t.lf_left + t.piece.lineFeedCnt, t.right === pe ) {
                  r = i - e - this.getOffsetAt( n + 1, 1 );
                  return new Q.a( n + 1, r + 1 )
                }
                t = t.right
              } return new Q.a( 1, 1 )
          }, e.prototype.getValueInRange = function ( e, t ) {
            if ( e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn ) return "";
            const n = this.nodeAt2( e.startLineNumber, e.startColumn ),
              i = this.nodeAt2( e.endLineNumber, e.endColumn ),
              o = this.getValueInRange2( n, i );
            return t ? t === this._EOL && this._EOLNormalized && t === this.getEOL() && this._EOLNormalized ? o : o.replace( /\r\n|\r|\n/g, t ) : o
          }, e.prototype.getValueInRange2 = function ( e, t ) {
            if ( e.node === t.node ) {
              const n = e.node,
                i = this._buffers[ n.piece.bufferIndex ].buffer,
                o = this.offsetInBuffer( n.piece.bufferIndex, n.piece.start );
              return i.substring( o + e.remainder, o + t.remainder )
            }
            let r = e.node;
            const s = this._buffers[ r.piece.bufferIndex ].buffer;
            const a = this.offsetInBuffer( r.piece.bufferIndex, r.piece.start );
            let u = s.substring( a + e.remainder, a + r.piece.length );
            for ( r = r.next(); r !== pe; ) {
              const l = this._buffers[ r.piece.bufferIndex ].buffer,
                c = this.offsetInBuffer( r.piece.bufferIndex, r.piece.start );
              if ( r === t.node ) {
                u += l.substring( c, c + t.remainder );
                break
              }
              u += l.substr( c, r.piece.length ), r = r.next()
            }
            return u
          }, e.prototype.getLinesContent = function () {
            return this.getContentOfSubTree( this.root ).split( /\r\n|\r|\n/ )
          }, e.prototype.getLength = function () {
            return this._length
          }, e.prototype.getLineCount = function () {
            return this._lineCnt
          }, e.prototype.getLineContent = function ( e ) {
            return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : ( this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent( e ) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent( e, this._EOLLength ) : this._lastVisitedLine.value = this.getLineRawContent( e ).replace( /(\r\n|\r|\n)$/, "" ), this._lastVisitedLine.value )
          }, e.prototype.getLineCharCode = function ( e, t ) {
            const n = this.nodeAt2( e, t + 1 );
            if ( n.remainder === n.node.piece.length ) {
              const i = n.node.next();
              if ( !i ) return 0;
              var o = this._buffers[ i.piece.bufferIndex ],
                r = this.offsetInBuffer( i.piece.bufferIndex, i.piece.start );
              return o.buffer.charCodeAt( r )
            }
            o = this._buffers[ n.node.piece.bufferIndex ];
            const s = ( r = this.offsetInBuffer( n.node.piece.bufferIndex, n.node.piece.start ) ) + n.remainder;
            return o.buffer.charCodeAt( s )
          }, e.prototype.getLineLength = function ( e ) {
            if ( e === this.getLineCount() ) {
              const t = this.getOffsetAt( e, 1 );
              return this.getLength() - t
            }
            return this.getOffsetAt( e + 1, 1 ) - this.getOffsetAt( e, 1 ) - this._EOLLength
          }, e.prototype.findMatchesInNode = function ( e, t, n, i, o, r, s, a, u, l, c ) {
            let d;
            const p = this._buffers[ e.piece.bufferIndex ];
            const f = this.offsetInBuffer( e.piece.bufferIndex, e.piece.start );
            const g = this.offsetInBuffer( e.piece.bufferIndex, o );
            const m = this.offsetInBuffer( e.piece.bufferIndex, r );
            t.reset( g );
            const _ = {
              line: 0,
              column: 0
            };
            do {
              if ( d = t.next( p.buffer ) ) {
                if ( d.index >= m ) return l;
                this.positionInBuffer( e, d.index - f, _ );
                const v = this.getLineFeedCnt( e.piece.bufferIndex, o, _ ),
                  y = _.line === o.line ? _.column - o.column + i : _.column + 1,
                  b = y + d[ 0 ].length;
                if ( c[ l++ ] = Object( de.d )( new h.a( n + v, y, n + v, b ), d, a ), d.index + d[ 0 ].length >= m ) return l;
                if ( l >= u ) return l
              }
            } while ( d );
            return l
          }, e.prototype.findMatchesLineByLine = function ( e, t, n, i ) {
            const o = [];
            let r = 0;
            const s = new de.b( t.wordSeparators, t.regex );
            let a = this.nodeAt2( e.startLineNumber, e.startColumn );
            if ( null === a ) return [];
            const u = this.nodeAt2( e.endLineNumber, e.endColumn );
            if ( null === u ) return [];
            let l = this.positionInBuffer( a.node, a.remainder );
            const c = this.positionInBuffer( u.node, u.remainder );
            if ( a.node === u.node ) return this.findMatchesInNode( a.node, s, e.startLineNumber, e.startColumn, l, c, t, n, i, r, o ), o;
            for ( var d = e.startLineNumber, h = a.node; h !== u.node; ) {
              const p = this.getLineFeedCnt( h.piece.bufferIndex, l, h.piece.end );
              if ( p >= 1 ) {
                const f = this._buffers[ h.piece.bufferIndex ].lineStarts,
                  g = this.offsetInBuffer( h.piece.bufferIndex, h.piece.start ),
                  m = f[ l.line + p ],
                  _ = d === e.startLineNumber ? e.startColumn : 1;
                if ( ( r = this.findMatchesInNode( h, s, d, _, l, this.positionInBuffer( h, m - g ), t, n, i, r, o ) ) >= i ) return o;
                d += p
              }
              const v = d === e.startLineNumber ? e.startColumn - 1 : 0;
              if ( d === e.endLineNumber ) {
                var y = this.getLineContent( d ).substring( v, e.endColumn - 1 );
                return r = this._findMatchesInLine( t, s, y, e.endLineNumber, v, r, o, n, i ), o
              }
              if ( ( r = this._findMatchesInLine( t, s, this.getLineContent( d ).substr( v ), d, v, r, o, n, i ) ) >= i ) return o;
              d++, h = ( a = this.nodeAt2( d, 1 ) ).node, l = this.positionInBuffer( a.node, a.remainder )
            }
            if ( d === e.endLineNumber ) {
              const b = d === e.startLineNumber ? e.startColumn - 1 : 0;
              y = this.getLineContent( d ).substring( b, e.endColumn - 1 );
              return r = this._findMatchesInLine( t, s, y, e.endLineNumber, b, r, o, n, i ), o
            }
            const C = d === e.startLineNumber ? e.startColumn : 1;
            return r = this.findMatchesInNode( u.node, s, d, C, l, c, t, n, i, r, o ), o
          }, e.prototype._findMatchesInLine = ( e, t, n, i, o, s, a, u, l ) => {
            let c;
            const d = e.wordSeparators;
            if ( !u && e.simpleSearch ) {
              for ( let p = e.simpleSearch, f = p.length, g = n.length, m = -f; - 1 !== ( m = n.indexOf( p, m + f ) ); )
                if ( ( !d || Object( de.e )( d, n, g, m, f ) ) && ( a[ s++ ] = new r.e( new h.a( i, m + 1 + o, i, m + 1 + f + o ), null ), s >= l ) ) return s;
              return s
            }
            t.reset( 0 );
            do {
              if ( ( c = t.next( n ) ) && ( a[ s++ ] = Object( de.d )( new h.a( i, c.index + 1 + o, i, c.index + 1 + c[ 0 ].length + o ), c, u ), s >= l ) ) return s
            } while ( c );
            return s
          }, e.prototype.insert = function ( e, t, n ) {
            if ( void 0 === n && ( n = !1 ), this._EOLNormalized = this._EOLNormalized && n, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = null, this.root !== pe ) {
              const i = this.nodeAt( e );
              var o = i.node;
              const r = i.remainder;
              const s = i.nodeStartOffset;
              const a = o.piece;
              const u = a.bufferIndex;
              const l = this.positionInBuffer( o, r );
              if ( 0 === o.piece.bufferIndex && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && s + a.length === e && t.length < 65535 ) return this.appendToNode( o, t ), void this.computeBufferMetadata();
              if ( s === e ) this.insertContentToNodeLeft( t, o ), this._searchCache.valdiate( e );
              else if ( s + o.piece.length > e ) {
                const c = [];
                let d = new Ee( a.bufferIndex, l, a.end, this.getLineFeedCnt( a.bufferIndex, l, a.end ), this.offsetInBuffer( u, a.end ) - this.offsetInBuffer( u, l ) );
                if ( this.shouldCheckCRLF() && this.endWithCR( t ) )
                  if ( 10 === this.nodeCharCodeAt( o, r ) ) {
                    const h = {
                      line: d.start.line + 1,
                      column: 0
                    };
                    d = new Ee( d.bufferIndex, h, d.end, this.getLineFeedCnt( d.bufferIndex, h, d.end ), d.length - 1 ), t += "\n"
                  } if ( this.shouldCheckCRLF() && this.startWithLF( t ) )
                  if ( 13 === this.nodeCharCodeAt( o, r - 1 ) ) {
                    const p = this.positionInBuffer( o, r - 1 );
                    this.deleteNodeTail( o, p ), t = "\r" + t, 0 === o.piece.length && c.push( o )
                  } else this.deleteNodeTail( o, l );
                else this.deleteNodeTail( o, l );
                const f = this.createNewPieces( t );
                d.length > 0 && this.rbInsertRight( o, d );
                for ( var g = o, m = 0; m < f.length; m++ ) g = this.rbInsertRight( g, f[ m ] );
                this.deleteNodes( c )
              } else this.insertContentToNodeRight( t, o )
            } else {
              const _ = this.createNewPieces( t );
              for ( o = this.rbInsertLeft( null, _[ 0 ] ), m = 1; m < _.length; m++ ) o = this.rbInsertRight( o, _[ m ] )
            }
            this.computeBufferMetadata()
          }, e.prototype.delete = function ( e, t ) {
            if ( this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = null, !( t <= 0 || this.root === pe ) ) {
              const n = this.nodeAt( e ),
                i = this.nodeAt( e + t ),
                o = n.node,
                r = i.node;
              if ( o === r ) {
                const s = this.positionInBuffer( o, n.remainder ),
                  a = this.positionInBuffer( o, i.remainder );
                if ( n.nodeStartOffset === e ) {
                  if ( t === o.piece.length ) {
                    const u = o.next();
                    return Ce( this, o ), this.validateCRLFWithPrevNode( u ), void this.computeBufferMetadata()
                  }
                  return this.deleteNodeHead( o, a ), this._searchCache.valdiate( e ), this.validateCRLFWithPrevNode( o ), void this.computeBufferMetadata()
                }
                return n.nodeStartOffset + o.piece.length === e + t ? ( this.deleteNodeTail( o, s ), this.validateCRLFWithNextNode( o ), void this.computeBufferMetadata() ) : ( this.shrinkNode( o, s, a ), void this.computeBufferMetadata() )
              }
              const l = [],
                c = this.positionInBuffer( o, n.remainder );
              this.deleteNodeTail( o, c ), this._searchCache.valdiate( e ), 0 === o.piece.length && l.push( o );
              const d = this.positionInBuffer( r, i.remainder );
              this.deleteNodeHead( r, d ), 0 === r.piece.length && l.push( r );
              for ( let h = o.next(); h !== pe && h !== r; h = h.next() ) l.push( h );
              const p = 0 === o.piece.length ? o.prev() : o;
              this.deleteNodes( l ), this.validateCRLFWithNextNode( p ), this.computeBufferMetadata()
            }
          }, e.prototype.insertContentToNodeLeft = function ( e, t ) {
            const n = [];
            if ( this.shouldCheckCRLF() && this.endWithCR( e ) && this.startWithLF( t ) ) {
              const i = t.piece,
                o = {
                  line: i.start.line + 1,
                  column: 0
                },
                r = new Ee( i.bufferIndex, o, i.end, this.getLineFeedCnt( i.bufferIndex, o, i.end ), i.length - 1 );
              t.piece = r, e += "\n", Se( this, t, -1, -1 ), 0 === t.piece.length && n.push( t )
            }
            for ( var s = this.createNewPieces( e ), a = this.rbInsertLeft( t, s[ s.length - 1 ] ), u = s.length - 2; u >= 0; u-- ) a = this.rbInsertLeft( a, s[ u ] );
            this.validateCRLFWithPrevNode( a ), this.deleteNodes( n )
          }, e.prototype.insertContentToNodeRight = function ( e, t ) {
            this.adjustCarriageReturnFromNext( e, t ) && ( e += "\n" );
            for ( var n = this.createNewPieces( e ), i = this.rbInsertRight( t, n[ 0 ] ), o = i, r = 1; r < n.length; r++ ) o = this.rbInsertRight( o, n[ r ] );
            this.validateCRLFWithPrevNode( i )
          }, e.prototype.positionInBuffer = function ( e, t, n ) {
            for ( var i, o, r, s = e.piece, a = e.piece.bufferIndex, u = this._buffers[ a ].lineStarts, l = u[ s.start.line ] + s.start.column + t, c = s.start.line, d = s.end.line; c <= d && ( r = u[ i = c + ( d - c ) / 2 | 0 ], i !== d ); )
              if ( o = u[ i + 1 ], l < r ) d = i - 1;
              else {
                if ( !( l >= o ) ) break;
                c = i + 1
              } return n ? ( n.line = i, n.column = l - r, null ) : {
              line: i,
              column: l - r
            }
          }, e.prototype.getLineFeedCnt = function ( e, t, n ) {
            if ( 0 === n.column ) return n.line - t.line;
            const i = this._buffers[ e ].lineStarts;
            if ( n.line === i.length - 1 ) return n.line - t.line;
            const o = i[ n.line + 1 ],
              r = i[ n.line ] + n.column;
            if ( o > r + 1 ) return n.line - t.line;
            const s = r - 1;
            return 13 === this._buffers[ e ].buffer.charCodeAt( s ) ? n.line - t.line + 1 : n.line - t.line
          }, e.prototype.offsetInBuffer = function ( e, t ) {
            return this._buffers[ e ].lineStarts[ t.line ] + t.column
          }, e.prototype.deleteNodes = function ( e ) {
            for ( let t = 0; t < e.length; t++ ) Ce( this, e[ t ] )
          }, e.prototype.createNewPieces = function ( e ) {
            if ( e.length > 65535 ) {
              for ( var t = []; e.length > 65535; ) {
                const n = e.charCodeAt( 65534 );
                let i = void 0;
                13 === n || n >= 55296 && n <= 56319 ? ( i = e.substring( 0, 65534 ), e = e.substring( 65534 ) ) : ( i = e.substring( 0, 65535 ), e = e.substring( 65535 ) );
                const o = Ne( i );
                t.push( new Ee( this._buffers.length, {
                  line: 0,
                  column: 0
                }, {
                  line: o.length - 1,
                  column: i.length - o[ o.length - 1 ]
                }, o.length - 1, i.length ) ), this._buffers.push( new ke( i, o ) )
              }
              const r = Ne( e );
              return t.push( new Ee( this._buffers.length, {
                line: 0,
                column: 0
              }, {
                line: r.length - 1,
                column: e.length - r[ r.length - 1 ]
              }, r.length - 1, e.length ) ), this._buffers.push( new ke( e, r ) ), t
            }
            let s = this._buffers[ 0 ].buffer.length;
            const a = Ne( e, !1 );
            let u = this._lastChangeBufferPos;
            if ( this._buffers[ 0 ].lineStarts[ this._buffers[ 0 ].lineStarts.length - 1 ] === s && 0 !== s && this.startWithLF( e ) && this.endWithCR( this._buffers[ 0 ].buffer ) ) {
              this._lastChangeBufferPos = {
                line: this._lastChangeBufferPos.line,
                column: this._lastChangeBufferPos.column + 1
              }, u = this._lastChangeBufferPos;
              for ( var l = 0; l < a.length; l++ ) a[ l ] += s + 1;
              this._buffers[ 0 ].lineStarts = this._buffers[ 0 ].lineStarts.concat( a.slice( 1 ) ), this._buffers[ 0 ].buffer += "_" + e, s += 1
            } else {
              if ( 0 !== s )
                for ( l = 0; l < a.length; l++ ) a[ l ] += s;
              this._buffers[ 0 ].lineStarts = this._buffers[ 0 ].lineStarts.concat( a.slice( 1 ) ), this._buffers[ 0 ].buffer += e
            }
            const c = this._buffers[ 0 ].buffer.length,
              d = this._buffers[ 0 ].lineStarts.length - 1,
              h = {
                line: d,
                column: c - this._buffers[ 0 ].lineStarts[ d ]
              },
              p = new Ee( 0, u, h, this.getLineFeedCnt( 0, u, h ), c - s );
            return this._lastChangeBufferPos = h, [ p ]
          }, e.prototype.getLineRawContent = function ( e, t ) {
            void 0 === t && ( t = 0 );
            let n = this.root;
            let i = "";
            const o = this._searchCache.get2( e );
            if ( o ) {
              n = o.node;
              var r = this.getAccumulatedValue( n, e - o.nodeStartLineNumber - 1 ),
                s = this._buffers[ n.piece.bufferIndex ].buffer,
                a = this.offsetInBuffer( n.piece.bufferIndex, n.piece.start );
              if ( o.nodeStartLineNumber + n.piece.lineFeedCnt !== e ) {
                var u = this.getAccumulatedValue( n, e - o.nodeStartLineNumber );
                return s.substring( a + r, a + u - t )
              }
              i = s.substring( a + r, a + n.piece.length )
            } else
              for ( let l = 0, c = e; n !== pe; )
                if ( n.left !== pe && n.lf_left >= e - 1 ) n = n.left;
                else {
                  if ( n.lf_left + n.piece.lineFeedCnt > e - 1 ) {
                    r = this.getAccumulatedValue( n, e - n.lf_left - 2 ), u = this.getAccumulatedValue( n, e - n.lf_left - 1 ), s = this._buffers[ n.piece.bufferIndex ].buffer, a = this.offsetInBuffer( n.piece.bufferIndex, n.piece.start );
                    return l += n.size_left, this._searchCache.set( {
                      node: n,
                      nodeStartOffset: l,
                      nodeStartLineNumber: c - ( e - 1 - n.lf_left )
                    } ), s.substring( a + r, a + u - t )
                  }
                  if ( n.lf_left + n.piece.lineFeedCnt === e - 1 ) {
                    r = this.getAccumulatedValue( n, e - n.lf_left - 2 ), s = this._buffers[ n.piece.bufferIndex ].buffer, a = this.offsetInBuffer( n.piece.bufferIndex, n.piece.start );
                    i = s.substring( a + r, a + n.piece.length );
                    break
                  }
                  e -= n.lf_left + n.piece.lineFeedCnt, l += n.size_left + n.piece.length, n = n.right
                } for ( n = n.next(); n !== pe; ) {
              s = this._buffers[ n.piece.bufferIndex ].buffer;
              if ( n.piece.lineFeedCnt > 0 ) {
                u = this.getAccumulatedValue( n, 0 ), a = this.offsetInBuffer( n.piece.bufferIndex, n.piece.start );
                return i += s.substring( a, a + u - t )
              }
              a = this.offsetInBuffer( n.piece.bufferIndex, n.piece.start );
              i += s.substr( a, n.piece.length ), n = n.next()
            }
            return i
          }, e.prototype.computeBufferMetadata = function () {
            for ( var e = this.root, t = 1, n = 0; e !== pe; ) t += e.lf_left + e.piece.lineFeedCnt, n += e.size_left + e.piece.length, e = e.right;
            this._lineCnt = t, this._length = n, this._searchCache.valdiate( this._length )
          }, e.prototype.getIndexOf = function ( e, t ) {
            const n = e.piece,
              i = this.positionInBuffer( e, t ),
              o = i.line - n.start.line;
            if ( this.offsetInBuffer( n.bufferIndex, n.end ) - this.offsetInBuffer( n.bufferIndex, n.start ) === t ) {
              const r = this.getLineFeedCnt( e.piece.bufferIndex, n.start, i );
              if ( r !== o ) return {
                index: r,
                remainder: 0
              }
            }
            return {
              index: o,
              remainder: i.column
            }
          }, e.prototype.getAccumulatedValue = function ( e, t ) {
            if ( t < 0 ) return 0;
            const n = e.piece,
              i = this._buffers[ n.bufferIndex ].lineStarts,
              o = n.start.line + t + 1;
            return o > n.end.line ? i[ n.end.line ] + n.end.column - i[ n.start.line ] - n.start.column : i[ o ] - i[ n.start.line ] - n.start.column
          }, e.prototype.deleteNodeTail = function ( e, t ) {
            const n = e.piece,
              i = n.lineFeedCnt,
              o = this.offsetInBuffer( n.bufferIndex, n.end ),
              r = t,
              s = this.offsetInBuffer( n.bufferIndex, r ),
              a = this.getLineFeedCnt( n.bufferIndex, n.start, r ),
              u = a - i,
              l = s - o,
              c = n.length + l;
            e.piece = new Ee( n.bufferIndex, n.start, r, a, c ), Se( this, e, l, u )
          }, e.prototype.deleteNodeHead = function ( e, t ) {
            const n = e.piece,
              i = n.lineFeedCnt,
              o = this.offsetInBuffer( n.bufferIndex, n.start ),
              r = t,
              s = this.getLineFeedCnt( n.bufferIndex, r, n.end ),
              a = s - i,
              u = o - this.offsetInBuffer( n.bufferIndex, r ),
              l = n.length + u;
            e.piece = new Ee( n.bufferIndex, r, n.end, s, l ), Se( this, e, u, a )
          }, e.prototype.shrinkNode = function ( e, t, n ) {
            const i = e.piece,
              o = i.start,
              r = i.end,
              s = i.length,
              a = i.lineFeedCnt,
              u = t,
              l = this.getLineFeedCnt( i.bufferIndex, i.start, u ),
              c = this.offsetInBuffer( i.bufferIndex, t ) - this.offsetInBuffer( i.bufferIndex, o );
            e.piece = new Ee( i.bufferIndex, i.start, u, l, c ), Se( this, e, c - s, l - a );
            const d = new Ee( i.bufferIndex, n, r, this.getLineFeedCnt( i.bufferIndex, n, r ), this.offsetInBuffer( i.bufferIndex, r ) - this.offsetInBuffer( i.bufferIndex, n ) ),
              h = this.rbInsertRight( e, d );
            this.validateCRLFWithPrevNode( h )
          }, e.prototype.appendToNode = function ( e, t ) {
            this.adjustCarriageReturnFromNext( t, e ) && ( t += "\n" );
            const n = this.shouldCheckCRLF() && this.startWithLF( t ) && this.endWithCR( e ),
              i = this._buffers[ 0 ].buffer.length;
            this._buffers[ 0 ].buffer += t;
            for ( var o = Ne( t, !1 ), r = 0; r < o.length; r++ ) o[ r ] += i;
            if ( n ) {
              const s = this._buffers[ 0 ].lineStarts[ this._buffers[ 0 ].lineStarts.length - 2 ];
              this._buffers[ 0 ].lineStarts.pop(), this._lastChangeBufferPos = {
                line: this._lastChangeBufferPos.line - 1,
                column: i - s
              }
            }
            this._buffers[ 0 ].lineStarts = this._buffers[ 0 ].lineStarts.concat( o.slice( 1 ) );
            const a = this._buffers[ 0 ].lineStarts.length - 1,
              u = {
                line: a,
                column: this._buffers[ 0 ].buffer.length - this._buffers[ 0 ].lineStarts[ a ]
              },
              l = e.piece.length + t.length,
              c = e.piece.lineFeedCnt,
              d = this.getLineFeedCnt( 0, e.piece.start, u ),
              h = d - c;
            e.piece = new Ee( e.piece.bufferIndex, e.piece.start, u, d, l ), this._lastChangeBufferPos = u, Se( this, e, t.length, h )
          }, e.prototype.nodeAt = function ( e ) {
            let t = this.root;
            const n = this._searchCache.get( e );
            if ( n ) return {
              node: n.node,
              nodeStartOffset: n.nodeStartOffset,
              remainder: e - n.nodeStartOffset
            };
            for ( let i = 0; t !== pe; )
              if ( t.size_left > e ) t = t.left;
              else {
                if ( t.size_left + t.piece.length >= e ) {
                  i += t.size_left;
                  const o = {
                    node: t,
                    remainder: e - t.size_left,
                    nodeStartOffset: i
                  };
                  return this._searchCache.set( o ), o
                }
                e -= t.size_left + t.piece.length, i += t.size_left + t.piece.length, t = t.right
              } return null
          }, e.prototype.nodeAt2 = function ( e, t ) {
            for ( var n = this.root, i = 0; n !== pe; )
              if ( n.left !== pe && n.lf_left >= e - 1 ) n = n.left;
              else {
                if ( n.lf_left + n.piece.lineFeedCnt > e - 1 ) {
                  var o = this.getAccumulatedValue( n, e - n.lf_left - 2 ),
                    r = this.getAccumulatedValue( n, e - n.lf_left - 1 );
                  return i += n.size_left, {
                    node: n,
                    remainder: Math.min( o + t - 1, r ),
                    nodeStartOffset: i
                  }
                }
                if ( n.lf_left + n.piece.lineFeedCnt === e - 1 ) {
                  if ( ( o = this.getAccumulatedValue( n, e - n.lf_left - 2 ) ) + t - 1 <= n.piece.length ) return {
                    node: n,
                    remainder: o + t - 1,
                    nodeStartOffset: i
                  };
                  t -= n.piece.length - o;
                  break
                }
                e -= n.lf_left + n.piece.lineFeedCnt, i += n.size_left + n.piece.length, n = n.right
              } for ( n = n.next(); n !== pe; ) {
              if ( n.piece.lineFeedCnt > 0 ) {
                r = this.getAccumulatedValue( n, 0 );
                const s = this.offsetOfNode( n );
                return {
                  node: n,
                  remainder: Math.min( t - 1, r ),
                  nodeStartOffset: s
                }
              }
              if ( n.piece.length >= t - 1 ) return {
                node: n,
                remainder: t - 1,
                nodeStartOffset: this.offsetOfNode( n )
              };
              t -= n.piece.length, n = n.next()
            }
            return null
          }, e.prototype.nodeCharCodeAt = function ( e, t ) {
            if ( e.piece.lineFeedCnt < 1 ) return -1;
            const n = this._buffers[ e.piece.bufferIndex ],
              i = this.offsetInBuffer( e.piece.bufferIndex, e.piece.start ) + t;
            return n.buffer.charCodeAt( i )
          }, e.prototype.offsetOfNode = function ( e ) {
            if ( !e ) return 0;
            for ( var t = e.size_left; e !== this.root; ) e.parent.right === e && ( t += e.parent.size_left + e.parent.piece.length ), e = e.parent;
            return t
          }, e.prototype.shouldCheckCRLF = function () {
            return !( this._EOLNormalized && "\n" === this._EOL )
          }, e.prototype.startWithLF = function ( e ) {
            if ( "string" === typeof e ) return 10 === e.charCodeAt( 0 );
            if ( e === pe || 0 === e.piece.lineFeedCnt ) return !1;
            const t = e.piece,
              n = this._buffers[ t.bufferIndex ].lineStarts,
              i = t.start.line,
              o = n[ i ] + t.start.column;
            return i !== n.length - 1 && ( !( n[ i + 1 ] > o + 1 ) && 10 === this._buffers[ t.bufferIndex ].buffer.charCodeAt( o ) )
          }, e.prototype.endWithCR = function ( e ) {
            return "string" === typeof e ? 13 === e.charCodeAt( e.length - 1 ) : e !== pe && 0 !== e.piece.lineFeedCnt && 13 === this.nodeCharCodeAt( e, e.piece.length - 1 )
          }, e.prototype.validateCRLFWithPrevNode = function ( e ) {
            if ( this.shouldCheckCRLF() && this.startWithLF( e ) ) {
              const t = e.prev();
              this.endWithCR( t ) && this.fixCRLF( t, e )
            }
          }, e.prototype.validateCRLFWithNextNode = function ( e ) {
            if ( this.shouldCheckCRLF() && this.endWithCR( e ) ) {
              const t = e.next();
              this.startWithLF( t ) && this.fixCRLF( e, t )
            }
          }, e.prototype.fixCRLF = function ( e, t ) {
            let n;
            const i = [];
            const o = this._buffers[ e.piece.bufferIndex ].lineStarts;
            n = 0 === e.piece.end.column ? {
              line: e.piece.end.line - 1,
              column: o[ e.piece.end.line ] - o[ e.piece.end.line - 1 ] - 1
            } : {
              line: e.piece.end.line,
              column: e.piece.end.column - 1
            };
            const r = e.piece.length - 1,
              s = e.piece.lineFeedCnt - 1;
            e.piece = new Ee( e.piece.bufferIndex, e.piece.start, n, s, r ), Se( this, e, -1, -1 ), 0 === e.piece.length && i.push( e );
            const a = {
                line: t.piece.start.line + 1,
                column: 0
              },
              u = t.piece.length - 1,
              l = this.getLineFeedCnt( t.piece.bufferIndex, a, t.piece.end );
            t.piece = new Ee( t.piece.bufferIndex, a, t.piece.end, l, u ), Se( this, t, -1, -1 ), 0 === t.piece.length && i.push( t );
            const c = this.createNewPieces( "\r\n" );
            this.rbInsertRight( e, c[ 0 ] );
            for ( let d = 0; d < i.length; d++ ) Ce( this, i[ d ] )
          }, e.prototype.adjustCarriageReturnFromNext = function ( e, t ) {
            if ( this.shouldCheckCRLF() && this.endWithCR( e ) ) {
              const n = t.next();
              if ( this.startWithLF( n ) ) {
                if ( e += "\n", 1 === n.piece.length ) Ce( this, n );
                else {
                  const i = n.piece,
                    o = {
                      line: i.start.line + 1,
                      column: 0
                    },
                    r = i.length - 1,
                    s = this.getLineFeedCnt( i.bufferIndex, o, i.end );
                  n.piece = new Ee( i.bufferIndex, o, i.end, s, r ), Se( this, n, -1, -1 )
                }
                return !0
              }
            }
            return !1
          }, e.prototype.iterate = function ( e, t ) {
            if ( e === pe ) return t( pe );
            const n = this.iterate( e.left, t );
            return n ? t( e ) && this.iterate( e.right, t ) : n
          }, e.prototype.getNodeContent = function ( e ) {
            if ( e === pe ) return "";
            const t = this._buffers[ e.piece.bufferIndex ],
              n = e.piece,
              i = this.offsetInBuffer( n.bufferIndex, n.start ),
              o = this.offsetInBuffer( n.bufferIndex, n.end );
            return t.buffer.substring( i, o )
          }, e.prototype.rbInsertRight = function ( e, t ) {
            const n = new he( t, 1 );
            if ( n.left = pe, n.right = pe, n.parent = pe, n.size_left = 0, n.lf_left = 0, this.root === pe ) this.root = n, n.color = 0;
            else if ( e.right === pe ) e.right = n, n.parent = e;
            else {
              const i = fe( e.right );
              i.left = n, n.parent = i
            }
            return we( this, n ), n
          }, e.prototype.rbInsertLeft = function ( e, t ) {
            const n = new he( t, 1 );
            if ( n.left = pe, n.right = pe, n.parent = pe, n.size_left = 0, n.lf_left = 0, this.root === pe ) this.root = n, n.color = 0;
            else if ( e.left === pe ) e.left = n, n.parent = e;
            else {
              const i = ge( e.left );
              i.right = n, n.parent = i
            }
            return we( this, n ), n
          }, e.prototype.getContentOfSubTree = function ( e ) {
            const t = this;
            let n = "";
            return this.iterate( e, ( e => {
              return n += t.getNodeContent( e ), !0
            } ) ), n;
          }, e;
        } )(),
        Me = ( () => {
          function e( e, t, n, i, o, r ) {
            this._BOM = t, this._mightContainNonBasicASCII = !o, this._mightContainRTL = i, this._pieceTree = new De( e, n, r )
          }
          return e.prototype.mightContainRTL = function () {
            return this._mightContainRTL
          }, e.prototype.mightContainNonBasicASCII = function () {
            return this._mightContainNonBasicASCII
          }, e.prototype.getBOM = function () {
            return this._BOM
          }, e.prototype.getEOL = function () {
            return this._pieceTree.getEOL()
          }, e.prototype.getOffsetAt = function ( e, t ) {
            return this._pieceTree.getOffsetAt( e, t )
          }, e.prototype.getPositionAt = function ( e ) {
            return this._pieceTree.getPositionAt( e )
          }, e.prototype.getRangeAt = function ( e, t ) {
            const n = e + t,
              i = this.getPositionAt( e ),
              o = this.getPositionAt( n );
            return new h.a( i.lineNumber, i.column, o.lineNumber, o.column )
          }, e.prototype.getValueInRange = function ( e, t ) {
            if ( void 0 === t && ( t = r.c.TextDefined ), e.isEmpty() ) return "";
            const n = this._getEndOfLine( t );
            return this._pieceTree.getValueInRange( e, n )
          }, e.prototype.getValueLengthInRange = function ( e, t ) {
            if ( void 0 === t && ( t = r.c.TextDefined ), e.isEmpty() ) return 0;
            if ( e.startLineNumber === e.endLineNumber ) return e.endColumn - e.startColumn;
            const n = this.getOffsetAt( e.startLineNumber, e.startColumn );
            return this.getOffsetAt( e.endLineNumber, e.endColumn ) - n
          }, e.prototype.getLength = function () {
            return this._pieceTree.getLength()
          }, e.prototype.getLineCount = function () {
            return this._pieceTree.getLineCount()
          }, e.prototype.getLinesContent = function () {
            return this._pieceTree.getLinesContent()
          }, e.prototype.getLineContent = function ( e ) {
            return this._pieceTree.getLineContent( e )
          }, e.prototype.getLineCharCode = function ( e, t ) {
            return this._pieceTree.getLineCharCode( e, t )
          }, e.prototype.getLineLength = function ( e ) {
            return this._pieceTree.getLineLength( e )
          }, e.prototype.getLineFirstNonWhitespaceColumn = function ( e ) {
            const t = C.firstNonWhitespaceIndex( this.getLineContent( e ) );
            return -1 === t ? 0 : t + 1
          }, e.prototype.getLineLastNonWhitespaceColumn = function ( e ) {
            const t = C.lastNonWhitespaceIndex( this.getLineContent( e ) );
            return -1 === t ? 0 : t + 2
          }, e.prototype._getEndOfLine = function ( e ) {
            switch ( e ) {
              case r.c.LF:
                return "\n";
              case r.c.CRLF:
                return "\r\n";
              case r.c.TextDefined:
                return this.getEOL()
            }
            throw new Error( "Unknown EOL preference" )
          }, e.prototype.setEOL = function ( e ) {
            this._pieceTree.setEOL( e )
          }, e.prototype.applyEdits = function ( t, n ) {
            for ( var i = this._mightContainRTL, o = this._mightContainNonBasicASCII, s = !0, a = [], u = 0; u < t.length; u++ ) {
              var l = t[ u ];
              s && l._isTracked && ( s = !1 );
              const c = l.range;
              !i && l.text && ( i = C.containsRTL( l.text ) ), !o && l.text && ( o = !C.isBasicASCII( l.text ) ), a[ u ] = {
                sortIndex: u,
                identifier: l.identifier,
                range: c,
                rangeOffset: this.getOffsetAt( c.startLineNumber, c.startColumn ),
                rangeLength: this.getValueLengthInRange( c ),
                lines: l.text ? l.text.split( /\r\n|\r|\n/ ) : null,
                forceMoveMarkers: l.forceMoveMarkers,
                isAutoWhitespaceEdit: l.isAutoWhitespaceEdit || !1
              }
            }
            a.sort( e._sortOpsAscending );
            for ( var d = !1, h = ( u = 0, a.length - 1 ); u < h; u++ ) {
              const p = a[ u ].range.getEndPosition(),
                f = a[ u + 1 ].range.getStartPosition();
              if ( f.isBeforeOrEqual( p ) ) {
                if ( f.isBefore( p ) ) throw new Error( "Overlapping ranges are not allowed!" );
                d = !0
              }
            }
            s && ( a = this._reduceOperations( a ) );
            const g = e._getInverseEditRanges( a ),
              m = [];
            for ( u = 0; u < a.length; u++ ) {
              l = a[ u ];
              var _ = g[ u ];
              if ( n && l.isAutoWhitespaceEdit && l.range.isEmpty() )
                for ( var v = _.startLineNumber; v <= _.endLineNumber; v++ ) {
                  let y = "";
                  v === _.startLineNumber && ( y = this.getLineContent( l.range.startLineNumber ), -1 !== C.firstNonWhitespaceIndex( y ) ) || m.push( {
                    lineNumber: v,
                    oldContent: y
                  } )
                }
            }
            const b = [];
            for ( u = 0; u < a.length; u++ ) {
              l = a[ u ], _ = g[ u ];
              b[ u ] = {
                sortIndex: l.sortIndex,
                identifier: l.identifier,
                range: _,
                text: this.getValueInRange( l.range ),
                forceMoveMarkers: l.forceMoveMarkers
              }
            }
            d || b.sort( ( ( e, t ) => {
              return e.sortIndex - t.sortIndex
            } ) ), this._mightContainRTL = i, this._mightContainNonBasicASCII = o;
            const w = this._doApplyEdits( a );
            let S = null;
            if ( n && m.length > 0 ) {
              m.sort( ( ( e, t ) => {
                return t.lineNumber - e.lineNumber
              } ) ), S = [];
              u = 0;
              for ( const O = m.length; u < O; u++ ) {
                v = m[ u ].lineNumber;
                if ( !( u > 0 && m[ u - 1 ].lineNumber === v ) ) {
                  const L = m[ u ].oldContent,
                    x = this.getLineContent( v );
                  0 !== x.length && x !== L && -1 === C.firstNonWhitespaceIndex( x ) && S.push( v )
                }
              }
            }
            return new r.a( b, w, S )
          }, e.prototype._reduceOperations = function ( e ) {
            return e.length < 1e3 ? e : [ this._toSingleEditOperation( e ) ]
          }, e.prototype._toSingleEditOperation = function ( e ) {
            for ( var t = !1, n = e[ 0 ].range, i = e[ e.length - 1 ].range, o = new h.a( n.startLineNumber, n.startColumn, i.endLineNumber, i.endColumn ), s = n.startLineNumber, a = n.startColumn, u = [], l = 0, c = e.length; l < c; l++ ) {
              const d = e[ l ],
                p = d.range;
              t = t || d.forceMoveMarkers;
              for ( let f = s; f < p.startLineNumber; f++ ) f === s ? u.push( this.getLineContent( f ).substring( a - 1 ) ) : ( u.push( "\n" ), u.push( this.getLineContent( f ) ) );
              if ( p.startLineNumber === s ? u.push( this.getLineContent( p.startLineNumber ).substring( a - 1, p.startColumn - 1 ) ) : ( u.push( "\n" ), u.push( this.getLineContent( p.startLineNumber ).substring( 0, p.startColumn - 1 ) ) ), d.lines )
                for ( let g = 0, m = d.lines.length; g < m; g++ ) 0 !== g && u.push( "\n" ), u.push( d.lines[ g ] );
              s = d.range.endLineNumber, a = d.range.endColumn
            }
            return {
              sortIndex: 0,
              identifier: e[ 0 ].identifier,
              range: o,
              rangeOffset: this.getOffsetAt( o.startLineNumber, o.startColumn ),
              rangeLength: this.getValueLengthInRange( o, r.c.TextDefined ),
              lines: u.join( "" ).split( "\n" ),
              forceMoveMarkers: t,
              isAutoWhitespaceEdit: !1
            }
          }, e.prototype._doApplyEdits = function ( t ) {
            t.sort( e._sortOpsDescending );
            for ( var n = [], i = 0; i < t.length; i++ ) {
              const o = t[ i ],
                r = o.range.startLineNumber,
                s = o.range.startColumn,
                a = o.range.endLineNumber,
                u = o.range.endColumn;
              if ( r !== a || s !== u || o.lines && 0 !== o.lines.length ) {
                const l = a - r,
                  c = o.lines ? o.lines.length - 1 : 0,
                  d = Math.min( l, c ),
                  p = o.lines ? o.lines.join( this.getEOL() ) : "";
                if ( p ? ( this._pieceTree.delete( o.rangeOffset, o.rangeLength ), this._pieceTree.insert( o.rangeOffset, p, !0 ) ) : this._pieceTree.delete( o.rangeOffset, o.rangeLength ), d < c ) {
                  for ( var f = [], g = d + 1; g <= c; g++ ) f.push( o.lines[ g ] );
                  f[ f.length - 1 ] = this.getLineContent( r + c - 1 )
                }
                const m = new h.a( r, s, a, u );
                n.push( {
                  range: m,
                  rangeLength: o.rangeLength,
                  text: p,
                  rangeOffset: o.rangeOffset,
                  forceMoveMarkers: o.forceMoveMarkers
                } )
              }
            }
            return n
          }, e.prototype.findMatchesLineByLine = function ( e, t, n, i ) {
            return this._pieceTree.findMatchesLineByLine( e, t, n, i )
          }, e._getInverseEditRanges = e => {
            for ( var t, n, i = [], o = null, r = 0, s = e.length; r < s; r++ ) {
              const a = e[ r ];
              let u = void 0;
              let l = void 0;
              o ? o.range.endLineNumber === a.range.startLineNumber ? ( u = t, l = n + ( a.range.startColumn - o.range.endColumn ) ) : ( u = t + ( a.range.startLineNumber - o.range.endLineNumber ), l = a.range.startColumn ) : ( u = a.range.startLineNumber, l = a.range.startColumn );
              let c = void 0;
              if ( a.lines && a.lines.length > 0 ) {
                const d = a.lines.length,
                  p = a.lines[ 0 ],
                  f = a.lines[ d - 1 ];
                c = 1 === d ? new h.a( u, l, u, l + p.length ) : new h.a( u, l, u + d - 1, f.length + 1 )
              } else c = new h.a( u, l, u, l );
              t = c.endLineNumber, n = c.endColumn, i.push( c ), o = a
            }
            return i
          }, e._sortOpsAscending = ( e, t ) => {
            const n = h.a.compareRangesUsingEnds( e.range, t.range );
            return 0 === n ? e.sortIndex - t.sortIndex : n
          }, e._sortOpsDescending = ( e, t ) => {
            const n = h.a.compareRangesUsingEnds( e.range, t.range );
            return 0 === n ? t.sortIndex - e.sortIndex : -n
          }, e;
        } )(),
        Te = ( () => {
          function e( e, t, n, i, o, r, s, a ) {
            this._chunks = e, this._bom = t, this._cr = n, this._lf = i, this._crlf = o, this._containsRTL = r, this._isBasicASCII = s, this._normalizeEOL = a
          }
          return e.prototype._getEOL = function ( e ) {
            const t = this._cr + this._lf + this._crlf,
              n = this._cr + this._crlf;
            return 0 === t ? e === r.b.LF ? "\n" : "\r\n" : n > t / 2 ? "\r\n" : "\n"
          }, e.prototype.create = function ( e ) {
            const t = this._getEOL( e ),
              n = this._chunks;
            if ( this._normalizeEOL && ( "\r\n" === t && ( this._cr > 0 || this._lf > 0 ) || "\n" === t && ( this._cr > 0 || this._crlf > 0 ) ) )
              for ( let i = 0, o = n.length; i < o; i++ ) {
                const r = n[ i ].buffer.replace( /\r\n|\r|\n/g, t ),
                  s = Ne( r );
                n[ i ] = new ke( r, s )
              }
            return new Me( n, this._bom, t, this._containsRTL, this._isBasicASCII, this._normalizeEOL )
          }, e;
        } )(),
        Re = ( () => {
          function e() {
            this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.isBasicASCII = !0
          }
          return e.prototype.acceptChunk = function ( e ) {
            if ( 0 !== e.length ) {
              0 === this.chunks.length && C.startsWithUTF8BOM( e ) && ( this.BOM = C.UTF8_BOM_CHARACTER, e = e.substr( 1 ) );
              const t = e.charCodeAt( e.length - 1 );
              13 === t || t >= 55296 && t <= 56319 ? ( this._acceptChunk1( e.substr( 0, e.length - 1 ), !1 ), this._hasPreviousChar = !0, this._previousChar = t ) : ( this._acceptChunk1( e, !1 ), this._hasPreviousChar = !1, this._previousChar = t )
            }
          }, e.prototype._acceptChunk1 = function ( e, t ) {
            ( t || 0 !== e.length ) && ( this._hasPreviousChar ? this._acceptChunk2( String.fromCharCode( this._previousChar ) + e ) : this._acceptChunk2( e ) )
          }, e.prototype._acceptChunk2 = function ( e ) {
            const t = ( ( e, t ) => {
              e.length = 0, e[ 0 ] = 0;
              for ( var n = 1, i = 0, o = 0, r = 0, s = !0, a = 0, u = t.length; a < u; a++ ) {
                const l = t.charCodeAt( a );
                13 === l ? a + 1 < u && 10 === t.charCodeAt( a + 1 ) ? ( r++, e[ n++ ] = a + 2, a++ ) : ( i++, e[ n++ ] = a + 1 ) : 10 === l ? ( o++, e[ n++ ] = a + 1 ) : s && 9 !== l && ( l < 32 || l > 126 ) && ( s = !1 )
              }
              const c = new xe( Le( e ), i, o, r, s );
              return e.length = 0, c
            } )( this._tmpLineStarts, e );
            this.chunks.push( new ke( e, t.lineStarts ) ), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, this.isBasicASCII && ( this.isBasicASCII = t.isBasicASCII ), this.isBasicASCII || this.containsRTL || ( this.containsRTL = C.containsRTL( e ) )
          }, e.prototype.finish = function ( e ) {
            return void 0 === e && ( e = !0 ), this._finish(), new Te( this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.isBasicASCII, e )
          }, e.prototype._finish = function () {
            if ( 0 === this.chunks.length && this._acceptChunk1( "", !0 ), this._hasPreviousChar ) {
              this._hasPreviousChar = !1;
              const e = this.chunks[ this.chunks.length - 1 ];
              e.buffer += String.fromCharCode( this._previousChar );
              const t = Ne( e.buffer );
              e.lineStarts = t, 13 === this._previousChar && this.cr++
            }
          }, e;
        } )();
      n.d( t, "b", ( () => {
        return je
      } ) ), n.d( t, "a", ( () => {
        return ze
      } ) );
      const Pe = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      function Ae( e ) {
        const t = new Re;
        return t.acceptChunk( e ), t.finish()
      }

      function Fe( e, t ) {
        return ( "string" === typeof e ? Ae( e ) : e ).create( t )
      }
      let We = 0;

      var je = ( e => {
        function t( n, a, u, l ) {
          void 0 === l && ( l = null );
          const c = e.call( this ) || this;
          c._onWillDispose = c._register( new o.a ), c.onWillDispose = c._onWillDispose.event, c._onDidChangeDecorations = c._register( new qe ), c.onDidChangeDecorations = c._onDidChangeDecorations.event, c._onDidChangeLanguage = c._register( new o.a ), c.onDidChangeLanguage = c._onDidChangeLanguage.event, c._onDidChangeLanguageConfiguration = c._register( new o.a ), c.onDidChangeLanguageConfiguration = c._onDidChangeLanguageConfiguration.event, c._onDidChangeTokens = c._register( new o.a ), c.onDidChangeTokens = c._onDidChangeTokens.event, c._onDidChangeOptions = c._register( new o.a ), c.onDidChangeOptions = c._onDidChangeOptions.event, c._eventEmitter = c._register( new Ge ), We++, c.id = "$model" + We, c.isForSimpleWidget = a.isForSimpleWidget, c._associatedResource = "undefined" === typeof l || null === l ? i.a.parse( "inmemory://model/" + We ) : l, c._attachedEditorCount = 0, c._buffer = Fe( n, a.defaultEOL ), c._options = t.resolveOptions( c._buffer, a );
          let p;
          const f = c._buffer.getLineCount();
          const g = c._buffer.getValueLengthInRange( new h.a( 1, 1, f, c._buffer.getLineLength( f ) + 1 ), r.c.TextDefined );
          return a.largeFileOptimizations ? c._isTooLargeForTokenization = g > t.LARGE_FILE_SIZE_THRESHOLD || f > t.LARGE_FILE_LINE_COUNT_THRESHOLD : c._isTooLargeForTokenization = !1, c._isTooLargeForSyncing = g > t.MODEL_SYNC_LIMIT, c._setVersionId( 1 ), c._isDisposed = !1, c._isDisposing = !1, c._languageIdentifier = u || X.a, c._tokenizationListener = s.y.onDidChange( ( e => {
            -1 !== e.changedLanguages.indexOf( c._languageIdentifier.language ) && ( c._resetTokenizationState(), c.emitModelTokensChangedEvent( {
              ranges: [ {
                fromLineNumber: 1,
                toLineNumber: c.getLineCount()
              } ]
            } ), c._shouldAutoTokenize() && c._warmUpTokens() )
          } ) ), c._revalidateTokensTimeout = -1, c._languageRegistryListener = J.a.onDidChange( ( e => {
            e.languageIdentifier.id === c._languageIdentifier.id && c._onDidChangeLanguageConfiguration.fire( {} )
          } ) ), c._resetTokenizationState(), c._instanceId = ( p = We, ( p %= 52 ) < 26 ? String.fromCharCode( 97 + p ) : String.fromCharCode( 65 + p - 26 ) ), c._lastDecorationId = 0, c._decorations = Object.create( null ), c._decorationsTree = new Ve, c._commandManager = new d( c ), c._isUndoing = !1, c._isRedoing = !1, c._trimAutoWhitespaceLines = null, c;
        }
        return Pe( t, e ), t.createFromString = ( e, n, i, o ) => {
          return void 0 === n && ( n = t.DEFAULT_CREATION_OPTIONS ), void 0 === i && ( i = null ), void 0 === o && ( o = null ), new t( e, n, i, o )
        }, t.resolveOptions = ( e, t ) => {
          if ( t.detectIndentation ) {
            const n = le( e, t.tabSize, t.insertSpaces );
            return new r.g( {
              tabSize: n.tabSize,
              insertSpaces: n.insertSpaces,
              trimAutoWhitespace: t.trimAutoWhitespace,
              defaultEOL: t.defaultEOL
            } )
          }
          return new r.g( {
            tabSize: t.tabSize,
            insertSpaces: t.insertSpaces,
            trimAutoWhitespace: t.trimAutoWhitespace,
            defaultEOL: t.defaultEOL
          } )
        }, t.prototype.onDidChangeRawContentFast = function ( e ) {
          return this._eventEmitter.fastEvent( ( t => {
            return e( t.rawContentChangedEvent )
          } ) );
        }, t.prototype.onDidChangeRawContent = function ( e ) {
          return this._eventEmitter.slowEvent( ( t => {
            return e( t.rawContentChangedEvent )
          } ) );
        }, t.prototype.onDidChangeContent = function ( e ) {
          return this._eventEmitter.slowEvent( ( t => {
            return e( t.contentChangedEvent )
          } ) );
        }, t.prototype.dispose = function () {
          this._isDisposing = !0, this._onWillDispose.fire(), this._commandManager = null, this._decorations = null, this._decorationsTree = null, this._tokenizationListener.dispose(), this._languageRegistryListener.dispose(), this._clearTimers(), this._tokens = null, this._isDisposed = !0, this._buffer = null, e.prototype.dispose.call( this ), this._isDisposing = !1
        }, t.prototype._assertNotDisposed = function () {
          if ( this._isDisposed ) throw new Error( "Model is disposed!" )
        }, t.prototype._emitContentChangedEvent = function ( e, t ) {
          this._isDisposing || this._eventEmitter.fire( new b( e, t ) )
        }, t.prototype.setValue = function ( e ) {
          if ( this._assertNotDisposed(), null !== e ) {
            const t = Fe( e, this._options.defaultEOL );
            this.setValueFromTextBuffer( t )
          }
        }, t.prototype._createContentChanged2 = function ( e, t, n, i, o, r, s ) {
          return {
            changes: [ {
              range: e,
              rangeOffset: t,
              rangeLength: n,
              text: i
            } ],
            eol: this._buffer.getEOL(),
            versionId: this.getVersionId(),
            isUndoing: o,
            isRedoing: r,
            isFlush: s
          }
        }, t.prototype.setValueFromTextBuffer = function ( e ) {
          if ( this._assertNotDisposed(), null !== e ) {
            const t = this.getFullModelRange(),
              n = this.getValueLengthInRange( t ),
              i = this.getLineCount(),
              o = this.getLineMaxColumn( i );
            this._buffer = e, this._increaseVersionId(), this._resetTokenizationState(), this._decorations = Object.create( null ), this._decorationsTree = new Ve, this._commandManager = new d( this ), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent( new y( [ new f ], this._versionId, !1, !1 ), this._createContentChanged2( new h.a( 1, 1, i, o ), 0, n, this.getValue(), !1, !1, !0 ) )
          }
        }, t.prototype.setEOL = function ( e ) {
          this._assertNotDisposed();
          const t = e === r.d.CRLF ? "\r\n" : "\n";
          if ( this._buffer.getEOL() !== t ) {
            const n = this.getFullModelRange(),
              i = this.getValueLengthInRange( n ),
              o = this.getLineCount(),
              s = this.getLineMaxColumn( o );
            this._onBeforeEOLChange(), this._buffer.setEOL( t ), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent( new y( [ new v ], this._versionId, !1, !1 ), this._createContentChanged2( new h.a( 1, 1, o, s ), 0, i, this.getValue(), !1, !1, !1 ) )
          }
        }, t.prototype._onBeforeEOLChange = function () {
          const e = this.getVersionId(),
            t = this._decorationsTree.search( 0, !1, !1, e );
          this._ensureNodesHaveRanges( t )
        }, t.prototype._onAfterEOLChange = function () {
          for ( let e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder(), n = 0, i = t.length; n < i; n++ ) {
            const o = t[ n ],
              r = o.cachedAbsoluteStart - o.start,
              s = this._buffer.getOffsetAt( o.range.startLineNumber, o.range.startColumn ),
              a = this._buffer.getOffsetAt( o.range.endLineNumber, o.range.endColumn );
            o.cachedAbsoluteStart = s, o.cachedAbsoluteEnd = a, o.cachedVersionId = e, o.start = s - r, o.end = a - r, H( o )
          }
        }, t.prototype._resetTokenizationState = function () {
          this._clearTimers();
          const e = this._isTooLargeForTokenization ? null : s.y.get( this._languageIdentifier.language );
          this._tokens = new se( this._languageIdentifier, e ), this._beginBackgroundTokenization()
        }, t.prototype._clearTimers = function () {
          -1 !== this._revalidateTokensTimeout && ( clearTimeout( this._revalidateTokensTimeout ), this._revalidateTokensTimeout = -1 )
        }, t.prototype.onBeforeAttached = function () {
          this._attachedEditorCount++, this._warmUpTokens()
        }, t.prototype.onBeforeDetached = function () {
          this._attachedEditorCount--
        }, t.prototype._shouldAutoTokenize = function () {
          return this.isAttachedToEditor()
        }, t.prototype.isAttachedToEditor = function () {
          return this._attachedEditorCount > 0
        }, t.prototype.getAttachedEditorCount = function () {
          return this._attachedEditorCount
        }, t.prototype.isTooLargeForSyncing = function () {
          return this._isTooLargeForSyncing
        }, t.prototype.isTooLargeForTokenization = function () {
          return this._isTooLargeForTokenization
        }, t.prototype.isDisposed = function () {
          return this._isDisposed
        }, t.prototype.isDominatedByLongLines = function () {
          if ( this._assertNotDisposed(), this.isTooLargeForTokenization() ) return !1;
          for ( var e = 0, t = 0, n = this._buffer.getLineCount(), i = 1; i <= n; i++ ) {
            const o = this._buffer.getLineLength( i );
            o >= 1e4 ? t += o : e += o
          }
          return t > e
        }, Object.defineProperty( t.prototype, "uri", {
          get() {
            return this._associatedResource
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.getOptions = function () {
          return this._assertNotDisposed(), this._options
        }, t.prototype.updateOptions = function ( e ) {
          this._assertNotDisposed();
          const t = "undefined" !== typeof e.tabSize ? e.tabSize : this._options.tabSize,
            n = "undefined" !== typeof e.insertSpaces ? e.insertSpaces : this._options.insertSpaces,
            i = "undefined" !== typeof e.trimAutoWhitespace ? e.trimAutoWhitespace : this._options.trimAutoWhitespace,
            o = new r.g( {
              tabSize: t,
              insertSpaces: n,
              defaultEOL: this._options.defaultEOL,
              trimAutoWhitespace: i
            } );
          if ( !this._options.equals( o ) ) {
            const s = this._options.createChangeEvent( o );
            this._options = o, this._onDidChangeOptions.fire( s )
          }
        }, t.prototype.detectIndentation = function ( e, t ) {
          this._assertNotDisposed();
          const n = le( this._buffer, t, e );
          this.updateOptions( {
            insertSpaces: n.insertSpaces,
            tabSize: n.tabSize
          } )
        }, t._normalizeIndentationFromWhitespace = ( e, t, n ) => {
          for ( var i = 0, o = 0; o < e.length; o++ ) "\t" === e.charAt( o ) ? i += t : i++;
          let r = "";
          if ( !n ) {
            const s = Math.floor( i / t );
            i %= t;
            for ( o = 0; o < s; o++ ) r += "\t"
          }
          for ( o = 0; o < i; o++ ) r += " ";
          return r
        }, t.normalizeIndentation = ( e, n, i ) => {
          let o = C.firstNonWhitespaceIndex( e );
          return -1 === o && ( o = e.length ), t._normalizeIndentationFromWhitespace( e.substring( 0, o ), n, i ) + e.substring( o )
        }, t.prototype.normalizeIndentation = function ( e ) {
          return this._assertNotDisposed(), t.normalizeIndentation( e, this._options.tabSize, this._options.insertSpaces )
        }, t.prototype.getOneIndent = function () {
          this._assertNotDisposed();
          const e = this._options.tabSize;
          if ( this._options.insertSpaces ) {
            for ( var t = "", n = 0; n < e; n++ ) t += " ";
            return t
          }
          return "\t"
        }, t.prototype.getVersionId = function () {
          return this._assertNotDisposed(), this._versionId
        }, t.prototype.mightContainRTL = function () {
          return this._buffer.mightContainRTL()
        }, t.prototype.mightContainNonBasicASCII = function () {
          return this._buffer.mightContainNonBasicASCII()
        }, t.prototype.getAlternativeVersionId = function () {
          return this._assertNotDisposed(), this._alternativeVersionId
        }, t.prototype.getOffsetAt = function ( e ) {
          this._assertNotDisposed();
          const t = this._validatePosition( e.lineNumber, e.column, !1 );
          return this._buffer.getOffsetAt( t.lineNumber, t.column )
        }, t.prototype.getPositionAt = function ( e ) {
          this._assertNotDisposed();
          const t = Math.min( this._buffer.getLength(), Math.max( 0, e ) );
          return this._buffer.getPositionAt( t )
        }, t.prototype._increaseVersionId = function () {
          this._setVersionId( this._versionId + 1 )
        }, t.prototype._setVersionId = function ( e ) {
          this._versionId = e, this._alternativeVersionId = this._versionId
        }, t.prototype._overwriteAlternativeVersionId = function ( e ) {
          this._alternativeVersionId = e
        }, t.prototype.getValue = function ( e, t ) {
          void 0 === t && ( t = !1 ), this._assertNotDisposed();
          const n = this.getFullModelRange(),
            i = this.getValueInRange( n, e );
          return t ? this._buffer.getBOM() + i : i
        }, t.prototype.getValueLength = function ( e, t ) {
          void 0 === t && ( t = !1 ), this._assertNotDisposed();
          const n = this.getFullModelRange(),
            i = this.getValueLengthInRange( n, e );
          return t ? this._buffer.getBOM().length + i : i
        }, t.prototype.getValueInRange = function ( e, t ) {
          return void 0 === t && ( t = r.c.TextDefined ), this._assertNotDisposed(), this._buffer.getValueInRange( this.validateRange( e ), t )
        }, t.prototype.getValueLengthInRange = function ( e, t ) {
          return void 0 === t && ( t = r.c.TextDefined ), this._assertNotDisposed(), this._buffer.getValueLengthInRange( this.validateRange( e ), t )
        }, t.prototype.getLineCount = function () {
          return this._assertNotDisposed(), this._buffer.getLineCount()
        }, t.prototype.getLineContent = function ( e ) {
          if ( this._assertNotDisposed(), e < 1 || e > this.getLineCount() ) throw new Error( "Illegal value for lineNumber" );
          return this._buffer.getLineContent( e )
        }, t.prototype.getLineLength = function ( e ) {
          if ( this._assertNotDisposed(), e < 1 || e > this.getLineCount() ) throw new Error( "Illegal value for lineNumber" );
          return this._buffer.getLineLength( e )
        }, t.prototype.getLinesContent = function () {
          return this._assertNotDisposed(), this._buffer.getLinesContent()
        }, t.prototype.getEOL = function () {
          return this._assertNotDisposed(), this._buffer.getEOL()
        }, t.prototype.getLineMinColumn = function ( e ) {
          return this._assertNotDisposed(), 1
        }, t.prototype.getLineMaxColumn = function ( e ) {
          if ( this._assertNotDisposed(), e < 1 || e > this.getLineCount() ) throw new Error( "Illegal value for lineNumber" );
          return this._buffer.getLineLength( e ) + 1
        }, t.prototype.getLineFirstNonWhitespaceColumn = function ( e ) {
          if ( this._assertNotDisposed(), e < 1 || e > this.getLineCount() ) throw new Error( "Illegal value for lineNumber" );
          return this._buffer.getLineFirstNonWhitespaceColumn( e )
        }, t.prototype.getLineLastNonWhitespaceColumn = function ( e ) {
          if ( this._assertNotDisposed(), e < 1 || e > this.getLineCount() ) throw new Error( "Illegal value for lineNumber" );
          return this._buffer.getLineLastNonWhitespaceColumn( e )
        }, t.prototype._validateRangeRelaxedNoAllocations = function ( e ) {
          let t;
          let n;
          const i = this._buffer.getLineCount();
          const o = e.startLineNumber;
          const r = e.startColumn;
          if ( o < 1 ) t = 1, n = 1;
          else if ( o > i ) t = i, n = this.getLineMaxColumn( t );
          else {
            if ( t = 0 | o, r <= 1 ) n = 1;
            else n = r >= ( c = this.getLineMaxColumn( t ) ) ? c : 0 | r
          }
          let s;
          let a;
          const u = e.endLineNumber;
          const l = e.endColumn;
          if ( u < 1 ) s = 1, a = 1;
          else if ( u > i ) s = i, a = this.getLineMaxColumn( s );
          else {
            var c;
            if ( s = 0 | u, l <= 1 ) a = 1;
            else a = l >= ( c = this.getLineMaxColumn( s ) ) ? c : 0 | l
          }
          return o === t && r === n && u === s && l === a && e instanceof h.a && !( e instanceof p.a ) ? e : new h.a( t, n, s, a )
        }, t.prototype._isValidPosition = function ( e, t, n ) {
          if ( isNaN( e ) ) return !1;
          if ( e < 1 ) return !1;
          if ( e > this._buffer.getLineCount() ) return !1;
          if ( isNaN( t ) ) return !1;
          if ( t < 1 ) return !1;
          if ( t > this.getLineMaxColumn( e ) ) return !1;
          if ( n && t > 1 ) {
            const i = this._buffer.getLineCharCode( e, t - 2 );
            if ( C.isHighSurrogate( i ) ) return !1
          }
          return !0
        }, t.prototype._validatePosition = function ( e, t, n ) {
          const i = Math.floor( "number" !== typeof e || isNaN( e ) ? 1 : e ),
            o = Math.floor( "number" !== typeof t || isNaN( t ) ? 1 : t ),
            r = this._buffer.getLineCount();
          if ( i < 1 ) return new Q.a( 1, 1 );
          if ( i > r ) return new Q.a( r, this.getLineMaxColumn( r ) );
          if ( o <= 1 ) return new Q.a( i, 1 );
          const s = this.getLineMaxColumn( i );
          if ( o >= s ) return new Q.a( i, s );
          if ( n ) {
            const a = this._buffer.getLineCharCode( i, o - 2 );
            if ( C.isHighSurrogate( a ) ) return new Q.a( i, o - 1 )
          }
          return new Q.a( i, o )
        }, t.prototype.validatePosition = function ( e ) {
          return this._assertNotDisposed(), e instanceof Q.a && this._isValidPosition( e.lineNumber, e.column, !0 ) ? e : this._validatePosition( e.lineNumber, e.column, !0 )
        }, t.prototype._isValidRange = function ( e, t ) {
          const n = e.startLineNumber,
            i = e.startColumn,
            o = e.endLineNumber,
            r = e.endColumn;
          if ( !this._isValidPosition( n, i, !1 ) ) return !1;
          if ( !this._isValidPosition( o, r, !1 ) ) return !1;
          if ( t ) {
            const s = i > 1 ? this._buffer.getLineCharCode( n, i - 2 ) : 0,
              a = r > 1 && r <= this._buffer.getLineLength( o ) ? this._buffer.getLineCharCode( o, r - 2 ) : 0,
              u = C.isHighSurrogate( s ),
              l = C.isHighSurrogate( a );
            return !u && !l
          }
          return !0
        }, t.prototype.validateRange = function ( e ) {
          if ( this._assertNotDisposed(), e instanceof h.a && !( e instanceof p.a ) && this._isValidRange( e, !0 ) ) return e;
          const t = this._validatePosition( e.startLineNumber, e.startColumn, !1 ),
            n = this._validatePosition( e.endLineNumber, e.endColumn, !1 ),
            i = t.lineNumber,
            o = t.column,
            r = n.lineNumber,
            s = n.column,
            a = o > 1 ? this._buffer.getLineCharCode( i, o - 2 ) : 0,
            u = s > 1 && s <= this._buffer.getLineLength( r ) ? this._buffer.getLineCharCode( r, s - 2 ) : 0,
            l = C.isHighSurrogate( a ),
            c = C.isHighSurrogate( u );
          return l || c ? i === r && o === s ? new h.a( i, o - 1, r, s - 1 ) : l && c ? new h.a( i, o - 1, r, s + 1 ) : l ? new h.a( i, o - 1, r, s ) : new h.a( i, o, r, s + 1 ) : new h.a( i, o, r, s )
        }, t.prototype.modifyPosition = function ( e, t ) {
          this._assertNotDisposed();
          const n = this.getOffsetAt( e ) + t;
          return this.getPositionAt( Math.min( this._buffer.getLength(), Math.max( 0, n ) ) )
        }, t.prototype.getFullModelRange = function () {
          this._assertNotDisposed();
          const e = this.getLineCount();
          return new h.a( 1, 1, e, this.getLineMaxColumn( e ) )
        }, t.prototype.findMatchesLineByLine = function ( e, t, n, i ) {
          return this._buffer.findMatchesLineByLine( e, t, n, i )
        }, t.prototype.findMatches = function ( e, t, n, i, o, r, s ) {
          let a;
          if ( void 0 === s && ( s = 999 ), this._assertNotDisposed(), a = h.a.isIRange( t ) ? this.validateRange( t ) : this.getFullModelRange(), !n && e.indexOf( "\n" ) < 0 ) {
            const u = new de.a( e, n, i, o ).parseSearchRequest();
            return u ? this.findMatchesLineByLine( a, u, r, s ) : []
          }
          return de.c.findMatches( this, new de.a( e, n, i, o ), a, r, s )
        }, t.prototype.findNextMatch = function ( e, t, n, i, o, r ) {
          this._assertNotDisposed();
          const s = this.validatePosition( t );
          if ( !n && e.indexOf( "\n" ) < 0 ) {
            const a = new de.a( e, n, i, o ).parseSearchRequest();
            const u = this.getLineCount();
            let l = new h.a( s.lineNumber, s.column, u, this.getLineMaxColumn( u ) );
            let c = this.findMatchesLineByLine( l, a, r, 1 );
            return de.c.findNextMatch( this, new de.a( e, n, i, o ), s, r ), c.length > 0 ? c[ 0 ] : ( l = new h.a( 1, 1, s.lineNumber, this.getLineMaxColumn( s.lineNumber ) ), ( c = this.findMatchesLineByLine( l, a, r, 1 ) ).length > 0 ? c[ 0 ] : null )
          }
          return de.c.findNextMatch( this, new de.a( e, n, i, o ), s, r )
        }, t.prototype.findPreviousMatch = function ( e, t, n, i, o, r ) {
          this._assertNotDisposed();
          const s = this.validatePosition( t );
          return de.c.findPreviousMatch( this, new de.a( e, n, i, o ), s, r )
        }, t.prototype.pushStackElement = function () {
          this._commandManager.pushStackElement()
        }, t.prototype.pushEOL = function ( e ) {
          if ( ( "\n" === this.getEOL() ? r.d.LF : r.d.CRLF ) !== e ) try {
            this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._commandManager.pushEOL( e )
          } finally {
            this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit()
          }
        }, t.prototype.pushEditOperations = function ( e, t, n ) {
          try {
            return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations( e, t, n )
          } finally {
            this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit()
          }
        }, t.prototype._pushEditOperations = function ( e, t, n ) {
          const i = this;
          if ( this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines ) {
            for ( var o = t.map( ( e => {
                return {
                  range: i.validateRange( e.range ),
                  text: e.text
                }
              } ) ), r = !0, s = 0, a = e.length; s < a; s++ ) {
              for ( var u = e[ s ], l = !1, c = 0, d = o.length; c < d; c++ ) {
                const p = ( v = o[ c ].range ).startLineNumber > u.endLineNumber,
                  f = u.startLineNumber > v.endLineNumber;
                if ( !p && !f ) {
                  l = !0;
                  break
                }
              }
              if ( !l ) {
                r = !1;
                break
              }
            }
            if ( r )
              for ( s = 0, a = this._trimAutoWhitespaceLines.length; s < a; s++ ) {
                const g = this._trimAutoWhitespaceLines[ s ];
                const m = this.getLineMaxColumn( g );
                let _ = !0;
                for ( c = 0, d = o.length; c < d; c++ ) {
                  var v = o[ c ].range;
                  const y = o[ c ].text;
                  if ( !( g < v.startLineNumber || g > v.endLineNumber ) && ( !( g === v.startLineNumber && v.startColumn === m && v.isEmpty() && y && y.length > 0 && "\n" === y.charAt( 0 ) ) && !( g === v.startLineNumber && 1 === v.startColumn && v.isEmpty() && y && y.length > 0 && "\n" === y.charAt( y.length - 1 ) ) ) ) {
                    _ = !1;
                    break
                  }
                }
                _ && t.push( {
                  range: new h.a( g, 1, g, m ),
                  text: null
                } )
              }
            this._trimAutoWhitespaceLines = null
          }
          return this._commandManager.pushEditOperation( e, t, n )
        }, t.prototype.applyEdits = function ( e ) {
          try {
            return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._applyEdits( e )
          } finally {
            this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit()
          }
        }, t._eolCount = e => {
          for ( var t = 0, n = 0, i = 0, o = e.length; i < o; i++ ) {
            const r = e.charCodeAt( i );
            13 === r ? ( 0 === t && ( n = i ), t++, i + 1 < o && 10 === e.charCodeAt( i + 1 ) && i++ ) : 10 === r && ( 0 === t && ( n = i ), t++ )
          }
          return 0 === t && ( n = e.length ), [ t, n ]
        }, t.prototype._applyEdits = function ( e ) {
          for ( var n = 0, i = e.length; n < i; n++ ) e[ n ].range = this.validateRange( e[ n ].range );
          const o = this._buffer.getLineCount(),
            r = this._buffer.applyEdits( e, this._options.trimAutoWhitespace ),
            s = this._buffer.getLineCount(),
            a = r.changes;
          if ( this._trimAutoWhitespaceLines = r.trimAutoWhitespaceLineNumbers, 0 !== a.length ) {
            const u = [];
            let l = o;
            for ( n = 0, i = a.length; n < i; n++ ) {
              const c = a[ n ],
                d = t._eolCount( c.text ),
                h = d[ 0 ],
                p = d[ 1 ];
              this._tokens.applyEdits( c.range, h, p ), this._onDidChangeDecorations.fire(), this._decorationsTree.acceptReplace( c.rangeOffset, c.rangeLength, c.text.length, c.forceMoveMarkers );
              for ( var f = c.range.startLineNumber, v = c.range.endLineNumber, b = v - f, C = h, w = Math.min( b, C ), S = C - b, O = w; O >= 0; O-- ) {
                const L = f + O,
                  x = s - l - S + L;
                u.push( new g( L, this.getLineContent( x ) ) )
              }
              if ( w < b ) {
                const N = f + w;
                u.push( new m( N + 1, v ) )
              }
              if ( w < C ) {
                for ( var E = f + w, k = C - w, I = s - l - k + E + 1, D = [], M = 0; M < k; M++ ) {
                  const T = I + M;
                  D[ T - I ] = this.getLineContent( T )
                }
                u.push( new _( E + 1, f + C, D ) )
              }
              l += S
            }
            this._increaseVersionId(), this._emitContentChangedEvent( new y( u, this.getVersionId(), this._isUndoing, this._isRedoing ), {
              changes: a,
              eol: this._buffer.getEOL(),
              versionId: this.getVersionId(),
              isUndoing: this._isUndoing,
              isRedoing: this._isRedoing,
              isFlush: !1
            } )
          }
          return this._tokens.hasLinesToTokenize( this._buffer ) && this._beginBackgroundTokenization(), r.reverseEdits
        }, t.prototype._undo = function () {
          this._isUndoing = !0;
          const e = this._commandManager.undo();
          return this._isUndoing = !1, e ? ( this._overwriteAlternativeVersionId( e.recordedVersionId ), e.selections ) : null
        }, t.prototype.undo = function () {
          try {
            return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._undo()
          } finally {
            this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit()
          }
        }, t.prototype.canUndo = function () {
          return this._commandManager.canUndo()
        }, t.prototype._redo = function () {
          this._isRedoing = !0;
          const e = this._commandManager.redo();
          return this._isRedoing = !1, e ? ( this._overwriteAlternativeVersionId( e.recordedVersionId ), e.selections ) : null
        }, t.prototype.redo = function () {
          try {
            return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._redo()
          } finally {
            this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit()
          }
        }, t.prototype.canRedo = function () {
          return this._commandManager.canRedo()
        }, t.prototype.changeDecorations = function ( e, t ) {
          void 0 === t && ( t = 0 ), this._assertNotDisposed();
          try {
            return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations( t, e )
          } finally {
            this._onDidChangeDecorations.endDeferredEmit()
          }
        }, t.prototype._changeDecorations = function ( e, t ) {
          const n = this;
          const i = {
            addDecoration( t, i ) {
              return n._onDidChangeDecorations.fire(), n._deltaDecorationsImpl( e, [], [ {
                range: t,
                options: i
              } ] )[ 0 ]
            },
            changeDecoration( e, t ) {
              n._onDidChangeDecorations.fire(), n._changeDecorationImpl( e, t )
            },
            changeDecorationOptions( e, t ) {
              n._onDidChangeDecorations.fire(), n._changeDecorationOptionsImpl( e, Ke( t ) )
            },
            removeDecoration( t ) {
              n._onDidChangeDecorations.fire(), n._deltaDecorationsImpl( e, [ t ], [] )
            },
            deltaDecorations( t, i ) {
              return 0 === t.length && 0 === i.length ? [] : ( n._onDidChangeDecorations.fire(), n._deltaDecorationsImpl( e, t, i ) )
            }
          };
          let o = null;
          try {
            o = t( i )
          } catch ( r ) {
            Object( a.e )( r )
          }
          return i.addDecoration = null, i.changeDecoration = null, i.removeDecoration = null, i.deltaDecorations = null, o
        }, t.prototype.deltaDecorations = function ( e, t, n ) {
          if ( void 0 === n && ( n = 0 ), this._assertNotDisposed(), e || ( e = [] ), 0 === e.length && 0 === t.length ) return [];
          try {
            return this._onDidChangeDecorations.beginDeferredEmit(), this._onDidChangeDecorations.fire(), this._deltaDecorationsImpl( n, e, t )
          } finally {
            this._onDidChangeDecorations.endDeferredEmit()
          }
        }, t.prototype._getTrackedRange = function ( e ) {
          return this.getDecorationRange( e )
        }, t.prototype._setTrackedRange = function ( e, t, n ) {
          const i = e ? this._decorations[ e ] : null;
          if ( !i ) return t ? this._deltaDecorationsImpl( 0, [], [ {
            range: t,
            options: Ue[ n ]
          } ] )[ 0 ] : null;
          if ( !t ) return this._decorationsTree.delete( i ), delete this._decorations[ i.id ], null;
          const o = this._validateRangeRelaxedNoAllocations( t ),
            r = this._buffer.getOffsetAt( o.startLineNumber, o.startColumn ),
            s = this._buffer.getOffsetAt( o.endLineNumber, o.endColumn );
          return this._decorationsTree.delete( i ), i.reset( this.getVersionId(), r, s, o ), i.setOptions( Ue[ n ] ), this._decorationsTree.insert( i ), i.id
        }, t.prototype.removeAllDecorationsWithOwnerId = function ( e ) {
          if ( !this._isDisposed )
            for ( let t = this._decorationsTree.collectNodesFromOwner( e ), n = 0, i = t.length; n < i; n++ ) {
              const o = t[ n ];
              this._decorationsTree.delete( o ), delete this._decorations[ o.id ]
            }
        }, t.prototype.getDecorationOptions = function ( e ) {
          const t = this._decorations[ e ];
          return t ? t.options : null
        }, t.prototype.getDecorationRange = function ( e ) {
          const t = this._decorations[ e ];
          if ( !t ) return null;
          const n = this.getVersionId();
          return t.cachedVersionId !== n && this._decorationsTree.resolveNode( t, n ), null === t.range && ( t.range = this._getRangeAt( t.cachedAbsoluteStart, t.cachedAbsoluteEnd ) ), t.range
        }, t.prototype.getLineDecorations = function ( e, t, n ) {
          return void 0 === t && ( t = 0 ), void 0 === n && ( n = !1 ), e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations( e, e, t, n )
        }, t.prototype.getLinesDecorations = function ( e, t, n, i ) {
          void 0 === n && ( n = 0 ), void 0 === i && ( i = !1 );
          const o = this.getLineCount(),
            r = Math.min( o, Math.max( 1, e ) ),
            s = Math.min( o, Math.max( 1, t ) ),
            a = this.getLineMaxColumn( s );
          return this._getDecorationsInRange( new h.a( r, 1, s, a ), n, i )
        }, t.prototype.getDecorationsInRange = function ( e, t, n ) {
          void 0 === t && ( t = 0 ), void 0 === n && ( n = !1 );
          const i = this.validateRange( e );
          return this._getDecorationsInRange( i, t, n )
        }, t.prototype.getOverviewRulerDecorations = function ( e, t ) {
          void 0 === e && ( e = 0 ), void 0 === t && ( t = !1 );
          const n = this.getVersionId(),
            i = this._decorationsTree.search( e, t, !0, n );
          return this._ensureNodesHaveRanges( i )
        }, t.prototype.getAllDecorations = function ( e, t ) {
          void 0 === e && ( e = 0 ), void 0 === t && ( t = !1 );
          const n = this.getVersionId(),
            i = this._decorationsTree.search( e, t, !1, n );
          return this._ensureNodesHaveRanges( i )
        }, t.prototype._getDecorationsInRange = function ( e, t, n ) {
          const i = this._buffer.getOffsetAt( e.startLineNumber, e.startColumn ),
            o = this._buffer.getOffsetAt( e.endLineNumber, e.endColumn ),
            r = this.getVersionId(),
            s = this._decorationsTree.intervalSearch( i, o, t, n, r );
          return this._ensureNodesHaveRanges( s )
        }, t.prototype._ensureNodesHaveRanges = function ( e ) {
          for ( let t = 0, n = e.length; t < n; t++ ) {
            const i = e[ t ];
            null === i.range && ( i.range = this._getRangeAt( i.cachedAbsoluteStart, i.cachedAbsoluteEnd ) )
          }
          return e
        }, t.prototype._getRangeAt = function ( e, t ) {
          return this._buffer.getRangeAt( e, t - e )
        }, t.prototype._changeDecorationImpl = function ( e, t ) {
          const n = this._decorations[ e ];
          if ( n ) {
            const i = this._validateRangeRelaxedNoAllocations( t ),
              o = this._buffer.getOffsetAt( i.startLineNumber, i.startColumn ),
              r = this._buffer.getOffsetAt( i.endLineNumber, i.endColumn );
            this._decorationsTree.delete( n ), n.reset( this.getVersionId(), o, r, i ), this._decorationsTree.insert( n )
          }
        }, t.prototype._changeDecorationOptionsImpl = function ( e, t ) {
          const n = this._decorations[ e ];
          n && ( !!n.options.overviewRuler.color !== !!t.overviewRuler.color ? ( this._decorationsTree.delete( n ), n.setOptions( t ), this._decorationsTree.insert( n ) ) : n.setOptions( t ) )
        }, t.prototype._deltaDecorationsImpl = function ( e, t, n ) {
          for ( var i = this.getVersionId(), o = t.length, r = 0, s = n.length, a = 0, u = new Array( s ); r < o || a < s; ) {
            let l = null;
            if ( r < o ) {
              do {
                l = this._decorations[ t[ r++ ] ]
              } while ( !l && r < o );
              l && this._decorationsTree.delete( l )
            }
            if ( a < s ) {
              if ( !l ) {
                const c = ++this._lastDecorationId,
                  d = this._instanceId + ";" + c;
                l = new D( d, 0, 0 ), this._decorations[ d ] = l
              }
              const h = n[ a ],
                p = this._validateRangeRelaxedNoAllocations( h.range ),
                f = Ke( h.options ),
                g = this._buffer.getOffsetAt( p.startLineNumber, p.startColumn ),
                m = this._buffer.getOffsetAt( p.endLineNumber, p.endColumn );
              l.ownerId = e, l.reset( i, g, m, p ), l.setOptions( f ), this._decorationsTree.insert( l ), u[ a ] = l.id, a++
            } else l && delete this._decorations[ l.id ]
          }
          return u
        }, t.prototype.tokenizeViewport = function ( e, t ) {
          if ( this._tokens.tokenizationSupport ) {
            const n = Math.floor( .3 * this._tokens.inValidLineStartIndex );
            if ( ( e = Math.max( 1, e - n ) ) <= this._tokens.inValidLineStartIndex ) this.forceTokenization( t );
            else {
              const i = new ae;
              let o = this.getLineFirstNonWhitespaceColumn( e );
              const r = [];
              let s = e - 1;
              let a = null;
              if ( o > 0 )
                for ( ; o > 0 && s >= 1; ) {
                  const u = this.getLineFirstNonWhitespaceColumn( s );
                  if ( 0 !== u ) {
                    if ( u < o ) {
                      if ( a = this._tokens._getState( s - 1 ) ) break;
                      r.push( this.getLineContent( s ) ), o = u
                    }
                    s--
                  } else s--
                }
              a || ( a = this._tokens.tokenizationSupport.getInitialState() );
              for ( var l = a.clone(), c = r.length - 1; c >= 0; c-- ) {
                l = ( p = this._tokens._tokenizeText( this._buffer, r[ c ], l ) ) ? p.endState.clone() : a.clone()
              }
              const d = Math.floor( .4 * this._tokens.inValidLineStartIndex );
              t = Math.min( this.getLineCount(), t + d );
              for ( let h = e; h <= t; h++ ) {
                var p;
                const f = this.getLineContent( h );
                ( p = this._tokens._tokenizeText( this._buffer, f, l ) ) ? ( this._tokens._setTokens( this._tokens.languageIdentifier.id, h - 1, f.length, p.tokens ), this._tokens._setIsInvalid( h - 1, !1 ), this._tokens._setState( h - 1, l ), l = p.endState.clone(), i.registerChangedTokens( h ) ) : l = a.clone()
              }
              const g = i.build();
              g && this._onDidChangeTokens.fire( g )
            }
          }
        }, t.prototype.forceTokenization = function ( e ) {
          if ( e < 1 || e > this.getLineCount() ) throw new Error( "Illegal value for lineNumber" );
          const t = new ae;
          this._tokens._updateTokensUntilLine( this._buffer, t, e );
          const n = t.build();
          n && this._onDidChangeTokens.fire( n )
        }, t.prototype.isCheapToTokenize = function ( e ) {
          return this._tokens.isCheapToTokenize( e )
        }, t.prototype.tokenizeIfCheap = function ( e ) {
          this.isCheapToTokenize( e ) && this.forceTokenization( e )
        }, t.prototype.getLineTokens = function ( e ) {
          if ( e < 1 || e > this.getLineCount() ) throw new Error( "Illegal value for lineNumber" );
          return this._getLineTokens( e )
        }, t.prototype._getLineTokens = function ( e ) {
          const t = this._buffer.getLineContent( e );
          return this._tokens.getTokens( this._languageIdentifier.id, e - 1, t )
        }, t.prototype.getLanguageIdentifier = function () {
          return this._languageIdentifier
        }, t.prototype.getModeId = function () {
          return this._languageIdentifier.language
        }, t.prototype.setMode = function ( e ) {
          if ( this._languageIdentifier.id !== e.id ) {
            const t = {
              oldLanguage: this._languageIdentifier.language,
              newLanguage: e.language
            };
            this._languageIdentifier = e, this._resetTokenizationState(), this.emitModelTokensChangedEvent( {
              ranges: [ {
                fromLineNumber: 1,
                toLineNumber: this.getLineCount()
              } ]
            } ), this._onDidChangeLanguage.fire( t ), this._onDidChangeLanguageConfiguration.fire( {} )
          }
        }, t.prototype.getLanguageIdAtPosition = function ( e, t ) {
          if ( !this._tokens.tokenizationSupport ) return this._languageIdentifier.id;
          const n = this.validatePosition( {
              lineNumber: e,
              column: t
            } ),
            i = n.lineNumber,
            o = n.column,
            r = this._getLineTokens( i );
          return r.getLanguageId( r.findTokenIndexAtOffset( o - 1 ) )
        }, t.prototype._beginBackgroundTokenization = function () {
          const e = this;
          this._shouldAutoTokenize() && -1 === this._revalidateTokensTimeout && ( this._revalidateTokensTimeout = setTimeout( ( () => {
            e._revalidateTokensTimeout = -1, e._revalidateTokensNow()
          } ), 0 ) )
        }, t.prototype._warmUpTokens = function () {
          const e = Math.min( 100, this.getLineCount() );
          this._revalidateTokensNow( e ), this._tokens.hasLinesToTokenize( this._buffer ) && this._beginBackgroundTokenization()
        }, t.prototype._revalidateTokensNow = function ( e ) {
          void 0 === e && ( e = this._buffer.getLineCount() );
          for ( var t = new ae, n = Y.create( !1 ); this._tokens.hasLinesToTokenize( this._buffer ) && !( n.elapsed() > 20 ); ) {
            if ( this._tokens._tokenizeOneLine( this._buffer, t ) >= e ) break
          }
          this._tokens.hasLinesToTokenize( this._buffer ) && this._beginBackgroundTokenization();
          const i = t.build();
          i && this._onDidChangeTokens.fire( i )
        }, t.prototype.emitModelTokensChangedEvent = function ( e ) {
          this._isDisposing || this._onDidChangeTokens.fire( e )
        }, t.prototype.getWordAtPosition = function ( e ) {
          this._assertNotDisposed();
          const n = this.validatePosition( e ),
            i = this.getLineContent( n.lineNumber ),
            o = this._getLineTokens( n.lineNumber ),
            r = o.findTokenIndexAtOffset( n.column - 1 ),
            s = t._findLanguageBoundaries( o, r ),
            a = s[ 0 ],
            u = s[ 1 ],
            l = Object( ee.d )( n.column, J.a.getWordDefinition( o.getLanguageId( r ) ), i.substring( a, u ), a );
          if ( l ) return l;
          if ( r > 0 && a === n.column - 1 ) {
            const c = t._findLanguageBoundaries( o, r - 1 ),
              d = c[ 0 ],
              h = c[ 1 ],
              p = Object( ee.d )( n.column, J.a.getWordDefinition( o.getLanguageId( r - 1 ) ), i.substring( d, h ), d );
            if ( p ) return p
          }
          return null
        }, t._findLanguageBoundaries = ( e, t ) => {
          for ( var n, i, o = e.getLanguageId( t ), r = t; r >= 0 && e.getLanguageId( r ) === o; r-- ) n = e.getStartOffset( r );
          r = t;
          for ( const s = e.getCount(); r < s && e.getLanguageId( r ) === o; r++ ) i = e.getEndOffset( r );
          return [ n, i ]
        }, t.prototype.getWordUntilPosition = function ( e ) {
          const t = this.getWordAtPosition( e );
          return t ? {
            word: t.word.substr( 0, e.column - t.startColumn ),
            startColumn: t.startColumn,
            endColumn: e.column
          } : {
            word: "",
            startColumn: e.column,
            endColumn: e.column
          }
        }, t.prototype.findMatchingBracketUp = function ( e, t ) {
          const n = e.toLowerCase(),
            i = this.validatePosition( t ),
            o = this._getLineTokens( i.lineNumber ),
            r = o.getLanguageId( o.findTokenIndexAtOffset( i.column - 1 ) ),
            s = J.a.getBracketsSupport( r );
          if ( !s ) return null;
          const a = s.textIsBracket[ n ];
          return a ? this._findMatchingBracketUp( a, i ) : null
        }, t.prototype.matchBracket = function ( e ) {
          return this._matchBracket( this.validatePosition( e ) )
        }, t.prototype._matchBracket = function ( e ) {
          const t = e.lineNumber;
          const n = this._getLineTokens( t );
          const i = this._buffer.getLineContent( t );
          let o = n.findTokenIndexAtOffset( e.column - 1 );
          if ( o < 0 ) return null;
          const r = J.a.getBracketsSupport( n.getLanguageId( o ) );
          if ( r && !Object( $.b )( n.getStandardTokenType( o ) ) ) {
            for ( var s = Math.max( n.getStartOffset( o ), e.column - 1 - r.maxBracketLength ), a = Math.min( n.getEndOffset( o ), e.column - 1 + r.maxBracketLength ), u = null;; ) {
              if ( !( c = Z.a.findNextBracketInToken( r.forwardRegex, t, i, s, a ) ) ) break;
              if ( c.startColumn <= e.column && e.column <= c.endColumn ) d = ( d = i.substring( c.startColumn - 1, c.endColumn - 1 ) ).toLowerCase(), ( h = this._matchFoundBracket( c, r.textIsBracket[ d ], r.textIsOpenBracket[ d ] ) ) && ( u = h );
              s = c.endColumn - 1
            }
            if ( u ) return u
          }
          if ( o > 0 && n.getStartOffset( o ) === e.column - 1 ) {
            a = n.getStartOffset( o );
            o--;
            const l = J.a.getBracketsSupport( n.getLanguageId( o ) );
            if ( l && !Object( $.b )( n.getStandardTokenType( o ) ) ) {
              var c, d, h;
              s = Math.max( n.getStartOffset( o ), e.column - 1 - l.maxBracketLength );
              if ( ( c = Z.a.findPrevBracketInToken( l.reversedRegex, t, i, s, a ) ) && c.startColumn <= e.column && e.column <= c.endColumn )
                if ( d = ( d = i.substring( c.startColumn - 1, c.endColumn - 1 ) ).toLowerCase(), h = this._matchFoundBracket( c, l.textIsBracket[ d ], l.textIsOpenBracket[ d ] ) ) return h
            }
          }
          return null
        }, t.prototype._matchFoundBracket = function ( e, t, n ) {
          if ( !t ) return null;
          let i;
          if ( n ) {
            if ( i = this._findMatchingBracketDown( t, e.getEndPosition() ) ) return [ e, i ]
          } else if ( i = this._findMatchingBracketUp( t, e.getStartPosition() ) ) return [ e, i ];
          return null
        }, t.prototype._findMatchingBracketUp = function ( e, t ) {
          for ( let n = e.languageIdentifier.id, i = e.reversedRegex, o = -1, r = t.lineNumber; r >= 1; r-- ) {
            const s = this._getLineTokens( r );
            const a = s.getCount();
            const u = this._buffer.getLineContent( r );
            let l = a - 1;
            let c = -1;
            for ( r === t.lineNumber && ( l = s.findTokenIndexAtOffset( t.column - 1 ), c = t.column - 1 ); l >= 0; l-- ) {
              const d = s.getLanguageId( l ),
                h = s.getStandardTokenType( l ),
                p = s.getStartOffset( l ),
                f = s.getEndOffset( l );
              if ( -1 === c && ( c = f ), d === n && !Object( $.b )( h ) )
                for ( ;; ) {
                  const g = Z.a.findPrevBracketInToken( i, r, u, p, c );
                  if ( !g ) break;
                  let m = u.substring( g.startColumn - 1, g.endColumn - 1 );
                  if ( ( m = m.toLowerCase() ) === e.open ? o++ : m === e.close && o--, 0 === o ) return g;
                  c = g.startColumn - 1
                }
              c = -1
            }
          }
          return null
        }, t.prototype._findMatchingBracketDown = function ( e, t ) {
          for ( let n = e.languageIdentifier.id, i = e.forwardRegex, o = 1, r = t.lineNumber, s = this.getLineCount(); r <= s; r++ ) {
            const a = this._getLineTokens( r );
            const u = a.getCount();
            const l = this._buffer.getLineContent( r );
            let c = 0;
            let d = 0;
            for ( r === t.lineNumber && ( c = a.findTokenIndexAtOffset( t.column - 1 ), d = t.column - 1 ); c < u; c++ ) {
              const h = a.getLanguageId( c ),
                p = a.getStandardTokenType( c ),
                f = a.getStartOffset( c ),
                g = a.getEndOffset( c );
              if ( 0 === d && ( d = f ), h === n && !Object( $.b )( p ) )
                for ( ;; ) {
                  const m = Z.a.findNextBracketInToken( i, r, l, d, g );
                  if ( !m ) break;
                  let _ = l.substring( m.startColumn - 1, m.endColumn - 1 );
                  if ( ( _ = _.toLowerCase() ) === e.open ? o++ : _ === e.close && o--, 0 === o ) return m;
                  d = m.endColumn - 1
                }
              d = 0
            }
          }
          return null
        }, t.prototype.findNextBracket = function ( e ) {
          for ( let t = this.validatePosition( e ), n = -1, i = null, o = t.lineNumber, r = this.getLineCount(); o <= r; o++ ) {
            const s = this._getLineTokens( o );
            const a = s.getCount();
            const u = this._buffer.getLineContent( o );
            let l = 0;
            let c = 0;
            for ( o === t.lineNumber && ( l = s.findTokenIndexAtOffset( t.column - 1 ), c = t.column - 1 ); l < a; l++ ) {
              const d = s.getLanguageId( l ),
                h = s.getStandardTokenType( l ),
                p = s.getStartOffset( l ),
                f = s.getEndOffset( l );
              if ( 0 === c && ( c = p ), n !== d && ( n = d, i = J.a.getBracketsSupport( n ) ), i && !Object( $.b )( h ) ) {
                const g = Z.a.findNextBracketInToken( i.forwardRegex, o, u, c, f );
                if ( g ) return this._toFoundBracket( i, g )
              }
              c = 0
            }
          }
          return null
        }, t.prototype._toFoundBracket = function ( e, t ) {
          if ( !t ) return null;
          let n = this.getValueInRange( t );
          n = n.toLowerCase();
          const i = e.textIsBracket[ n ];
          return i ? {
            range: t,
            open: i.open,
            close: i.close,
            isOpen: e.textIsOpenBracket[ n ]
          } : null
        }, t.computeIndentLevel = ( e, t ) => {
          for ( var n = 0, i = 0, o = e.length; i < o; ) {
            const r = e.charCodeAt( i );
            if ( 32 === r ) n++;
            else {
              if ( 9 !== r ) break;
              n = n - n % t + t
            }
            i++
          }
          return i === o ? -1 : n
        }, t.prototype._computeIndentLevel = function ( e ) {
          return t.computeIndentLevel( this._buffer.getLineContent( e + 1 ), this._options.tabSize )
        }, t.prototype.getActiveIndentGuide = function ( e, t, n ) {
          const i = this;
          this._assertNotDisposed();
          const o = this.getLineCount();
          if ( e < 1 || e > o ) throw new Error( "Illegal value for lineNumber" );
          for ( var r = J.a.getFoldingRules( this._languageIdentifier.id ), s = r && r.offSide, a = -2, u = -1, l = -2, c = -1, d = e => {
              if ( -1 !== a && ( -2 === a || a > e - 1 ) ) {
                a = -1, u = -1;
                for ( var t = e - 2; t >= 0; t-- ) {
                  const n = i._computeIndentLevel( t );
                  if ( n >= 0 ) {
                    a = t, u = n;
                    break
                  }
                }
              }
              if ( -2 === l ) {
                l = -1, c = -1;
                for ( t = e; t < o; t++ ) {
                  const r = i._computeIndentLevel( t );
                  if ( r >= 0 ) {
                    l = t, c = r;
                    break
                  }
                }
              }
            }, h = -2, p = -1, f = -2, g = -1, m = e => {
              if ( -2 === h ) {
                h = -1, p = -1;
                for ( var t = e - 2; t >= 0; t-- ) {
                  const n = i._computeIndentLevel( t );
                  if ( n >= 0 ) {
                    h = t, p = n;
                    break
                  }
                }
              }
              if ( -1 !== f && ( -2 === f || f < e - 1 ) ) {
                f = -1, g = -1;
                for ( t = e; t < o; t++ ) {
                  const r = i._computeIndentLevel( t );
                  if ( r >= 0 ) {
                    f = t, g = r;
                    break
                  }
                }
              }
            }, _ = 0, v = !0, y = 0, b = !0, C = 0, w = 0; v || b; w++ ) {
            const S = e - w,
              O = e + w;
            if ( 0 !== w && ( S < 1 || S < t ) && ( v = !1 ), 0 !== w && ( O > o || O > n ) && ( b = !1 ), w > 5e4 && ( v = !1, b = !1 ), v ) {
              let L = void 0;
              if ( ( x = this._computeIndentLevel( S - 1 ) ) >= 0 ? ( l = S - 1, c = x, L = Math.ceil( x / this._options.tabSize ) ) : ( d( S ), L = this._getIndentLevelForWhitespaceLine( s, u, c ) ), 0 === w ) {
                if ( _ = S, y = O, 0 === ( C = L ) ) return {
                  startLineNumber: _,
                  endLineNumber: y,
                  indent: C
                };
                continue
              }
              L >= C ? _ = S : v = !1
            }
            if ( b ) {
              var x;
              let N = void 0;
              ( x = this._computeIndentLevel( O - 1 ) ) >= 0 ? ( h = O - 1, p = x, N = Math.ceil( x / this._options.tabSize ) ) : ( m( O ), N = this._getIndentLevelForWhitespaceLine( s, p, g ) ), N >= C ? y = O : b = !1
            }
          }
          return {
            startLineNumber: _,
            endLineNumber: y,
            indent: C
          }
        }, t.prototype.getLinesIndentGuides = function ( e, t ) {
          this._assertNotDisposed();
          const n = this.getLineCount();
          if ( e < 1 || e > n ) throw new Error( "Illegal value for startLineNumber" );
          if ( t < 1 || t > n ) throw new Error( "Illegal value for endLineNumber" );
          for ( var i = J.a.getFoldingRules( this._languageIdentifier.id ), o = i && i.offSide, r = new Array( t - e + 1 ), s = -2, a = -1, u = -2, l = -1, c = e; c <= t; c++ ) {
            const d = c - e,
              h = this._computeIndentLevel( c - 1 );
            if ( h >= 0 ) s = c - 1, a = h, r[ d ] = Math.ceil( h / this._options.tabSize );
            else {
              if ( -2 === s ) {
                s = -1, a = -1;
                for ( var p = c - 2; p >= 0; p-- ) {
                  if ( ( f = this._computeIndentLevel( p ) ) >= 0 ) {
                    s = p, a = f;
                    break
                  }
                }
              }
              if ( -1 !== u && ( -2 === u || u < c - 1 ) ) {
                u = -1, l = -1;
                for ( p = c; p < n; p++ ) {
                  var f;
                  if ( ( f = this._computeIndentLevel( p ) ) >= 0 ) {
                    u = p, l = f;
                    break
                  }
                }
              }
              r[ d ] = this._getIndentLevelForWhitespaceLine( o, a, l )
            }
          }
          return r
        }, t.prototype._getIndentLevelForWhitespaceLine = function ( e, t, n ) {
          return -1 === t || -1 === n ? 0 : t < n ? 1 + Math.floor( t / this._options.tabSize ) : t === n ? Math.ceil( n / this._options.tabSize ) : e ? Math.ceil( n / this._options.tabSize ) : 1 + Math.floor( n / this._options.tabSize )
        }, t.MODEL_SYNC_LIMIT = 52428800, t.LARGE_FILE_SIZE_THRESHOLD = 20971520, t.LARGE_FILE_LINE_COUNT_THRESHOLD = 3e5, t.DEFAULT_CREATION_OPTIONS = {
          isForSimpleWidget: !1,
          tabSize: ce.c.tabSize,
          insertSpaces: ce.c.insertSpaces,
          detectIndentation: !1,
          defaultEOL: r.b.LF,
          trimAutoWhitespace: ce.c.trimAutoWhitespace,
          largeFileOptimizations: ce.c.largeFileOptimizations
        }, t;
      } )( K.a );

      const Ve = ( () => {
        function e() {
          this._decorationsTree0 = new T, this._decorationsTree1 = new T
        }
        return e.prototype.intervalSearch = function ( e, t, n, i, o ) {
          const r = this._decorationsTree0.intervalSearch( e, t, n, i, o ),
            s = this._decorationsTree1.intervalSearch( e, t, n, i, o );
          return r.concat( s )
        }, e.prototype.search = function ( e, t, n, i ) {
          if ( n ) return this._decorationsTree1.search( e, t, i );
          const o = this._decorationsTree0.search( e, t, i ),
            r = this._decorationsTree1.search( e, t, i );
          return o.concat( r )
        }, e.prototype.collectNodesFromOwner = function ( e ) {
          const t = this._decorationsTree0.collectNodesFromOwner( e ),
            n = this._decorationsTree1.collectNodesFromOwner( e );
          return t.concat( n )
        }, e.prototype.collectNodesPostOrder = function () {
          const e = this._decorationsTree0.collectNodesPostOrder(),
            t = this._decorationsTree1.collectNodesPostOrder();
          return e.concat( t )
        }, e.prototype.insert = function ( e ) {
          E( e ) ? this._decorationsTree1.insert( e ) : this._decorationsTree0.insert( e )
        }, e.prototype.delete = function ( e ) {
          E( e ) ? this._decorationsTree1.delete( e ) : this._decorationsTree0.delete( e )
        }, e.prototype.resolveNode = function ( e, t ) {
          E( e ) ? this._decorationsTree1.resolveNode( e, t ) : this._decorationsTree0.resolveNode( e, t )
        }, e.prototype.acceptReplace = function ( e, t, n, i ) {
          this._decorationsTree0.acceptReplace( e, t, n, i ), this._decorationsTree1.acceptReplace( e, t, n, i )
        }, e;
      } )();

      function Be( e ) {
        return e.replace( /[^a-z0-9\-_]/gi, " " )
      }
      const He = function ( e ) {
        this.color = C.empty, this.darkColor = C.empty, this.hcColor = C.empty, this.position = r.f.Center, this._resolvedColor = null, e && e.color && ( this.color = e.color ), e && e.darkColor && ( this.darkColor = e.darkColor, this.hcColor = e.darkColor ), e && e.hcColor && ( this.hcColor = e.hcColor ), e && e.hasOwnProperty( "position" ) && ( this.position = e.position )
      };
      var ze = ( () => {
        function e( e ) {
          this.stickiness = e.stickiness || r.h.AlwaysGrowsWhenTypingAtEdges, this.zIndex = e.zIndex || 0, this.className = e.className ? Be( e.className ) : C.empty, this.hoverMessage = e.hoverMessage || [], this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || [], this.isWholeLine = e.isWholeLine || !1, this.showIfCollapsed = e.showIfCollapsed || !1, this.overviewRuler = new He( e.overviewRuler ), this.glyphMarginClassName = e.glyphMarginClassName ? Be( e.glyphMarginClassName ) : C.empty, this.linesDecorationsClassName = e.linesDecorationsClassName ? Be( e.linesDecorationsClassName ) : C.empty, this.marginClassName = e.marginClassName ? Be( e.marginClassName ) : C.empty, this.inlineClassName = e.inlineClassName ? Be( e.inlineClassName ) : C.empty, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.beforeContentClassName = e.beforeContentClassName ? Be( e.beforeContentClassName ) : C.empty, this.afterContentClassName = e.afterContentClassName ? Be( e.afterContentClassName ) : C.empty
        }
        return e.register = t => {
          return new e( t )
        }, e.createDynamic = t => {
          return new e( t )
        }, e;
      } )();
      ze.EMPTY = ze.register( {} );
      var Ue = [ ze.register( {
        stickiness: r.h.AlwaysGrowsWhenTypingAtEdges
      } ), ze.register( {
        stickiness: r.h.NeverGrowsWhenTypingAtEdges
      } ), ze.register( {
        stickiness: r.h.GrowsOnlyWhenTypingBefore
      } ), ze.register( {
        stickiness: r.h.GrowsOnlyWhenTypingAfter
      } ) ];

      function Ke( e ) {
        return e instanceof ze ? e : ze.createDynamic( e )
      }
      var qe = ( e => {
          function t() {
            const t = e.call( this ) || this;
            return t._actual = t._register( new o.a ), t.event = t._actual.event, t._deferredCnt = 0, t._shouldFire = !1, t
          }
          return Pe( t, e ), t.prototype.beginDeferredEmit = function () {
            this._deferredCnt++
          }, t.prototype.endDeferredEmit = function () {
            this._deferredCnt--, 0 === this._deferredCnt && this._shouldFire && ( this._shouldFire = !1, this._actual.fire( {} ) )
          }, t.prototype.fire = function () {
            this._shouldFire = !0
          }, t
        } )( K.a ),
        Ge = ( e => {
          function t() {
            const t = e.call( this ) || this;
            return t._fastEmitter = t._register( new o.a ), t.fastEvent = t._fastEmitter.event, t._slowEmitter = t._register( new o.a ), t.slowEvent = t._slowEmitter.event, t._deferredCnt = 0, t._deferredEvent = null, t
          }
          return Pe( t, e ), t.prototype.beginDeferredEmit = function () {
            this._deferredCnt++
          }, t.prototype.endDeferredEmit = function () {
            if ( this._deferredCnt--, 0 === this._deferredCnt && null !== this._deferredEvent ) {
              const e = this._deferredEvent;
              this._deferredEvent = null, this._fastEmitter.fire( e ), this._slowEmitter.fire( e )
            }
          }, t.prototype.fire = function ( e ) {
            this._deferredCnt > 0 ? this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge( e ) : this._deferredEvent = e : ( this._fastEmitter.fire( e ), this._slowEmitter.fire( e ) )
          }, t;
        } )( K.a )
    },
    tXSY( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "T8No" ),
        o = n( "sswD" ),
        r = n( "pmY6" ),
        s = ( n( "dFcq" ), n( "N0LK" ) ),
        a = n( "M1Kb" ),
        u = n( "0/Sa" ),
        l = n( "uACm" ),
        c = n( "gCVg" ),
        d = n( "aokT" ),
        h = n( "6OMU" ),
        p = n( "3/fG" ),
        f = n( "4J+e" ),
        g = ( () => {
          function e( e ) {
            this._delegates = e
          }
          return e.prototype.resolve = function ( e ) {
            for ( let t = 0, n = this._delegates; t < n.length; t++ ) {
              const i = n[ t ].resolve( e );
              if ( void 0 !== i ) return i
            }
          }, e;
        } )(),
        m = ( () => {
          function e( e, t ) {
            this._model = e, this._selection = t
          }
          return e.prototype.resolve = function ( e ) {
            const t = e.name;
            if ( "SELECTION" === t || "TM_SELECTED_TEXT" === t ) {
              let n = this._model.getValueInRange( this._selection ) || void 0;
              if ( n && this._selection.startLineNumber !== this._selection.endLineNumber ) {
                const i = this._model.getLineContent( this._selection.startLineNumber );
                const o = Object( s.getLeadingWhitespace )( i, 0, this._selection.startColumn - 1 );
                let r = o;
                e.snippet.walk( ( t => {
                  return t !== e && ( t instanceof l.d && ( r = Object( s.getLeadingWhitespace )( t.value.split( /\r\n|\r|\n/ ).pop() ) ), !0 )
                } ) );
                const a = Object( s.commonPrefixLength )( r, o );
                n = n.replace( /(\r\n|\r|\n)(.*)/g, ( ( e, t, n ) => {
                  return "" + t + r.substr( a ) + n
                } ) )
              }
              return n
            }
            if ( "TM_CURRENT_LINE" === t ) return this._model.getLineContent( this._selection.positionLineNumber );
            if ( "TM_CURRENT_WORD" === t ) {
              const u = this._model.getWordAtPosition( {
                lineNumber: this._selection.positionLineNumber,
                column: this._selection.positionColumn
              } );
              return u && u.word || void 0
            }
            return "TM_LINE_INDEX" === t ? String( this._selection.positionLineNumber - 1 ) : "TM_LINE_NUMBER" === t ? String( this._selection.positionLineNumber ) : void 0
          }, e;
        } )(),
        _ = ( () => {
          function e( e ) {
            this._model = e
          }
          return e.prototype.resolve = function ( e ) {
            const t = e.name;
            if ( "TM_FILENAME" === t ) return Object( f.a )( this._model.uri.fsPath );
            if ( "TM_FILENAME_BASE" === t ) {
              const n = Object( f.a )( this._model.uri.fsPath ),
                i = n.lastIndexOf( "." );
              return i <= 0 ? n : n.slice( 0, i )
            }
            if ( "TM_DIRECTORY" === t ) {
              const o = Object( f.b )( this._model.uri.fsPath );
              return "." !== o ? o : ""
            }
            return "TM_FILEPATH" === t ? this._model.uri.fsPath : void 0
          }, e;
        } )(),
        v = ( () => {
          function e( e, t, n ) {
            this._clipboardService = e, this._selectionIdx = t, this._selectionCount = n
          }
          return e.prototype.resolve = function ( e ) {
            if ( "CLIPBOARD" === e.name && this._clipboardService ) {
              const t = this._clipboardService.readText();
              if ( t ) {
                const n = t.split( /\r\n|\n|\r/ ).filter( ( e => {
                  return !Object( s.isFalsyOrWhitespace )( e )
                } ) );
                return n.length === this._selectionCount ? n[ this._selectionIdx ] : t
              }
            }
          }, e;
        } )(),
        y = ( () => {
          function e() {}
          return e.prototype.resolve = t => {
            const n = t.name;
            return "CURRENT_YEAR" === n ? String( ( new Date ).getFullYear() ) : "CURRENT_YEAR_SHORT" === n ? String( ( new Date ).getFullYear() ).slice( -2 ) : "CURRENT_MONTH" === n ? Object( s.pad )( ( new Date ).getMonth().valueOf() + 1, 2 ) : "CURRENT_DATE" === n ? Object( s.pad )( ( new Date ).getDate().valueOf(), 2 ) : "CURRENT_HOUR" === n ? Object( s.pad )( ( new Date ).getHours().valueOf(), 2 ) : "CURRENT_MINUTE" === n ? Object( s.pad )( ( new Date ).getMinutes().valueOf(), 2 ) : "CURRENT_SECOND" === n ? Object( s.pad )( ( new Date ).getSeconds().valueOf(), 2 ) : "CURRENT_DAY_NAME" === n ? e.dayNames[ ( new Date ).getDay() ] : "CURRENT_DAY_NAME_SHORT" === n ? e.dayNamesShort[ ( new Date ).getDay() ] : "CURRENT_MONTH_NAME" === n ? e.monthNames[ ( new Date ).getMonth() ] : "CURRENT_MONTH_NAME_SHORT" === n ? e.monthNamesShort[ ( new Date ).getMonth() ] : void 0
          }, e.dayNames = [ p.a( "Sunday", "Sunday" ), p.a( "Monday", "Monday" ), p.a( "Tuesday", "Tuesday" ), p.a( "Wednesday", "Wednesday" ), p.a( "Thursday", "Thursday" ), p.a( "Friday", "Friday" ), p.a( "Saturday", "Saturday" ) ], e.dayNamesShort = [ p.a( "SundayShort", "Sun" ), p.a( "MondayShort", "Mon" ), p.a( "TuesdayShort", "Tue" ), p.a( "WednesdayShort", "Wed" ), p.a( "ThursdayShort", "Thu" ), p.a( "FridayShort", "Fri" ), p.a( "SaturdayShort", "Sat" ) ], e.monthNames = [ p.a( "January", "January" ), p.a( "February", "February" ), p.a( "March", "March" ), p.a( "April", "April" ), p.a( "May", "May" ), p.a( "June", "June" ), p.a( "July", "July" ), p.a( "August", "August" ), p.a( "September", "September" ), p.a( "October", "October" ), p.a( "November", "November" ), p.a( "December", "December" ) ], e.monthNamesShort = [ p.a( "JanuaryShort", "Jan" ), p.a( "FebruaryShort", "Feb" ), p.a( "MarchShort", "Mar" ), p.a( "AprilShort", "Apr" ), p.a( "MayShort", "May" ), p.a( "JuneShort", "Jun" ), p.a( "JulyShort", "Jul" ), p.a( "AugustShort", "Aug" ), p.a( "SeptemberShort", "Sep" ), p.a( "OctoberShort", "Oct" ), p.a( "NovemberShort", "Nov" ), p.a( "DecemberShort", "Dec" ) ], e;
        } )(),
        b = n( "tX9W" ),
        C = n( "9XeP" ),
        w = n( "Cg/j" ),
        S = ( () => {
          function e( e, t, n ) {
            this._nestingLevel = 1, this._editor = e, this._snippet = t, this._offset = n, this._placeholderGroups = Object( h.j )( t.placeholders, l.b.compareByIndex ), this._placeholderGroupsIdx = -1
          }
          return e.prototype.dispose = function () {
            if ( this._placeholderDecorations ) {
              const e = [];
              this._placeholderDecorations.forEach( ( t => {
                return e.push( t )
              } ) ), this._editor.deltaDecorations( e, [] )
            }
            this._placeholderGroups.length = 0
          }, e.prototype._initDecorations = function () {
            const t = this;
            if ( !this._placeholderDecorations ) {
              this._placeholderDecorations = new Map;
              const n = this._editor.getModel();
              this._editor.changeDecorations( ( i => {
                for ( let o = 0, r = t._snippet.placeholders; o < r.length; o++ ) {
                  const s = r[ o ],
                    a = t._snippet.offset( s ),
                    u = t._snippet.fullLen( s ),
                    l = d.a.fromPositions( n.getPositionAt( t._offset + a ), n.getPositionAt( t._offset + a + u ) ),
                    c = s.isFinalTabstop ? e._decor.inactiveFinal : e._decor.inactive,
                    h = i.addDecoration( l, c );
                  t._placeholderDecorations.set( s, h )
                }
              } ) )
            }
          }, e.prototype.move = function ( t ) {
            const n = this;
            if ( this._initDecorations(), this._placeholderGroupsIdx >= 0 ) {
              for ( var i = [], o = 0, r = this._placeholderGroups[ this._placeholderGroupsIdx ]; o < r.length; o++ ) {
                const s = r[ o ];
                if ( s.transform ) {
                  const a = this._placeholderDecorations.get( s ),
                    l = this._editor.getModel().getDecorationRange( a ),
                    d = this._editor.getModel().getValueInRange( l );
                  i.push( u.a.replaceMove( l, s.transform.resolve( d ) ) )
                }
              }
              i.length > 0 && this._editor.executeEdits( "snippet.placeholderTransform", i )
            }
            return !0 === t && this._placeholderGroupsIdx < this._placeholderGroups.length - 1 ? this._placeholderGroupsIdx += 1 : !1 === t && this._placeholderGroupsIdx > 0 && ( this._placeholderGroupsIdx -= 1 ), this._editor.getModel().changeDecorations( ( t => {
              for ( var i = new Set, o = [], r = 0, s = n._placeholderGroups[ n._placeholderGroupsIdx ]; r < s.length; r++ ) {
                const a = s[ r ],
                  u = n._placeholderDecorations.get( a ),
                  l = n._editor.getModel().getDecorationRange( u );
                o.push( new c.a( l.startLineNumber, l.startColumn, l.endLineNumber, l.endColumn ) ), t.changeDecorationOptions( u, a.isFinalTabstop ? e._decor.activeFinal : e._decor.active ), i.add( a );
                for ( let d = 0, h = n._snippet.enclosingPlaceholders( a ); d < h.length; d++ ) {
                  const p = h[ d ],
                    f = n._placeholderDecorations.get( p );
                  t.changeDecorationOptions( f, p.isFinalTabstop ? e._decor.activeFinal : e._decor.active ), i.add( p )
                }
              }
              return n._placeholderDecorations.forEach( ( ( n, o ) => {
                i.has( o ) || t.changeDecorationOptions( n, o.isFinalTabstop ? e._decor.inactiveFinal : e._decor.inactive )
              } ) ), o;
            } ) );
          }, Object.defineProperty( e.prototype, "isAtFirstPlaceholder", {
            get() {
              return this._placeholderGroupsIdx <= 0 || 0 === this._placeholderGroups.length
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "isAtLastPlaceholder", {
            get() {
              return this._placeholderGroupsIdx === this._placeholderGroups.length - 1
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "hasPlaceholder", {
            get() {
              return this._snippet.placeholders.length > 0
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.computePossibleSelections = function () {
            for ( var e = new Map, t = 0, n = this._placeholderGroups; t < n.length; t++ )
              for ( let i = void 0, o = 0, r = n[ t ]; o < r.length; o++ ) {
                const s = r[ o ];
                if ( s.isFinalTabstop ) break;
                i || ( i = [], e.set( s.index, i ) );
                const a = this._placeholderDecorations.get( s ),
                  u = this._editor.getModel().getDecorationRange( a );
                if ( !u ) {
                  e.delete( s.index );
                  break
                }
                i.push( u )
              }
            return e
          }, Object.defineProperty( e.prototype, "choice", {
            get() {
              return this._placeholderGroups[ this._placeholderGroupsIdx ][ 0 ].choice
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.merge = function ( t ) {
            const n = this,
              i = this._editor.getModel();
            this._nestingLevel *= 10, this._editor.changeDecorations( ( o => {
              for ( let r = 0, s = n._placeholderGroups[ n._placeholderGroupsIdx ]; r < s.length; r++ ) {
                const a = s[ r ],
                  u = t.shift();
                console.assert( !u._placeholderDecorations );
                for ( let c = 0, p = u._snippet.placeholderInfo.all; c < p.length; c++ ) {
                  const f = p[ c ];
                  f.isFinalTabstop ? f.index = a.index + ( u._snippet.placeholderInfo.last.index + 1 ) / n._nestingLevel : f.index = a.index + f.index / n._nestingLevel
                }
                n._snippet.replace( a, u._snippet.children );
                const g = n._placeholderDecorations.get( a );
                o.removeDecoration( g ), n._placeholderDecorations.delete( a );
                for ( let m = 0, _ = u._snippet.placeholders; m < _.length; m++ ) {
                  const v = _[ m ],
                    y = u._snippet.offset( v ),
                    b = u._snippet.fullLen( v ),
                    C = d.a.fromPositions( i.getPositionAt( u._offset + y ), i.getPositionAt( u._offset + y + b ) ),
                    w = o.addDecoration( C, e._decor.inactive );
                  n._placeholderDecorations.set( v, w )
                }
              }
              n._placeholderGroups = Object( h.j )( n._snippet.placeholders, l.b.compareByIndex )
            } ) )
          }, e._decor = {
            active: b.a.register( {
              stickiness: a.h.AlwaysGrowsWhenTypingAtEdges,
              className: "snippet-placeholder"
            } ),
            inactive: b.a.register( {
              stickiness: a.h.NeverGrowsWhenTypingAtEdges,
              className: "snippet-placeholder"
            } ),
            activeFinal: b.a.register( {
              stickiness: a.h.NeverGrowsWhenTypingAtEdges,
              className: "finish-snippet-placeholder"
            } ),
            inactiveFinal: b.a.register( {
              stickiness: a.h.NeverGrowsWhenTypingAtEdges,
              className: "finish-snippet-placeholder"
            } )
          }, e;
        } )(),
        O = ( () => {
          function e( e, t, n, i ) {
            void 0 === n && ( n = 0 ), void 0 === i && ( i = 0 ), this._templateMerges = [], this._snippets = [], this._editor = e, this._template = t, this._overwriteBefore = n, this._overwriteAfter = i
          }
          return e.adjustWhitespace2 = ( e, t, n ) => {
            const i = e.getLineContent( t.lineNumber ),
              o = Object( s.getLeadingWhitespace )( i, 0, t.column - 1 );
            n.walk( ( t => {
              if ( t instanceof l.d && !( t.parent instanceof l.a ) ) {
                for ( var n = t.value.split( /\r\n|\r|\n/ ), i = 1; i < n.length; i++ ) {
                  const r = Object( s.getLeadingWhitespace )( n[ i ] );
                  n[ i ] = e.normalizeIndentation( o + r ) + n[ i ].substr( r.length )
                }
                const a = n.join( e.getEOL() );
                a !== t.value && t.parent.replace( t, [ new l.d( a ) ] )
              }
              return !0
            } ) )
          }, e.adjustSelection = ( e, t, n, i ) => {
            if ( 0 !== n || 0 !== i ) {
              const o = t.positionLineNumber,
                r = t.positionColumn,
                s = r - n,
                a = r + i,
                u = e.validateRange( {
                  startLineNumber: o,
                  startColumn: s,
                  endLineNumber: o,
                  endColumn: a
                } );
              t = c.a.createWithDirection( u.startLineNumber, u.startColumn, u.endLineNumber, u.endColumn, t.getDirection() )
            }
            return t
          }, e.createEditsAndSnippets = ( t, n, i, o, r ) => {
            for ( var s = t.getModel(), a = [], c = [], h = new _( s ), p = t.invokeWithinContext( ( e => {
                return e.get( C.a, w.d )
              } ) ), f = 0, b = s.getValueInRange( e.adjustSelection( s, t.getSelection(), i, 0 ) ), O = s.getValueInRange( e.adjustSelection( s, t.getSelection(), 0, o ) ), L = t.getSelections().map( ( ( e, t ) => {
                return {
                  selection: e,
                  idx: t
                }
              } ) ).sort( ( ( e, t ) => {
                return d.a.compareRangesUsingStarts( e.selection, t.selection )
              } ) ), x = 0, N = L; x < N.length; x++ ) {
              const E = N[ x ];
              const k = E.selection;
              const I = E.idx;
              let D = e.adjustSelection( s, k, i, 0 );
              let M = e.adjustSelection( s, k, 0, o );
              b !== s.getValueInRange( D ) && ( D = k ), O !== s.getValueInRange( M ) && ( M = k );
              const T = k.setStartPosition( D.startLineNumber, D.startColumn ).setEndPosition( M.endLineNumber, M.endColumn ),
                R = ( new l.c ).parse( n, !0, r ),
                P = T.getStartPosition();
              e.adjustWhitespace2( s, P, R ), R.resolveVariables( new g( [ h, new v( p, I, L.length ), new m( s, k ), new y ] ) );
              const A = s.getOffsetAt( P ) + f;
              f += R.toString().length - s.getValueLengthInRange( T ), a[ I ] = u.a.replace( T, R.toString() ), c[ I ] = new S( t, R, A )
            }
            return {
              edits: a,
              snippets: c
            }
          }, e.prototype.dispose = function () {
            Object( r.d )( this._snippets )
          }, e.prototype._logInfo = function () {
            return 'template="' + this._template + '", merged_templates="' + this._templateMerges.join( " -> " ) + '"'
          }, e.prototype.insert = function () {
            const t = this,
              n = this._editor.getModel(),
              i = e.createEditsAndSnippets( this._editor, this._template, this._overwriteBefore, this._overwriteAfter, !1 ),
              o = i.edits,
              r = i.snippets;
            this._snippets = r;
            const s = n.pushEditOperations( this._editor.getSelections(), o, ( e => {
              return t._snippets[ 0 ].hasPlaceholder ? t._move( !0 ) : e.map( ( e => {
                return c.a.fromPositions( e.range.getEndPosition() )
              } ) );
            } ) );
            this._editor.setSelections( s ), this._editor.revealRange( s[ 0 ] )
          }, e.prototype.merge = function ( t, n, i ) {
            const o = this;
            void 0 === n && ( n = 0 ), void 0 === i && ( i = 0 ), this._templateMerges.push( [ this._snippets[ 0 ]._nestingLevel, this._snippets[ 0 ]._placeholderGroupsIdx, t ] );
            const r = e.createEditsAndSnippets( this._editor, t, n, i, !0 ),
              s = r.edits,
              a = r.snippets;
            this._editor.setSelections( this._editor.getModel().pushEditOperations( this._editor.getSelections(), s, ( e => {
              for ( let t = 0, n = o._snippets; t < n.length; t++ ) {
                n[ t ].merge( a )
              }
              return console.assert( 0 === a.length ), o._snippets[ 0 ].hasPlaceholder ? o._move( void 0 ) : e.map( ( e => {
                return c.a.fromPositions( e.range.getEndPosition() )
              } ) );
            } ) ) )
          }, e.prototype.next = function () {
            const e = this._move( !0 );
            this._editor.setSelections( e ), this._editor.revealPositionInCenterIfOutsideViewport( e[ 0 ].getPosition() )
          }, e.prototype.prev = function () {
            const e = this._move( !1 );
            this._editor.setSelections( e ), this._editor.revealPositionInCenterIfOutsideViewport( e[ 0 ].getPosition() )
          }, e.prototype._move = function ( e ) {
            for ( var t = [], n = 0, i = this._snippets; n < i.length; n++ ) {
              const o = i[ n ].move( e );
              t.push.apply( t, o )
            }
            return t
          }, Object.defineProperty( e.prototype, "isAtFirstPlaceholder", {
            get() {
              return this._snippets[ 0 ].isAtFirstPlaceholder
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "isAtLastPlaceholder", {
            get() {
              return this._snippets[ 0 ].isAtLastPlaceholder
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "hasPlaceholder", {
            get() {
              return this._snippets[ 0 ].hasPlaceholder
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( e.prototype, "choice", {
            get() {
              return this._snippets[ 0 ].choice
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.isSelectionWithinPlaceholders = function () {
            if ( !this.hasPlaceholder ) return !1;
            let e;
            const t = this._editor.getSelections();
            if ( t.length < this._snippets.length ) return !1;
            for ( let n = n => {
                const i = n.computePossibleSelections();
                if ( e || ( e = new Map, i.forEach( ( ( n, i ) => {
                    n.sort( d.a.compareRangesUsingStarts );
                    for ( let o = 0, r = t; o < r.length; o++ ) {
                      const s = r[ o ];
                      if ( n[ 0 ].containsRange( s ) ) {
                        e.set( i, [] );
                        break
                      }
                    }
                  } ) ) ), 0 === e.size ) return {
                  value: !1
                };
                e.forEach( ( ( e, t ) => {
                  e.push.apply( e, i.get( t ) )
                } ) )
              }, i = 0, o = this._snippets; i < o.length; i++ ) {
              const r = n( o[ i ] );
              if ( "object" === typeof r ) return r.value
            }
            return t.sort( d.a.compareRangesUsingStarts ), e.forEach( ( ( n, i ) => {
              if ( n.length === t.length ) {
                n.sort( d.a.compareRangesUsingStarts );
                for ( let o = 0; o < n.length; o++ )
                  if ( !n[ o ].containsRange( t[ o ] ) ) return void e.delete( i )
              } else e.delete( i )
            } ) ), e.size > 0;
          }, e;
        } )(),
        L = n( "wQH0" ),
        x = n( "QVNv" ),
        N = n( "09fa" );
      n.d( t, "SnippetController2", ( () => {
        return I
      } ) );

      const E = function ( e, t, n, i ) {
        let o;
        const r = arguments.length;
        let s = r < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor( t, n ) : i;
        if ( "object" === typeof Reflect && "function" === typeof Reflect.decorate ) s = Reflect.decorate( e, t, n, i );
        else
          for ( let a = e.length - 1; a >= 0; a-- )( o = e[ a ] ) && ( s = ( r < 3 ? o( s ) : r > 3 ? o( t, n, s ) : o( t, n ) ) || s );
        return r > 3 && s && Object.defineProperty( t, n, s ), s
      };

      const k = ( e, t ) => {
        return ( n, i ) => {
          t( n, i, e )
        };
      };
      var I = ( () => {
        function e( t, n, i ) {
          this._editor = t, this._logService = n, this._snippetListener = [], this._inSnippet = e.InSnippetMode.bindTo( i ), this._hasNextTabstop = e.HasNextTabstop.bindTo( i ), this._hasPrevTabstop = e.HasPrevTabstop.bindTo( i )
        }
        return e.get = e => {
          return e.getContribution( "snippetController2" )
        }, e.prototype.dispose = function () {
          this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), Object( r.d )( this._session )
        }, e.prototype.getId = () => {
          return "snippetController2"
        }, e.prototype.insert = function ( e, t, n, i, o ) {
          void 0 === t && ( t = 0 ), void 0 === n && ( n = 0 ), void 0 === i && ( i = !0 ), void 0 === o && ( o = !0 );
          try {
            this._doInsert( e, t, n, i, o )
          } catch ( r ) {
            this.cancel(), this._logService.error( r ), this._logService.error( "snippet_error" ), this._logService.error( "insert_template=", e ), this._logService.error( "existing_template=", this._session ? this._session._logInfo() : "<no_session>" )
          }
        }, e.prototype._doInsert = function ( e, t, n, i, o ) {
          const s = this;
          void 0 === t && ( t = 0 ), void 0 === n && ( n = 0 ), void 0 === i && ( i = !0 ), void 0 === o && ( o = !0 ), this._snippetListener = Object( r.d )( this._snippetListener ), i && this._editor.getModel().pushStackElement(), this._session ? this._session.merge( e, t, n ) : ( this._modelVersionId = this._editor.getModel().getAlternativeVersionId(), this._session = new O( this._editor, e, t, n ), this._session.insert() ), o && this._editor.getModel().pushStackElement(), this._updateState(), this._snippetListener = [ this._editor.onDidChangeModelContent( ( e => {
            return e.isFlush && s.cancel()
          } ) ), this._editor.onDidChangeModel( ( () => {
            return s.cancel()
          } ) ), this._editor.onDidChangeCursorSelection( ( () => {
            return s._updateState()
          } ) ) ]
        }, e.prototype._updateState = function () {
          if ( this._session ) {
            if ( this._modelVersionId === this._editor.getModel().getAlternativeVersionId() ) return this.cancel();
            if ( !this._session.hasPlaceholder ) return this.cancel();
            if ( this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders() ) return this.cancel();
            this._inSnippet.set( !0 ), this._hasPrevTabstop.set( !this._session.isAtFirstPlaceholder ), this._hasNextTabstop.set( !this._session.isAtLastPlaceholder ), this._handleChoice()
          }
        }, e.prototype._handleChoice = function () {
          const e = this._session.choice;
          if ( e ) {
            if ( this._currentChoice !== e ) {
              this._currentChoice = e, this._editor.setSelections( this._editor.getSelections().map( ( e => {
                return c.a.fromPositions( e.getStartPosition() )
              } ) ) );
              const t = e.options[ 0 ];
              Object( x.e )( this._editor, e.options.map( ( ( e, n ) => {
                return {
                  type: "value",
                  label: e.value,
                  insertText: e.value,
                  sortText: Object( s.repeat )( "a", n ),
                  overwriteAfter: t.value.length
                }
              } ) ) )
            }
          } else this._currentChoice = void 0
        }, e.prototype.finish = function () {
          for ( ; this._inSnippet.get(); ) this.next()
        }, e.prototype.cancel = function () {
          this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), Object( r.d )( this._snippetListener ), Object( r.d )( this._session ), this._session = void 0, this._modelVersionId = -1
        }, e.prototype.prev = function () {
          this._session.prev(), this._updateState()
        }, e.prototype.next = function () {
          this._session.next(), this._updateState()
        }, e.prototype.isInSnippet = function () {
          return this._inSnippet.get()
        }, e.InSnippetMode = new i.f( "inSnippetMode", !1 ), e.HasNextTabstop = new i.f( "hasNextTabstop", !1 ), e.HasPrevTabstop = new i.f( "hasPrevTabstop", !1 ), e = E( [ k( 1, N.a ), k( 2, i.e ) ], e );
      } )();
      Object( o.h )( I );
      const D = o.c.bindToContribution( I.get );
      Object( o.g )( new D( {
        id: "jumpToNextSnippetPlaceholder",
        precondition: i.d.and( I.InSnippetMode, I.HasNextTabstop ),
        handler( e ) {
          return e.next()
        },
        kbOpts: {
          weight: 130,
          kbExpr: L.a.editorTextFocus,
          primary: 2
        }
      } ) ), Object( o.g )( new D( {
        id: "jumpToPrevSnippetPlaceholder",
        precondition: i.d.and( I.InSnippetMode, I.HasPrevTabstop ),
        handler( e ) {
          return e.prev()
        },
        kbOpts: {
          weight: 130,
          kbExpr: L.a.editorTextFocus,
          primary: 1026
        }
      } ) ), Object( o.g )( new D( {
        id: "leaveSnippet",
        precondition: I.InSnippetMode,
        handler( e ) {
          return e.cancel()
        },
        kbOpts: {
          weight: 130,
          kbExpr: L.a.editorTextFocus,
          primary: 9,
          secondary: [ 1033 ]
        }
      } ) ), Object( o.g )( new D( {
        id: "acceptSnippet",
        precondition: I.InSnippetMode,
        handler( e ) {
          return e.finish()
        }
      } ) )
    },
    tYmi( e, t, n ) {
      "use strict";
      let i;
      n.d( t, "a", ( () => {
        return i
      } ) ), ( e => {
        e.inMemory = "inmemory", e.vscode = "vscode", e.internal = "private", e.walkThrough = "walkThrough", e.walkThroughSnippet = "walkThroughSnippet", e.http = "http", e.https = "https", e.file = "file", e.mailto = "mailto", e.untitled = "untitled", e.data = "data"
      } )( i || ( i = {} ) )
    },
    twdY( e, t, n ) {
      "use strict";
      const i = n( "MI8n" ),
        o = n( "pmY6" ),
        r = n( "l2gE" );

      function s( e, t, n, i ) {
        if ( Array.isArray( e ) ) {
          for ( var o = 0, a = 0, u = e; a < u.length; a++ ) {
            const l = s( u[ a ], t, n, i );
            if ( 10 === l ) return l;
            l > o && ( o = l )
          }
          return o
        }
        if ( "string" === typeof e ) return i ? "*" === e ? 5 : e === n ? 10 : 0 : 0;
        if ( e ) {
          const c = e.language,
            d = e.pattern,
            h = e.scheme,
            p = e.hasAccessToAllModels;
          if ( !i && !p ) return 0;
          o = 0;
          if ( h )
            if ( h === t.scheme ) o = 10;
            else {
              if ( "*" !== h ) return 0;
              o = 5
            } if ( c )
            if ( c === n ) o = 10;
            else {
              if ( "*" !== c ) return 0;
              o = Math.max( o, 5 )
            } if ( d ) {
            if ( d !== t.fsPath && !Object( r.a )( d, t.fsPath ) ) return 0;
            o = 10
          }
          return o
        }
        return 0
      }
      const a = n( "G2kB" );

      function u( e ) {
        return "string" !== typeof e && ( Array.isArray( e ) ? e.every( u ) : e.exclusive )
      }
      const l = ( () => {
          function e() {
            this._clock = 0, this._entries = [], this._onDidChange = new i.a
          }
          return Object.defineProperty( e.prototype, "onDidChange", {
            get() {
              return this._onDidChange.event
            },
            enumerable: !0,
            configurable: !0
          } ), e.prototype.register = function ( e, t ) {
            const n = this;
            let i = {
              selector: e,
              provider: t,
              _score: -1,
              _time: this._clock++
            };
            return this._entries.push( i ), this._lastCandidate = void 0, this._onDidChange.fire( this._entries.length ), Object( o.f )( ( () => {
              if ( i ) {
                const e = n._entries.indexOf( i );
                e >= 0 && ( n._entries.splice( e, 1 ), n._lastCandidate = void 0, n._onDidChange.fire( n._entries.length ), i = void 0 )
              }
            } ) );
          }, e.prototype.has = function ( e ) {
            return this.all( e ).length > 0
          }, e.prototype.all = function ( e ) {
            if ( !e ) return [];
            this._updateScores( e );
            for ( var t = [], n = 0, i = this._entries; n < i.length; n++ ) {
              const o = i[ n ];
              o._score > 0 && t.push( o.provider )
            }
            return t
          }, e.prototype.ordered = function ( e ) {
            const t = [];
            return this._orderedForEach( e, ( e => {
              return t.push( e.provider )
            } ) ), t;
          }, e.prototype.orderedGroups = function ( e ) {
            let t;
            let n;
            const i = [];
            return this._orderedForEach( e, ( e => {
              t && n === e._score ? t.push( e.provider ) : ( n = e._score, t = [ e.provider ], i.push( t ) )
            } ) ), i;
          }, e.prototype._orderedForEach = function ( e, t ) {
            if ( e ) {
              this._updateScores( e );
              for ( let n = 0; n < this._entries.length; n++ ) {
                const i = this._entries[ n ];
                i._score > 0 && t( i )
              }
            }
          }, e.prototype._updateScores = function ( t ) {
            const n = {
              uri: t.uri.toString(),
              language: t.getLanguageIdentifier().language
            };
            if ( !this._lastCandidate || this._lastCandidate.language !== n.language || this._lastCandidate.uri !== n.uri ) {
              this._lastCandidate = n;
              for ( let i = 0, o = this._entries; i < o.length; i++ ) {
                const r = o[ i ];
                if ( r._score = s( r.selector, t.uri, t.getLanguageIdentifier().language, Object( a.b )( t ) ), u( r.selector ) && r._score > 0 ) {
                  for ( let l = 0, c = this._entries; l < c.length; l++ ) {
                    c[ l ]._score = 0
                  }
                  r._score = 1e3;
                  break
                }
              }
              this._entries.sort( e._compareByScoreAndTime )
            }
          }, e._compareByScoreAndTime = ( e, t ) => {
            return e._score < t._score ? 1 : e._score > t._score ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0
          }, e;
        } )(),
        c = ( () => {
          function e() {
            this._onDidChange = new i.a, this.onDidChange = this._onDidChange.event, this._map = Object.create( null ), this._colorMap = null
          }
          return e.prototype.fire = function ( e ) {
            this._onDidChange.fire( {
              changedLanguages: e,
              changedColorMap: !1
            } )
          }, e.prototype.register = function ( e, t ) {
            const n = this;
            return this._map[ e ] = t, this.fire( [ e ] ), Object( o.f )( ( () => {
              n._map[ e ] === t && ( delete n._map[ e ], n.fire( [ e ] ) )
            } ) );
          }, e.prototype.get = function ( e ) {
            return this._map[ e ] || null
          }, e.prototype.setColorMap = function ( e ) {
            this._colorMap = e, this._onDidChange.fire( {
              changedLanguages: Object.keys( this._map ),
              changedColorMap: !0
            } )
          }, e.prototype.getColorMap = function () {
            return this._colorMap
          }, e.prototype.getDefaultBackground = function () {
            return this._colorMap[ 2 ]
          }, e;
        } )(),
        d = n( "746U" );
      n.d( t, "o", ( () => {
        return m
      } ) ), n.d( t, "x", ( () => {
        return _
      } ) ), n.d( t, "v", ( () => {
        return h
      } ) ), n.d( t, "b", ( () => {
        return p
      } ) ), n.d( t, "g", ( () => {
        return f
      } ) ), n.d( t, "w", ( () => {
        return g
      } ) ), n.d( t, "B", ( () => {
        return v
      } ) ), n.d( t, "k", ( () => {
        return y
      } ) ), n.d( t, "A", ( () => {
        return b
      } ) ), n.d( t, "r", ( () => {
        return C
      } ) ), n.d( t, "s", ( () => {
        return w
      } ) ), n.d( t, "u", ( () => {
        return S
      } ) ), n.d( t, "t", ( () => {
        return O
      } ) ), n.d( t, "m", ( () => {
        return L
      } ) ), n.d( t, "j", ( () => {
        return x
      } ) ), n.d( t, "h", ( () => {
        return N
      } ) ), n.d( t, "e", ( () => {
        return E
      } ) ), n.d( t, "n", ( () => {
        return k
      } ) ), n.d( t, "z", ( () => {
        return I
      } ) ), n.d( t, "c", ( () => {
        return D
      } ) ), n.d( t, "a", ( () => {
        return M
      } ) ), n.d( t, "f", ( () => {
        return T
      } ) ), n.d( t, "i", ( () => {
        return R
      } ) ), n.d( t, "q", ( () => {
        return P
      } ) ), n.d( t, "p", ( () => {
        return A
      } ) ), n.d( t, "d", ( () => {
        return F
      } ) ), n.d( t, "l", ( () => {
        return W
      } ) ), n.d( t, "y", ( () => {
        return j
      } ) );
      var h, p, f, g, m = function ( e, t ) {
          this.language = e, this.id = t
        },
        _ = ( () => {
          function e() {}
          return e.getLanguageId = e => {
            return ( 255 & e ) >>> 0
          }, e.getTokenType = e => {
            return ( 1792 & e ) >>> 8
          }, e.getFontStyle = e => {
            return ( 14336 & e ) >>> 11
          }, e.getForeground = e => {
            return ( 8372224 & e ) >>> 14
          }, e.getBackground = e => {
            return ( 4286578688 & e ) >>> 23
          }, e.getClassNameFromMetadata = function ( e ) {
            let t = "mtk" + this.getForeground( e );
            const n = this.getFontStyle( e );
            return 1 & n && ( t += " mtki" ), 2 & n && ( t += " mtkb" ), 4 & n && ( t += " mtku" ), t
          }, e.getInlineStyleFromMetadata = function ( e, t ) {
            const n = this.getForeground( e );
            const i = this.getFontStyle( e );
            let o = "color: " + t[ n ] + ";";
            return 1 & i && ( o += "font-style: italic;" ), 2 & i && ( o += "font-weight: bold;" ), 4 & i && ( o += "text-decoration: underline;" ), o
          }, e;
        } )();
      !( e => {
        e[ e.Invoke = 0 ] = "Invoke", e[ e.TriggerCharacter = 1 ] = "TriggerCharacter", e[ e.TriggerForIncompleteCompletions = 2 ] = "TriggerForIncompleteCompletions"
      } )( h || ( h = {} ) ), ( e => {
        e[ e.Automatic = 1 ] = "Automatic", e[ e.Manual = 2 ] = "Manual"
      } )( p || ( p = {} ) ), ( e => {
        e[ e.Text = 0 ] = "Text", e[ e.Read = 1 ] = "Read", e[ e.Write = 2 ] = "Write"
      } )( f || ( f = {} ) ), ( e => {
        e[ e.File = 0 ] = "File", e[ e.Module = 1 ] = "Module", e[ e.Namespace = 2 ] = "Namespace", e[ e.Package = 3 ] = "Package", e[ e.Class = 4 ] = "Class", e[ e.Method = 5 ] = "Method", e[ e.Property = 6 ] = "Property", e[ e.Field = 7 ] = "Field", e[ e.Constructor = 8 ] = "Constructor", e[ e.Enum = 9 ] = "Enum", e[ e.Interface = 10 ] = "Interface", e[ e.Function = 11 ] = "Function", e[ e.Variable = 12 ] = "Variable", e[ e.Constant = 13 ] = "Constant", e[ e.String = 14 ] = "String", e[ e.Number = 15 ] = "Number", e[ e.Boolean = 16 ] = "Boolean", e[ e.Array = 17 ] = "Array", e[ e.Object = 18 ] = "Object", e[ e.Key = 19 ] = "Key", e[ e.Null = 20 ] = "Null", e[ e.EnumMember = 21 ] = "EnumMember", e[ e.Struct = 22 ] = "Struct", e[ e.Event = 23 ] = "Event", e[ e.Operator = 24 ] = "Operator", e[ e.TypeParameter = 25 ] = "TypeParameter"
      } )( g || ( g = {} ) );
      var v = ( () => {
          const e = Object.create( null );
          return e[ g.File ] = "file", e[ g.Module ] = "module", e[ g.Namespace ] = "namespace", e[ g.Package ] = "package", e[ g.Class ] = "class", e[ g.Method ] = "method", e[ g.Property ] = "property", e[ g.Field ] = "field", e[ g.Constructor ] = "constructor", e[ g.Enum ] = "enum", e[ g.Interface ] = "interface", e[ g.Function ] = "function", e[ g.Variable ] = "variable", e[ g.Constant ] = "constant", e[ g.String ] = "string", e[ g.Number ] = "number", e[ g.Boolean ] = "boolean", e[ g.Array ] = "array", e[ g.Object ] = "object", e[ g.Key ] = "key", e[ g.Null ] = "null", e[ g.EnumMember ] = "enum-member", e[ g.Struct ] = "struct", e[ g.Event ] = "event", e[ g.Operator ] = "operator", e[ g.TypeParameter ] = "type-parameter", t => {
            return "symbol-icon " + ( e[ t ] || "property" )
          };
        } )(),
        y = ( () => {
          function e( e ) {
            this.value = e
          }
          return e.Comment = new e( "comment" ), e.Imports = new e( "imports" ), e.Region = new e( "region" ), e
        } )();

      function b( e ) {
        return Object( d.g )( e ) && e.resource && Array.isArray( e.edits )
      }
      var C = new l,
        w = new l,
        S = new l,
        O = new l,
        L = new l,
        x = new l,
        N = new l,
        E = new l,
        k = new l,
        I = new l,
        D = new l,
        M = new l,
        T = new l,
        R = new l,
        P = new l,
        A = new l,
        F = new l,
        W = new l,
        j = new c
    },
    uACm( e, t, n ) {
      "use strict";
      n.d( t, "d", ( () => {
        return a
      } ) ), n.d( t, "b", ( () => {
        return l
      } ) ), n.d( t, "a", ( () => {
        return c
      } ) ), n.d( t, "c", ( () => {
        return m
      } ) );
      let i;
      const o = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();

      const r = ( () => {
        function e() {
          this.text( "" )
        }
        return e.isDigitCharacter = e => {
          return e >= 48 && e <= 57
        }, e.isVariableCharacter = e => {
          return 95 === e || e >= 97 && e <= 122 || e >= 65 && e <= 90
        }, e.prototype.text = function ( e ) {
          this.value = e, this.pos = 0
        }, e.prototype.tokenText = function ( e ) {
          return this.value.substr( e.pos, e.len )
        }, e.prototype.next = function () {
          if ( this.pos >= this.value.length ) return {
            type: 14,
            pos: this.pos,
            len: 0
          };
          let t;
          const n = this.pos;
          let i = 0;
          let o = this.value.charCodeAt( n );
          if ( "number" === typeof ( t = e._table[ o ] ) ) return this.pos += 1, {
            type: t,
            pos: n,
            len: 1
          };
          if ( e.isDigitCharacter( o ) ) {
            t = 8;
            do {
              i += 1, o = this.value.charCodeAt( n + i )
            } while ( e.isDigitCharacter( o ) );
            return this.pos += i, {
              type: t,
              pos: n,
              len: i
            }
          }
          if ( e.isVariableCharacter( o ) ) {
            t = 9;
            do {
              o = this.value.charCodeAt( n + ++i )
            } while ( e.isVariableCharacter( o ) || e.isDigitCharacter( o ) );
            return this.pos += i, {
              type: t,
              pos: n,
              len: i
            }
          }
          t = 10;
          do {
            i += 1, o = this.value.charCodeAt( n + i )
          } while ( !isNaN( o ) && "undefined" === typeof e._table[ o ] && !e.isDigitCharacter( o ) && !e.isVariableCharacter( o ) );
          return this.pos += i, {
            type: t,
            pos: n,
            len: i
          }
        }, e._table = ( ( i = {} )[ 36 ] = 0, i[ 58 ] = 1, i[ 44 ] = 2, i[ 123 ] = 3, i[ 125 ] = 4, i[ 92 ] = 5, i[ 47 ] = 6, i[ 124 ] = 7, i[ 43 ] = 11, i[ 45 ] = 12, i[ 63 ] = 13, i ), e;
      } )();

      const s = ( () => {
        function e() {
          this._children = []
        }
        return e.prototype.appendChild = function ( e ) {
          return e instanceof a && this._children[ this._children.length - 1 ] instanceof a ? this._children[ this._children.length - 1 ].value += e.value : ( e.parent = this, this._children.push( e ) ), this
        }, e.prototype.replace = ( e, t ) => {
          const n = e.parent,
            i = n.children.indexOf( e ),
            o = n.children.slice( 0 );
          o.splice.apply( o, [ i, 1 ].concat( t ) ), n._children = o, t.forEach( ( e => {
            return e.parent = n
          } ) )
        }, Object.defineProperty( e.prototype, "children", {
          get() {
            return this._children
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "snippet", {
          get() {
            for ( let e = this;; ) {
              if ( !e ) return;
              if ( e instanceof g ) return e;
              e = e.parent
            }
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.toString = function () {
          return this.children.reduce( ( ( e, t ) => {
            return e + t.toString()
          } ), "" );
        }, e.prototype.len = () => {
          return 0
        }, e;
      } )();
      var a = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n.value = t, n
        }
        return o( t, e ), t.prototype.toString = function () {
          return this.value
        }, t.prototype.len = function () {
          return this.value.length
        }, t.prototype.clone = function () {
          return new t( this.value )
        }, t
      } )( s );
      const u = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return o( t, e ), t
      } )( s );
      var l = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n.index = t, n
        }
        return o( t, e ), t.compareByIndex = ( e, t ) => {
          return e.index === t.index ? 0 : e.isFinalTabstop ? 1 : t.isFinalTabstop ? -1 : e.index < t.index ? -1 : e.index > t.index ? 1 : 0
        }, Object.defineProperty( t.prototype, "isFinalTabstop", {
          get() {
            return 0 === this.index
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( t.prototype, "choice", {
          get() {
            return 1 === this._children.length && this._children[ 0 ] instanceof c ? this._children[ 0 ] : void 0
          },
          enumerable: !0,
          configurable: !0
        } ), t.prototype.clone = function () {
          const e = new t( this.index );
          return this.transform && ( e.transform = this.transform.clone() ), e._children = this.children.map( ( e => {
            return e.clone()
          } ) ), e;
        }, t;
      } )( u );
      var c = ( e => {
        function t() {
          const t = null !== e && e.apply( this, arguments ) || this;
          return t.options = [], t
        }
        return o( t, e ), t.prototype.appendChild = function ( e ) {
          return e instanceof a && ( e.parent = this, this.options.push( e ) ), this
        }, t.prototype.toString = function () {
          return this.options[ 0 ].value
        }, t.prototype.len = function () {
          return this.options[ 0 ].len()
        }, t.prototype.clone = function () {
          const e = new t;
          return this.options.forEach( e.appendChild, e ), e
        }, t;
      } )( s );
      const d = ( e => {
        function t() {
          return null !== e && e.apply( this, arguments ) || this
        }
        return o( t, e ), t.prototype.resolve = function ( e ) {
          const t = this;
          return e.replace( this.regexp, ( function () {
            for ( var e = "", n = 0, i = t._children; n < i.length; n++ ) {
              const o = i[ n ];
              if ( o instanceof h ) {
                let r = arguments.length - 2 > o.index ? arguments[ o.index ] : "";
                e += r = o.resolve( r )
              } else e += o.toString()
            }
            return e
          } ) );
        }, t.prototype.toString = () => {
          return ""
        }, t.prototype.clone = function () {
          const e = new t;
          return e.regexp = new RegExp( this.regexp.source, ( this.regexp.ignoreCase ? "i" : "" ) + ( this.regexp.global ? "g" : "" ) ), e._children = this.children.map( ( e => {
            return e.clone()
          } ) ), e;
        }, t;
      } )( s );
      const h = ( e => {
        function t( t, n, i, o ) {
          const r = e.call( this ) || this;
          return r.index = t, r.shorthandName = n, r.ifValue = i, r.elseValue = o, r
        }
        return o( t, e ), t.prototype.resolve = function ( e ) {
          return "upcase" === this.shorthandName ? e ? e.toLocaleUpperCase() : "" : "downcase" === this.shorthandName ? e ? e.toLocaleLowerCase() : "" : "capitalize" === this.shorthandName ? e ? e[ 0 ].toLocaleUpperCase() + e.substr( 1 ) : "" : Boolean( e ) && "string" === typeof this.ifValue ? this.ifValue : Boolean( e ) || "string" !== typeof this.elseValue ? e || "" : this.elseValue
        }, t.prototype.clone = function () {
          return new t( this.index, this.shorthandName, this.ifValue, this.elseValue )
        }, t
      } )( s );
      const p = ( e => {
        function t( t ) {
          const n = e.call( this ) || this;
          return n.name = t, n
        }
        return o( t, e ), t.prototype.resolve = function ( e ) {
          let t = e.resolve( this );
          return this.transform && ( t = this.transform.resolve( t || "" ) ), void 0 !== t && ( this._children = [ new a( t ) ], !0 )
        }, t.prototype.clone = function () {
          const e = new t( this.name );
          return this.transform && ( e.transform = this.transform.clone() ), e._children = this.children.map( ( e => {
            return e.clone()
          } ) ), e;
        }, t;
      } )( u );

      function f( e, t ) {
        for ( const n = e.slice(); n.length > 0; ) {
          const i = n.shift();
          if ( !t( i ) ) break;
          n.unshift.apply( n, i.children )
        }
      }
      var g = ( e => {
          function t() {
            return null !== e && e.apply( this, arguments ) || this
          }
          return o( t, e ), Object.defineProperty( t.prototype, "placeholderInfo", {
            get() {
              if ( !this._placeholders ) {
                let e;
                const t = [];
                this.walk( ( n => {
                  return n instanceof l && ( t.push( n ), e = !e || e.index < n.index ? n : e ), !0
                } ) ), this._placeholders = {
                  all: t,
                  last: e
                }
              }
              return this._placeholders
            },
            enumerable: !0,
            configurable: !0
          } ), Object.defineProperty( t.prototype, "placeholders", {
            get() {
              return this.placeholderInfo.all
            },
            enumerable: !0,
            configurable: !0
          } ), t.prototype.offset = function ( e ) {
            let t = 0,
              n = !1;
            return this.walk( ( i => {
              return i === e ? ( n = !0, !1 ) : ( t += i.len(), !0 )
            } ) ), n ? t : -1;
          }, t.prototype.fullLen = e => {
            let t = 0;
            return f( [ e ], ( e => {
              return t += e.len(), !0
            } ) ), t;
          }, t.prototype.enclosingPlaceholders = e => {
            for ( var t = [], n = e.parent; n; ) n instanceof l && t.push( n ), n = n.parent;
            return t
          }, t.prototype.resolveVariables = function ( e ) {
            const t = this;
            return this.walk( ( n => {
              return n instanceof p && n.resolve( e ) && ( t._placeholders = void 0 ), !0
            } ) ), this;
          }, t.prototype.appendChild = function ( t ) {
            return this._placeholders = void 0, e.prototype.appendChild.call( this, t )
          }, t.prototype.replace = function ( t, n ) {
            return this._placeholders = void 0, e.prototype.replace.call( this, t, n )
          }, t.prototype.clone = function () {
            const e = new t;
            return this._children = this.children.map( ( e => {
              return e.clone()
            } ) ), e;
          }, t.prototype.walk = function ( e ) {
            f( this.children, e )
          }, t;
        } )( s ),
        m = ( () => {
          function e() {
            this._scanner = new r
          }
          return e.escape = e => {
            return e.replace( /\$|}|\\/g, "\\$&" )
          }, e.prototype.parse = function ( e, t, n ) {
            this._scanner.text( e ), this._token = this._scanner.next();
            for ( var i = new g; this._parse( i ); );
            const o = new Map;
            const r = [];
            let s = 0;
            i.walk( ( e => {
              return e instanceof l && ( s += 1, e.isFinalTabstop ? o.set( 0, void 0 ) : !o.has( e.index ) && e.children.length > 0 ? o.set( e.index, e.children ) : r.push( e ) ), !0
            } ) );
            for ( let a = 0, u = r; a < u.length; a++ ) {
              const c = u[ a ];
              if ( o.has( c.index ) ) {
                const d = new l( c.index );
                d.transform = c.transform;
                for ( let h = 0, p = o.get( c.index ); h < p.length; h++ ) {
                  const f = p[ h ];
                  d.appendChild( f.clone() )
                }
                i.replace( c, [ d ] )
              }
            }
            return n || ( n = s > 0 && t ), !o.has( 0 ) && n && i.appendChild( new l( 0 ) ), i
          }, e.prototype._accept = function ( e, t ) {
            if ( void 0 === e || this._token.type === e ) {
              const n = !t || this._scanner.tokenText( this._token );
              return this._token = this._scanner.next(), n
            }
            return !1
          }, e.prototype._backTo = function ( e ) {
            return this._scanner.pos = e.pos + e.len, this._token = e, !1
          }, e.prototype._until = function ( e ) {
            if ( 14 === this._token.type ) return !1;
            for ( var t = this._token; this._token.type !== e; )
              if ( this._token = this._scanner.next(), 14 === this._token.type ) return !1;
            const n = this._scanner.value.substring( t.pos, this._token.pos );
            return this._token = this._scanner.next(), n
          }, e.prototype._parse = function ( e ) {
            return this._parseEscaped( e ) || this._parseTabstopOrVariableName( e ) || this._parseComplexPlaceholder( e ) || this._parseComplexVariable( e ) || this._parseAnything( e )
          }, e.prototype._parseEscaped = function ( e ) {
            let t;
            return !!( t = this._accept( 5, !0 ) ) && ( t = this._accept( 0, !0 ) || this._accept( 4, !0 ) || this._accept( 5, !0 ) || t, e.appendChild( new a( t ) ), !0 )
          }, e.prototype._parseTabstopOrVariableName = function ( e ) {
            let t;
            const n = this._token;
            return this._accept( 0 ) && ( t = this._accept( 9, !0 ) || this._accept( 8, !0 ) ) ? ( e.appendChild( /^\d+$/.test( t ) ? new l( Number( t ) ) : new p( t ) ), !0 ) : this._backTo( n )
          }, e.prototype._parseComplexPlaceholder = function ( e ) {
            let t;
            const n = this._token;
            if ( !( this._accept( 0 ) && this._accept( 3 ) && ( t = this._accept( 8, !0 ) ) ) ) return this._backTo( n );
            const i = new l( Number( t ) );
            if ( this._accept( 1 ) )
              for ( ;; ) {
                if ( this._accept( 4 ) ) return e.appendChild( i ), !0;
                if ( !this._parse( i ) ) return e.appendChild( new a( "${" + t + ":" ) ), i.children.forEach( e.appendChild, e ), !0
              } else {
                if ( !( i.index > 0 && this._accept( 7 ) ) ) return this._accept( 6 ) ? this._parseTransform( i ) ? ( e.appendChild( i ), !0 ) : ( this._backTo( n ), !1 ) : this._accept( 4 ) ? ( e.appendChild( i ), !0 ) : this._backTo( n );
                for ( const o = new c;; ) {
                  if ( this._parseChoiceElement( o ) ) {
                    if ( this._accept( 2 ) ) continue;
                    if ( this._accept( 7 ) && ( i.appendChild( o ), this._accept( 4 ) ) ) return e.appendChild( i ), !0
                  }
                  return this._backTo( n ), !1
                }
              }
          }, e.prototype._parseChoiceElement = function ( e ) {
            for ( var t = this._token, n = []; 2 !== this._token.type && 7 !== this._token.type; ) {
              let i = void 0;
              if ( !( i = ( i = this._accept( 5, !0 ) ) ? this._accept( 2, !0 ) || this._accept( 7, !0 ) || i : this._accept( void 0, !0 ) ) ) return this._backTo( t ), !1;
              n.push( i )
            }
            return 0 === n.length ? ( this._backTo( t ), !1 ) : ( e.appendChild( new a( n.join( "" ) ) ), !0 )
          }, e.prototype._parseComplexVariable = function ( e ) {
            let t;
            const n = this._token;
            if ( !( this._accept( 0 ) && this._accept( 3 ) && ( t = this._accept( 9, !0 ) ) ) ) return this._backTo( n );
            const i = new p( t );
            if ( !this._accept( 1 ) ) return this._accept( 6 ) ? this._parseTransform( i ) ? ( e.appendChild( i ), !0 ) : ( this._backTo( n ), !1 ) : this._accept( 4 ) ? ( e.appendChild( i ), !0 ) : this._backTo( n );
            for ( ;; ) {
              if ( this._accept( 4 ) ) return e.appendChild( i ), !0;
              if ( !this._parse( i ) ) return e.appendChild( new a( "${" + t + ":" ) ), i.children.forEach( e.appendChild, e ), !0
            }
          }, e.prototype._parseTransform = function ( e ) {
            for ( var t = new d, n = "", i = ""; !this._accept( 6 ); ) {
              var o = void 0;
              if ( o = this._accept( 5, !0 ) ) n += o = this._accept( 6, !0 ) || o;
              else {
                if ( 14 === this._token.type ) return !1;
                n += this._accept( void 0, !0 )
              }
            }
            for ( ; !this._accept( 6 ); ) {
              o = void 0;
              if ( o = this._accept( 5, !0 ) ) o = this._accept( 6, !0 ) || o, t.appendChild( new a( o ) );
              else if ( !this._parseFormatString( t ) && !this._parseAnything( t ) ) return !1
            }
            for ( ; !this._accept( 4 ); ) {
              if ( 14 === this._token.type ) return !1;
              i += this._accept( void 0, !0 )
            }
            try {
              t.regexp = new RegExp( n, i )
            } catch ( r ) {
              return !1
            }
            return e.transform = t, !0
          }, e.prototype._parseFormatString = function ( e ) {
            const t = this._token;
            if ( !this._accept( 0 ) ) return !1;
            let n = !1;
            this._accept( 3 ) && ( n = !0 );
            const i = this._accept( 8, !0 );
            if ( !i ) return this._backTo( t ), !1;
            if ( !n ) return e.appendChild( new h( Number( i ) ) ), !0;
            if ( this._accept( 4 ) ) return e.appendChild( new h( Number( i ) ) ), !0;
            if ( !this._accept( 1 ) ) return this._backTo( t ), !1;
            if ( this._accept( 6 ) ) {
              const o = this._accept( 9, !0 );
              return o && this._accept( 4 ) ? ( e.appendChild( new h( Number( i ), o ) ), !0 ) : ( this._backTo( t ), !1 )
            }
            if ( this._accept( 11 ) ) {
              if ( r = this._until( 4 ) ) return e.appendChild( new h( Number( i ), void 0, r, void 0 ) ), !0
            } else if ( this._accept( 12 ) ) {
              if ( s = this._until( 4 ) ) return e.appendChild( new h( Number( i ), void 0, void 0, s ) ), !0
            } else if ( this._accept( 13 ) ) {
              var r;
              if ( r = this._until( 1 ) )
                if ( s = this._until( 4 ) ) return e.appendChild( new h( Number( i ), void 0, r, s ) ), !0
            } else {
              var s;
              if ( s = this._until( 4 ) ) return e.appendChild( new h( Number( i ), void 0, void 0, s ) ), !0
            }
            return this._backTo( t ), !1
          }, e.prototype._parseAnything = function ( e ) {
            return 14 !== this._token.type && ( e.appendChild( new a( this._scanner.tokenText( this._token ) ) ), this._accept( void 0 ), !0 )
          }, e;
        } )()
    },
    uAX5( e, t, n ) {},
    uDWl( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return c
      } ) );
      const i = n( "/kV6" ),
        o = n( "MNsG" ),
        r = n( "D3Dy" ),
        s = new Array( 230 ),
        a = new Array( 112 );
      !( () => {
        for ( let e = 0; e < a.length; e++ ) a[ e ] = -1;

        function t( e, t ) {
          s[ e ] = t, a[ t ] = e
        }
        t( 3, 7 ), t( 8, 1 ), t( 9, 2 ), t( 13, 3 ), t( 16, 4 ), t( 17, 5 ), t( 18, 6 ), t( 19, 7 ), t( 20, 8 ), t( 27, 9 ), t( 32, 10 ), t( 33, 11 ), t( 34, 12 ), t( 35, 13 ), t( 36, 14 ), t( 37, 15 ), t( 38, 16 ), t( 39, 17 ), t( 40, 18 ), t( 45, 19 ), t( 46, 20 ), t( 48, 21 ), t( 49, 22 ), t( 50, 23 ), t( 51, 24 ), t( 52, 25 ), t( 53, 26 ), t( 54, 27 ), t( 55, 28 ), t( 56, 29 ), t( 57, 30 ), t( 65, 31 ), t( 66, 32 ), t( 67, 33 ), t( 68, 34 ), t( 69, 35 ), t( 70, 36 ), t( 71, 37 ), t( 72, 38 ), t( 73, 39 ), t( 74, 40 ), t( 75, 41 ), t( 76, 42 ), t( 77, 43 ), t( 78, 44 ), t( 79, 45 ), t( 80, 46 ), t( 81, 47 ), t( 82, 48 ), t( 83, 49 ), t( 84, 50 ), t( 85, 51 ), t( 86, 52 ), t( 87, 53 ), t( 88, 54 ), t( 89, 55 ), t( 90, 56 ), t( 93, 58 ), t( 96, 93 ), t( 97, 94 ), t( 98, 95 ), t( 99, 96 ), t( 100, 97 ), t( 101, 98 ), t( 102, 99 ), t( 103, 100 ), t( 104, 101 ), t( 105, 102 ), t( 106, 103 ), t( 107, 104 ), t( 108, 105 ), t( 109, 106 ), t( 110, 107 ), t( 111, 108 ), t( 112, 59 ), t( 113, 60 ), t( 114, 61 ), t( 115, 62 ), t( 116, 63 ), t( 117, 64 ), t( 118, 65 ), t( 119, 66 ), t( 120, 67 ), t( 121, 68 ), t( 122, 69 ), t( 123, 70 ), t( 124, 71 ), t( 125, 72 ), t( 126, 73 ), t( 127, 74 ), t( 128, 75 ), t( 129, 76 ), t( 130, 77 ), t( 144, 78 ), t( 145, 79 ), t( 186, 80 ), t( 187, 81 ), t( 188, 82 ), t( 189, 83 ), t( 190, 84 ), t( 191, 85 ), t( 192, 86 ), t( 193, 110 ), t( 194, 111 ), t( 219, 87 ), t( 220, 88 ), t( 221, 89 ), t( 222, 90 ), t( 223, 91 ), t( 226, 92 ), t( 229, 109 ), r.k ? t( 91, 57 ) : r.j ? ( t( 59, 80 ), t( 107, 81 ), t( 109, 83 ), o.d && t( 224, 57 ) ) : r.n && ( t( 91, 57 ), o.d ? t( 93, 57 ) : t( 92, 57 ) )
      } )();
      const u = o.d ? 256 : 2048;
      const l = o.d ? 2048 : 256;
      var c = ( () => {
        function e( e ) {
          const t = e;
          this.browserEvent = t, this.target = t.target, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.keyCode = ( e => {
            if ( e.charCode ) {
              const t = String.fromCharCode( e.charCode ).toUpperCase();
              return i.b.fromString( t )
            }
            return s[ e.keyCode ] || 0
          } )( t ), this.code = t.code, this.ctrlKey = this.ctrlKey || 5 === this.keyCode, this.altKey = this.altKey || 6 === this.keyCode, this.shiftKey = this.shiftKey || 4 === this.keyCode, this.metaKey = this.metaKey || 57 === this.keyCode, this._asKeybinding = this._computeKeybinding(), this._asRuntimeKeybinding = this._computeRuntimeKeybinding()
        }
        return e.prototype.preventDefault = function () {
          this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault()
        }, e.prototype.stopPropagation = function () {
          this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation()
        }, e.prototype.toKeybinding = function () {
          return this._asRuntimeKeybinding
        }, e.prototype.equals = function ( e ) {
          return this._asKeybinding === e
        }, e.prototype._computeKeybinding = function () {
          let e = 0;
          5 !== this.keyCode && 4 !== this.keyCode && 6 !== this.keyCode && 57 !== this.keyCode && ( e = this.keyCode );
          let t = 0;
          return this.ctrlKey && ( t |= u ), this.altKey && ( t |= 512 ), this.shiftKey && ( t |= 1024 ), this.metaKey && ( t |= l ), t |= e
        }, e.prototype._computeRuntimeKeybinding = function () {
          let e = 0;
          return 5 !== this.keyCode && 4 !== this.keyCode && 6 !== this.keyCode && 57 !== this.keyCode && ( e = this.keyCode ), new i.e( this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e )
        }, e;
      } )();
    },
    uWgD( e, t, n ) {},
    ufhN( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "st",
        extensions: [ ".st", ".iecst", ".iecplc", ".lc3lib" ],
        aliases: [ "StructuredText", "scl", "stl" ],
        loader() {
          return o.Promise.wrap( n.e( 308 ).then( n.bind( null, "rMIR" ) ) )
        }
      } )
    },
    undH( e, t, n ) {},
    uzpd( e, t, n ) {
      "use strict";
      let i;
      n.d( t, "a", ( () => {
        return i
      } ) ), ( e => {
        e[ e.NotSet = 0 ] = "NotSet", e[ e.ContentFlush = 1 ] = "ContentFlush", e[ e.RecoverFromMarkers = 2 ] = "RecoverFromMarkers", e[ e.Explicit = 3 ] = "Explicit", e[ e.Paste = 4 ] = "Paste", e[ e.Undo = 5 ] = "Undo", e[ e.Redo = 6 ] = "Redo"
      } )( i || ( i = {} ) )
    },
    "v+CO": function ( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "EditorActionCommandEntry", ( () => {
        return g
      } ) ), n.d( t, "QuickCommandAction", ( () => {
        return m
      } ) );
      const i = n( "3/fG" );
      const o = n( "/cxE" );
      const r = n( "fpMC" );
      const s = n( "VMIq" );
      const a = n( "Rpxm" );
      const u = n( "ksmt" );
      const l = n( "bexQ" );
      const c = n( "wQH0" );
      const d = n( "rzPn" );
      const h = n( "sswD" );
      const p = n( "D3Dy" );
      const f = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      var g = ( e => {
        function t( t, n, i, o ) {
          const r = e.call( this ) || this;
          return r.key = t, r.setHighlights( n ), r.action = i, r.editor = o, r
        }
        return f( t, e ), t.prototype.getLabel = function () {
          return this.action.label
        }, t.prototype.getAriaLabel = function () {
          return i.a( "ariaLabelEntry", "{0}, commands", this.getLabel() )
        }, t.prototype.getGroupLabel = function () {
          return this.key
        }, t.prototype.run = function ( e, t ) {
          const n = this;
          return e === u.a.OPEN && ( s.b.timeout( 50 ).done( ( () => {
            n.editor.focus();
            try {
              ( n.action.run() || s.b.as( null ) ).done( null, o.e )
            } catch ( e ) {
              Object( o.e )( e )
            }
          } ), o.e ), !0 );
        }, t;
      } )( a.b );
      var m = ( e => {
        function t() {
          return e.call( this, i.a( "quickCommandActionInput", "Type the name of an action you want to execute" ), {
            id: "editor.action.quickCommand",
            label: i.a( "QuickCommandAction.label", "Command Palette" ),
            alias: "Command Palette",
            precondition: null,
            kbOpts: {
              kbExpr: c.a.focus,
              primary: p.k ? 571 : 59,
              weight: 100
            },
            menuOpts: {
              group: "z_commands",
              order: 1
            }
          } ) || this
        }
        return f( t, e ), t.prototype.run = function ( e, t ) {
          const n = this,
            i = e.get( l.a );
          this._show( this.getController( t ), {
            getModel( e ) {
              return new a.c( n._editorActionsToEntries( i, t, e ) )
            },
            getAutoFocus( e ) {
              return {
                autoFocusFirstEntry: !0,
                autoFocusPrefixMatch: e
              }
            }
          } )
        }, t.prototype._sort = ( e, t ) => {
          const n = e.getLabel().toLowerCase(),
            i = t.getLabel().toLowerCase();
          return n.localeCompare( i )
        }, t.prototype._editorActionsToEntries = function ( e, t, n ) {
          for ( var i = t.getSupportedActions(), o = [], s = 0; s < i.length; s++ ) {
            const a = i[ s ],
              u = e.lookupKeybinding( a.id );
            if ( a.label ) {
              const l = Object( r.e )( n, a.label );
              l && o.push( new g( u ? u.getLabel() : "", l, a, t ) )
            }
          }
          return o = o.sort( this._sort )
        }, t;
      } )( d.a );
      Object( h.f )( m )
    },
    vATl( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return r
      } ) );
      const i = n( "N0LK" );
      var o = ( () => {
        function e( e, t ) {
          if ( this.flags = t, 0 !== ( 1 & this.flags ) ) {
            const n = e.getModel();
            this.modelVersionId = n ? i.format( "{0}#{1}", n.uri.toString(), n.getVersionId() ) : null
          }
          0 !== ( 4 & this.flags ) && ( this.position = e.getPosition() ), 0 !== ( 2 & this.flags ) && ( this.selection = e.getSelection() ), 0 !== ( 8 & this.flags ) && ( this.scrollLeft = e.getScrollLeft(), this.scrollTop = e.getScrollTop() )
        }
        return e.prototype._equals = function ( t ) {
          if ( !( t instanceof e ) ) return !1;
          const n = t;
          return this.modelVersionId === n.modelVersionId && ( this.scrollLeft === n.scrollLeft && this.scrollTop === n.scrollTop && ( !( !this.position && n.position || this.position && !n.position || this.position && n.position && !this.position.equals( n.position ) ) && !( !this.selection && n.selection || this.selection && !n.selection || this.selection && n.selection && !this.selection.equalsRange( n.selection ) ) ) )
        }, e.prototype.validate = function ( t ) {
          return this._equals( new e( t, this.flags ) )
        }, e;
      } )();
      var r = ( () => {
        function e( e, t ) {
          this._visiblePosition = e, this._visiblePositionScrollDelta = t
        }
        return e.capture = t => {
          let n = null,
            i = 0;
          if ( 0 !== t.getScrollTop() ) {
            const o = t.getVisibleRanges();
            if ( o.length > 0 ) {
              n = o[ 0 ].getStartPosition();
              const r = t.getTopForPosition( n.lineNumber, n.column );
              i = t.getScrollTop() - r
            }
          }
          return new e( n, i )
        }, e.prototype.restore = function ( e ) {
          if ( this._visiblePosition ) {
            const t = e.getTopForPosition( this._visiblePosition.lineNumber, this._visiblePosition.column );
            e.setScrollTop( t + this._visiblePositionScrollDelta )
          }
        }, e;
      } )();
    },
    vKxM( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) ), n.d( t, "b", ( () => {
        return c
      } ) );
      n( "TT2d" );
      var i;
      let o;
      let r;
      const s = n( "lCHf" );
      const a = n( "EffR" );
      const u = n( "pmY6" );

      function l( e, t, n ) {
        const i = n.offset + n.size;
        return n.position === r.Before ? t <= e - i ? i : t <= n.offset ? n.offset - t : Math.max( e - t, 0 ) : t <= n.offset ? n.offset - t : t <= e - i ? i : 0
      }!( e => {
        e[ e.LEFT = 0 ] = "LEFT", e[ e.RIGHT = 1 ] = "RIGHT"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.BELOW = 0 ] = "BELOW", e[ e.ABOVE = 1 ] = "ABOVE"
      } )( o || ( o = {} ) ), ( e => {
        e[ e.Before = 0 ] = "Before", e[ e.After = 1 ] = "After"
      } )( r || ( r = {} ) );
      var c = ( () => {
        function e( e ) {
          const t = this;
          this.$view = Object( s.a )( ".context-view" ).hide(), this.setContainer( e ), this.toDispose = [ Object( u.f )( ( () => {
            t.setContainer( null )
          } ) ) ], this.toDisposeOnClean = null
        }
        return e.prototype.setContainer = function ( t ) {
          const n = this;
          this.$container && ( this.$container.getHTMLElement().removeChild( this.$view.getHTMLElement() ), this.$container.off( e.BUBBLE_UP_EVENTS ), this.$container.off( e.BUBBLE_DOWN_EVENTS, !0 ), this.$container = null ), t && ( this.$container = Object( s.a )( t ), this.$view.appendTo( this.$container ), this.$container.on( e.BUBBLE_UP_EVENTS, ( e => {
            n.onDOMEvent( e, document.activeElement, !1 )
          } ) ), this.$container.on( e.BUBBLE_DOWN_EVENTS, ( e => {
            n.onDOMEvent( e, document.activeElement, !0 )
          } ), null, !0 ) )
        }, e.prototype.show = function ( e ) {
          this.isVisible() && this.hide(), this.$view.setClass( "context-view" ).empty().style( {
            top: "0px",
            left: "0px"
          } ).show(), this.toDisposeOnClean = e.render( this.$view.getHTMLElement() ), this.delegate = e, this.doLayout()
        }, e.prototype.layout = function () {
          this.isVisible() && ( !1 !== this.delegate.canRelayout ? ( this.delegate.layout && this.delegate.layout(), this.doLayout() ) : this.hide() )
        }, e.prototype.doLayout = function () {
          let e;
          const t = this.delegate.getAnchor();
          if ( a.C( t ) ) {
            const n = a.u( t );
            e = {
              top: n.top,
              left: n.left,
              width: n.width,
              height: n.height
            }
          } else {
            const s = t;
            e = {
              top: s.y,
              left: s.x,
              width: s.width || 0,
              height: s.height || 0
            }
          }
          let u;
          const c = this.$view.getTotalSize();
          const d = this.delegate.anchorPosition || o.BELOW;
          const h = this.delegate.anchorAlignment || i.LEFT;
          const p = {
            offset: e.top,
            size: e.height,
            position: d === o.BELOW ? r.Before : r.After
          };
          u = h === i.LEFT ? {
            offset: e.left,
            size: 0,
            position: r.Before
          } : {
            offset: e.left + e.width,
            size: 0,
            position: r.After
          };
          const f = a.u( this.$container.getHTMLElement() ),
            g = l( window.innerHeight, c.height, p ) - f.top,
            m = l( window.innerWidth, c.width, u ) - f.left;
          this.$view.removeClass( "top", "bottom", "left", "right" ), this.$view.addClass( d === o.BELOW ? "bottom" : "top" ), this.$view.addClass( h === i.LEFT ? "left" : "right" ), this.$view.style( {
            top: g + "px",
            left: m + "px",
            width: "initial"
          } )
        }, e.prototype.hide = function ( e ) {
          this.delegate && this.delegate.onHide && this.delegate.onHide( e ), this.delegate = null, this.toDisposeOnClean && ( this.toDisposeOnClean.dispose(), this.toDisposeOnClean = null ), this.$view.hide()
        }, e.prototype.isVisible = function () {
          return !!this.delegate
        }, e.prototype.onDOMEvent = function ( e, t, n ) {
          this.delegate && ( this.delegate.onDOMEvent ? this.delegate.onDOMEvent( e, document.activeElement ) : n && !a.B( e.target, this.$container.getHTMLElement() ) && this.hide() )
        }, e.prototype.dispose = function () {
          this.hide(), this.toDispose = Object( u.d )( this.toDispose )
        }, e.BUBBLE_UP_EVENTS = [ "click", "keydown", "focus", "blur" ], e.BUBBLE_DOWN_EVENTS = [ "click" ], e;
      } )()
    },
    vMFT( e, t, n ) {},
    vVA1( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "3/fG" ),
        o = n( "sswD" ),
        r = n( "scqD" ),
        s = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        a = ( e => {
          function t() {
            const t = e.call( this, {
              id: "editor.action.toggleHighContrast",
              label: i.a( "toggleHighContrast", "Toggle High Contrast Theme" ),
              alias: "Toggle High Contrast Theme",
              precondition: null
            } ) || this;
            return t._originalThemeName = null, t
          }
          return s( t, e ), t.prototype.run = function ( e, t ) {
            const n = e.get( r.a );
            this._originalThemeName ? ( n.setTheme( this._originalThemeName ), this._originalThemeName = null ) : ( this._originalThemeName = n.getTheme().themeName, n.setTheme( "hc-black" ) )
          }, t;
        } )( o.b );
      Object( o.f )( a )
    },
    "w29/": function ( e, t, n ) {
      "use strict";
      n.r( t );
      n( "5DEy" );
      const i = n( "3/fG" ),
        o = n( "D3Dy" ),
        r = n( "MNsG" ),
        s = n( "Vxe3" ),
        a = n( "sswD" ),
        u = n( "5TxY" ),
        l = n( "wQH0" ),
        c = n( "fjLI" ),
        d = ( () => {
          const e = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && ( ( e, t ) => {
            e.__proto__ = t
          } ) || ( ( e, t ) => {
            for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
          } );
          return ( t, n ) => {
            function i() {
              this.constructor = t
            }
            e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
          };
        } )(),
        h = "9_cutcopypaste",
        p = r.e || document.queryCommandSupported( "cut" ),
        f = r.e || document.queryCommandSupported( "copy" ),
        g = f && !o.h,
        m = r.e || !o.f && document.queryCommandSupported( "paste" ),
        _ = ( e => {
          function t( t, n ) {
            const i = e.call( this, n ) || this;
            return i.browserCommand = t, i
          }
          return d( t, e ), t.prototype.runCommand = function ( e, t ) {
            const n = e.get( s.a ).getFocusedCodeEditor();
            n && n.hasTextFocus() ? n.trigger( "keyboard", this.id, t ) : document.execCommand( this.browserCommand )
          }, t.prototype.run = function ( e, t ) {
            t.focus(), document.execCommand( this.browserCommand )
          }, t;
        } )( a.b ),
        v = ( e => {
          function t() {
            let t = {
              kbExpr: l.a.textInputFocus,
              primary: 2102,
              win: {
                primary: 2102,
                secondary: [ 1044 ]
              },
              weight: 100
            };
            return r.e || ( t = null ), e.call( this, "cut", {
              id: "editor.action.clipboardCutAction",
              label: i.a( "actions.clipboard.cutLabel", "Cut" ),
              alias: "Cut",
              precondition: l.a.writable,
              kbOpts: t,
              menuOpts: {
                group: h,
                order: 1
              },
              menubarOpts: {
                menuId: c.b.MenubarEditMenu,
                group: "2_ccp",
                title: i.a( {
                  key: "miCut",
                  comment: [ "&& denotes a mnemonic" ]
                }, "Cu&&t" ),
                order: 1
              }
            } ) || this
          }
          return d( t, e ), t.prototype.run = function ( t, n ) {
            !n.getConfiguration().emptySelectionClipboard && n.getSelection().isEmpty() || e.prototype.run.call( this, t, n )
          }, t
        } )( _ ),
        y = ( e => {
          function t() {
            let t = {
              kbExpr: l.a.textInputFocus,
              primary: 2081,
              win: {
                primary: 2081,
                secondary: [ 2067 ]
              },
              weight: 100
            };
            return r.e || ( t = null ), e.call( this, "copy", {
              id: "editor.action.clipboardCopyAction",
              label: i.a( "actions.clipboard.copyLabel", "Copy" ),
              alias: "Copy",
              precondition: null,
              kbOpts: t,
              menuOpts: {
                group: h,
                order: 2
              },
              menubarOpts: {
                menuId: c.b.MenubarEditMenu,
                group: "2_ccp",
                title: i.a( {
                  key: "miCopy",
                  comment: [ "&& denotes a mnemonic" ]
                }, "&&Copy" ),
                order: 2
              }
            } ) || this
          }
          return d( t, e ), t.prototype.run = function ( t, n ) {
            !n.getConfiguration().emptySelectionClipboard && n.getSelection().isEmpty() || e.prototype.run.call( this, t, n )
          }, t
        } )( _ ),
        b = ( e => {
          function t() {
            let t = {
              kbExpr: l.a.textInputFocus,
              primary: 2100,
              win: {
                primary: 2100,
                secondary: [ 1043 ]
              },
              weight: 100
            };
            return r.e || ( t = null ), e.call( this, "paste", {
              id: "editor.action.clipboardPasteAction",
              label: i.a( "actions.clipboard.pasteLabel", "Paste" ),
              alias: "Paste",
              precondition: l.a.writable,
              kbOpts: t,
              menuOpts: {
                group: h,
                order: 3
              },
              menubarOpts: {
                menuId: c.b.MenubarEditMenu,
                group: "2_ccp",
                title: i.a( {
                  key: "miPaste",
                  comment: [ "&& denotes a mnemonic" ]
                }, "&&Paste" ),
                order: 3
              }
            } ) || this
          }
          return d( t, e ), t
        } )( _ ),
        C = ( e => {
          function t() {
            return e.call( this, "copy", {
              id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
              label: i.a( "actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting" ),
              alias: "Copy With Syntax Highlighting",
              precondition: null,
              kbOpts: {
                kbExpr: l.a.textInputFocus,
                primary: null,
                weight: 100
              }
            } ) || this
          }
          return d( t, e ), t.prototype.run = function ( t, n ) {
            !n.getConfiguration().emptySelectionClipboard && n.getSelection().isEmpty() || ( u.a.forceCopyWithSyntaxHighlighting = !0, e.prototype.run.call( this, t, n ), u.a.forceCopyWithSyntaxHighlighting = !1 )
          }, t
        } )( _ );
      p && Object( a.f )( v ), f && Object( a.f )( y ), m && Object( a.f )( b ), g && Object( a.f )( C )
    },
    w9QG( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "sql",
        extensions: [ ".sql" ],
        aliases: [ "SQL" ],
        loader() {
          return o.Promise.wrap( n.e( 307 ).then( n.bind( null, "Czvm" ) ) )
        }
      } )
    },
    wQH0( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return i
      } ) );
      var i;
      const o = n( "T8No" );
      !( e => {
        e.editorTextFocus = new o.f( "editorTextFocus", !1 ), e.focus = new o.f( "editorFocus", !1 ), e.textInputFocus = new o.f( "textInputFocus", !1 ), e.readOnly = new o.f( "editorReadonly", !1 ), e.writable = e.readOnly.toNegated(), e.hasNonEmptySelection = new o.f( "editorHasSelection", !1 ), e.hasOnlyEmptySelection = e.hasNonEmptySelection.toNegated(), e.hasMultipleSelections = new o.f( "editorHasMultipleSelections", !1 ), e.hasSingleSelection = e.hasMultipleSelections.toNegated(), e.tabMovesFocus = new o.f( "editorTabMovesFocus", !1 ), e.tabDoesNotMoveFocus = e.tabMovesFocus.toNegated(), e.isInEmbeddedEditor = new o.f( "isInEmbeddedEditor", void 0 ), e.canUndo = new o.f( "canUndo", !1 ), e.canRedo = new o.f( "canRedo", !1 ), e.languageId = new o.f( "editorLangId", void 0 ), e.hasCompletionItemProvider = new o.f( "editorHasCompletionItemProvider", void 0 ), e.hasCodeActionsProvider = new o.f( "editorHasCodeActionsProvider", void 0 ), e.hasCodeLensProvider = new o.f( "editorHasCodeLensProvider", void 0 ), e.hasDefinitionProvider = new o.f( "editorHasDefinitionProvider", void 0 ), e.hasImplementationProvider = new o.f( "editorHasImplementationProvider", void 0 ), e.hasTypeDefinitionProvider = new o.f( "editorHasTypeDefinitionProvider", void 0 ), e.hasHoverProvider = new o.f( "editorHasHoverProvider", void 0 ), e.hasDocumentHighlightProvider = new o.f( "editorHasDocumentHighlightProvider", void 0 ), e.hasDocumentSymbolProvider = new o.f( "editorHasDocumentSymbolProvider", void 0 ), e.hasReferenceProvider = new o.f( "editorHasReferenceProvider", void 0 ), e.hasRenameProvider = new o.f( "editorHasRenameProvider", void 0 ), e.hasDocumentFormattingProvider = new o.f( "editorHasDocumentFormattingProvider", void 0 ), e.hasDocumentSelectionFormattingProvider = new o.f( "editorHasDocumentSelectionFormattingProvider", void 0 ), e.hasSignatureHelpProvider = new o.f( "editorHasSignatureHelpProvider", void 0 )
      } )( i || ( i = {} ) )
    },
    woZy( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "pug",
        extensions: [ ".jade", ".pug" ],
        aliases: [ "Pug", "Jade", "jade" ],
        loader() {
          return o.Promise.wrap( n.e( 290 ).then( n.bind( null, "I+Au" ) ) )
        }
      } )
    },
    wsa1( e, t, n ) {
      let i;
      self.MonacoEnvironment = ( i = {
        editorWorkerService: "monaco/0.14.20/editor.worker.js",
        css: "monaco/0.14.20/css.worker.js",
        html: "monaco/0.14.20/html.worker.js",
        json: "monaco/0.14.20/json.worker.js",
        typescript: "monaco/0.14.20/typescript.worker.js",
        javascript: "monaco/0.14.20/typescript.worker.js",
        less: "monaco/0.14.20/css.worker.js",
        scss: "monaco/0.14.20/css.worker.js",
        handlebars: "monaco/0.14.20/html.worker.js",
        razor: "monaco/0.14.20/html.worker.js"
      }, {
        getWorkerUrl( e, t ) {
          const n = "string" === typeof window.__webpack_public_path__ ? window.__webpack_public_path__ : "/public";
          return ( n ? n.replace( /\/$/, "" ) + "/" : "" ) + i[ t ]
        }
      } ), n( "SBYE" ), n( "bk7F" ), n( "KTWA" ), n( "w29/" ), n( "CxEt" ), n( "d6R0" ), n( "kqbb" ), n( "n01l" ), n( "fD5p" ), n( "1YUG" ), n( "5RaG" ), n( "/RFl" ), n( "oQaD" ), n( "dgXF" ), n( "bfR1" ), n( "cIJc" ), n( "n3JV" ), n( "gh2A" ), n( "lY/7" ), n( "AhDq" ), n( "rugR" ), n( "GvMn" ), n( "gJAb" ), n( "oiKk" ), n( "dH+W" ), n( "2ESN" ), n( "8XyJ" ), n( "WwIK" ), n( "v+CO" ), n( "WQDh" ), n( "TC2m" ), n( "4sI4" ), n( "Q631" ), n( "10Fh" ), n( "tXSY" ), n( "ep4t" ), n( "vVA1" ), n( "k7pc" ), n( "ba9Q" ), n( "XtJs" ), n( "s7Km" ), n( "LUcL" ), e.exports = n( "jqkw" ), n( "CdFp" ), n( "23p7" ), n( "CuPc" ), n( "OOlL" ), n( "li8W" ), n( "kdPm" ), n( "ApJL" ), n( "jrbv" ), n( "gqHg" ), n( "DtFZ" ), n( "p3Ex" ), n( "E+ie" ), n( "9B1q" ), n( "9XAT" ), n( "SvYn" ), n( "I/Lx" ), n( "e39c" ), n( "0oIH" ), n( "+a1H" ), n( "hFdI" ), n( "c2dO" ), n( "zQEy" ), n( "k7mE" ), n( "cldp" ), n( "p5tG" ), n( "2qqv" ), n( "Dvnd" ), n( "FvUK" ), n( "ZvGG" ), n( "QFiB" ), n( "ZkA/" ), n( "/cAr" ), n( "xYNL" ), n( "jVwG" ), n( "6lNC" ), n( "q8qy" ), n( "sStQ" ), n( "oKJv" ), n( "H6Gb" ), n( "y3CF" ), n( "JlLP" ), n( "j2o1" ), n( "woZy" ), n( "iLY9" ), n( "628j" ), n( "Msxo" ), n( "ajgA" ), n( "QiAa" ), n( "pI2L" ), n( "yKqg" ), n( "ij/i" ), n( "XQgg" ), n( "Gb1F" ), n( "G9H2" ), n( "xmOD" ), n( "c9ML" ), n( "Mzro" ), n( "GZrW" ), n( "1lwE" ), n( "w9QG" ), n( "ufhN" ), n( "LRks" ), n( "BUKB" ), n( "n18v" ), n( "EOst" ), n( "z3hU" ), n( "nrBJ" ), n( "BEdG" ), n( "E4kL" )
    },
    "x/UI": function ( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return o
      } ) );
      const i = n( "Cg/j" );
      var o = Object( i.c )( "IWorkspaceEditService" );
    },
    xNeX( e, t, n ) {},
    xONI( e, t, n ) {
      "use strict";
      n.d( t, "b", ( () => {
        return c
      } ) ), n.d( t, "a", ( () => {
        return d
      } ) );
      n( "KgQ1" );
      const i = n( "EffR" );
      const o = n( "7lZ/" );
      const r = n( "4J+e" );
      const s = n( "3rx1" );
      const a = n( "pmY6" );
      const u = ( () => {
        const e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && ( ( e, t ) => {
          e.__proto__ = t
        } ) || ( ( e, t ) => {
          for ( const n in t ) t.hasOwnProperty( n ) && ( e[ n ] = t[ n ] )
        } );
        return ( t, n ) => {
          function i() {
            this.constructor = t
          }
          e( t, n ), t.prototype = null === n ? Object.create( n ) : ( i.prototype = n.prototype, new i )
        };
      } )();
      const l = ( () => {
        function e( e ) {
          this._element = e
        }
        return Object.defineProperty( e.prototype, "element", {
          get() {
            return this._element
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "textContent", {
          set( e ) {
            this.disposed || e === this._textContent || ( this._textContent = e, this._element.textContent = e )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "className", {
          set( e ) {
            this.disposed || e === this._className || ( this._className = e, this._element.className = e )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "title", {
          set( e ) {
            this.disposed || e === this._title || ( this._title = e, this._title ? this._element.title = e : this._element.removeAttribute( "title" ) )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "empty", {
          set( e ) {
            this.disposed || e === this._empty || ( this._empty = e, this._element.style.marginLeft = e ? "0" : null )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.dispose = function () {
          this.disposed = !0
        }, e;
      } )();
      var c = ( e => {
        function t( t, n ) {
          const r = e.call( this ) || this;
          return r.domNode = r._register( new l( i.k( t, i.a( ".monaco-icon-label" ) ) ) ), r.labelDescriptionContainer = r._register( new l( i.k( r.domNode.element, i.a( ".monaco-icon-label-description-container" ) ) ) ), n && n.supportHighlights ? r.labelNode = r._register( new o.a( i.k( r.labelDescriptionContainer.element, i.a( "a.label-name" ) ) ) ) : r.labelNode = r._register( new l( i.k( r.labelDescriptionContainer.element, i.a( "a.label-name" ) ) ) ), n && n.supportDescriptionHighlights ? r.descriptionNodeFactory = () => {
            return r._register( new o.a( i.k( r.labelDescriptionContainer.element, i.a( "span.label-description" ) ) ) )
          } : r.descriptionNodeFactory = () => {
            return r._register( new l( i.k( r.labelDescriptionContainer.element, i.a( "span.label-description" ) ) ) )
          }, r;
        }
        return u( t, e ), t.prototype.setValue = function ( e, t, n ) {
          const i = [ "monaco-icon-label" ];
          n && ( n.extraClasses && i.push.apply( i, n.extraClasses ), n.italic && i.push( "italic" ) ), this.domNode.className = i.join( " " ), this.domNode.title = n && n.title ? n.title : "", this.labelNode instanceof o.a ? this.labelNode.set( e || "", n ? n.matches : void 0 ) : this.labelNode.textContent = e || "", ( t || this.descriptionNode ) && ( this.descriptionNode || ( this.descriptionNode = this.descriptionNodeFactory() ), this.descriptionNode instanceof o.a ? ( this.descriptionNode.set( t || "", n ? n.descriptionMatches : void 0 ), n && n.descriptionTitle ? this.descriptionNode.element.title = n.descriptionTitle : this.descriptionNode.element.removeAttribute( "title" ) ) : ( this.descriptionNode.textContent = t || "", this.descriptionNode.title = n && n.descriptionTitle ? n.descriptionTitle : "", this.descriptionNode.empty = !t ) )
        }, t;
      } )( a.a );
      var d = ( e => {
        function t( t, n, i, o ) {
          const r = e.call( this, t ) || this;
          return r.setFile( n, i, o ), r
        }
        return u( t, e ), t.prototype.setFile = function ( e, t, n ) {
          const i = r.b( e.fsPath );
          this.setValue( Object( s.a )( e ), i && "." !== i ? Object( s.b )( i, n, t ) : "", {
            title: e.fsPath
          } )
        }, t;
      } )( c );
    },
    xYNL( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "mysql",
        extensions: [],
        aliases: [ "MySQL", "mysql" ],
        loader() {
          return o.Promise.wrap( n.e( 280 ).then( n.bind( null, "tGOS" ) ) )
        }
      } )
    },
    xmOD( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "scheme",
        extensions: [ ".scm", ".ss", ".sch", ".rkt" ],
        aliases: [ "scheme", "Scheme" ],
        loader() {
          return o.Promise.wrap( n.e( 302 ).then( n.bind( null, "fB/Z" ) ) )
        }
      } )
    },
    y3CF( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "postiats",
        extensions: [ ".dats", ".sats", ".hats" ],
        aliases: [ "ATS", "ATS/Postiats" ],
        loader() {
          return o.Promise.wrap( n.e( 287 ).then( n.bind( null, "YdqL" ) ) )
        }
      } )
    },
    yEoX( e, t, n ) {},
    yKqg( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "restructuredtext",
        extensions: [ ".rst" ],
        aliases: [ "reStructuredText", "restructuredtext" ],
        loader() {
          return o.Promise.wrap( n.e( 297 ).then( n.bind( null, "LdT9" ) ) )
        }
      } )
    },
    yqFB( e, t, n ) {},
    yrU1( e, t, n ) {},
    z3hU( e, t, n ) {
      "use strict";
      n.r( t ), n.d( t, "LanguageServiceDefaultsImpl", ( () => {
        return l
      } ) );
      n( "M/lh" );
      let i;
      let o;
      let r;
      let s;
      let a;
      const u = monaco.Emitter;
      var l = ( () => {
        function e( e, t ) {
          this._onDidChange = new u, this._extraLibs = Object.create( null ), this._workerMaxIdleTime = 12e4, this.setCompilerOptions( e ), this.setDiagnosticsOptions( t )
        }
        return Object.defineProperty( e.prototype, "onDidChange", {
          get() {
            return this._onDidChange.event
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.getExtraLibs = function () {
          const e = Object.create( null );
          for ( const t in this._extraLibs ) e[ t ] = this._extraLibs[ t ];
          return Object.freeze( e )
        }, e.prototype.addExtraLib = function ( e, t ) {
          const n = this;
          if ( "undefined" === typeof t && ( t = "ts:extralib-" + Date.now() ), this._extraLibs[ t ] ) throw new Error( t + " already a extra lib" );
          return this._extraLibs[ t ] = e, this._onDidChange.fire( this ), {
            dispose() {
              delete n._extraLibs[ t ] && n._onDidChange.fire( n )
            }
          };
        }, e.prototype.getCompilerOptions = function () {
          return this._compilerOptions
        }, e.prototype.setCompilerOptions = function ( e ) {
          this._compilerOptions = e || Object.create( null ), this._onDidChange.fire( this )
        }, e.prototype.getDiagnosticsOptions = function () {
          return this._diagnosticsOptions
        }, e.prototype.setDiagnosticsOptions = function ( e ) {
          this._diagnosticsOptions = e || Object.create( null ), this._onDidChange.fire( this )
        }, e.prototype.setMaximumWorkerIdleTime = function ( e ) {
          this._workerMaxIdleTime = e
        }, e.prototype.getWorkerMaxIdleTime = function () {
          return this._workerMaxIdleTime
        }, e.prototype.setEagerModelSync = function ( e ) {
          this._eagerModelSync = e
        }, e.prototype.getEagerModelSync = function () {
          return this._eagerModelSync
        }, e;
      } )();
      !( e => {
        e[ e.None = 0 ] = "None", e[ e.CommonJS = 1 ] = "CommonJS", e[ e.AMD = 2 ] = "AMD", e[ e.UMD = 3 ] = "UMD", e[ e.System = 4 ] = "System", e[ e.ES2015 = 5 ] = "ES2015", e[ e.ESNext = 6 ] = "ESNext"
      } )( i || ( i = {} ) ), ( e => {
        e[ e.None = 0 ] = "None", e[ e.Preserve = 1 ] = "Preserve", e[ e.React = 2 ] = "React", e[ e.ReactNative = 3 ] = "ReactNative"
      } )( o || ( o = {} ) ), ( e => {
        e[ e.CarriageReturnLineFeed = 0 ] = "CarriageReturnLineFeed", e[ e.LineFeed = 1 ] = "LineFeed"
      } )( r || ( r = {} ) ), ( e => {
        e[ e.ES3 = 0 ] = "ES3", e[ e.ES5 = 1 ] = "ES5", e[ e.ES2015 = 2 ] = "ES2015", e[ e.ES2016 = 3 ] = "ES2016", e[ e.ES2017 = 4 ] = "ES2017", e[ e.ES2018 = 5 ] = "ES2018", e[ e.ESNext = 6 ] = "ESNext", e[ e.JSON = 100 ] = "JSON", e[ e.Latest = 6 ] = "Latest"
      } )( s || ( s = {} ) ), ( e => {
        e[ e.Classic = 1 ] = "Classic", e[ e.NodeJs = 2 ] = "NodeJs"
      } )( a || ( a = {} ) );
      const c = new l( {
          allowNonTsExtensions: !0,
          target: s.Latest
        }, {
          noSemanticValidation: !1,
          noSyntaxValidation: !1
        } ),
        d = new l( {
          allowNonTsExtensions: !0,
          allowJs: !0,
          target: s.Latest
        }, {
          noSemanticValidation: !0,
          noSyntaxValidation: !1
        } );

      function h() {
        return f().then( ( e => {
          return e.getTypeScriptWorker()
        } ) );
      }

      function p() {
        return f().then( ( e => {
          return e.getJavaScriptWorker()
        } ) );
      }

      function f() {
        return monaco.Promise.wrap( n.e( 318 ).then( n.bind( null, "4yiN" ) ) )
      }
      monaco.languages.typescript = {
        ModuleKind: i,
        JsxEmit: o,
        NewLineKind: r,
        ScriptTarget: s,
        ModuleResolutionKind: a,
        typescriptDefaults: c,
        javascriptDefaults: d,
        getTypeScriptWorker: h,
        getJavaScriptWorker: p
      }, monaco.languages.onLanguage( "typescript", ( () => {
        return f().then( ( e => {
          return e.setupTypeScript( c )
        } ) );
      } ) ), monaco.languages.onLanguage( "javascript", ( () => {
        return f().then( ( e => {
          return e.setupJavaScript( d )
        } ) );
      } ) )
    },
    zN7H( e, t, n ) {
      "use strict";
      n.d( t, "a", ( () => {
        return u
      } ) );
      const i = n( "N0LK" );
      const o = n( "Ll0s" );
      const r = n( "aokT" );
      const s = n( "gCVg" );
      const a = n( "cMvZ" );

      var u = ( () => {
        function e( e, t ) {
          this._opts = t, this._selection = e, this._useLastEditRangeForCursorEndPosition = !1, this._selectionStartColumnStaysPut = !1
        }
        return e.unshiftIndentCount = ( e, t, n ) => {
          const i = o.a.visibleColumnFromColumn( e, t, n );
          return o.a.prevTabStop( i, n ) / n
        }, e.shiftIndentCount = ( e, t, n ) => {
          const i = o.a.visibleColumnFromColumn( e, t, n );
          return o.a.nextTabStop( i, n ) / n
        }, e.prototype._addEditOperation = function ( e, t, n ) {
          this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation( t, n ) : e.addEditOperation( t, n )
        }, e.prototype.getEditOperations = function ( t, n ) {
          const s = this._selection.startLineNumber;
          let u = this._selection.endLineNumber;
          1 === this._selection.endColumn && s !== u && ( u -= 1 );
          const l = this._opts.tabSize,
            c = this._opts.oneIndent,
            d = s === u;
          if ( this._selection.isEmpty() && /^\s*$/.test( t.getLineContent( s ) ) && ( this._useLastEditRangeForCursorEndPosition = !0 ), this._opts.useTabStops )
            for ( var h = [ "", c ], p = 0, f = 0, g = s; g <= u; g++, p = f ) {
              f = 0;
              var m = t.getLineContent( g ),
                _ = i.firstNonWhitespaceIndex( m );
              if ( ( !this._opts.isUnshift || 0 !== m.length && 0 !== _ ) && ( d || this._opts.isUnshift || 0 !== m.length ) ) {
                if ( -1 === _ && ( _ = m.length ), g > 1 )
                  if ( o.a.visibleColumnFromColumn( m, _ + 1, l ) % l !== 0 && t.isCheapToTokenize( g - 1 ) ) {
                    const v = a.a.getRawEnterActionAtPosition( t, g - 1, t.getLineMaxColumn( g - 1 ) );
                    if ( v ) {
                      if ( f = p, v.appendText )
                        for ( var y = 0, b = v.appendText.length; y < b && f < l && 32 === v.appendText.charCodeAt( y ); y++ ) f++;
                      v.removeText && ( f = Math.max( 0, f - v.removeText ) );
                      for ( y = 0; y < f && ( 0 !== _ && 32 === m.charCodeAt( _ - 1 ) ); y++ ) _--
                    }
                  } if ( !this._opts.isUnshift || 0 !== _ ) {
                  let C = void 0;
                  C = this._opts.isUnshift ? e.unshiftIndentCount( m, _ + 1, l ) : e.shiftIndentCount( m, _ + 1, l );
                  for ( y = h.length; y <= C; y++ ) h[ y ] = h[ y - 1 ] + c;
                  this._addEditOperation( n, new r.a( g, 1, g, _ + 1 ), h[ C ] ), g === s && ( this._selectionStartColumnStaysPut = this._selection.startColumn <= _ + 1 )
                }
              }
            } else
              for ( g = s; g <= u; g++ ) {
                m = t.getLineContent( g ), _ = i.firstNonWhitespaceIndex( m );
                if ( ( !this._opts.isUnshift || 0 !== m.length && 0 !== _ ) && ( ( d || this._opts.isUnshift || 0 !== m.length ) && ( -1 === _ && ( _ = m.length ), !this._opts.isUnshift || 0 !== _ ) ) )
                  if ( this._opts.isUnshift ) {
                    _ = Math.min( _, l );
                    for ( let w = 0; w < _; w++ ) {
                      if ( 9 === m.charCodeAt( w ) ) {
                        _ = w + 1;
                        break
                      }
                    }
                    this._addEditOperation( n, new r.a( g, 1, g, _ + 1 ), "" )
                  } else this._addEditOperation( n, new r.a( g, 1, g, 1 ), c ), g === s && ( this._selectionStartColumnStaysPut = 1 === this._selection.startColumn )
              }
          this._selectionId = n.trackSelection( this._selection )
        }, e.prototype.computeCursorState = function ( e, t ) {
          if ( this._useLastEditRangeForCursorEndPosition ) {
            const n = t.getInverseEditOperations()[ 0 ];
            return new s.a( n.range.endLineNumber, n.range.endColumn, n.range.endLineNumber, n.range.endColumn )
          }
          const i = t.getTrackedSelection( this._selectionId );
          if ( this._selectionStartColumnStaysPut ) {
            const o = this._selection.startColumn;
            return i.startColumn <= o ? i : i.getDirection() === s.b.LTR ? new s.a( i.startLineNumber, o, i.endLineNumber, i.endColumn ) : new s.a( i.endLineNumber, i.endColumn, i.startLineNumber, o )
          }
          return i
        }, e;
      } )();
    },
    zQEy( e, t, n ) {
      "use strict";
      n.r( t );
      const i = n( "+hIS" ),
        o = "undefined" === typeof monaco ? self.monaco : monaco;
      Object( i.a )( {
        id: "ini",
        extensions: [ ".ini", ".properties", ".gitconfig" ],
        filenames: [ "config", ".gitattributes", ".gitconfig", ".editorconfig" ],
        aliases: [ "Ini", "ini" ],
        loader() {
          return o.Promise.wrap( n.e( 270 ).then( n.bind( null, "On+f" ) ) )
        }
      } )
    },
    zrhQ( e, t, n ) {
      "use strict";

      function i( e, t ) {
        const n = Math.pow( 10, t );
        return Math.round( e * n ) / n
      }
      n.d( t, "c", ( () => {
        return o
      } ) ), n.d( t, "b", ( () => {
        return s
      } ) ), n.d( t, "a", ( () => {
        return a
      } ) );
      var o = ( () => {
        function e( e, t, n, o ) {
          void 0 === o && ( o = 1 ), this.r = 0 | Math.min( 255, Math.max( 0, e ) ), this.g = 0 | Math.min( 255, Math.max( 0, t ) ), this.b = 0 | Math.min( 255, Math.max( 0, n ) ), this.a = i( Math.max( Math.min( 1, o ), 0 ), 3 )
        }
        return e.equals = ( e, t ) => {
          return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a
        }, e;
      } )();

      const r = ( () => {
        function e( e, t, n, o ) {
          this.h = 0 | Math.max( Math.min( 360, e ), 0 ), this.s = i( Math.max( Math.min( 1, t ), 0 ), 3 ), this.l = i( Math.max( Math.min( 1, n ), 0 ), 3 ), this.a = i( Math.max( Math.min( 1, o ), 0 ), 3 )
        }
        return e.equals = ( e, t ) => {
          return e.h === t.h && e.s === t.s && e.l === t.l && e.a === t.a
        }, e.fromRGBA = t => {
          const n = t.r / 255;
          const i = t.g / 255;
          const o = t.b / 255;
          const r = t.a;
          const s = Math.max( n, i, o );
          const a = Math.min( n, i, o );
          let u = 0;
          let l = 0;
          const c = ( a + s ) / 2;
          const d = s - a;
          if ( d > 0 ) {
            switch ( l = Math.min( c <= .5 ? d / ( 2 * c ) : d / ( 2 - 2 * c ), 1 ), s ) {
              case n:
                u = ( i - o ) / d + ( i < o ? 6 : 0 );
                break;
              case i:
                u = ( o - n ) / d + 2;
                break;
              case o:
                u = ( n - i ) / d + 4
            }
            u *= 60, u = Math.round( u )
          }
          return new e( u, l, c, r )
        }, e._hue2rgb = ( e, t, n ) => {
          return n < 0 && ( n += 1 ), n > 1 && ( n -= 1 ), n < 1 / 6 ? e + 6 * ( t - e ) * n : n < .5 ? t : n < 2 / 3 ? e + ( t - e ) * ( 2 / 3 - n ) * 6 : e
        }, e.toRGBA = t => {
          let n;
          let i;
          let r;
          const s = t.h / 360;
          const a = t.s;
          const u = t.l;
          const l = t.a;
          if ( 0 === a ) n = i = r = u;
          else {
            const c = u < .5 ? u * ( 1 + a ) : u + a - u * a,
              d = 2 * u - c;
            n = e._hue2rgb( d, c, s + 1 / 3 ), i = e._hue2rgb( d, c, s ), r = e._hue2rgb( d, c, s - 1 / 3 )
          }
          return new o( Math.round( 255 * n ), Math.round( 255 * i ), Math.round( 255 * r ), l )
        }, e;
      } )();

      var s = ( () => {
        function e( e, t, n, o ) {
          this.h = 0 | Math.max( Math.min( 360, e ), 0 ), this.s = i( Math.max( Math.min( 1, t ), 0 ), 3 ), this.v = i( Math.max( Math.min( 1, n ), 0 ), 3 ), this.a = i( Math.max( Math.min( 1, o ), 0 ), 3 )
        }
        return e.equals = ( e, t ) => {
          return e.h === t.h && e.s === t.s && e.v === t.v && e.a === t.a
        }, e.fromRGBA = t => {
          let n;
          const i = t.r / 255;
          const o = t.g / 255;
          const r = t.b / 255;
          const s = Math.max( i, o, r );
          const a = s - Math.min( i, o, r );
          const u = 0 === s ? 0 : a / s;
          return n = 0 === a ? 0 : s === i ? ( ( o - r ) / a % 6 + 6 ) % 6 : s === o ? ( r - i ) / a + 2 : ( i - o ) / a + 4, new e( Math.round( 60 * n ), u, s, t.a )
        }, e.toRGBA = e => {
          const t = e.h;
          const n = e.s;
          const i = e.v;
          const r = e.a;
          const s = i * n;
          const a = s * ( 1 - Math.abs( t / 60 % 2 - 1 ) );
          const u = i - s;
          const l = [ 0, 0, 0 ];
          let c = l[ 0 ];
          let d = l[ 1 ];
          let h = l[ 2 ];
          return t < 60 ? ( c = s, d = a ) : t < 120 ? ( c = a, d = s ) : t < 180 ? ( d = s, h = a ) : t < 240 ? ( d = a, h = s ) : t < 300 ? ( c = a, h = s ) : t < 360 && ( c = s, h = a ), c = Math.round( 255 * ( c + u ) ), d = Math.round( 255 * ( d + u ) ), h = Math.round( 255 * ( h + u ) ), new o( c, d, h, r )
        }, e;
      } )();

      var a = ( () => {
        function e( e ) {
          if ( !e ) throw new Error( "Color needs a value" );
          if ( e instanceof o ) this.rgba = e;
          else if ( e instanceof r ) this._hsla = e, this.rgba = r.toRGBA( e );
          else {
            if ( !( e instanceof s ) ) throw new Error( "Invalid color ctor argument" );
            this._hsva = e, this.rgba = s.toRGBA( e )
          }
        }
        return e.fromHex = t => {
          return e.Format.CSS.parseHex( t ) || e.red
        }, Object.defineProperty( e.prototype, "hsla", {
          get() {
            return this._hsla ? this._hsla : r.fromRGBA( this.rgba )
          },
          enumerable: !0,
          configurable: !0
        } ), Object.defineProperty( e.prototype, "hsva", {
          get() {
            return this._hsva ? this._hsva : s.fromRGBA( this.rgba )
          },
          enumerable: !0,
          configurable: !0
        } ), e.prototype.equals = function ( e ) {
          return !!e && o.equals( this.rgba, e.rgba ) && r.equals( this.hsla, e.hsla ) && s.equals( this.hsva, e.hsva )
        }, e.prototype.getRelativeLuminance = function () {
          return i( .2126 * e._relativeLuminanceForComponent( this.rgba.r ) + .7152 * e._relativeLuminanceForComponent( this.rgba.g ) + .0722 * e._relativeLuminanceForComponent( this.rgba.b ), 4 )
        }, e._relativeLuminanceForComponent = e => {
          const t = e / 255;
          return t <= .03928 ? t / 12.92 : Math.pow( ( t + .055 ) / 1.055, 2.4 )
        }, e.prototype.isLighter = function () {
          return ( 299 * this.rgba.r + 587 * this.rgba.g + 114 * this.rgba.b ) / 1e3 >= 128
        }, e.prototype.isLighterThan = function ( e ) {
          return this.getRelativeLuminance() > e.getRelativeLuminance()
        }, e.prototype.isDarkerThan = function ( e ) {
          return this.getRelativeLuminance() < e.getRelativeLuminance()
        }, e.prototype.lighten = function ( t ) {
          return new e( new r( this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * t, this.hsla.a ) )
        }, e.prototype.darken = function ( t ) {
          return new e( new r( this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * t, this.hsla.a ) )
        }, e.prototype.transparent = function ( t ) {
          const n = this.rgba,
            i = n.r,
            r = n.g,
            s = n.b,
            a = n.a;
          return new e( new o( i, r, s, a * t ) )
        }, e.prototype.isTransparent = function () {
          return 0 === this.rgba.a
        }, e.prototype.isOpaque = function () {
          return 1 === this.rgba.a
        }, e.prototype.opposite = function () {
          return new e( new o( 255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a ) )
        }, e.prototype.toString = function () {
          return e.Format.CSS.format( this )
        }, e.getLighterColor = ( e, t, n ) => {
          if ( e.isLighterThan( t ) ) return e;
          n = n || .5;
          const i = e.getRelativeLuminance(),
            o = t.getRelativeLuminance();
          return n = n * ( o - i ) / o, e.lighten( n )
        }, e.getDarkerColor = ( e, t, n ) => {
          if ( e.isDarkerThan( t ) ) return e;
          n = n || .5;
          const i = e.getRelativeLuminance();
          return n = n * ( i - t.getRelativeLuminance() ) / i, e.darken( n )
        }, e.white = new e( new o( 255, 255, 255, 1 ) ), e.black = new e( new o( 0, 0, 0, 1 ) ), e.red = new e( new o( 255, 0, 0, 1 ) ), e.blue = new e( new o( 0, 0, 255, 1 ) ), e.cyan = new e( new o( 0, 255, 255, 1 ) ), e.lightgrey = new e( new o( 211, 211, 211, 1 ) ), e.transparent = new e( new o( 0, 0, 0, 0 ) ), e;
      } )();
      !( e => {
        !( t => {
          !( t => {
            function n( e ) {
              const t = e.toString( 16 );
              return 2 !== t.length ? "0" + t : t
            }

            function i( e ) {
              switch ( e ) {
                case 48:
                  return 0;
                case 49:
                  return 1;
                case 50:
                  return 2;
                case 51:
                  return 3;
                case 52:
                  return 4;
                case 53:
                  return 5;
                case 54:
                  return 6;
                case 55:
                  return 7;
                case 56:
                  return 8;
                case 57:
                  return 9;
                case 97:
                case 65:
                  return 10;
                case 98:
                case 66:
                  return 11;
                case 99:
                case 67:
                  return 12;
                case 100:
                case 68:
                  return 13;
                case 101:
                case 69:
                  return 14;
                case 102:
                case 70:
                  return 15
              }
              return 0
            }
            t.formatRGB = t => {
              return 1 === t.rgba.a ? "rgb(" + t.rgba.r + ", " + t.rgba.g + ", " + t.rgba.b + ")" : e.Format.CSS.formatRGBA( t )
            }, t.formatRGBA = e => {
              return "rgba(" + e.rgba.r + ", " + e.rgba.g + ", " + e.rgba.b + ", " + +e.rgba.a.toFixed( 2 ) + ")"
            }, t.formatHSL = t => {
              return 1 === t.hsla.a ? "hsl(" + t.hsla.h + ", " + ( 100 * t.hsla.s ).toFixed( 2 ) + "%, " + ( 100 * t.hsla.l ).toFixed( 2 ) + "%)" : e.Format.CSS.formatHSLA( t )
            }, t.formatHSLA = e => {
              return "hsla(" + e.hsla.h + ", " + ( 100 * e.hsla.s ).toFixed( 2 ) + "%, " + ( 100 * e.hsla.l ).toFixed( 2 ) + "%, " + e.hsla.a.toFixed( 2 ) + ")"
            }, t.formatHex = e => {
              return "#" + n( e.rgba.r ) + n( e.rgba.g ) + n( e.rgba.b )
            }, t.formatHexA = ( t, i ) => {
              return void 0 === i && ( i = !1 ), i && 1 === t.rgba.a ? e.Format.CSS.formatHex( t ) : "#" + n( t.rgba.r ) + n( t.rgba.g ) + n( t.rgba.b ) + n( Math.round( 255 * t.rgba.a ) )
            }, t.format = t => {
              return t ? t.isOpaque() ? e.Format.CSS.formatHex( t ) : e.Format.CSS.formatRGBA( t ) : null
            }, t.parseHex = t => {
              if ( !t ) return null;
              const n = t.length;
              if ( 0 === n ) return null;
              if ( 35 !== t.charCodeAt( 0 ) ) return null;
              if ( 7 === n ) {
                var r = 16 * i( t.charCodeAt( 1 ) ) + i( t.charCodeAt( 2 ) ),
                  s = 16 * i( t.charCodeAt( 3 ) ) + i( t.charCodeAt( 4 ) ),
                  a = 16 * i( t.charCodeAt( 5 ) ) + i( t.charCodeAt( 6 ) );
                return new e( new o( r, s, a, 1 ) )
              }
              if ( 9 === n ) {
                r = 16 * i( t.charCodeAt( 1 ) ) + i( t.charCodeAt( 2 ) ), s = 16 * i( t.charCodeAt( 3 ) ) + i( t.charCodeAt( 4 ) ), a = 16 * i( t.charCodeAt( 5 ) ) + i( t.charCodeAt( 6 ) );
                var u = 16 * i( t.charCodeAt( 7 ) ) + i( t.charCodeAt( 8 ) );
                return new e( new o( r, s, a, u / 255 ) )
              }
              if ( 4 === n ) {
                r = i( t.charCodeAt( 1 ) ), s = i( t.charCodeAt( 2 ) ), a = i( t.charCodeAt( 3 ) );
                return new e( new o( 16 * r + r, 16 * s + s, 16 * a + a ) )
              }
              if ( 5 === n ) {
                r = i( t.charCodeAt( 1 ) ), s = i( t.charCodeAt( 2 ) ), a = i( t.charCodeAt( 3 ) ), u = i( t.charCodeAt( 4 ) );
                return new e( new o( 16 * r + r, 16 * s + s, 16 * a + a, ( 16 * u + u ) / 255 ) )
              }
              return null
            }
          } )( t.CSS || ( t.CSS = {} ) )
        } )( e.Format || ( e.Format = {} ) )
      } )( a || ( a = {} ) )
    }
  }
] );
//# sourceMappingURL=f54b42984bfe4d114461fcea2710af414ac1fe74.3c54d85565f4502c3c58.js.map
