<!DOCTYPE html>
<html>
    <head>
        <meta name="generator" content="HTML Tidy for Windows (vers 14 October 2008), see www.w3.org" />
        <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
        <title>DATA-Structures</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="./DATA-Structures_files/katex.min.css" type="text/css" />
        <style type="text/css">
    /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
    code[class*="language-"],
    pre[class*="language-"] {
      color: #333;
      background: none;
      font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
      text-align: left;
      white-space: pre;
      word-spacing: normal;
      word-break: normal;
      word-wrap: normal;
      line-height: 1.4;

      -moz-tab-size: 8;
      -o-tab-size: 8;
      tab-size: 8;

      -webkit-hyphens: none;
      -moz-hyphens: none;
      -ms-hyphens: none;
      hyphens: none;
    }

    /* Code blocks */
    pre[class*="language-"] {
      padding: .8em;
      overflow: auto;
      /* border: 1px solid #ddd; */
      border-radius: 3px;
      /* background: #fff; */
      background: #f5f5f5;
    }

    /* Inline code */
    :not(pre)&gt;code[class*="language-"] {
      padding: .1em;
      border-radius: .3em;
      white-space: normal;
      background: #f5f5f5;
    }

    .token.comment,
    .token.blockquote {
      color: #969896;
    }

    .token.cdata {
      color: #183691;
    }

    .token.doctype,
    .token.punctuation,
    .token.variable,
    .token.macro.property {
      color: #333;
    }

    .token.operator,
    .token.important,
    .token.keyword,
    .token.rule,
    .token.builtin {
      color: #a71d5d;
    }

    .token.string,
    .token.url,
    .token.regex,
    .token.attr-value {
      color: #183691;
    }

    .token.property,
    .token.number,
    .token.boolean,
    .token.entity,
    .token.atrule,
    .token.constant,
    .token.symbol,
    .token.command,
    .token.code {
      color: #0086b3;
    }

    .token.tag,
    .token.selector,
    .token.prolog {
      color: #63a35c;
    }

    .token.function,
    .token.namespace,
    .token.pseudo-element,
    .token.class,
    .token.class-name,
    .token.pseudo-class,
    .token.id,
    .token.url-reference .token.variable,
    .token.attr-name {
      color: #795da3;
    }

    .token.entity {
      cursor: help;
    }

    .token.title,
    .token.title .token.punctuation {
      font-weight: bold;
      color: #1d3e81;
    }

    .token.list {
      color: #ed6a43;
    }

    .token.inserted {
      background-color: #eaffea;
      color: #55a532;
    }

    .token.deleted {
      background-color: #ffecec;
      color: #bd2c00;
    }

    .token.bold {
      font-weight: bold;
    }

    .token.italic {
      font-style: italic;
    }


    /* JSON */
    .language-json .token.property {
      color: #183691;
    }

    .language-markup .token.tag .token.punctuation {
      color: #333;
    }

    /* CSS */
    code.language-css,
    .language-css .token.function {
      color: #0086b3;
    }

    /* YAML */
    .language-yaml .token.atrule {
      color: #63a35c;
    }

    code.language-yaml {
      color: #183691;
    }

    /* Ruby */
    .language-ruby .token.function {
      color: #333;
    }

    /* Markdown */
    .language-markdown .token.url {
      color: #795da3;
    }

    /* Makefile */
    .language-makefile .token.symbol {
      color: #795da3;
    }

    .language-makefile .token.variable {
      color: #183691;
    }

    .language-makefile .token.builtin {
      color: #0086b3;
    }

    /* Bash */
    .language-bash .token.keyword {
      color: #0086b3;
    }

    /* highlight */
    pre[data-line] {
      position: relative;
      padding: 1em 0 1em 3em;
    }

    pre[data-line] .line-highlight-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      background-color: transparent;
      display: block;
      width: 100%;
    }

    pre[data-line] .line-highlight {
      position: absolute;
      left: 0;
      right: 0;
      padding: inherit 0;
      margin-top: 1em;
      background: hsla(24, 20%, 50%, .08);
      background: linear-gradient(to right, hsla(24, 20%, 50%, .1) 70%, hsla(24, 20%, 50%, 0));
      pointer-events: none;
      line-height: inherit;
      white-space: pre;
    }

    pre[data-line] .line-highlight:before,
    pre[data-line] .line-highlight[data-end]:after {
      content: attr(data-start);
      position: absolute;
      top: .4em;
      left: .6em;
      min-width: 1em;
      padding: 0 .5em;
      background-color: hsla(24, 20%, 50%, .4);
      color: hsl(24, 20%, 95%);
      font: bold 65%/1.5 sans-serif;
      text-align: center;
      vertical-align: .3em;
      border-radius: 999px;
      text-shadow: none;
      box-shadow: 0 1px white;
    }

    pre[data-line] .line-highlight[data-end]:after {
      content: attr(data-end);
      top: auto;
      bottom: .4em;
    }

    html body {
      font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
      font-size: 16px;
      line-height: 1.6;
      color: #333;
      background-color: #fff;
      overflow: initial;
      box-sizing: border-box;
      word-wrap: break-word
    }

    html body&gt;:first-child {
      margin-top: 0
    }

    html body h1,
    html body h2,
    html body h3,
    html body h4,
    html body h5,
    html body h6 {
      line-height: 1.2;
      margin-top: 1em;
      margin-bottom: 16px;
      color: #000
    }

    html body h1 {
      font-size: 2.25em;
      font-weight: 300;
      padding-bottom: .3em
    }

    html body h2 {
      font-size: 1.75em;
      font-weight: 400;
      padding-bottom: .3em
    }

    html body h3 {
      font-size: 1.5em;
      font-weight: 500
    }

    html body h4 {
      font-size: 1.25em;
      font-weight: 600
    }

    html body h5 {
      font-size: 1.1em;
      font-weight: 600
    }

    html body h6 {
      font-size: 1em;
      font-weight: 600
    }

    html body h1,
    html body h2,
    html body h3,
    html body h4,
    html body h5 {
      font-weight: 600
    }

    html body h5 {
      font-size: 1em
    }

    html body h6 {
      color: #5c5c5c
    }

    html body strong {
      color: #000
    }

    html body del {
      color: #5c5c5c
    }

    html body a:not([href]) {
      color: inherit;
      text-decoration: none
    }

    html body a {
      color: #08c;
      text-decoration: none
    }

    html body a:hover {
      color: #00a3f5;
      text-decoration: none
    }

    html body img {
      max-width: 100%
    }

    html body&gt;p {
      margin-top: 0;
      margin-bottom: 16px;
      word-wrap: break-word
    }

    html body&gt;ul,
    html body&gt;ol {
      margin-bottom: 16px
    }

    html body ul,
    html body ol {
      padding-left: 2em
    }

    html body ul.no-list,
    html body ol.no-list {
      padding: 0;
      list-style-type: none
    }

    html body ul ul,
    html body ul ol,
    html body ol ol,
    html body ol ul {
      margin-top: 0;
      margin-bottom: 0
    }

    html body li {
      margin-bottom: 0
    }

    html body li.task-list-item {
      list-style: none
    }

    html body li&gt;p {
      margin-top: 0;
      margin-bottom: 0
    }

    html body .task-list-item-checkbox {
      margin: 0 .2em .25em -1.8em;
      vertical-align: middle
    }

    html body .task-list-item-checkbox:hover {
      cursor: pointer
    }

    html body blockquote {
      margin: 16px 0;
      font-size: inherit;
      padding: 0 15px;
      color: #5c5c5c;
      background-color: #f0f0f0;
      border-left: 4px solid #d6d6d6
    }

    html body blockquote&gt;:first-child {
      margin-top: 0
    }

    html body blockquote&gt;:last-child {
      margin-bottom: 0
    }

    html body hr {
      height: 4px;
      margin: 32px 0;
      background-color: #d6d6d6;
      border: 0 none
    }

    html body table {
      margin: 10px 0 15px 0;
      border-collapse: collapse;
      border-spacing: 0;
      display: block;
      width: 100%;
      overflow: auto;
      word-break: normal;
      word-break: keep-all
    }

    html body table th {
      font-weight: bold;
      color: #000
    }

    html body table td,
    html body table th {
      border: 1px solid #d6d6d6;
      padding: 6px 13px
    }

    html body dl {
      padding: 0
    }

    html body dl dt {
      padding: 0;
      margin-top: 16px;
      font-size: 1em;
      font-style: italic;
      font-weight: bold
    }

    html body dl dd {
      padding: 0 16px;
      margin-bottom: 16px
    }

    html body code {
      font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;
      font-size: .85em !important;
      color: #000;
      background-color: #f0f0f0;
      border-radius: 3px;
      padding: .2em 0
    }

    html body code::before,
    html body code::after {
      letter-spacing: -0.2em;
      content: "\00a0"
    }

    html body pre&gt;code {
      padding: 0;
      margin: 0;
      font-size: .85em !important;
      word-break: normal;
      white-space: pre;
      background: transparent;
      border: 0
    }

    html body .highlight {
      margin-bottom: 16px
    }

    html body .highlight pre,
    html body pre {
      padding: 1em;
      overflow: auto;
      font-size: .85em !important;
      line-height: 1.45;
      border: #d6d6d6;
      border-radius: 3px
    }

    html body .highlight pre {
      margin-bottom: 0;
      word-break: normal
    }

    html body pre code,
    html body pre tt {
      display: inline;
      max-width: initial;
      padding: 0;
      margin: 0;
      overflow: initial;
      line-height: inherit;
      word-wrap: normal;
      background-color: transparent;
      border: 0
    }

    html body pre code:before,
    html body pre tt:before,
    html body pre code:after,
    html body pre tt:after {
      content: normal
    }

    html body p,
    html body blockquote,
    html body ul,
    html body ol,
    html body dl,
    html body pre {
      margin-top: 0;
      margin-bottom: 16px
    }

    html body kbd {
      color: #000;
      border: 1px solid #d6d6d6;
      border-bottom: 2px solid #c7c7c7;
      padding: 2px 4px;
      background-color: #f0f0f0;
      border-radius: 3px
    }

    @media print {
      html body {
        background-color: #fff
      }

      html body h1,
      html body h2,
      html body h3,
      html body h4,
      html body h5,
      html body h6 {
        color: #000;
        page-break-after: avoid
      }

      html body blockquote {
        color: #5c5c5c
      }

      html body pre {
        page-break-inside: avoid
      }

      html body table {
        display: table
      }

      html body img {
        display: block;
        max-width: 100%;
        max-height: 100%
      }

      html body pre,
      html body code {
        word-wrap: break-word;
        white-space: pre
      }
    }

    .markdown-preview {
      width: 100%;
      height: 100%;
      box-sizing: border-box
    }

    .markdown-preview .pagebreak,
    .markdown-preview .newpage {
      page-break-before: always
    }

    .markdown-preview pre.line-numbers {
      position: relative;
      padding-left: 3.8em;
      counter-reset: linenumber
    }

    .markdown-preview pre.line-numbers&gt;code {
      position: relative
    }

    .markdown-preview pre.line-numbers .line-numbers-rows {
      position: absolute;
      pointer-events: none;
      top: 1em;
      font-size: 100%;
      left: 0;
      width: 3em;
      letter-spacing: -1px;
      border-right: 1px solid #999;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none
    }

    .markdown-preview pre.line-numbers .line-numbers-rows&gt;span {
      pointer-events: none;
      display: block;
      counter-increment: linenumber
    }

    .markdown-preview pre.line-numbers .line-numbers-rows&gt;span:before {
      content: counter(linenumber);
      color: #999;
      display: block;
      padding-right: .8em;
      text-align: right
    }

    .markdown-preview .mathjax-exps .MathJax_Display {
      text-align: center !important
    }

    .markdown-preview:not([for="preview"]) .code-chunk .btn-group {
      display: none
    }

    .markdown-preview:not([for="preview"]) .code-chunk .status {
      display: none
    }

    .markdown-preview:not([for="preview"]) .code-chunk .output-div {
      margin-bottom: 16px
    }

    .scrollbar-style::-webkit-scrollbar {
      width: 8px
    }

    .scrollbar-style::-webkit-scrollbar-track {
      border-radius: 10px;
      background-color: transparent
    }

    .scrollbar-style::-webkit-scrollbar-thumb {
      border-radius: 5px;
      background-color: rgba(150, 150, 150, 0.66);
      border: 4px solid rgba(150, 150, 150, 0.66);
      background-clip: content-box
    }

    html body[for="html-export"]:not([data-presentation-mode]) {
      position: relative;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      margin: 0;
      padding: 0;
      overflow: auto
    }

    html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview {
      position: relative;
      top: 0
    }

    @media screen and (min-width:914px) {
      html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview {
        padding: 2em calc(50% - 457px + 2em)
      }
    }

    @media screen and (max-width:914px) {
      html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview {
        padding: 2em
      }
    }

    @media screen and (max-width:450px) {
      html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview {
        font-size: 14px !important;
        padding: 1em
      }
    }

    @media print {
      html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn {
        display: none
      }
    }

    html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn {
      position: fixed;
      bottom: 8px;
      left: 8px;
      font-size: 28px;
      cursor: pointer;
      color: inherit;
      z-index: 99;
      width: 32px;
      text-align: center;
      opacity: .4
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn {
      opacity: 1
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc {
      position: fixed;
      top: 0;
      left: 0;
      width: 300px;
      height: 100%;
      padding: 32px 0 48px 0;
      font-size: 14px;
      box-shadow: 0 0 4px rgba(150, 150, 150, 0.33);
      box-sizing: border-box;
      overflow: auto;
      background-color: inherit
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar {
      width: 8px
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track {
      border-radius: 10px;
      background-color: transparent
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb {
      border-radius: 5px;
      background-color: rgba(150, 150, 150, 0.66);
      border: 4px solid rgba(150, 150, 150, 0.66);
      background-clip: content-box
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a {
      text-decoration: none
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul {
      padding: 0 1.6em;
      margin-top: .8em
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li {
      margin-bottom: .8em
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul {
      list-style-type: none
    }

    html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview {
      left: 300px;
      width: calc(100% - 300px);
      padding: 2em calc(50% - 457px - 150px);
      margin: 0;
      box-sizing: border-box
    }

    @media screen and (max-width:1274px) {
      html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview {
        padding: 2em
      }
    }

    @media screen and (max-width:450px) {
      html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview {
        width: 100%
      }
    }

    html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview {
      left: 50%;
      transform: translateX(-50%)
    }

    html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc {
      display: none
    }

    /* Please visit the URL below for more information: */
    /*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */
  
</style>
    </head>
    <body for="html-export">
    <div class="mume markdown-preview">
        <hr />
        <h1 class="mume-header" id="efficient-sorting-algorithms">Efficient Sorting Algorithms</h1>
        <hr />
        <ul>
            <li>it is easy to merge elements of two sorted arrays into a single sorted array</li>
            <li>we can consider an array containing only a single element as already trivially sorted
            <ul>
                <li>we can also consider an empty array as trivially sorted</li>
            </ul></li>
        </ul>
        <h2 class="mume-header" id="the-algorithm-divide-and-conquer">The Algorithm: "Divide and Conquer"</h2>
        <p>We're going to need a helper function that solves the first major point from above. How might we merge two sorted arrays? In other words we want a 
        <code>merge</code> function that will behave like so:</p>
        <pre class="language-text">
let arr1 = [1, 5, 10, 15];
let arr2 = [0, 2, 3, 7, 10];
merge(arr1, arr2); // =&gt; [0, 1, 2, 3, 5, 7, 10, 10, 15]
</pre>
        <h3 class="mume-header" id="merge">Merge</h3>
        <p>Merging two sorted arrays is simple. Since both arrays are sorted, we know the smallest numbers to always be at the front of the arrays. We can construct the new array by comparing the first elements of both input arrays. We remove the smaller element from it's respective array and add it to our new array. Do this until both input arrays are empty:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">merge</span>
<span class="token punctuation">(</span>
<span class="token parameter">array1
<span class="token punctuation">,</span> array2</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword">let</span> merged 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">while</span> 
<span class="token punctuation">(</span>array1
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">||</span> array2
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">let</span> ele1 
<span class="token operator">=</span> array1
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">?</span> array1
<span class="token punctuation">[</span>
<span class="token number">0</span>
<span class="token punctuation">]</span> 
<span class="token operator">:</span> 
<span class="token number">Infinity</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> ele2 
<span class="token operator">=</span> array2
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">?</span> array2
<span class="token punctuation">[</span>
<span class="token number">0</span>
<span class="token punctuation">]</span> 
<span class="token operator">:</span> 
<span class="token number">Infinity</span>
<span class="token punctuation">;</span>

        
<span class="token keyword">let</span> next
<span class="token punctuation">;</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>ele1 
<span class="token operator">&lt;</span> ele2
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            next 
<span class="token operator">=</span> array1
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
            next 
<span class="token operator">=</span> array2
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>

        merged
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>next
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword control-flow">return</span> merged
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <p>If your JavaScript is rusty, don't freak out! Here are a few cool JS patterns that we leverage above.</p>
        <ul>
            <li>
            <code>0</code> is considered a falsey value, meaning it acts like 
            <code>false</code> when used in boolean expressions. All other numbers are truthy.</li>
            <li>
            <code>Infinity</code> is a value that is guaranteed to be greater than any other quantity</li>
            <li>
            <code>shift</code> is an array method that removes and returns the first element</li>
        </ul>
        <p>Is the code still hazy? Let's look at an annotated version:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token comment">// commented```js</span>
<span class="token keyword">function</span> 
<span class="token function">merge</span>
<span class="token punctuation">(</span>
<span class="token parameter">array1
<span class="token punctuation">,</span> array2</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword">let</span> merged 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>

    
<span class="token comment">// keep running while either array still contains elements</span>
    
<span class="token keyword control-flow">while</span> 
<span class="token punctuation">(</span>array1
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">||</span> array2
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token comment">// if array1 is nonempty, take its the first element as ele1</span>
        
<span class="token comment">// otherwise array1 is empty, so take Infinity as ele1</span>
        
<span class="token keyword">let</span> ele1 
<span class="token operator">=</span> array1
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">?</span> array1
<span class="token punctuation">[</span>
<span class="token number">0</span>
<span class="token punctuation">]</span> 
<span class="token operator">:</span> 
<span class="token number">Infinity</span>
<span class="token punctuation">;</span>

        
<span class="token comment">// do the same for array2, ele2</span>
        
<span class="token keyword">let</span> ele2 
<span class="token operator">=</span> array2
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">?</span> array2
<span class="token punctuation">[</span>
<span class="token number">0</span>
<span class="token punctuation">]</span> 
<span class="token operator">:</span> 
<span class="token number">Infinity</span>
<span class="token punctuation">;</span>

        
<span class="token keyword">let</span> next
<span class="token punctuation">;</span>
        
<span class="token comment">// remove the smaller of the eles from it's array</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>ele1 
<span class="token operator">&lt;</span> ele2
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            next 
<span class="token operator">=</span> array1
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
            next 
<span class="token operator">=</span> array2
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>

        
<span class="token comment">// and add that ele to the new array</span>
        merged
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>next
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword control-flow">return</span> merged
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <p>By using 
        <code>Infinity</code> as the default ele when an array is empty, we are able to elegantly handle the scenario where one array empties before the other. We know that any actual element will be less than 
        <code>Infinity</code> so we will continually take the other element into our merged array.</p>
        <p>In other words, we can safely handle this edge case:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token function">merge</span>
<span class="token punctuation">(</span>
<span class="token punctuation">[</span>
<span class="token number">10</span>
<span class="token punctuation">,</span> 
<span class="token number">13</span>
<span class="token punctuation">,</span> 
<span class="token number">15</span>
<span class="token punctuation">,</span> 
<span class="token number">25</span>
<span class="token punctuation">]</span>
<span class="token punctuation">,</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; [10, 13, 15, 25]</span>
</pre>
        <p>Nice! We now have a way to merge two sorted arrays into a single sorted array. It's worth mentioning that 
        <code>merge</code> will have a 
        <code>O(n)</code> runtime where 
        <code>n</code> is the combined length of the two input arrays. This is what we meant when we said it was "easy" to merge two sorted arrays; linear time is fast! We'll find fact this useful later.</p>
        <h3 class="mume-header" id="merge-sort-recursion">Merge Sort Recursion</h3>
        <p>Now that we satisfied the merge idea, let's handle the second point. That is, we say an array of 1 or 0 elements is already sorted. This will be the base case of our recursion. Let's begin adding this code:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">function</span> 
<span class="token function">mergeSort</span>
<span class="token punctuation">(</span>
<span class="token parameter">array</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">&lt;=</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> array
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
       
<span class="token comment">//...some code here.</span>
    
<span class="token punctuation">}</span>

<span class="token maybe-class-name">If</span> our base 
<span class="token keyword">case</span> pretains to an array 
<span class="token keyword">of</span> a very small size
<span class="token punctuation">,</span> then the design 
<span class="token keyword">of</span> our recursive 
<span class="token keyword">case</span> should make progress toward hitting 
<span class="token keyword">this</span> base scenario
<span class="token punctuation">.</span> 
<span class="token property-access token maybe-class-name">In</span> other words
<span class="token punctuation">,</span> we should recursively call 
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">mergeSort</span>
    <span class="token template-punctuation string">`</span>
</span> on smaller and smaller arrays
<span class="token punctuation">.</span> 
<span class="token constant">A</span> logical way to 
<span class="token keyword control-flow">do</span> 
<span class="token keyword">this</span> is to take the input array and split it into left and right halves
<span class="token punctuation">.</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">js
        function mergeSort(array) {
            if (array.length &lt;= 1) {
                return array;
            }

            let midIdx = Math.floor(array.length / 2);
            let leftHalf = array.slice(0, midIdx);
            let rightHalf = array.slice(midIdx);

            let sortedLeft = mergeSort(leftHalf);
            let sortedRight = mergeSort(rightHalf);
           //...some code here
        }

    Here is the part of the recursion where we do a lot of hand waving and we take things on faith. We know that </span>
    <span class="token template-punctuation string">`</span>
</span>mergeSort
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string"> will take in an array and return the sorted version; we assume that it works. That means the two recursive calls will return the </span>
    <span class="token template-punctuation string">`</span>
</span>sortedLeft
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string"> and </span>
    <span class="token template-punctuation string">`</span>
</span>sortedRight
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string"> halves.

    Okay, so we have two sorted arrays. We want to return one sorted array. So </span>
    <span class="token template-punctuation string">`</span>
</span>merge
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string"> them! Using the </span>
    <span class="token template-punctuation string">`</span>
</span>merge
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string"> function we designed earlier:
    </span>
    <span class="token template-punctuation string">`</span>
</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>js
    
<span class="token keyword">function</span> 
<span class="token function">mergeSort</span>
<span class="token punctuation">(</span>
<span class="token parameter">array</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">&lt;=</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> array
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>

        
<span class="token keyword">let</span> midIdx 
<span class="token operator">=</span> 
<span class="token known-class-name class-name">Math</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">floor</span>
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">/</span> 
<span class="token number">2</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> leftHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>
<span class="token number">0</span>
<span class="token punctuation">,</span> midIdx
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> rightHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>midIdx
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

        
<span class="token keyword">let</span> sortedLeft 
<span class="token operator">=</span> 
<span class="token function">mergeSort</span>
<span class="token punctuation">(</span>leftHalf
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> sortedRight 
<span class="token operator">=</span> 
<span class="token function">mergeSort</span>
<span class="token punctuation">(</span>rightHalf
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

        
<span class="token keyword control-flow">return</span> 
<span class="token function">merge</span>
<span class="token punctuation">(</span>sortedLeft
<span class="token punctuation">,</span> sortedRight
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">Wow. that's it. Notice how light the implementation of </span>
    <span class="token template-punctuation string">`</span>
</span>mergeSort
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string"> is. Much of the heavy lifting (the actually comparisons) is done by the </span>
    <span class="token template-punctuation string">`</span>
</span>merge
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string"> helper.

    </span>
    <span class="token template-punctuation string">`</span>
</span>mergeSort
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string"> is a classic example of a "Divide and Conquer" algorithm. In other words, we keep breaking the array into smaller and smaller sub arrays. This is the same as saying we take the problem and break it down into smaller and smaller subproblems. We do this until the subproblems are so small that we trivially know the answer to them (an array length 0 or 1 is already sorted). Once we have those subanswers we can combine to reconstruct the larger problems that we previously divided (merge the left and right subarrays).

    The process is visualized below. When elements are moved to the bottom of the picture, they are going through the </span>
    <span class="token template-punctuation string">`</span>
</span>merge
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string"> step:

    ![source: https://visualgo.net](https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/efficient_sorting_algorithms/merge_sort/images/MergeSort.gif)

    ### Merge Sort JS Implementation

    Here is the full code for your reference:
    </span>
    <span class="token template-punctuation string">`</span>
</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>js
    
<span class="token keyword">function</span> 
<span class="token function">merge</span>
<span class="token punctuation">(</span>
<span class="token parameter">array1
<span class="token punctuation">,</span> array2</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">let</span> merged 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>

        
<span class="token keyword control-flow">while</span> 
<span class="token punctuation">(</span>array1
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">||</span> array2
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">let</span> ele1 
<span class="token operator">=</span> array1
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">?</span> array1
<span class="token punctuation">[</span>
<span class="token number">0</span>
<span class="token punctuation">]</span> 
<span class="token operator">:</span> 
<span class="token number">Infinity</span>
<span class="token punctuation">;</span>
            
<span class="token keyword">let</span> ele2 
<span class="token operator">=</span> array2
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">?</span> array2
<span class="token punctuation">[</span>
<span class="token number">0</span>
<span class="token punctuation">]</span> 
<span class="token operator">:</span> 
<span class="token number">Infinity</span>
<span class="token punctuation">;</span>

            
<span class="token keyword">let</span> next
<span class="token punctuation">;</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>ele1 
<span class="token operator">&lt;</span> ele2
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
                next 
<span class="token operator">=</span> array1
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
                next 
<span class="token operator">=</span> array2
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token punctuation">}</span>

            merged
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>next
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>

        
<span class="token keyword control-flow">return</span> merged
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>js
    
<span class="token keyword">function</span> 
<span class="token function">mergeSort</span>
<span class="token punctuation">(</span>
<span class="token parameter">array</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">&lt;=</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> array
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>

        
<span class="token keyword">let</span> midIdx 
<span class="token operator">=</span> 
<span class="token known-class-name class-name">Math</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">floor</span>
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">/</span> 
<span class="token number">2</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> leftHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>
<span class="token number">0</span>
<span class="token punctuation">,</span> midIdx
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> rightHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>midIdx
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

        
<span class="token keyword">let</span> sortedLeft 
<span class="token operator">=</span> 
<span class="token function">mergeSort</span>
<span class="token punctuation">(</span>leftHalf
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> sortedRight 
<span class="token operator">=</span> 
<span class="token function">mergeSort</span>
<span class="token punctuation">(</span>rightHalf
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

        
<span class="token keyword control-flow">return</span> 
<span class="token function">merge</span>
<span class="token punctuation">(</span>sortedLeft
<span class="token punctuation">,</span> sortedRight
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

</pre>
        <h2 class="mume-header" id="time-and-space-complexity-analysis">Time and Space Complexity Analysis</h2>
        <p>The complexity analysis of this algorithm is easier to explain through visuals, so we 
        <strong>highly encourage</strong> you to watch the lecture that accompanies this reading. In any case, here is a summary of the complexity:</p>
        <h3 class="mume-header" id="time-complexity-on-logn">Time Complexity: O(n log(n))</h3>
        <ul>
            <li>
            <code>n</code> is the length of the input array</li>
            <li>We must calculate how many recursive calls we make. The number of recursive calls is the number of times we must split the array to reach the base case. Since we split in half each time, the number of recursive calls is 
            <code>O(log(n))</code>.
            <ul>
                <li>for example, say we had an array of length 
                <code>32</code></li>
                <li>then the length would change as 
                <code>32 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</code>, we have to split 5 times before reaching the base case, 
                <code>log(32) = 5</code></li>
                <li>in our algorithm, 
                <strong>log(n)</strong> describes how many times we must halve 
                <strong>n</strong> until the quantity reaches 1.</li>
            </ul></li>
            <li>Besides the recursive calls, we must consider the while loop within the 
            <code>merge</code> function, which contributes 
            <code>O(n)</code> in isolation</li>
            <li>We call 
            <code>merge</code> in every recursive 
            <code>mergeSort</code> call, so the total complexity is 
            <strong>O(n * log(n))</strong></li>
        </ul>
        <h3 class="mume-header" id="space-complexity-on">Space Complexity: O(n)</h3>
        <p>Merge Sort is the first non-O(1) space sorting algorithm we've seen thus far.</p>
        <p>The larger the size of our input array, the greater the number of subarrays we must create in memory. These are not free! They each take up finite space, and we will need a new subarray for each element in the original input. Therefore, Merge Sort has a linear space complexity, O(n).</p>
        <h3 class="mume-header" id="when-should-we-use-merge-sort">When should we use Merge Sort?</h3>
        <p>Unless we, the engineers, have access in advance to some unique, exploitable insight about our dataset, it turns out that O(n log n) time is 
        <em>the best</em> we can do when sorting unknown datasets.</p>
        <p>That means that Merge Sort is fast! It's way faster than Bubble Sort, Selection Sort, and Insertion Sort. However, due to its linear space complexity, we must always weigh the tradeoff between speed and memory consumption when making the choice to use Merge Sort. Consider the following:</p>
        <ul>
            <li>If you have unlimited memory available, use it, it's fast!</li>
            <li>If you have a decent amount of memory available and a medium sized dataset, run some tests first, but use it!</li>
            <li>If you have very limited memory and you've got time to kill, maybe you should consider other options.</li>
            <li>If you have very limited memory and no time to kill...well, you're going to have to do some data analysis to look for some exploitable feature of the data set, but that takes human time.</li>
        </ul>
        <hr />
        <hr />
        <ul>
            <li>it is easy to sort elements of an array relative to a particular target value
            <ul>
                <li>for example given 
                <code>[7, 3, 8, 9, 2]</code> and a target of 
                <code>5</code>, we know 
                <code>[3, 2]</code> are numbers less than 
                <code>5</code> and 
                <code>[7, 8, 9]</code> are numbers greater than 
                <code>5</code>.</li>
            </ul></li>
            <li>we can consider an array of 0 or 1 elements as already trivially sorted</li>
        </ul>
        <h2 class="mume-header" id="how-does-it-work">How does it work?</h2>
        <p>In general, the strategy is to divide the input array into two subarrays; one with the smaller elements, and one with the larger elements. Then, it recursively operates on the two new subarrays, and continues this process until we reach subarrays of length 1 or smaller. As we have seen with Merge Sort, arrays of such length are automatically sorted (for obvious reasons).</p>
        <p>The steps, when discussed on a high level, are simple:</p>
        <ul>
            <li>Select one element called the "pivot". (This step varies by the implementation.)</li>
            <li>Find the index in the final output at which the pivot element should end up. To do this:
            <ul>
                <li>Move all elements smaller than the pivot to the pivot's left, and all elements greater than than the pivot to the pivot's right.</li>
            </ul></li>
            <li>Repeat the process, individually, for the left side, and then for the right side, by recursively calling Quick Sort on each subarray.</li>
        </ul>
        <p>Before we move forward, see if you can observe the behavior described above in the following animation:</p>
        <p>
            <img src="./DATA-Structures_files/QuickSort.gif" alt="Source: https://visualgo.net" />
        </p>
        <h2 class="mume-header" id="the-algorithm-divide-and-conquer-1">The Algorithm: "Divide and Conquer"</h2>
        <p>Let's hone in on the first major point above. Formally, we want to partition elements of an array relative to a pivot value. That is, we want elements less than the pivot to be separated from elements that are greater than or equal to the pivot. Our goal is to create a function with this behavior:</p>
        <pre class="language-text">
let arr = [7, 3, 8, 9, 2];
partition(arr, 5);  // =&gt; [[3, 2], [7,8,9]]
</pre>
        <h3 class="mume-header" id="partition">Partition</h3>
        <p>Seems simple enough! Let's implement it in JavaScript: // nothing fancy</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">partition</span>
<span class="token punctuation">(</span>
<span class="token parameter">array
<span class="token punctuation">,</span> pivot</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword">let</span> left 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> right 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>

    array
<span class="token punctuation">.</span>
<span class="token method function property-access">forEach</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>el 
<span class="token operator">&lt;</span> pivot
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            left
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>el
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
            right
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>el
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">return</span> 
<span class="token punctuation">[</span>left
<span class="token punctuation">,</span> right
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">partition</span>
<span class="token punctuation">(</span>
<span class="token parameter">array
<span class="token punctuation">,</span> pivot</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword">let</span> left 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&lt;</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> right 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&gt;=</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword control-flow">return</span> 
<span class="token punctuation">[</span>left
<span class="token punctuation">,</span> right
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <p>Both of the above implementations are correct, but we'll use the second one as it is cleaner. It's worth mentioning that the 
        <code>partition</code> function will have a runtime of 
        <code>O(n)</code> . 
        <code>forEach</code> and 
        <code>filter</code> both have linear, 
        <code>O(n)</code> , time complexity. Although our fancy 
        <code>partition</code> does filter twice, this is a constant we drop, 
        <code>O(2n) = O(n)</code> . Linear time is fast so we are quite happy with 
        <code>partition</code> .</p>
        <p>We won't be using an explicit 
        <code>partition</code> helper function in our 
        <code>quickSort</code> implementation, however we will borrow heavily from this pattern. As you design algorithms, it helps to think about key patterns in isolation, although your solution may not feature that exact helper. Some would say we like to divide and conquer ??.</p>
        <h3 class="mume-header" id="quick-sort-recursion">Quick Sort Recursion</h3>
        <p>Let's begin structuring the recursion. The base case of any recursive problem is where the input is so trivial, we immediately know the answer without calculation. If our problem is to sort an array, what is the trivial array? An array of 1 or 0 elements! Let's establish the code:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>
<span class="token parameter">array</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">&lt;=</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> array
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
        <p>If our base case pretains to an array of a very small size, then the design of our recursive case should make progress toward hitting this base scenario. In other words, we should recursively call 
        <code>quickSort</code> on smaller and smaller arrays. This is very similar to our previous 
        <code>mergeSort</code> , except we don't just split the array down the middle. Instead we should arbitrarily choose an element of the array as a pivot and partition the remaining elements relative to this pivot:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">function</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>
<span class="token parameter">array</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">&lt;=</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> array
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>

</pre>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">let</span> pivot 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> left 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&lt;</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> right 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&gt;=</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token comment">//...some code here</span>
</pre>
        <p>Here is what to notice about the partition step above: 1. the pivot is an element of the array; we arbitrarily chose the first element 2. we removed the pivot from the master array before we filter into the left and right partitions</p>
        <p>Now that we have the two subarrays of 
        <code>left</code> and 
        <code>right</code> we have our subproblems! To solve these subproblems we must sort the subarrays. I wish we had a function that sorts an array...oh wait we do, 
        <code>quickSort</code> ! Recursively:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">function</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>
<span class="token parameter">array</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">&lt;=</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> array
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>

        
<span class="token keyword">let</span> pivot 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> left 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&lt;</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> right 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&gt;=</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

        
<span class="token keyword">let</span> leftSorted 
<span class="token operator">=</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>left
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">let</span> rightSorted 
<span class="token operator">=</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>right
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
       
<span class="token comment">//...some code here</span>
</pre>
        <p>Okay, so we have the two sorted partitions. This means we have the two subsolutions. But how do we put them together? Think about how we partitioned them in the first place. Everything in 
        <code>leftSorted</code> is 
        <strong>guaranteed</strong> to be less than everything in 
        <code>rightSorted</code> . On top of that, 
        <code>pivot</code> should be placed after the last element in 
        <code>leftSorted</code> , but before the first element in 
        <code>rightSorted</code> . So all we need to do is to combine the elements in the order "left, pivot, right"!</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>
<span class="token parameter">array</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">&lt;=</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> array
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword">let</span> pivot 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> left 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&lt;</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> right 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&gt;=</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword">let</span> leftSorted 
<span class="token operator">=</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>left
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> rightSorted 
<span class="token operator">=</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>right
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">return</span> leftSorted
<span class="token punctuation">.</span>
<span class="token method function property-access">concat</span>
<span class="token punctuation">(</span>
<span class="token punctuation">[</span>pivot
<span class="token punctuation">]</span>
<span class="token punctuation">)</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">concat</span>
<span class="token punctuation">(</span>rightSorted
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <p>That last 
        <code>concat</code> line is a bit clunky. Bonus JS Lesson: we can use the spread 
        <code>...</code> operator to elegantly concat arrays. In general:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">let</span> one 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token string">"a"</span>
<span class="token punctuation">,</span> 
<span class="token string">"b"</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> two 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token string">"d"</span>
<span class="token punctuation">,</span> 
<span class="token string">"e"</span>
<span class="token punctuation">,</span> 
<span class="token string">"f"</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> newArr 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token spread operator">...</span>one
<span class="token punctuation">,</span> 
<span class="token string">"c"</span>
<span class="token punctuation">,</span> 
<span class="token spread operator">...</span>two
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
newArr
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt;  [ 'a', 'b', 'c', 'd', 'e', 'f' ]</span>
</pre>
        <p>Utilizing that spread pattern gives us this final implementation:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>
<span class="token parameter">array</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">&lt;=</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> array
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword">let</span> pivot 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> left 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&lt;</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> right 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&gt;=</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword">let</span> leftSorted 
<span class="token operator">=</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>left
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> rightSorted 
<span class="token operator">=</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>right
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">return</span> 
<span class="token punctuation">[</span>
<span class="token spread operator">...</span>leftSorted
<span class="token punctuation">,</span> pivot
<span class="token punctuation">,</span> 
<span class="token spread operator">...</span>rightSorted
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <p>I'd hire that programmer.</p>
        <h3 class="mume-header" id="quicksort-sort-js-implementation">Quicksort Sort JS Implementation</h3>
        <p>That code was so clean we should show it again. Here's the complete code for your reference, for when you 
        <code>ctrl+F "quicksort"</code> the night before an interview:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>
<span class="token parameter">array</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">&lt;=</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> array
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword">let</span> pivot 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> left 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&lt;</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> right 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">filter</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">el</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> el 
<span class="token operator">&gt;=</span> pivot
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword">let</span> leftSorted 
<span class="token operator">=</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>left
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> rightSorted 
<span class="token operator">=</span> 
<span class="token function">quickSort</span>
<span class="token punctuation">(</span>right
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">return</span> 
<span class="token punctuation">[</span>
<span class="token spread operator">...</span>leftSorted
<span class="token punctuation">,</span> pivot
<span class="token punctuation">,</span> 
<span class="token spread operator">...</span>rightSorted
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <h2 class="mume-header" id="time-and-space-complexity-analysis-1">Time and Space Complexity Analysis</h2>
        <p>The complexity analysis of this algorithm is easier to explain through visuals, so we 
        <strong>highly encourage</strong> you to watch the lecture that accompanies this reading. In any case, here is a summary of the complexity.</p>
        <h3 class="mume-header" id="time-complexity">Time Complexity</h3>
        <ul>
            <li>Avg Case: O(n log(n))</li>
            <li>Worst Case: O(n2)</li>
        </ul>
        <p>The runtime analysis of 
        <code>quickSort</code> is more complex than 
        <code>mergeSort</code></p>
        <ul>
            <li>
            <code>n</code> is the length of the input array</li>
            <li>The partition step alone is 
            <code>O(n)</code></li>
            <li>We must calculate how many recursive calls we make. The number of recursive calls is the number of times we must split the array to reach the base case. This is dependent on how we choose the pivot. Let's analyze the best and worst case:
            <ul>
                <li>
                <strong>Best Case:</strong> We are lucky and always choose the median as the pivot. This means the left and right partitions will have equal length. This will halve the array length at every step of the recursion. We benefit from this halving with 
                <code>O(log(n))</code> recursive calls to reach the base case.</li>
                <li>
                <strong>Worst Case:</strong> We are unlucky and always choose the min or max as the pivot. This means one partition will contain everything, and the other partition is empty. This will decrease the array length by 1 at every step of the recursion. We suffer from 
                <code>O(n)</code> recursive calls to reach the base case.</li>
            </ul></li>
            <li>The partition step occurs in every recursive call, so our total complexities are:
            <ul>
                <li>
                <strong>Best Case:</strong> O(n * log(n))</li>
                <li>
                <strong>Worst Case:</strong> O(n2)</li>
            </ul></li>
        </ul>
        <p>Although we typically take the worst case when describing Big-O for an algorithm, much research on 
        <code>quickSort</code> has shown the worst case to be an exceedingly rare occurance even if we choose the pivot at random. Because of this we still consider 
        <code>quickSort</code> an efficient algorithm. This is a common interview talking point, so you should be familiar with the relationship between the choice of pivot and efficiency of the algorithm.</p>
        <p>Just in case: A somewhat common question a student may ask when studying 
        <code>quickSort</code> is, "If the median is the best pivot, why don't we always just choose the median when we partition?" Don't overthink this. To know the median of an array, it must be sorted in the first place.</p>
        <h3 class="mume-header" id="space-complexity">Space Complexity</h3>
        <p>Our implementation of 
        <code>quickSort</code> uses 
        <code>O(n)</code> space because of the partition arrays we create. There is an in-place version of 
        <code>quickSort</code> that uses 
        <code>O(log(n))</code> space. 
        <code>O(log(n))</code> space is not huge benefit over 
        <code>O(n)</code> . You'll also find our version of 
        <code>quickSort</code> as easier to remember, easier to implement. Just know that a 
        <code>O(logn)</code> space 
        <code>quickSort</code> exists.</p>
        <h3 class="mume-header" id="when-should-we-use-quick-sort">When should we use Quick Sort?</h3>
        <ul>
            <li>When you are in a pinch and need to throw down an efficent sort (on average). The recursive code is light and simple to implement; much smaller than 
            <code>mergeSort</code>.</li>
            <li>When constant space is important to you, use the in-place version. This will of course trade off some simplicity of implementation.</li>
        </ul>
        <hr />
        <h3 class="mume-header" id="end-of-efficient-sorting-algorithms">End of Efficient Sorting Algorithms</h3>
        <hr />
        <hr />
        <h1 class="mume-header" id="binary-search">Binary Search</h1>
        <hr />
        <p>We've explored many ways to sort arrays so far, but why did we go through all of that trouble? By sorting elements of an array, we are organizing the data in a way that gives us a quick way to look up elements later on. For simplicity, we have been using arrays of numbers up until this point. However, these sorting concepts can be generalized to other data types. For example, it would be easy to modify our comparison-based sorting algorithms to sort strings: instead of leveraging facts like 
        <code>0 &lt; 1</code> , we can say 
        <code>'A' &lt; 'B'</code> .</p>
        <p>Think of a dictionary. A dictionary contains alphabetically sorted words and their definitions. A dictionary is pretty much only useful if it is ordered in this way. Let's say you wanted to look up the definition of "stupendous." What steps might you take?</p>
        <ul>
            <li>you open up the dictionary at the roughly middle page
            <ul>
                <li>you land in the "m" section</li>
            </ul></li>
            <li>you know "s" comes somewhere after "m" in the book, so you disregard all pages before the "m" section. Instead, you flip to the roughly middle page between "m" and "z"
            <ul>
                <li>you land in the "u" section</li>
            </ul></li>
            <li>you know "s" comes somewhere before "u", so you can disregard all pages after the "u" section. Instead, you flip to the roughly middle page between the previous "m" page and "u"</li>
            <li>...</li>
        </ul>
        <p>You are essentially using the 
        <code>binarySearch</code> algorithm in the real world.</p>
        <h2 class="mume-header" id="the-algorithm-check-the-middle-and-half-the-search-space">The Algorithm: "check the middle and half the search space"</h2>
        <p>Formally, our 
        <code>binarySearch</code> will seek to solve the following problem:</p>
        <pre class="language-text">
Given a sorted array of numbers and a target num, return a boolean indicating whether or not that target is contained in the array.
</pre>
        <p>Programmatically, we want to satisfy the following behavior:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>
<span class="token punctuation">[</span>
<span class="token number">5</span>
<span class="token punctuation">,</span> 
<span class="token number">10</span>
<span class="token punctuation">,</span> 
<span class="token number">12</span>
<span class="token punctuation">,</span> 
<span class="token number">15</span>
<span class="token punctuation">,</span> 
<span class="token number">20</span>
<span class="token punctuation">,</span> 
<span class="token number">30</span>
<span class="token punctuation">,</span> 
<span class="token number">70</span>
<span class="token punctuation">]</span>
<span class="token punctuation">,</span> 
<span class="token number">12</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; true</span>
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>
<span class="token punctuation">[</span>
<span class="token number">5</span>
<span class="token punctuation">,</span> 
<span class="token number">10</span>
<span class="token punctuation">,</span> 
<span class="token number">12</span>
<span class="token punctuation">,</span> 
<span class="token number">15</span>
<span class="token punctuation">,</span> 
<span class="token number">20</span>
<span class="token punctuation">,</span> 
<span class="token number">30</span>
<span class="token punctuation">,</span> 
<span class="token number">70</span>
<span class="token punctuation">]</span>
<span class="token punctuation">,</span> 
<span class="token number">24</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; false</span>
</pre>
        <p>Before we move on, really internalize the fact that 
        <code>binarySearch</code> will only work on 
        <strong>sorted</strong> arrays! Obviously we can search any array, sorted or unsorted, in 
        <code>O(n)</code> time. But now our goal is be able to search the array with a sub-linear time complexity (less than 
        <code>O(n)</code> ).</p>
        <h3 class="mume-header" id="binary-search-recursion">Binary Search Recursion</h3>
        <p>We'll implement binary search recursively. As always, we start with a base case that captures the scenario of the input array being so trivial, that we know the answer without further calculation. If we are given an empty array and a target, we can be certain that the target is not inside of the array:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>
<span class="token parameter">array
<span class="token punctuation">,</span> target</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">===</span> 
<span class="token number">0</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token boolean">false</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
    
<span class="token comment">//...some code here</span>
<span class="token punctuation">}</span>
</pre>
        <p>Now for our recursive case. If we want to get a time complexity less than 
        <code>O(n)</code> , we must avoid touching all 
        <code>n</code> elements. Adopting our dictionary strategy, let's find the middle element and grab references to the left and right halves of the sorted array:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>
<span class="token parameter">array
<span class="token punctuation">,</span> target</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">===</span> 
<span class="token number">0</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token boolean">false</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword">let</span> midIdx 
<span class="token operator">=</span> 
<span class="token known-class-name class-name">Math</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">floor</span>
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">/</span> 
<span class="token number">2</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> leftHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>
<span class="token number">0</span>
<span class="token punctuation">,</span> midIdx
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> rightHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>midIdx 
<span class="token operator">+</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token comment">//...some code here</span>
<span class="token punctuation">}</span>
</pre>
        <p>It's worth pointing out that the left and right halves do not contain the middle element we chose.</p>
        <p>Here is where we leverage the sorted property of the array. If the target is less than the middle, then the target must be in the left half of the array. If the target is greater than the middle, then the target must be in the right half of the array. So we can narrow our search to one of these halves, and ignore the other. Luckily we have a function that can search the half, its 
        <code>binarySearch</code> :</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>
<span class="token parameter">array
<span class="token punctuation">,</span> target</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">===</span> 
<span class="token number">0</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token boolean">false</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword">let</span> midIdx 
<span class="token operator">=</span> 
<span class="token known-class-name class-name">Math</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">floor</span>
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">/</span> 
<span class="token number">2</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> leftHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>
<span class="token number">0</span>
<span class="token punctuation">,</span> midIdx
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> rightHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>midIdx 
<span class="token operator">+</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>target 
<span class="token operator">&lt;</span> array
<span class="token punctuation">[</span>midIdx
<span class="token punctuation">]</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>leftHalf
<span class="token punctuation">,</span> target
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>target 
<span class="token operator">&gt;</span> array
<span class="token punctuation">[</span>midIdx
<span class="token punctuation">]</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>rightHalf
<span class="token punctuation">,</span> target
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
    
<span class="token comment">//...some code here</span>
<span class="token punctuation">}</span>
</pre>
        <p>We know 
        <code>binarySeach</code> will return the correct boolean, so we just pass that result up by returning it ourselves. However, something is lacking in our code. It is only possible to get a false from the literal 
        <code>return false</code> line, but there is no 
        <code>return true</code> . Looking at our conditionals, we handle the cases where the target is less than middle or the target is greater than the middle, but what if the product is 
        <strong>equal</strong> to the middle? If the target is equal to the middle, then we found the target and should 
        <code>return true</code> ! This is easy to add with an 
        <code>else</code> :</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>
<span class="token parameter">array
<span class="token punctuation">,</span> target</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">===</span> 
<span class="token number">0</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token boolean">false</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword">let</span> midIdx 
<span class="token operator">=</span> 
<span class="token known-class-name class-name">Math</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">floor</span>
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">/</span> 
<span class="token number">2</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> leftHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>
<span class="token number">0</span>
<span class="token punctuation">,</span> midIdx
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> rightHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>midIdx 
<span class="token operator">+</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>target 
<span class="token operator">&lt;</span> array
<span class="token punctuation">[</span>midIdx
<span class="token punctuation">]</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>leftHalf
<span class="token punctuation">,</span> target
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>target 
<span class="token operator">&gt;</span> array
<span class="token punctuation">[</span>midIdx
<span class="token punctuation">]</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>rightHalf
<span class="token punctuation">,</span> target
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token boolean">true</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
        <p>To wrap up, we have confidence of our base case will eventually be hit because we are continually halving the array. We halve the array until it's length is 0 or we actually find the target.</p>
        <h3 class="mume-header" id="binary-search-js-implementation">Binary Search JS Implementation</h3>
        <p>Here is the code again for your quick reference:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>
<span class="token parameter">array
<span class="token punctuation">,</span> target</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">===</span> 
<span class="token number">0</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token boolean">false</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword">let</span> midIdx 
<span class="token operator">=</span> 
<span class="token known-class-name class-name">Math</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">floor</span>
<span class="token punctuation">(</span>array
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">/</span> 
<span class="token number">2</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> leftHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>
<span class="token number">0</span>
<span class="token punctuation">,</span> midIdx
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> rightHalf 
<span class="token operator">=</span> array
<span class="token punctuation">.</span>
<span class="token method function property-access">slice</span>
<span class="token punctuation">(</span>midIdx 
<span class="token operator">+</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>target 
<span class="token operator">&lt;</span> array
<span class="token punctuation">[</span>midIdx
<span class="token punctuation">]</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>leftHalf
<span class="token punctuation">,</span> target
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>target 
<span class="token operator">&gt;</span> array
<span class="token punctuation">[</span>midIdx
<span class="token punctuation">]</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token function">binarySearch</span>
<span class="token punctuation">(</span>rightHalf
<span class="token punctuation">,</span> target
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token boolean">true</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
        <h2 class="mume-header" id="time-and-space-complexity-analysis-2">Time and Space Complexity Analysis</h2>
        <p>The complexity analysis of this algorithm is easier to explain through visuals, so we 
        <strong>highly encourage</strong> you to watch the lecture that accompanies this reading. In any case, here is a summary of the complexity:</p>
        <h3 class="mume-header" id="time-complexity-ologn">Time Complexity: O(log(n))</h3>
        <ul>
            <li>
            <code>n</code> is the length of the input array</li>
            <li>We have no loops, so we must only consider the number of recursive calls it takes to hit the base case</li>
            <li>The number of recursive calls is the number of times we must halve the array until it's length becomes 0. This number can be described by 
            <code>log(n)</code>
            <ul>
                <li>for example, say we had an array of 8 elements, 
                <code>n = 8</code></li>
                <li>the length would halve as 
                <code>8 -&gt; 4 -&gt; 2 -&gt; 1</code></li>
                <li>it takes 3 calls, 
                <code>log(8) = 3</code></li>
            </ul></li>
        </ul>
        <h3 class="mume-header" id="space-complexity-on-1">Space Complexity: O(n)</h3>
        <p>Our implementation uses 
        <code>n</code> space due to half arrays we create using slice. Note that JavaScript 
        <code>slice</code> creates a new array, so it requires additional memory to be allocated.</p>
        <h3 class="mume-header" id="when-should-we-use-binary-search">When should we use Binary Search?</h3>
        <p>Use this algorithm when the input data is sorted!!! This is a heavy requirement, but if you have it, you'll have an insanely fast algorithm.</p>
        <hr />
        <h3 class="mume-header" id="end-of-binary-search">End of Binary Search</h3>
        <hr />
        <hr />
        <h1 class="mume-header" id="memoization">Memoization</h1>
        <hr />
        <h2 class="mume-header" id="dynamic-programming">Dynamic Programming</h2>
        <p>
        <strong>Dynamic Programming</strong> is a design pattern used to solve a large problem by dividing it into smaller subproblems that are more manageable. Dynamic Programming will solve the subproblems efficiently, meaning that we avoid duplicate calculations and only "solve" each subproblem once by storing subsolutions in some additional data structure. We cannot always apply Dynamic Programming to a problem. Problems that can be solved with Dynamic Programming must have a sense of repetitive subproblems that overlap.</p>
        <p>Here's an example of a problem that has such a structure:</p>
        <pre class="language-text">
// Using pennies, nickels, dimes, and quarters,
// what is the smallest combination of coins that
// total 27 cents?
</pre>
        <p>We'll explore this exact problem in depth later on. For now, here is some food for thought. Along the way to calculating the smallest coin combination of 27 cents, we should also calculate the smallest coin combination of say, 25 cents as a component of that problem. This is the essence of an overlapping subproblem structure.</p>
        <p>There are two strategies we can use to implement Dynamic Programming: 
        <em>Memoization</em> and 
        <em>Tabulation</em>. Let's explore Memoization first!</p>
        <h3 class="mume-header" id="memoization-1">Memoization</h3>
        <p>Let's first implement Dynamic Programming through 
        <em>memoization</em>. In particular, we'll apply the memoization technique to recursive code. The underlying idea of memoization is this: every time we call a function with a particular argument, we expect to get the same result every time. Memoization allows us to store the result of a function in an object so it can be recalled later on. There are two features that comprise Memoization:</p>
        <ul>
            <li>the function is recursive</li>
            <li>the additional data structure used is typically an object (we refer to this as the memo!)</li>
        </ul>
        <h3 class="mume-header" id="memoizing-factorial-kind-of">Memoizing Factorial (kind of)</h3>
        <p>Let's begin by memoizing our previous 
        <code>factorial</code> recursive function. As it is, our 
        <code>factorial</code> is pretty fast with a 
        <code>O(n)</code> runtime. This is because we simply subtract 
        <code>1</code> from 
        <code>n</code> for every recursive call until 
        <code>n</code> reaches 
        <code>0</code> . This is feasibly the fastest we could ever do, but we'll memoize it nonetheless to explore the mechanics of memoization:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token parameter">n</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>n 
<span class="token operator">===</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> 
<span class="token number">1</span>
<span class="token punctuation">;</span>
    
<span class="token keyword control-flow">return</span> n 
<span class="token operator">*</span> 
<span class="token function">factorial</span>
<span class="token punctuation">(</span>n 
<span class="token operator">-</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token number">6</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; 720, requires 6 calls</span>
<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token number">6</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; 720, requires 6 calls</span>
<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token number">5</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; 120, requires 5 calls</span>
<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token number">7</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; 5040, requires 7 calls</span>
</pre>
        <p>From our plain 
        <code>factorial</code> above, it is clear that every time we call 
        <code>factorial(6)</code> we should get the same result of 
        <code>720</code> each time. The code is somewhat inefficient because we must go down the full recursive stack for each top level call to 
        <code>factorial(6)</code> . It would be great if we could store the result of 
        <code>factorial(6)</code> the first time we calculate it, then on subsequent calls to 
        <code>factorial(6)</code> we simply fetch the stored result in constant time. We can accomplish exactly this by memoizing with an object! We'll refactor the code later, but for now:</p>
        <pre class="language-text">
let memo = {}
</pre>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token parameter">n</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token comment">// if we have calculated factorial(n) previously, fetch the stored result in memo</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>n 
<span class="token keyword">in</span> memo
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> memo
<span class="token punctuation">[</span>n
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>n 
<span class="token operator">===</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> 
<span class="token number">1</span>
<span class="token punctuation">;</span>

    
<span class="token comment">// otherwise, we have not calculated factorial(n) previously, so calculate it now,</span>
    
<span class="token comment">// but store the result in case we need it again in the future</span>
    memo
<span class="token punctuation">[</span>n
<span class="token punctuation">]</span> 
<span class="token operator">=</span> n 
<span class="token operator">*</span> 
<span class="token function">factorial</span>
<span class="token punctuation">(</span>n 
<span class="token operator">-</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword control-flow">return</span> memo
<span class="token punctuation">[</span>n
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token number">6</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; 720, requires 6 calls</span>
<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token number">6</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; 720, requires 1 call</span>
<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token number">5</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; 120, requires 1 call</span>
<span class="token function">factorial</span>
<span class="token punctuation">(</span>
<span class="token number">7</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; 5040, requires 2 calls</span>

memo
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; { '2': 2, '3': 6, '4': 24, '5': 120, '6': 720, '7': 5040 }</span>
</pre>
        <p>The 
        <code>memo</code> object above will map an argument of 
        <code>factorial</code> to it's return value. That is, the keys will be arguments and their values will be the corresponding results returned. By using the memo, we are able to avoid duplicate recursive calls! Here's some food for thought: By the time our first call to 
        <code>factorial(6)</code> returns, we will not have just the arg 
        <code>6</code> stored in the memo. Rather, we will have 
        <em>all</em> args 2 to 6 stored in the memo.</p>
        <p>Hopefully you sense the efficiency we can get by memoizing our functions, but maybe you are not convinced by the last example for two reasons:</p>
        <ul>
            <li>We didn't improve the speed of the algorithm by an order of Big-O (it is still O(n)).</li>
            <li>The code uses some global variable, so it's kind of ugly.</li>
        </ul>
        <p>Both of those points are true, so let's take a look at a more advanced but also practical example that benefits from memoization.</p>
        <h3 class="mume-header" id="memoizing-fib-actually">Memoizing Fib (actually)</h3>
        <p>Let's begin with our previous 
        <code>fib</code> implementation that calculates the n-th number in the fibonacci sequence:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">fib</span>
<span class="token punctuation">(</span>
<span class="token parameter">n</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>n 
<span class="token operator">===</span> 
<span class="token number">1</span> 
<span class="token operator">||</span> n 
<span class="token operator">===</span> 
<span class="token number">2</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> 
<span class="token number">1</span>
<span class="token punctuation">;</span>
    
<span class="token keyword control-flow">return</span> 
<span class="token function">fib</span>
<span class="token punctuation">(</span>n 
<span class="token operator">-</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token operator">+</span> 
<span class="token function">fib</span>
<span class="token punctuation">(</span>n 
<span class="token operator">-</span> 
<span class="token number">2</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <pre class="language-text">
fib(6);     // =&gt; 8
</pre>
        <p>Before we optimize this, let's ask what complexity class it falls into in the first place. Hmm, the time complexity of this function is not super intuitive to describe because the code branches twice recursively. Fret not! You'll find it useful to visualize a 
        <em>tree</em> when reasoning about the time complexity for recursive functions. Every node of the tree represents a call of the recursion:</p>
        <p>
            <img src="./DATA-Structures_files/fib_tree.png" alt="fib_tree" />
        </p>
        <p>In general, the height of this tree will be 
        <code>n</code> . We derive this by following the path going straight down the left side of the tree. We can also see that each internal node leads to two more nodes. Overall, this means our tree will have roughly 2n nodes which is the same as saying our 
        <code>fib</code> function has an exponential time complexity of 2n. That is very slow! See for yourself, try running 
        <code>fib(50)</code> - you'll be waiting for quite a while (it took 3 minutes on our machine).</p>
        <p>Okay. So our 
        <code>fib</code> is slow, but is there anyway to speed it up? Take a look at the tree above. Can you find any repetitive regions of the tree? We'll highlight a few:</p>
        <p>
            <img src="./DATA-Structures_files/fib_tree_duplicates.png" alt="fib_tree_duplicates" />
        </p>
        <p>As the 
        <code>n</code> grows bigger, the number of duplicate subtrees grows exponentially. Luckily we can fix this using memoization. We'll use a similar object strategy as before, but we'll indulge in some JavaScript default arguments to clean things up:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">fastFib</span>
<span class="token punctuation">(</span>
<span class="token parameter">n
<span class="token punctuation">,</span> memo 
<span class="token operator">=</span> 
<span class="token punctuation">{</span>
<span class="token punctuation">}</span></span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>n 
<span class="token keyword">in</span> memo
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> memo
<span class="token punctuation">[</span>n
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>n 
<span class="token operator">===</span> 
<span class="token number">1</span> 
<span class="token operator">||</span> n 
<span class="token operator">===</span> 
<span class="token number">2</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> 
<span class="token number">1</span>
<span class="token punctuation">;</span>

    memo
<span class="token punctuation">[</span>n
<span class="token punctuation">]</span> 
<span class="token operator">=</span> 
<span class="token function">fastFib</span>
<span class="token punctuation">(</span>n 
<span class="token operator">-</span> 
<span class="token number">1</span>
<span class="token punctuation">,</span> memo
<span class="token punctuation">)</span> 
<span class="token operator">+</span> 
<span class="token function">fastFib</span>
<span class="token punctuation">(</span>n 
<span class="token operator">-</span> 
<span class="token number">2</span>
<span class="token punctuation">,</span> memo
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword control-flow">return</span> memo
<span class="token punctuation">[</span>n
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <pre class="language-text">
fastFib(6);     // =&gt; 8
fastFib(50);    // =&gt; 12586269025
</pre>
        <p>The code above can calculate the 50th fibonacci number almost instantly! Thanks to our memo, we only need to explore a subtree fully once. Visually, our 
        <code>fastFib</code> recursion has this structure:</p>
        <p>
            <img src="./DATA-Structures_files/fib_memoized.png" alt="fib_memoized" />
        </p>
        <p>We marked nodes (function calls) that access the memo in green. It's easy to see that we will do far less computations as 
        <code>n</code> grows larger! In fact, we have brought the time complexity down to linear 
        <code>O(n)</code> time because the tree only branches on the left side. This is an enormous gain if you recall the complexity class hierarchy.</p>
        <h3 class="mume-header" id="the-memoization-formula">The Memoization Formula</h3>
        <p>Now that we have memoization under our belts, when should we apply it? Memoization is useful when attacking recursive problems that have many overlapping subproblems. You'll find it most useful to draw out the visual tree first. If you notice duplicate subtrees, time to memoize. Here are the hard and fast rules you can use to memoize a slow function:</p>
        <ol>
            <li>Write the unoptimized, brute force recursion and make sure it works.</li>
            <li>Add the memo object as an additional arg to the function. The keys will represent unique arguments to the function, and their values will represent the results for those arguments.</li>
            <li>Add a base case condition to the function that returns the stored value if the function's arg is in the memo.</li>
            <li>Before you return the result of the recursive case, store it in the memo as a value and make the function's arg it's key.</li>
        </ol>
        <hr />
        <h3 class="mume-header" id="end-of-memoization">end-of-memoization</h3>
        <hr />
        <hr />
        <h1 class="mume-header" id="tabulation">tabulation</h1>
        <hr />
        <h2 class="mume-header" id="tabulation-1">Tabulation</h2>
        <p>Now that we are familiar with Memoization, let's explore another Dynamic Programming strategy: Tabulation. In case you forgot, Memoization and Tabulation are two distinct Dynamic Programming strategies. That being said, our goal for Tabulation is still to solve large problems efficiently by breaking them down into many subproblems. There are two main features that comprise the Tabulation strategy:</p>
        <ul>
            <li>the function is iterative and 
            <em>not</em> recursive</li>
            <li>the additional data structure used is typically an array (we refer to this as the table!)</li>
        </ul>
        <p>Many problems that can be solved with Memoization can also be solved with Tabulation, so let's begin by attacking a familar problem with a fresh set of eyes. Don't worry, we'll also work on some brand new problems in the upcoming project.</p>
        <h3 class="mume-header" id="tabulating-fib">Tabulating Fib</h3>
        <p>Tabulation is all about creating a table (array) and filling it out with elements. In general, we will complete the table by filling entries from left to right. This means that the first entry of our table (first element of the array) will correspond to the smallest subproblem. Naturally, the final entry of our table (last element of the array) will correspond to the largest problem, which is also our final answer.</p>
        <p>Let's tabulate 
        <code>fib</code> . As always, we want 
        <code>fib(n)</code> to return the n-th number of the Fibonacci sequence:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token comment">// fib(0);      // =&gt; 0</span>
<span class="token comment">// fib(1);      // =&gt; 1</span>
<span class="token comment">// fib(2);      // =&gt; 1</span>
<span class="token comment">// fib(6);      // =&gt; 8</span>
<span class="token comment">// fib(7);      // =&gt; 13</span>
</pre>
        <p>Let's jump straight into the code:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">tabulatedFib</span>
<span class="token punctuation">(</span>
<span class="token parameter">n</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token comment">// create a blank array of length `n`</span>

    
<span class="token keyword">let</span> table 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">Array</span>
<span class="token punctuation">(</span>n
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token comment">// seed the first two values</span>
    table
<span class="token punctuation">[</span>
<span class="token number">0</span>
<span class="token punctuation">]</span> 
<span class="token operator">=</span> 
<span class="token number">0</span>
<span class="token punctuation">;</span>
    table
<span class="token punctuation">[</span>
<span class="token number">1</span>
<span class="token punctuation">]</span> 
<span class="token operator">=</span> 
<span class="token number">1</span>
<span class="token punctuation">;</span>

    
<span class="token comment">// complete the table by moving from left to right,</span>
    
<span class="token comment">// following the fibonacci pattern</span>
    
<span class="token keyword control-flow">for</span> 
<span class="token punctuation">(</span>
<span class="token keyword">let</span> i 
<span class="token operator">=</span> 
<span class="token number">2</span>
<span class="token punctuation">;</span> i 
<span class="token operator">&lt;=</span> n
<span class="token punctuation">;</span> i
<span class="token operator">++</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        table
<span class="token punctuation">[</span>i
<span class="token punctuation">]</span> 
<span class="token operator">=</span> table
<span class="token punctuation">[</span>i 
<span class="token operator">-</span> 
<span class="token number">1</span>
<span class="token punctuation">]</span> 
<span class="token operator">+</span> table
<span class="token punctuation">[</span>i 
<span class="token operator">-</span> 
<span class="token number">2</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword control-flow">return</span> table
<span class="token punctuation">[</span>n
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <pre class="language-text">
console.log(tabulatedFib(7));      // =&gt; 13
</pre>
        <p>Visually, we initialized the table with the following structure:</p>
        <table>
            <thead>
                <tr>
                    <th>i</th>
                    <th>0</th>
                    <th>1</th>
                    <th>2</th>
                    <th>3</th>
                    <th>4</th>
                    <th>5</th>
                    <th>6</th>
                    <th>7</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code>table[i]</code>
                    </td>
                    <td>
                        <code>0</code>
                    </td>
                    <td colspan="7">
                        <code>1</code>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>After our loop finishes, the final table will be:</p>
        <table>
            <thead>
                <tr>
                    <th>i</th>
                    <th>0</th>
                    <th>1</th>
                    <th>2</th>
                    <th>3</th>
                    <th>4</th>
                    <th>5</th>
                    <th>6</th>
                    <th>7</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code>table[i]</code>
                    </td>
                    <td>
                        <code>0</code>
                    </td>
                    <td>
                        <code>1</code>
                    </td>
                    <td>
                        <code>1</code>
                    </td>
                    <td>
                        <code>2</code>
                    </td>
                    <td>
                        <code>3</code>
                    </td>
                    <td>
                        <code>5</code>
                    </td>
                    <td>
                        <code>8</code>
                    </td>
                    <td>
                        <code>13</code>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>Similar to our previous 
        <code>memo</code> , by the time our function completes, our 
        <code>table</code> will contain our final solution as well as all subsolutions calculated along the way.</p>
        <h4 class="mume-header" id="complexity-analysis">Complexity Analysis</h4>
        <p>The analysis of our 
        <code>tabulatedFib</code> is very straightforward, since the code is iterative. The dominant operation in the function is the loop used to fill out the entire table. The length of the table is roughly 
        <code>n</code> elements long, so our algorithm will have an 
        <em>O(n)</em> runtime. The space taken by our algorithm is also 
        <em>O(n)</em> due to the size of the table. Overall, we should be satisfied with the effiency of our algorithm.</p>
        <h3 class="mume-header" id="aside-refactoring-for-o1-space">Aside: Refactoring for O(1) Space</h3>
        <p>You may notice that we can cut down on the space used by our function. At any point of our loop we really only need the previous two subproblems, so there is little utility to storing the full array. This refactor is easy to do by using two variables:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">fib</span>
<span class="token punctuation">(</span>
<span class="token parameter">n</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>n 
<span class="token operator">===</span> 
<span class="token number">0</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> 
<span class="token number">0</span>
<span class="token punctuation">;</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>n 
<span class="token operator">===</span> 
<span class="token number">1</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> 
<span class="token number">1</span>
<span class="token punctuation">;</span>

    
<span class="token keyword">let</span> secondLast 
<span class="token operator">=</span> 
<span class="token number">0</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> last 
<span class="token operator">=</span> 
<span class="token number">1</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">for</span> 
<span class="token punctuation">(</span>
<span class="token keyword">let</span> i 
<span class="token operator">=</span> 
<span class="token number">2</span>
<span class="token punctuation">;</span> i 
<span class="token operator">&lt;=</span> n
<span class="token punctuation">;</span> i
<span class="token operator">++</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">let</span> temp 
<span class="token operator">=</span> last
<span class="token punctuation">;</span>
        last 
<span class="token operator">=</span> last 
<span class="token operator">+</span> secondLast
<span class="token punctuation">;</span>
        secondLast 
<span class="token operator">=</span> temp
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token keyword control-flow">return</span> last
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <p>Bam! We now have O(n) runtime and O(1) space. This is the most optimal algorithm for calculating 
        <code>fib</code> . Note that this strategy is not quite Tabulation, since there is no table array being used. However, this still falls under the overarching category of Dynamic Programming since we saved previous subproblem results in order to calculate the final answer. There's no fancy name for this strategy; it's just amazing.</p>
        <h3 class="mume-header" id="the-tabulation-formula">The Tabulation Formula</h3>
        <p>Here are our general guidelines for implementing a Tabulation strategy. Bear in mind that Dynamic Programming (whether it be by Tabulation or Memoization) is only applicable to problems that can be divided into many subproblems of similar structure. This is just a 
        <em>general</em> recipe so adjust for taste depending on your problem:</p>
        <ol>
            <li>Create the table array based off of the size of the input
            <ul>
                <li>this isn't always straightforward if you have multiple args</li>
            </ul></li>
            <li>Initialize some values in the table that "answer" the trivially small subproblem
            <ul>
                <li>usually this means initializing the first entry of the table</li>
            </ul></li>
            <li>Iterate through the array and fill in remaining entries
            <ul>
                <li>calculating the next entry should require using other entries of the table</li>
            </ul></li>
            <li>Your final answer is the last entry in the table (usually)</li>
        </ol>
        <hr />
        <h3 class="mume-header" id="end-of-tabulation">End of Tabulation</h3>
        <hr />
        <hr />
        <h1 class="mume-header" id="linked-lists">Linked-Lists</h1>
        <hr />
        <h2 class="mume-header" id="what-is-a-linked-list">What is a Linked List?</h2>
        <p>A Linked List data structure represents a linear sequence of "vertices" (or "nodes"), and tracks three important properties.</p>
        <p>
            <strong>Linked List Properties:</strong>
        </p>
        <table>
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code>head</code>
                    </td>
                    <td>The first node in the list.</td>
                </tr>
                <tr>
                    <td>
                        <code>tail</code>
                    </td>
                    <td>The last node in the list.</td>
                </tr>
                <tr>
                    <td>
                        <code>length</code>
                    </td>
                    <td>The number of nodes in the list; the list's length.</td>
                </tr>
            </tbody>
        </table>
        <p>The data being tracked by a particular Linked List does not live inside the Linked List instance itself. Instead, each vertex is actually an instance of an even simpler, smaller data structure, often referred to as a "Node".</p>
        <p>Depending on the type of Linked List (there are many), Node instances track some very important properties as well.</p>
        <p>
            <strong>Linked List Node Properties:</strong>
        </p>
        <table>
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code>value</code>
                    </td>
                    <td>The actual value this node represents.</td>
                </tr>
                <tr>
                    <td>
                        <code>next</code>
                    </td>
                    <td>The next node in the list (relative to this node).</td>
                </tr>
                <tr>
                    <td>
                        <code>previous</code>
                    </td>
                    <td>The previous node in the list (relative to this node).</td>
                </tr>
            </tbody>
        </table>
        <p>
        <strong>NOTE:</strong> The 
        <code>previous</code> property is for Doubly Linked Lists only!</p>
        <p>Linked Lists contain 
        <em>ordered</em> data, just like arrays. The first node in the list is, indeed, first. From the perspective of the very first node in the list, the 
        <em>next</em> node is the second node. From the perspective of the second node in the list, the 
        <em>previous</em> node is the first node, and the 
        <em>next</em> node is the third node. And so it goes.</p>
        <h4 class="mume-header" id="_sothis-sounds-a-lot-like-an-array_">
            <em>"So...this sounds a lot like an Array..."</em>
        </h4>
        <p>Admittedly, this does 
        <em>sound</em> a lot like an Array so far, and that's because Arrays and Linked Lists are both implementations of the List ADT. However, there is an incredibly important distinction to be made between Arrays and Linked Lists, and that is how they 
        <em>physically store</em> their data. (As opposed to how they 
        <em>represent</em> the order of their data.)</p>
        <p>Recall that Arrays contain 
        <em>contiguous</em> data. Each element of an array is actually stored 
        <em>next to</em> it's neighboring element 
        <em>in the actual hardware of your machine</em>, in a single continuous block in memory.</p>
        <p>
            <img src="./DATA-Structures_files/array-in-memory.png" alt="Array in Memory" />
        </p>
        <p>
            <em>An Array's contiguous data being stored in a continuous block of addresses in memory.</em>
        </p>
        <p>Unlike Arrays, Linked Lists contain 
        <em>non-contiguous</em> data. Though Linked Lists 
        <em>represent</em> data that is ordered linearly, that mental model is just that - an interpretation of the 
        <em>representation</em> of information, not reality.</p>
        <p>In reality, in the actual hardware of your machine, whether it be in disk or in memory, a Linked List's Nodes are not stored in a single continuous block of addresses. Rather, Linked List Nodes live at randomly distributed addresses throughout your machine! The only reason we know which node comes next in the list is because we've assigned its reference to the current node's 
        <code>next</code> pointer.</p>
        <p>
            <img src="./DATA-Structures_files/SLL-diagram.png" alt="Array in Memory" />
        </p>
        <p>
            <em>A Singly Linked List's non-contiguous data (Nodes) being stored at randomly distributed addresses in memory.</em>
        </p>
        <p>For this reason, Linked List Nodes have 
        <em>no indices</em>, and no 
        <em>random access</em>. Without random access, we do not have the ability to look up an individual Linked List Node in constant time. Instead, to find a particular Node, we have to start at the very first Node and iterate through the Linked List one node at a time, checking each Node's 
        <em>next</em> Node until we find the one we're interested in.</p>
        <p>So when implementing a Linked List, we actually must implement both the Linked List class 
        <em>and</em> the Node class. Since the actual data lives in the Nodes, it's simpler to implement the Node class first.</p>
        <h2 class="mume-header" id="types-of-linked-lists">Types of Linked Lists</h2>
        <p>There are four flavors of Linked List you should be familiar with when walking into your job interviews.</p>
        <p>
            <strong>Linked List Types:</strong>
        </p>
        <table>
            <thead>
                <tr>
                    <th>List Type</th>
                    <th>Description</th>
                    <th>Directionality</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Singly Linked</td>
                    <td>Nodes have a single pointer connecting them in a single direction.</td>
                    <td>Head?Tail</td>
                </tr>
                <tr>
                    <td>Doubly Linked</td>
                    <td>Nodes have two pointers connecting them bi-directionally.</td>
                    <td>Head?Tail</td>
                </tr>
                <tr>
                    <td>Mulitply Linked</td>
                    <td>Nodes have two or more pointers, providing a variety of potential node orderings.</td>
                    <td>Head?Tail, A?Z, Jan?Dec, etc.</td>
                </tr>
                <tr>
                    <td>Circularly Linked</td>
                    <td>Final node's 
                    <code>next</code> pointer points to the first node, creating a non-linear, circular version of a Linked List.</td>
                    <td>Head?Tail?Head?Tail</td>
                </tr>
            </tbody>
        </table>
        <p>
        <strong>NOTE:</strong> These Linked List types are not always mutually exclusive.</p>
        <p>For instance:</p>
        <ul>
            <li>Any type of Linked List can be implemented Circularly (e.g. A Circular Doubly Linked List).</li>
            <li>A Doubly Linked List is actually just a special case of a Mulitply Linked List.</li>
            <li>Etc.</li>
        </ul>
        <p>You are most likely to encounter Singly and Doubly Linked Lists in your upcoming job search, so we are going to focus exlusively on those two moving forward. However, in more senior level interviews, it is very valuable to have some familiarity with the other types of Linked Lists. Though you may not actually code them out, 
        <em>you will win extra points by illustrating your ability to weigh the tradeoffs of your technical decisions</em> by discussing how your choice of Linked List type may affect the efficiency of the solutions you propose.</p>
        <h2 class="mume-header" id="linked-list-methods">Linked List Methods</h2>
        <p>Linked Lists are great foundation builders when learning about data structures because they share a number of similar methods (and edge cases) with many other common data structures. You will find that many of the concepts discussed here will repeat themselves as we dive into some of the more complex non-linear data structures later on, like Trees and Graphs.</p>
        <p>In the project that follows, we will implement the following Linked List methods:</p>
        <table>
            <thead>
                <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                    <th>Returns</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Insertion</td>
                    <td>
                        <code>addToTail</code>
                    </td>
                    <td>Adds a new node to the tail of the Linked List.</td>
                    <td>Updated Linked List</td>
                </tr>
                <tr>
                    <td>Insertion</td>
                    <td>
                        <code>addToHead</code>
                    </td>
                    <td>Adds a new node to the head of the Linked List.</td>
                    <td>Updated Linked List</td>
                </tr>
                <tr>
                    <td>Insertion</td>
                    <td>
                        <code>insertAt</code>
                    </td>
                    <td>Inserts a new node at the "index", or position, specified.</td>
                    <td>Boolean</td>
                </tr>
                <tr>
                    <td>Deletion</td>
                    <td>
                        <code>removeTail</code>
                    </td>
                    <td>Removes the node at the tail of the Linked List.</td>
                    <td>Removed node</td>
                </tr>
                <tr>
                    <td>Deletion</td>
                    <td>
                        <code>removeHead</code>
                    </td>
                    <td>Removes the node at the head of the Linked List.</td>
                    <td>Removed node</td>
                </tr>
                <tr>
                    <td>Deletion</td>
                    <td>
                        <code>removeFrom</code>
                    </td>
                    <td>Removes the node at the "index", or position, specified.</td>
                    <td>Removed node</td>
                </tr>
                <tr>
                    <td>Search</td>
                    <td>
                        <code>contains</code>
                    </td>
                    <td>Searches the Linked List for a node with the value specified.</td>
                    <td>Boolean</td>
                </tr>
                <tr>
                    <td>Access</td>
                    <td>
                        <code>get</code>
                    </td>
                    <td>Gets the node at the "index", or position, specified.</td>
                    <td>Node at index</td>
                </tr>
                <tr>
                    <td>Access</td>
                    <td>
                        <code>set</code>
                    </td>
                    <td>Updates the value of a node at the "index", or position, specified.</td>
                    <td>Boolean</td>
                </tr>
                <tr>
                    <td>Meta</td>
                    <td>
                        <code>size</code>
                    </td>
                    <td>Returns the current size of the Linked List.</td>
                    <td>Integer</td>
                </tr>
            </tbody>
        </table>
        <h2 class="mume-header" id="time-and-space-complexity-analysis-3">Time and Space Complexity Analysis</h2>
        <p>Before we begin our analysis, here is a quick summary of the Time and Space constraints of each Linked List Operation. The complexities below apply to both Singly and Doubly Linked Lists:</p>
        <table>
            <thead>
                <tr>
                    <th>Data Structure Operation</th>
                    <th>Time Complexity (Avg)</th>
                    <th>Time Complexity (Worst)</th>
                    <th>Space Complexity (Worst)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Access</td>
                    <td>
                        <code>T(n)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                </tr>
                <tr>
                    <td>Search</td>
                    <td>
                        <code>T(n)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                </tr>
                <tr>
                    <td>Insertion</td>
                    <td>
                        <code>T(1)</code>
                    </td>
                    <td>
                        <code>O(1)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                </tr>
                <tr>
                    <td>Deletion</td>
                    <td>
                        <code>T(1)</code>
                    </td>
                    <td>
                        <code>O(1)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>Before moving forward, see if you can reason to yourself why each operation has the time and space complexity listed above!</p>
        <h2 class="mume-header" id="time-complexity-access-and-search">Time Complexity - Access and Search:</h2>
        <h3 class="mume-header" id="scenarios">Scenarios:</h3>
        <ol>
            <li>We have a Linked List, and we'd like to find the 8th item in the list.</li>
            <li>We have a Linked List of sorted alphabet letters, and we'd like to see if the letter "Q" is inside that list.</li>
        </ol>
        <h3 class="mume-header" id="discussion">Discussion:</h3>
        <p>Unlike Arrays, Linked Lists Nodes are not stored contiguously in memory, and thereby do not have an indexed set of memory addresses at which we can quickly lookup individual nodes in constant time. Instead, we must begin at the head of the list (or possibly at the tail, if we have a Doubly Linked List), and iterate through the list until we arrive at the node of interest.</p>
        <p>In Scenario 1, we'll know we're there because we've iterated 8 times. In Scenario 2, we'll know we're there because, while iterating, we've checked each node's value and found one that matches our target value, "Q".</p>
        <p>In the worst case scenario, we may have to traverse the entire Linked List until we arrive at the final node. This makes both Access &amp; Search 
        <strong>Linear Time</strong> operations.</p>
        <h2 class="mume-header" id="time-complexity-insertion-and-deletion">Time Complexity - Insertion and Deletion:</h2>
        <h3 class="mume-header" id="scenarios-1">Scenarios:</h3>
        <ol>
            <li>We have an empty Linked List, and we'd like to insert our first node.</li>
            <li>We have a Linked List, and we'd like to insert or delete a node at the Head or Tail.</li>
            <li>We have a Linked List, and we'd like to insert or delete a node from somewhere in the middle of the list.</li>
        </ol>
        <h3 class="mume-header" id="discussion-1">Discussion:</h3>
        <p>Since we have our Linked List Nodes stored in a non-contiguous manner that relies on pointers to keep track of where the next and previous nodes live, Linked Lists liberate us from the linear time nature of Array insertions and deletions. We no longer have to adjust the position at which each node/element is stored after making an insertion at a particular position in the list. Instead, if we want to insert a new node at position 
        <code>i</code> , we can simply:</p>
        <ol>
            <li>Create a new node.</li>
            <li>Set the new node's 
            <code>next</code> and 
            <code>previous</code> pointers to the nodes that live at postions 
            <code>i</code> and 
            <code>i - 1</code>, respectively.</li>
            <li>Adjust the 
            <code>next</code> pointer of the node that lives at position 
            <code>i - 1</code> to point to the new node.</li>
            <li>Adjust the 
            <code>previous</code> pointer of the node that lives at position 
            <code>i</code> to point to the new node.</li>
        </ol>
        <p>And we're done, in Constant Time. No iterating across the entire list necessary.</p>
        <p>"But hold on one second, " you may be thinking. "In order to insert a new node in the middle of the list, don't we have to lookup its position? Doesn't that take linear time?!"</p>
        <p>Yes, it is tempting to call insertion or deletion in the middle of a Linked List a linear time operation since there is lookup involved. However, it's usually the case that you'll already have a reference to the node where your desired insertion or deletion will occur.</p>
        <p>For this reason, we separate the Access time complexity from the Insertion/Deletion time complexity, and formally state that Insertion and Deletion in a Linked List are 
        <strong>Constant Time</strong> across the board.</p>
        <h3 class="mume-header" id="note">NOTE:</h3>
        <p>Without a reference to the node at which an insertion or deletion will occur, due to linear time lookup, an insertion or deletion 
        <em>in the middle</em> of a Linked List will still take Linear Time, sum total.</p>
        <h2 class="mume-header" id="space-complexity-1">Space Complexity:</h2>
        <h3 class="mume-header" id="scenarios-2">Scenarios:</h3>
        <ol>
            <li>We're given a Linked List, and need to operate on it.</li>
            <li>We've decided to create a new Linked List as part of strategy to solve some problem.</li>
        </ol>
        <h3 class="mume-header" id="discussion-2">Discussion:</h3>
        <p>It's obvious that Linked Lists have one node for every one item in the list, and for that reason we know that Linked Lists take up Linear Space in memory. However, when asked in an interview setting what the Space Complexity 
        <em>of your solution</em> to a problem is, it's important to recognize the difference between the two scenarios above.</p>
        <p>In Scenario 1, we 
        <em>are not</em> creating a new Linked List. We simply need to operate on the one given. Since we are not storing a 
        <em>new</em> node for every node represented in the Linked List we are provided, our solution is 
        <em>not necessarily</em> linear in space.</p>
        <p>In Scenario 2, we 
        <em>are</em> creating a new Linked List. If the number of nodes we create is linearly correlated to the size of our input data, we are now operating in Linear Space.</p>
        <h3 class="mume-header" id="note-1">NOTE:</h3>
        <p>Linked Lists can be traversed both iteratively and recursively. 
        <em>If you choose to traverse a Linked List recursively</em>, there will be a recursive function call added to the call stack for every node in the Linked List. Even if you're provided the Linked List, as in Scenario 1, you will still use Linear Space in the call stack, and that counts.</p>
        <hr />
        <h3 class="mume-header" id="end-of-linked-list">End of Linked-List</h3>
        <hr />
        <hr />
        <h1 class="mume-header" id="stacks-and-queues">Stacks And Queue's</h1>
        <hr />
        <p>Stacks and Queues aren't really "data structures" by the strict definition of the term. The more appropriate terminology would be to call them abstract data types (ADTs), meaning that their definitions are more conceptual and related to the rules governing their user-facing behaviors rather than their core implementations.</p>
        <p>For the sake of simplicity, we'll refer to them as data structures and ADTs interchangeably throughout the course, but the distinction is an important one to be familiar with as you level up as an engineer.</p>
        <p>Now that that's out of the way, Stacks and Queues represent a linear collection of nodes or values. In this way, they are quite similar to the Linked List data structure we discussed in the previous section. In fact, you can even use a modified version of a Linked List to implement each of them. (Hint, hint.)</p>
        <p>These two ADTs are similar to each other as well, but each obey their own special rule regarding the order with which Nodes can be added and removed from the structure.</p>
        <p>Since we've covered Linked Lists in great length, these two data structures will be quick and easy. Let's break them down individually in the next couple of sections.</p>
        <h2 class="mume-header" id="what-is-a-stack">What is a Stack?</h2>
        <p>Stacks are a Last In First Out (LIFO) data structure. The last Node added to a stack is always the first Node to be removed, and as a result, the first Node added is always the last Node removed.</p>
        <p>The name Stack actually comes from this characteristic, as it is helpful to visualize the data structure as a vertical stack of items. Personally, I like to think of a Stack as a stack of plates, or a stack of sheets of paper. This seems to make them more approachable, because the analogy relates to something in our everyday lives.</p>
        <p>If you can imagine adding items to, or removing items from, a Stack of...literally anything...you'll realize that every (sane) person naturally obeys the LIFO rule.</p>
        <p>We add things to the 
        <em>top</em> of a stack. We remove things from the 
        <em>top</em> of a stack. We never add things to, or remove things from, the 
        <em>bottom</em> of the stack. That's just crazy.</p>
        <p>Note: We can use JavaScript Arrays to implement a basic stack. 
        <code>Array#push</code> adds to the top of the stack and 
        <code>Array#pop</code> will remove from the top of the stack. In the exercise that follows, we'll build our own Stack class from scratch (without using any arrays). In an interview setting, your evaluator may be okay with you using an array as a stack.</p>
        <h2 class="mume-header" id="what-is-a-queue">What is a Queue?</h2>
        <p>Queues are a First In First Out (FIFO) data structure. The first Node added to the queue is always the first Node to be removed.</p>
        <p>The name Queue comes from this characteristic, as it is helpful to visualize this data structure as a horizontal line of items with a beginning and an end. Personally, I like to think of a Queue as the line one waits on for an amusement park, at a grocery store checkout, or to see the teller at a bank.</p>
        <p>If you can imagine a queue of humans waiting...again, for literally anything...you'll realize that 
        <em>most</em> people (the civil ones) naturally obey the FIFO rule.</p>
        <p>People add themselves to the 
        <em>back</em> of a queue, wait their turn in line, and make their way toward the 
        <em>front</em>. People exit from the 
        <em>front</em> of a queue, but only when they have made their way to being first in line.</p>
        <p>We never add ourselves to the front of a queue (unless there is no one else in line), otherwise we would be "cutting" the line, and other humans don't seem to appreciate that.</p>
        <p>Note: We can use JavaScript Arrays to implement a basic queue. 
        <code>Array#push</code> adds to the back (enqueue) and 
        <code>Array#shift</code> will remove from the front (dequeue). In the exercise that follows, we'll build our own Queue class from scratch (without using any arrays). In an interview setting, your evaluator may be okay with you using an array as a queue.</p>
        <h2 class="mume-header" id="stack-and-queue-properties">Stack and Queue Properties</h2>
        <p>Stacks and Queues are so similar in composition that we can discuss their properties together. They track the following three properties:</p>
        <p>
            <strong>Stack Properties | Queue Properties:</strong>
        </p>
        <table>
            <thead>
                <tr>
                    <th>Stack Property</th>
                    <th>Description</th>
                    <th>Queue Property</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code>top</code>
                    </td>
                    <td>The first node in the Stack</td>
                    <td>
                        <code>front</code>
                    </td>
                    <td>The first node in the Queue</td>
                </tr>
                <tr>
                    <td>
                        <code>bottom</code>
                    </td>
                    <td>The last node in the Stack. (Optional)</td>
                    <td>
                        <code>back</code>
                    </td>
                    <td>The last node in the Queue.</td>
                </tr>
                <tr>
                    <td>
                        <code>length</code>
                    </td>
                    <td>The number of nodes in the Stack; the Stack's length.</td>
                    <td>
                        <code>length</code>
                    </td>
                    <td>The number of nodes in the Queue; the Queue's length.</td>
                </tr>
            </tbody>
        </table>
        <p>Notice that rather than having a 
        <code>head</code> and a 
        <code>tail</code> like Linked Lists, Stacks have a 
        <code>top</code> and a 
        <code>bottom</code> , and Queues have a 
        <code>front</code> and a 
        <code>back</code> instead. These properties are essentially the same; pointers to the end points of the respective List ADT where important actions way take place. The differences in naming conventions are strictly for human comprehension.</p>
        <hr />
        <p>Similarly to Linked Lists, the values stored inside a Stack or a Queue are actually contained within Stack Node and Queue Node instances. Stack, Queue, and Singly Linked List Nodes are all identical, but just as a reminder and for the sake of completion, these List Nodes track the following two properties:</p>
        <p>
            <strong>Stack &amp; Queue Node Properties:</strong>
        </p>
        <table>
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code>value</code>
                    </td>
                    <td>The actual value this node represents.</td>
                </tr>
                <tr>
                    <td>
                        <code>next</code>
                    </td>
                    <td>The next node in the Stack (relative to this node).</td>
                </tr>
            </tbody>
        </table>
        <h2 class="mume-header" id="stack-methods">Stack Methods</h2>
        <p>In the exercise that follows, we will implement a Stack data structure along with the following Stack methods:</p>
        <table>
            <thead>
                <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                    <th>Returns</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Insertion</td>
                    <td>
                        <code>push</code>
                    </td>
                    <td>Adds a Node to the top of the Stack.</td>
                    <td>Integer - New size of stack</td>
                </tr>
                <tr>
                    <td>Deletion</td>
                    <td>
                        <code>pop</code>
                    </td>
                    <td>Removes a Node from the top of the Stack.</td>
                    <td>Node removed from top of Stack</td>
                </tr>
                <tr>
                    <td>Meta</td>
                    <td>
                        <code>size</code>
                    </td>
                    <td>Returns the current size of the Stack.</td>
                    <td>Integer</td>
                </tr>
            </tbody>
        </table>
        <h2 class="mume-header" id="stack-javascript-implementation">Stack JavaScript Implementation</h2>
        <p>The following code is the preferred implementation of a 
        <code>Stack</code> ADT:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">class</span> 
<span class="token class-name">Node</span> 
<span class="token punctuation">{</span>
    
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token parameter">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">value</span> 
<span class="token operator">=</span> val
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">next</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> 
<span class="token class-name">Stack</span> 
<span class="token punctuation">{</span>
    
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">bottom</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">=</span> 
<span class="token number">0</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token function">push</span>
<span class="token punctuation">(</span>
<span class="token parameter">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">const</span> newNode 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">Node</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span> 
<span class="token operator">=</span> newNode
<span class="token punctuation">;</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">bottom</span> 
<span class="token operator">=</span> newNode
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">const</span> temp 
<span class="token operator">=</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span>
<span class="token punctuation">;</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span> 
<span class="token operator">=</span> newNode
<span class="token punctuation">;</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span>
<span class="token punctuation">.</span>
<span class="token property-access">next</span> 
<span class="token operator">=</span> temp
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token operator">++</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token function">pop</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
        
<span class="token keyword">const</span> temp 
<span class="token operator">=</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span>
<span class="token punctuation">;</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span> 
<span class="token operator">===</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">bottom</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">bottom</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span> 
<span class="token operator">=</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">top</span>
<span class="token punctuation">.</span>
<span class="token property-access">next</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token operator">--</span>
<span class="token punctuation">;</span>
        
<span class="token keyword control-flow">return</span> temp
<span class="token punctuation">.</span>
<span class="token property-access">value</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token function">size</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
        <h2 class="mume-header" id="queue-methods">Queue Methods</h2>
        <p>In the exercise that follows, we will implement a Queue data structure along with the following Queue methods:</p>
        <table>
            <thead>
                <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                    <th>Returns</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Insertion</td>
                    <td>
                        <code>enqueue</code>
                    </td>
                    <td>Adds a Node to the front of the Queue.</td>
                    <td>Integer - New size of Queue</td>
                </tr>
                <tr>
                    <td>Deletion</td>
                    <td>
                        <code>dequeue</code>
                    </td>
                    <td>Removes a Node from the front of the Queue.</td>
                    <td>Node removed from front of Queue</td>
                </tr>
                <tr>
                    <td>Meta</td>
                    <td>
                        <code>size</code>
                    </td>
                    <td>Returns the current size of the Queue.</td>
                    <td>Integer</td>
                </tr>
            </tbody>
        </table>
        <h2 class="mume-header" id="queue-javascript-implementation">Queue JavaScript Implementation</h2>
        <p>The following code is the preferred implementation of a 
        <code>Queue</code> ADT:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">class</span> 
<span class="token class-name">Node</span> 
<span class="token punctuation">{</span>
    
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token parameter">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">value</span> 
<span class="token operator">=</span> val
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">next</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> 
<span class="token class-name">Queue</span> 
<span class="token punctuation">{</span>
    
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">front</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">back</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">length</span> 
<span class="token operator">=</span> 
<span class="token number">0</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token function">enqueue</span>
<span class="token punctuation">(</span>
<span class="token parameter">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">const</span> newNode 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">Node</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">front</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">front</span> 
<span class="token operator">=</span> newNode
<span class="token punctuation">;</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">back</span> 
<span class="token operator">=</span> newNode
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">back</span>
<span class="token punctuation">.</span>
<span class="token property-access">next</span> 
<span class="token operator">=</span> newNode
<span class="token punctuation">;</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">back</span> 
<span class="token operator">=</span> newNode
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token operator">++</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token function">dequeue</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">front</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
        
<span class="token keyword">const</span> temp 
<span class="token operator">=</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">front</span>
<span class="token punctuation">;</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">front</span> 
<span class="token operator">===</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">back</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">back</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">front</span> 
<span class="token operator">=</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">front</span>
<span class="token punctuation">.</span>
<span class="token property-access">next</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token operator">--</span>
<span class="token punctuation">;</span>
        
<span class="token keyword control-flow">return</span> temp
<span class="token punctuation">.</span>
<span class="token property-access">value</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token function">size</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">return</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
        <h2 class="mume-header" id="time-and-space-complexity-analysis-4">Time and Space Complexity Analysis</h2>
        <p>Before we begin our analysis, here is a quick summary of the Time and Space constraints of each Stack Operation.</p>
        <table>
            <thead>
                <tr>
                    <th>Data Structure Operation</th>
                    <th>Time Complexity (Avg)</th>
                    <th>Time Complexity (Worst)</th>
                    <th>Space Complexity (Worst)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Access</td>
                    <td>
                        <code>T(n)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                </tr>
                <tr>
                    <td>Search</td>
                    <td>
                        <code>T(n)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                </tr>
                <tr>
                    <td>Insertion</td>
                    <td>
                        <code>T(1)</code>
                    </td>
                    <td>
                        <code>O(1)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                </tr>
                <tr>
                    <td>Deletion</td>
                    <td>
                        <code>T(1)</code>
                    </td>
                    <td>
                        <code>O(1)</code>
                    </td>
                    <td>
                        <code>O(n)</code>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>Before moving forward, see if you can reason to yourself why each operation has the time and space complexity listed above!</p>
        <h4 class="mume-header" id="time-complexity-access-and-search-1">Time Complexity - Access and Search:</h4>
        <p>When the Stack ADT was first conceived, its inventor definitely did not prioritize searching and accessing individual Nodes or values in the list. The same idea applies for the Queue ADT. There are certainly better data structures for speedy search and lookup, and if these operations are a priority for your use case, it would be best to choose something else!</p>
        <p>Search and Access are both linear time operations for Stacks and Queues, and that shouldn't be too unclear. Both ADTs are nearly identical to Linked Lists in this way. The only way to find a Node somewhere in the middle of a Stack or a Queue, is to start at the 
        <code>top</code> (or the 
        <code>back</code> ) and traverse downward (or forward) toward the 
        <code>bottom</code> (or 
        <code>front</code> ) one node at a time via each Node's 
        <code>next</code> property.</p>
        <p>This is a linear time operation, O(n).</p>
        <h4 class="mume-header" id="time-complexity-insertion-and-deletion-1">Time Complexity - Insertion and Deletion:</h4>
        <p>For Stacks and Queues, insertion and deletion is what it's all about. If there is one feature a Stack absolutely must have, it's constant time insertion and removal to and from the 
        <code>top</code> of the Stack (FIFO). The same applies for Queues, but with insertion occuring at the 
        <code>back</code> and removal occuring at the 
        <code>front</code> (LIFO).</p>
        <p>Think about it. When you add a plate to the top of a stack of plates, do you have to iterate through all of the other plates first to do so? Of course not. You simply add your plate to the top of the stack, and that's that. The concept is the same for removal.</p>
        <p>Therefore, Stacks and Queues have constant time Insertion and Deletion via their 
        <code>push</code> and 
        <code>pop</code> or 
        <code>enqueue</code> and 
        <code>dequeue</code> methods, O(1).</p>
        <h4 class="mume-header" id="space-complexity-2">Space Complexity:</h4>
        <p>The space complexity of Stacks and Queues is very simple. Whether we are instantiating a new instance of a Stack or Queue to store a set of data, or we are using a Stack or Queue as part of a strategy to solve some problem, Stacks and Queues always store one Node for each value they receive as input.</p>
        <p>For this reason, we always consider Stacks and Queues to have a linear space complexity, O(n).</p>
        <h2 class="mume-header" id="when-should-we-use-stacks-and-queues">When should we use Stacks and Queues?</h2>
        <p>At this point, we've done a lot of work understanding the ins and outs of Stacks and Queues, but we still haven't really discussed what we can use them for. The answer is actually...a lot!</p>
        <p>For one, Stacks and Queues can be used as intermediate data structures while implementing some of the more complicated data structures and methods we'll see in some of our upcoming sections.</p>
        <p>For example, the implementation of the breadth-first Tree traversal algorithm takes advantage of a Queue instance, and the depth-first Graph traveral algorithm exploits the benefits of a Stack instance.</p>
        <p>Additionally, Stacks and Queues serve as the essential underlying data structures to a wide variety of applications you use all the time. Just to name a few:</p>
        <h4 class="mume-header" id="stacks">Stacks:</h4>
        <ul>
            <li>The Call Stack is a Stack data structure, and is used to manage the order of function invocations in your code.</li>
            <li>Browser History is often implemented using a Stack, with one great example being the browser history object in the very popular React Router module.</li>
            <li>Undo/Redo functionality in just about any application. For example:
            <ul>
                <li>When you're coding in your text editor, each of the actions you take on your keyboard are recorded by 
                <code>push</code>ing that event to a Stack.</li>
                <li>When you hit cmd + z to undo your most recent action, that event is 
                <code>pop</code>ed off the Stack, because the last event that occured should be the first one to be undone (LIFO).</li>
                <li>When you hit cmd + y to redo your most recent action, that event is 
                <code>push</code>ed back onto the Stack.</li>
            </ul></li>
        </ul>
        <h4 class="mume-header" id="queues">Queues:</h4>
        <ul>
            <li>Printers use a Queue to manage incoming jobs to ensure that documents are printed in the order they are received.</li>
            <li>Chat rooms, online video games, and customer service phone lines use a Queue to ensure that patrons are served in the order they arrive.
            <ul>
                <li>In the case of a Chat Room, to be admitted to a size-limited room.</li>
                <li>In the case of an Online Multi-Player Game, players wait in a lobby until there is enough space and it is their turn to be admitted to a game.</li>
                <li>In the case of a Customer Service Phone Line...you get the point.</li>
            </ul></li>
            <li>As a more advanced use case, Queues are often used as components or services in the system design of a service-oriented architecture. A very popular and easy to use example of this is Amazon's Simple Queue Service (SQS), which is a part of their Amazon Web Services (AWS) offering.
            <ul>
                <li>You would add this service to your system between two other services, one that is sending information for processing, and one that is receiving information to be processed, when the volume of incoming requests is high and the integrity of the order with which those requests are processed must be maintained.</li>
            </ul></li>
        </ul>
        <hr />
        <h3 class="mume-header" id="end-of-stacks-and-queues">End of Stacks And Queue's</h3>
        <hr />
        <hr />
        <h1 class="mume-header" id="binary-trees">Binary-Trees</h1>
        <hr />
        <p>Binary Trees are perhaps the most pervasive data structure in computer science. Let's take a moment to go over the basic characteristics of a Binary Tree before we explore algorithms that utilize this structure.</p>
        <h3 class="mume-header" id="what-is-a-graph">What is a Graph?</h3>
        <p>Before we define what a 
        <strong>Tree</strong> is, we must first understand the definition of a 
        <strong>Graph</strong>. A graph is a collection of 
        <strong>nodes</strong> and any 
        <strong>edges</strong> between those nodes. You've likely seen depictions of graphs before, they usually exist as circles (nodes) and arrows (edges) between those circles. Below are few examples of graphs:</p>
        <p>
            <img src="./DATA-Structures_files/graphs.png" alt="graphs" />
        </p>
        <p>For now, you can ignore the blue coloring. Notice how the graphs above vary greatly in their structure. A graph is indeed a very broad, overarching category. In fact, linked lists and trees are both considered subclasses of graphs. We'll cover algorithms that operate on a general graph structure later, but for now we want to focus on what graphs are trees and what graphs are not. It's worth mentioning that a single node with no edges (image 1) is considered a graph. The empty graph (a graph with 0 nodes and 0 edges, not pictured ??) is also still a graph. This line of thinking will help us later when we design graph algorithms.</p>
        <h3 class="mume-header" id="what-is-a-tree">What is a Tree?</h3>
        <p>A 
        <strong>Tree</strong> is a 
        <strong>Graph</strong> that does not contain any cycles. A cycle is is defined as a path through edges that begins and ends at the same node. This seems straightforward, but the definition becomes a bit muddled as Mathematicians and Computer Scientists use the term "tree" in slightly different ways. Lets break it down:</p>
        <ul>
            <li>To a Mathematician, graphs 1, 2, 3, and 4 in the above image are trees.</li>
            <li>To a Computer Scientist, only graphs 1 , 2, and 3 are trees.</li>
        </ul>
        <p>Well, at least both camps agree that graph 5 is most certainly not a tree! This is because of the obvious cycle that spans all three nodes. However, why is there disagreement over graph 4? The reason is this: In computer science, we use to the term "tree" to really refer to a "rooted tree." A "rooted tree" is a "tree" where there exists a special node from which every other node is accessible; we call this special node the "root". Think of the root as ultimate ancestor, the single node that all other nodes inherit from. Above we have colored all roots in blue. Like you'd probably suspect, in this course we'll subscribe to the Computer Scientist's interpretation. That is, we won't consider graph 4 a tree because there is no such root we can label.</p>
        <p>You've probably heard the term "root" throughout your software engineering career: root directory, root user, etc.. All of these concepts branch from the humble tree data structure!</p>
        <h3 class="mume-header" id="what-is-a-binary-tree">What is a Binary Tree?</h3>
        <p>A 
        <strong>Binary Tree</strong> is a 
        <strong>Tree</strong> where nodes have 
        <strong>at most 2 children</strong>. This means graphs 1, 2, and 3 are all Binary Trees. There exist ternary trees (at most 3 children) and n-ary trees (at most n children), but you'll likely encounter binary trees in your job hunt, so we'll focus on them in this course. Based on our final definition for a binary tree, here is some food for thought:</p>
        <ul>
            <li>an empty graph of 0 nodes and 0 edges is a binary tree</li>
            <li>a graph of 1 node and 0 edges is a binary tree</li>
            <li>a linked list is a binary tree</li>
        </ul>
        <p>Take a moment to use the definitions we explored to verify that each of the three statements above is true. We bring up these three scenarios in particular because they are the simplest types of Binary Trees. We want to eventually build elegant algorithms and these simple scenarios will fuel our design.</p>
        <h3 class="mume-header" id="representing-a-tree-with-node-instances">Representing a Tree with Node Instances</h3>
        <p>Let's explore a common way to represent binary trees using some object oriented design. A tree is a collection of nodes, so let's implement a 
        <code>TreeNode</code> class. We'll use properties of 
        <code>left</code> and 
        <code>right</code> to reference the children of a 
        <code>TreeNode</code> . That is, 
        <code>left</code> and 
        <code>right</code> will reference other 
        <code>TreeNode</code> s:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">class</span> 
<span class="token class-name">TreeNode</span> 
<span class="token punctuation">{</span>
        
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token parameter">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">val</span> 
<span class="token operator">=</span> val
<span class="token punctuation">;</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">left</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">right</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

<span class="token maybe-class-name">Constructing</span> a tree is a matter 
<span class="token keyword">of</span> creating the nodes and setting 
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">left</span>
    <span class="token template-punctuation string">`</span>
</span> and 
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">right</span>
    <span class="token template-punctuation string">`</span>
</span> however we please
<span class="token punctuation">.</span> 
<span class="token property-access token maybe-class-name">For</span> example
<span class="token operator">:</span>

    
<span class="token keyword">let</span> a 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>
<span class="token string">'a'</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> b 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>
<span class="token string">'b'</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> c 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>
<span class="token string">'c'</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> d 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>
<span class="token string">'d'</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> e 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>
<span class="token string">'e'</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> f 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>
<span class="token string">'f'</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    a
<span class="token punctuation">.</span>
<span class="token property-access">left</span> 
<span class="token operator">=</span> b
<span class="token punctuation">;</span>
    a
<span class="token punctuation">.</span>
<span class="token property-access">right</span> 
<span class="token operator">=</span> c
<span class="token punctuation">;</span>
    b
<span class="token punctuation">.</span>
<span class="token property-access">left</span> 
<span class="token operator">=</span> d
<span class="token punctuation">;</span>
    b
<span class="token punctuation">.</span>
<span class="token property-access">right</span> 
<span class="token operator">=</span> e
<span class="token punctuation">;</span>
    c
<span class="token punctuation">.</span>
<span class="token property-access">right</span> 
<span class="token operator">=</span> f
<span class="token punctuation">;</span>
</pre>
        <p>The visual representation of the tree is:</p>
        <p>
            <img src="./DATA-Structures_files/graph_a.png" alt="graph_a" />
        </p>
        <p>To simplify our diagrams, we'll omit the arrowheads on the edges. Moving forward you can assume that the top node is the root and the direction of edges points downward. In other words, node A is the Root. Node A can access node B through 
        <code>a.left</code> , but Node B cannot access Node A.</p>
        <p>We now have a data structure we can use to explore Binary Tree algorithms! Creating a tree in this way may be tedious and repetitive, however it allows us to decide exactly what nodes are connected and in what direction. This is will be useful as we account for edge cases in our design.</p>
        <h3 class="mume-header" id="basic-tree-terminology">Basic Tree Terminology</h3>
        <ul>
            <li>tree - graph with no cycles</li>
            <li>binary tree - tree where nodes have at most 2 nodes</li>
            <li>root - the ultimate parent, the single node of a tree that can access every other node through edges; by definition the root will not have a parent</li>
            <li>internal node - a node that has children</li>
            <li>leaf - a node that does not have any children</li>
            <li>path - a series of nodes that can be traveled through edges - for example A, B, E is a path through the above tree</li>
        </ul>
        <p>Now that we have the basic definition of a binary tree, let's begin with three short algorithms that print out the values. The algorithms are structurally the same, however they will differ in what order the values are printed. We'll use the following tree as the input when running these algorithms:</p>
        <p>
            <img src="./DATA-Structures_files/graph_a.png" alt="graph_a" />
        </p>
        <h2 class="mume-header" id="in-order">In-Order</h2>
        <p>Let's begin with the 
        <code>inOrderPrint</code> function. All three of our algorithms will be recursive and have the same base case. As always, our base case should cover the scenario where the input is trivially small enough so that we don't need to perform further calculation. Since our "problem" is to print all values in a tree, what is the simplest tree we can be given? The empty tree! A common mistake when designing recursive tree algorithms is to make the base case about the root being a leaf, instead we'll want the basecase to cover the root being empty:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">inOrderPrint</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>root 
<span class="token operator">===</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>
    
<span class="token comment">//...some code here</span>
<span class="token punctuation">}</span>
</pre>
        <p>Note that taking in an entire tree as input is really just a matter of taking in the root node. This is because the root node can access every other node through a path of edges. Our base case says, "if the tree is empty, return since there is nothing to print."</p>
        <p>Here is where the meat of the algorithm comes in. Given the root of a tree, the steps for 
        <code>inOrderPrint</code> are:</p>
        <pre class="language-text">
- print all nodes in the left subtree
- print root
- print all nodes in the right subtree
</pre>
        <p>Translating this into code:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">function</span> 
<span class="token function">inOrderPrint</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>

        
<span class="token function">inOrderPrint</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token function">inOrderPrint</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

<span class="token maybe-class-name">Given</span> our tree
<span class="token punctuation">,</span> 
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">inOrderPrint</span>
    <span class="token template-punctuation string">`</span>
</span> would print the values 
<span class="token keyword">in</span> the order
<span class="token operator">:</span> 
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">d, b, e, a, c, f</span>
    <span class="token template-punctuation string">`</span>
</span>

<span class="token maybe-class-name">In</span>
<span class="token operator">-</span>
<span class="token maybe-class-name">Order</span> has the pattern 
<span class="token keyword">of</span> left
<span class="token punctuation">,</span> self
<span class="token punctuation">,</span> right
<span class="token punctuation">.</span> 
<span class="token property-access token maybe-class-name">This</span> means
<span class="token operator">:</span>

<span class="token operator">-</span>   a node can only be printed once it's left subtree has been completely printed
<span class="token punctuation">.</span>
<span class="token operator">-</span>   a node's right subtree can only be printed once the node itself has been printed
<span class="token punctuation">.</span>

## 
<span class="token maybe-class-name">Pre</span>
<span class="token operator">-</span>
<span class="token maybe-class-name">Order</span>

<span class="token maybe-class-name">Given</span> the root 
<span class="token keyword">of</span> a tree
<span class="token punctuation">,</span> the steps 
<span class="token keyword control-flow">for</span> 
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">preOrderPrint</span>
    <span class="token template-punctuation string">`</span>
</span> are
<span class="token operator">:</span>

    
<span class="token operator">-</span> print root
    
<span class="token operator">-</span> print all nodes 
<span class="token keyword">in</span> the left subtree
    
<span class="token operator">-</span> print all nodes 
<span class="token keyword">in</span> the right subtree

<span class="token maybe-class-name">Translating</span> 
<span class="token keyword">this</span> into code
<span class="token operator">:</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>`js
    
<span class="token keyword">function</span> 
<span class="token function">preOrderPrint</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>

        
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token function">preOrderPrint</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token function">preOrderPrint</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

</pre>
        <p>Given our tree, 
        <code>preOrderPrint</code> would print the values in the order: 
        <code>a, b, d, e, c, f</code></p>
        <p>Pre-Order has the patten of self, left, right. This means:</p>
        <ul>
            <li>a node must be printed before it's children</li>
            <li>a node's left subtree must be printed before it's right subtree</li>
        </ul>
        <h2 class="mume-header" id="post-order">Post-Order</h2>
        <p>Given the root of a tree, the steps for 
        <code>postOrderPrint</code> are:</p>
        <pre class="language-text">
- print all nodes in the left subtree
- print all nodes in the right subtree
- print root
</pre>
        <p>Translating this into code:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">postOrderPrint</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>

    
<span class="token function">postOrderPrint</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token function">postOrderPrint</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <p>Given our Tree, 
        <code>postOrderPrint</code> would print the values in the order: 
        <code>d, e, b, f, c, a</code></p>
        <p>Post-Order has the pattern of left, right, self. This means:</p>
        <ul>
            <li>a node can only be printed after it's left and right subtrees</li>
            <li>a node's left subtree is printed before it's right subtree</li>
        </ul>
        <hr />
        <h3 class="mume-header" id="end-of-binary-trees">End of Binary-Trees</h3>
        <hr />
        <hr />
        <h1 class="mume-header" id="binary-search-trees">Binary-Search-Trees</h1>
        <hr />
        <h3 class="mume-header" id="bst-definition">BST Definition</h3>
        <p>We can also describe a BST using a recursive definition. A 
        <strong>Binary Tree</strong> is a 
        <strong>Binary Search Tree</strong> if:</p>
        <ul>
            <li>the left subtree contains values less than the root</li>
            <li>AND the right subtree contains values greater than or equal to the root</li>
            <li>AND the left subtree is a Binary Search Tree</li>
            <li>AND the right subtree is a Binary Search Tree</li>
        </ul>
        <p>It's worth mentioning that the empty tree (a tree with 0 nodes) is indeed a BST (did someone say base case?).</p>
        <p>Here are a few examples of BSTs:</p>
        <p>
            <img src="./DATA-Structures_files/bsts.png" alt="bsts" />
        </p>
        <p>Take a moment to verify that the above binary trees are BSTs. Note that image 2 has the sane chain structure as a linked list. This will come into play later.</p>
        <p>Below is an example of a binary tree that is 
        <strong>not</strong> a search tree because a left child (35) is greater than it's parent (23):</p>
        <p>
            <img src="./DATA-Structures_files/not_bst.png" alt="not_bst" />
        </p>
        <h3 class="mume-header" id="a-bst-is-a-sorted-data-structure">A BST is a Sorted Data Structure</h3>
        <p>So what's the big deal with BSTs? Well, because of the properties of a BST, we can consider the tree as having an order to the values. That means the values are fully sorted! By looking at the three BST examples above, you are probably not convinced of things being sorted. This is because the ordering is encoded by an inorder traversal. Let's recall our previous 
        <code>inOrderPrint</code> function:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">inOrderPrint</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>

    
<span class="token function">inOrderPrint</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token function">inOrderPrint</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <p>If we run 
        <code>inOrderPrint</code> on the three BSTs, we will get the following output:</p>
        <pre class="language-text">
BST 1: 42
BST 2: 4, 5, 6
BST 3: 1, 5, 7, 10, 16, 16
</pre>
        <p>For each tree, we printed out values in increasing order! A binary search tree contains sorted data; this will come into play when we perform algorithms on this data structure.</p>
        <h3 class="mume-header" id="naive-bst-implementation">Naive BST Implementation</h3>
        <p>Let's implement a 
        <code>BST</code> class that will maintain the ordered property through any number of insertions into the tree. We are going to avoid manually creating all nodes and explicitly setting 
        <code>left</code> s and 
        <code>right</code> s, so we don't have to worry about breaking order. We'll use our classic 
        <code>TreeNode</code> as a component of 
        <code>BST</code> . In addition, we'll need a proper 
        <code>BST#insert</code> method that will conduct legal insertions on the tree. Interpret the code below and scroll further to our annotated version when you need clarification:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">class</span> 
<span class="token class-name">TreeNode</span> 
<span class="token punctuation">{</span>
    
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token parameter">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">val</span> 
<span class="token operator">=</span> val
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">left</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">right</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> 
<span class="token class-name">BST</span> 
<span class="token punctuation">{</span>
    
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

    
<span class="token function">insert</span>
<span class="token punctuation">(</span>
<span class="token parameter">val
<span class="token punctuation">,</span> root 
<span class="token operator">=</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span></span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span> 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>

        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>val 
<span class="token operator">&lt;</span> root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
                root
<span class="token punctuation">.</span>
<span class="token property-access">left</span> 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
                
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">,</span> root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token punctuation">}</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
                root
<span class="token punctuation">.</span>
<span class="token property-access">right</span> 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
                
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">,</span> root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token punctuation">}</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
        <pre class="language-text">
// commented naive BST class
</pre>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">class</span> 
<span class="token class-name">BST</span> 
<span class="token punctuation">{</span>
        
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token comment">// initialize the tree to be empty</span>
            
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span> 
<span class="token operator">=</span> 
<span class="token keyword null nil">null</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>

        
<span class="token function">insert</span>
<span class="token punctuation">(</span>
<span class="token parameter">val
<span class="token punctuation">,</span> root
<span class="token operator">=</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span></span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token comment">// if the tree is currently empty, then create the node as the 'absolute' root</span>
            
<span class="token keyword control-flow">if</span>
<span class="token punctuation">(</span>
<span class="token operator">!</span>
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
                
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span> 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
                
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>
            
<span class="token punctuation">}</span>

            
<span class="token comment">// otherwise, the tree is not empty, so...</span>
            
<span class="token comment">// if our val to insert is less than the root...</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>val 
<span class="token operator">&lt;</span> root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
                
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>                      
<span class="token comment">//...some code hereand the left child does not exist,</span>
                    root
<span class="token punctuation">.</span>
<span class="token property-access">left</span> 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>      
<span class="token comment">//      then create the node as the left child</span>
                
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>                               
<span class="token comment">//...some code hereand the left child already exists,</span>
                    
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">,</span> root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>        
<span class="token comment">//      then recursively insert on the left subtree</span>
                
<span class="token punctuation">}</span>

            
<span class="token comment">// if our val to insert is greater than or equal to the root...</span>
            
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
                
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>                      
<span class="token comment">//  ...and the right child does not exist,</span>
                    root
<span class="token punctuation">.</span>
<span class="token property-access">right</span> 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">TreeNode</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>     
<span class="token comment">//      then create the node as the right child</span>
                
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>                                
<span class="token comment">//  ...and the right child already exists,</span>
                    
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">,</span> root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>       
<span class="token comment">//      then recursively insert on the right subtree</span>
                
<span class="token punctuation">}</span>
            
<span class="token punctuation">}</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

<span class="token maybe-class-name">We</span> can call 
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">insert</span>
    <span class="token template-punctuation string">`</span>
</span> to build up the 
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token string">BST</span>
    <span class="token template-punctuation string">`</span>
</span> without worrying about breaking the search tree property
<span class="token punctuation">.</span> 
<span class="token property-access token maybe-class-name">Let</span>'s build two different trees
<span class="token operator">:</span>

    
<span class="token keyword">let</span> tree1 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">BST</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree1
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">10</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree1
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">5</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree1
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">16</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree1
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree1
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">7</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree1
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">16</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    
<span class="token keyword">let</span> tree2 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">BST</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree2
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree2
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">5</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree2
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">7</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree2
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">10</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree2
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">16</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    tree2
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">16</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
</pre>
        <p>The insertions above will yield the following trees:</p>
        <p>
            <img src="./DATA-Structures_files/good_bad_bst.png" alt="good_bad_bst" />
        </p>
        <p>Are you cringing at 
        <code>tree2</code> ? You should be. Although we have the same values in both trees, they display drastically different structures because of the insertion order we used. This is why we have been referring to our 
        <code>BST</code> implementation as 
        <strong>naive</strong>. Both of these trees are Binary Search Trees, however not all BSTs are created equal. A worst case BST degenerates into a linked list. The "best" BSTs are 
        <strong>height balanced</strong>, we'll explore this concept soon</p>
        <h3 class="mume-header" id="implementing-binary-search-on-a-bst">Implementing Binary Search on a BST</h3>
        <p>Our goal is to implement a 
        <code>#search</code> method on our previous 
        <code>BST</code> class that will solve the problem:</p>
        <pre class="language-text">
Given a binary search tree and a target value, return a boolean indicating whether or not the target is
contained in the tree.
</pre>
        <p>In other words, our 
        <code>BST#search</code> should satisfy the following behavior:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">let</span> tree 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">BST</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
tree
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">10</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
tree
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">5</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
tree
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">16</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
tree
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
tree
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">7</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
tree
<span class="token punctuation">.</span>
<span class="token method function property-access">insert</span>
<span class="token punctuation">(</span>
<span class="token number">16</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

tree
<span class="token punctuation">.</span>
<span class="token method function property-access">search</span>
<span class="token punctuation">(</span>
<span class="token number">7</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; true</span>
tree
<span class="token punctuation">.</span>
<span class="token method function property-access">search</span>
<span class="token punctuation">(</span>
<span class="token number">16</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; true</span>
tree
<span class="token punctuation">.</span>
<span class="token method function property-access">search</span>
<span class="token punctuation">(</span>
<span class="token number">14</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span> 
<span class="token comment">// =&gt; false</span>
</pre>
        <p>As with many tree problems, this problem lends itself nicely to recursion! Like always, our base case should capture the scenario where the input tree is trivial and we know the answer to the problem without further calculation. If the given tree is empty, then we can be certain that the target is not found in the tree. The logic of our 
        <code>BST#search</code> method will be much the same compared to our 
        <code>binarySearch</code> function for sorted arrays. Try to interpret the code below and scroll further to the annotated version when you need clarification</p>
        <pre class="language-text">
// assuming our BST class from the previous section
</pre>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">class</span> 
<span class="token class-name">BST</span> 
<span class="token punctuation">{</span>
    
<span class="token comment">//...some code here</span>

    
<span class="token function">search</span>
<span class="token punctuation">(</span>
<span class="token parameter">val
<span class="token punctuation">,</span> root 
<span class="token operator">=</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span></span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> 
<span class="token boolean">false</span>
<span class="token punctuation">;</span>

        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>val 
<span class="token operator">&lt;</span> root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">search</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">,</span> root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>val 
<span class="token operator">&gt;</span> root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">search</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">,</span> root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword control-flow">return</span> 
<span class="token boolean">true</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// assuming our BST class from the previous section</span>
<span class="token keyword">class</span> 
<span class="token class-name">BST</span> 
<span class="token punctuation">{</span>
    
<span class="token comment">//...some code here</span>

    
<span class="token comment">// commented</span>
    
<span class="token function">search</span>
<span class="token punctuation">(</span>
<span class="token parameter">val
<span class="token punctuation">,</span> root 
<span class="token operator">=</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">root</span></span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token comment">// if the tree is empty, then the target val is not in the tree, so return false</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span> 
<span class="token boolean">false</span>
<span class="token punctuation">;</span>

        
<span class="token comment">// otherwise the tree is not empty, so...</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>val 
<span class="token operator">&lt;</span> root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token comment">// if the target is less than the root,</span>
            
<span class="token comment">//  then search the left subtree</span>
            
<span class="token keyword control-flow">return</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">search</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">,</span> root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>val 
<span class="token operator">&gt;</span> root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token comment">// if the target is greater than the root,</span>
            
<span class="token comment">//  then search the right subtree</span>
            
<span class="token keyword control-flow">return</span> 
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">search</span>
<span class="token punctuation">(</span>val
<span class="token punctuation">,</span> root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span> 
<span class="token keyword control-flow">else</span> 
<span class="token punctuation">{</span>
            
<span class="token comment">// otherwise, the target must be equal to the root</span>
            
<span class="token comment">// so return true since we found it!</span>
            
<span class="token keyword control-flow">return</span> 
<span class="token boolean">true</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
        <h3 class="mume-header" id="height-balance">Height Balance</h3>
        <p>Before we analyze the time complexity of 
        <code>BST#search</code> , we'll first need to learn about height balance. Recalling what we touched on briefly in our chat on binary trees, 
        <strong>height</strong> is defined as the number of edges between the root and farthest leaf in a tree. Note that height is dictated by the 
        <strong>farthest</strong> leaf (think worst case):</p>
        <p>
            <img src="./DATA-Structures_files/height.png" alt="height" />
        </p>
        <p>Following this definition, a tree consisting of a single node has height 0. We consider then an empty tree as having height -1. Height is relevant because not all BSTs are created equal! That is, some BSTs have "good / small" heights, others have "bad / large" heights. Take a look at these two BSTs containing identical values, but very different heights:</p>
        <p>
            <img src="./DATA-Structures_files/balanced_unbalanced.png" alt="balanced_unbalanced" />
        </p>
        <p>
        <code>Tree 1</code> is preferred over 
        <code>Tree 2</code> , because 
        <code>Tree 1</code> is 
        <strong>balanced</strong>. Balanced Binary Trees will be the most efficient to perform operations on.</p>
        <p>For a binary tree to be 
        <strong>balanced</strong>:</p>
        <ul>
            <li>the left and right subtrees must differ in height by at most 1</li>
            <li>AND the left subtree is balanced</li>
            <li>AND the right subtree is balanced</li>
        </ul>
        <p>Notice that 
        <strong>balanced</strong> has a recursive definition. Like you probably guessed, the empty tree is considered balanced. This will be the base case of our definition.</p>
        <h3 class="mume-header" id="only-the-best-trees-have-logs">Only the Best Trees Have Logs</h3>
        <p>A balanced binary tree is incredible to have because it's height is guaranteed to be 
        <strong>O(log2(n))</strong>, where n is the number of nodes in the tree. Let's take a look at a few examples:</p>
        <p>
            <img src="./DATA-Structures_files/log_heights.png" alt="log_heights" />
        </p>
        <p>To make the approximations above, we rounded the result of each log down to the nearest integer. If you are not convinced of how powerful this is, this means that a balanced tree of 1000 nodes will have a height of just 10.</p>
        <h3 class="mume-header" id="time-complexity-analysis-of-binary-search-for-bsts">Time Complexity Analysis of Binary Search for BSTs</h3>
        <p>Worst case for the algorithm occurs when the target value is not present in the tree. This means that we must traverse a path from root to a leaf, so we must travel the full 
        <strong>height</strong> of the tree in the worst case. However, like we discussed, the height of a tree can vary wildly. We can have a tree with minimal height (a balanced tree like 
        <code>Tree 1</code> ), or we can have a tree with maximal height (a linked list like 
        <code>Tree 2</code> ).</p>
        <ul>
            <li>
            <strong>O(log(n))</strong> time for a balanced tree:</li>
            <li>
            <strong>O(n)</strong> time for unbalanced tree:</li>
        </ul>
        <h3 class="mume-header" id="space-complexity-analysis-of-binary-search-for-bsts">Space Complexity Analysis of Binary Search for BSTs</h3>
        <p>No additional space is needed for the algorithm, so we have constant 
        <strong>O(1)</strong> space.</p>
        <p>To play devil's advocate, what if we count the recursive stack calls as contributing to the space complexity? Some coding challenges in your job hunt may pose this. If that is the case then our recursive implementation above will use:</p>
        <ul>
            <li>
            <strong>O(log(n))</strong> space for a balanced tree</li>
            <li>
            <strong>O(n)</strong> space for unbalanced tree</li>
        </ul>
        <hr />
        <h3 class="mume-header" id="end-of-binary-search-trees">End of Binary-Search-Trees</h3>
        <hr />
        <p>Let's add two more tree traversal algorithms to our arsenal. 
        <strong>Depth-First</strong> and 
        <strong>Breadth-First</strong> are two classic traversal strategies that differ in the order nodes are hit. In this reading, our candidate tree will be:</p>
        <p>
            <img src="./DATA-Structures_files/graph_a.png" alt="tree" />
        </p>
        <p>Like we are accustomed to, we can represent the tree programmatically with:</p>
        <pre class="language-text">
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}


let a = new TreeNode('a');
let b = new TreeNode('b');
let c = new TreeNode('c');
let d = new TreeNode('d');
let e = new TreeNode('e');
let f = new TreeNode('f');

a.left = b;
a.right = c;
b.left = d;
b.right = e;
c.right = f;
</pre>
        <h2 class="mume-header" id="depth-first">Depth-First</h2>
        <p>To help verbalize Depth-First (DF), we'll be using a few familial terms to describe the relative positions of the nodes. Think of the words you would use if viewing a family tree! Here are some examples:</p>
        <ul>
            <li>
            <code>B</code> and 
            <code>C</code> are siblings</li>
            <li>
            <code>D</code> and 
            <code>E</code> are descendants of 
            <code>B</code></li>
            <li>
            <code>B</code>, 
            <code>C</code>, 
            <code>D</code>, 
            <code>E</code>, 
            <code>F</code> are all descendants of 
            <code>A</code></li>
        </ul>
        <p>A Depth-First traversal will continually travel deeper into a tree before switching branches. This means that, given a node, we must visit all of it's descendants before visiting it's sibling.</p>
        <p>Performing DF on our tree will hit the nodes in the order: 
        <code>A, B, D, E, C, F</code></p>
        <h3 class="mume-header" id="depth-first-implementation">Depth-First Implementation</h3>
        <p>To travel the nodes of a tree according to Depth-First behavior, we'll utilize a 
        <strong>stack.</strong> Recall from earlier that a stack is LIFO (Last In, First Out). Our strategy is to use an array as a stack. We'll use 
        <code>push</code> to add to the top of our stack and 
        <code>pop</code> to remove the top. Below is a complete implementation of 
        <code>depthFirst</code> . Try to interpret the code below and scroll further to see the annotated version:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">function</span> 
<span class="token function">depthFirst</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">let</span> stack 
<span class="token operator">=</span> 
<span class="token punctuation">[</span> root 
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
        
<span class="token keyword control-flow">while</span> 
<span class="token punctuation">(</span>stack
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">let</span> node 
<span class="token operator">=</span> stack
<span class="token punctuation">.</span>
<span class="token method function property-access">pop</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span> stack
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span> stack
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>`js
    
<span class="token keyword">function</span> 
<span class="token function">depthFirst</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token comment">// initialize the stack with the root node</span>
        
<span class="token keyword">let</span> stack 
<span class="token operator">=</span> 
<span class="token punctuation">[</span> root 
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>

        
<span class="token comment">// continue running the algorithm while there are still nodes on the stack</span>
        
<span class="token keyword control-flow">while</span> 
<span class="token punctuation">(</span>stack
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>

            
<span class="token comment">// pop the top node from the stack</span>
            
<span class="token keyword">let</span> node 
<span class="token operator">=</span> stack
<span class="token punctuation">.</span>
<span class="token method function property-access">pop</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

            
<span class="token comment">// we consider a node visited once we pop it,</span>
            
<span class="token comment">// so we should print the node's value now</span>
            
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

            
<span class="token comment">// add the node's left and right children, if they exist</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span> stack
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span> stack
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

            
<span class="token comment">// IMPORTANT: do not print out the children yet; they must wait their turn to be popped first</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

</pre>
        <p>You should watch the video lecture that follows this reading for a visual on how a stack inherently gives us DF order. For now, a key idea to take away is that we only consider a node "visited" once we pop it. We do not consider a node "visited" when we push it.</p>
        <p>Because a stack naturally leads to DF order on a tree, we can easily write a recursive version. Why is recursion relevant to DF? Recursion utilizies the call 
        <strong>stack</strong>:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">depthFirstRecur</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>
<span class="token operator">!</span>root
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>
    
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token function">depthFirstRecur</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token function">depthFirstRecur</span>
<span class="token punctuation">(</span>root
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <p>Does this code look familiar? It's identical to the 
        <code>preOrderPrint</code> function we wrote previously. That's right, pre-order and depth-first are identical tree node orderings.</p>
        <p>You should study both the iterative and recursive implementations as they will both prove valuable to solving problems.</p>
        <h2 class="mume-header" id="breadth-first">Breadth-First</h2>
        <p>This algorithm has nothing to do with bread. The word "breadth" is the same as "width". To help veribalize Breadth-First (BF) we'll need to understand the simple concept of tree 
        <strong>levels</strong>. With the tree at the top of this reading in mind, we can say the following:</p>
        <ul>
            <li>level 0 contains 
            <code>A</code></li>
            <li>level 1 contains 
            <code>B</code>, 
            <code>C</code></li>
            <li>level 2 contains 
            <code>D</code>, 
            <code>E</code>, 
            <code>F</code></li>
        </ul>
        <p>A Breadth-First traversal will visit all nodes across a level, before moving to the next level. This means we travel laterally as much as we can before going deeper into the tree.</p>
        <p>Perform BF on our tree will hit the nodes in the order: 
        <code>A, B, C, D, E, F</code></p>
        <h3 class="mume-header" id="breadth-first-implementation">Breadth-First Implementation</h3>
        <p>While DF uses a stack, BF will use a 
        <strong>queue</strong>. Recall that a queue is FIFO (First In, First Out). The code is very similar to our iterative DF, except we will use an array as a queue. 
        <code>shift</code> will remove the front of the queue and 
        <code>push</code> will add to the back of the queue. Interpret the implementation below and scroll further to the annotated version when you need more insight:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">function</span> 
<span class="token function">breadthFirst</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">let</span> queue 
<span class="token operator">=</span> 
<span class="token punctuation">[</span> root 
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
        
<span class="token keyword control-flow">while</span> 
<span class="token punctuation">(</span>queue
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token keyword">let</span> node 
<span class="token operator">=</span> queue
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

            
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span> queue
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span> queue
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>`js
    
<span class="token keyword">function</span> 
<span class="token function">breadthFirst</span>
<span class="token punctuation">(</span>
<span class="token parameter">root</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token comment">// initialize the queue with the root node</span>
        
<span class="token keyword">let</span> queue 
<span class="token operator">=</span> 
<span class="token punctuation">[</span> root 
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>

        
<span class="token comment">// continue running the algorithm while there are still nodes on the queue</span>
        
<span class="token keyword control-flow">while</span> 
<span class="token punctuation">(</span>queue
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token comment">// remove the front node from the queue</span>
            
<span class="token keyword">let</span> node 
<span class="token operator">=</span> queue
<span class="token punctuation">.</span>
<span class="token method function property-access">shift</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

            
<span class="token comment">// the node we just removed is now "visited", so print it</span>
            
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

            
<span class="token comment">// add the left and right children to the back of the queue, if they exist</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span> queue
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">left</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
            
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span> queue
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">right</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

            
<span class="token comment">// IMPORTANT: do not print out the children yet; they must wait their turn to exit the front of the queue first</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

</pre>
        <p>We'll rarely run into a recursive BF implementation (probably never) because recursion uses an underlying call stack, but we really want the opposite of a stack (a queue).</p>
        <hr />
        <h1 class="mume-header" id="graphs-graph-traversal">Graphs &amp; Graph Traversal</h1>
        <hr />
        <h2 class="mume-header" id="what-is-a-graph-1">What is a Graph?</h2>
        <p>A 
        <strong>graph</strong> is 
        <strong>any</strong> collection of nodes and edges. In contrast to our previous trees, a graph is much more relaxed in it's structure. A graph may:</p>
        <ul>
            <li>lack a root node</li>
            <li>have cycles</li>
            <li>have any number edges leaving a node</li>
        </ul>
        <p>In this section, we will draw heavily from our tree algorithms. The adjustments we will make to those algorithms will be motivated by these core differences.</p>
        <p>Below are a few examples of graphs that don't agree with our CompSci definition of a binary tree:</p>
        <p>
            <img src="./DATA-Structures_files/graphs(1).png" alt="graphs" />
        </p>
        <p>Here are some highlights:</p>
        <ul>
            <li>
            <code>Graph 1</code> lacks a root. This means there is no single node that can access all other nodes in a path through edges. This is important because we previously referenced "entire" trees by referring to the ultimate root. We can no longer do that in a graph. If we provide just 
            <code>T</code>, you can't access 
            <code>U</code>. If we provide just 
            <code>U</code>, you can't access 
            <code>T</code>. If we provide just 
            <code>V</code>, you can't access 
            <code>T</code> or 
            <code>U</code>.</li>
            <li>
            <code>Graph 2</code> has a cycle. This means there is no longer a parent-child relationship. Choose any node in 
            <code>Graph 2</code>, its grandchild will also be its parent. Wait - what? From now on we'll have to use less specific language such as "
            <code>X</code> is a neighbor of 
            <code>Y</code>." Perhaps even more deadly, imagine we ran a "simple" Depth-First traversal on this graph. We could get trapped in an infinite loop if we are not careful.</li>
            <li>
            <code>Graph 3</code> features nodes that have more than 2 edges. Anarchy!</li>
        </ul>
        <h2 class="mume-header" id="graph-implementations">Graph Implementations</h2>
        <p>There are many ways to represent a graph programmatically. Let's take a moment to explore each and describe the tradeoffs we make when choosing among them. We will use 
        <code>Graph 3</code> from above as our candidate. Bear in mind that our graph is directed. For example, this means that 
        <code>C</code> can access 
        <code>D</code> , but 
        <code>D</code> cannot access 
        <code>C</code> .</p>
        <h3 class="mume-header" id="graphnode-class">GraphNode Class</h3>
        <p>This implementation is most similar to how we implemented binary trees. That is, we create a node class that maintains a value and an array of references to neighboring nodes. This easily solves the problem that a node can have any number of neighbors, no longer just a left and right.</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">class</span> 
<span class="token class-name">GraphNode</span> 
<span class="token punctuation">{</span>
    
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token parameter">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">val</span> 
<span class="token operator">=</span> val
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"a"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> b 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"b"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> c 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"c"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> d 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"d"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> e 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"e"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> f 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"f"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
a
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>b
<span class="token punctuation">,</span> c
<span class="token punctuation">,</span> e
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
c
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>b
<span class="token punctuation">,</span> d
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
e
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>a
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
f
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>e
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
</pre>
        <p>This implementation is great because it feels familiar to how we implemented trees. However, this implementation is clunky in that we have no easy way to refer to the entire graph. How can we pass this graph to a function? Recall that there is no root to act as the definite starting point.</p>
        <h3 class="mume-header" id="adjacency-matrix">Adjacency Matrix</h3>
        <p>This is the often the mathematician's preferred way of representing a graph. We use a 2D array to represent edges. We'll first map each node's value to an index. This means 
        <code>A -&gt; 0</code> , 
        <code>B -&gt; 1</code> , 
        <code>C -&gt; 2</code> , etc.. Below is the mapping for 
        <code>Graph 3</code> :</p>
        <p>
            <img src="./DATA-Structures_files/adj_matrix_graph.png" alt="adj_matrix_graph" />
        </p>
        <p>From here, the row index will correspond to the source of an edge and the column index will correspond to its destination. A value of 
        <code>true</code> will mean that there does exist an edge from source to destination.</p>
        <pre class="language-text">
let matrix = [
/*          A       B       C       D       E       F   */
/*A*/    [true,  true,   true,   false,  true,   false],
/*B*/    [false, true,   false,  false,  false,  false],
/*C*/    [false, true,   true,   true,   false,  false],
/*D*/    [false, false,  false,  true,   false,  false],
/*E*/    [true,  false,  false,  false,  true,   false],
/*F*/    [false, false,  false,  false,  true,   true]
];
</pre>
        <p>A few things to note about using an adjacency matrix:</p>
        <ul>
            <li>when the edges have direction, 
            <code>matrix[i][j]</code> may not be the same as 
            <code>matrix[j][i]</code></li>
            <li>it is common to say that a node is adjacent to itself, so 
            <code>matrix[x][x] === true</code> for any 
            <code>x</code></li>
        </ul>
        <p>An advantage of the matrix implementation is that it allows us to refer to the entire graph by simply referring to the 2D array. A huge disadvantage of using a matrix is the space required. To represent a graph of n nodes, we must allocate n2 space for the 2D array. This is even more upsetting when there are few edges in graph. We will have to use n2 space, even though the array would be sparse with only a few 
        <code>true</code> elements.</p>
        <h3 class="mume-header" id="adjacency-list">Adjacency List</h3>
        <p>An adjacency list seeks to solve the shortcomings of the matrix implementation. We use an object where keys represent the node labels. The values associated with the keys will be an array containing all adjacent nodes:</p>
        <pre class="language-text">
let graph = {
    'a': ['b', 'c', 'e'],
    'b': [],
    'c': ['b', 'd'],
    'd': [],
    'e': ['a'],
    'f': ['e']
};
</pre>
        <p>An adjacency list is easy to implement and allows us to refer to the entire graph by simply referencing the object. The space required for an adjacency list is the number of edges in the graph. Since there will be at most n2 edges in a graph of n nodes, the adjacency list will use at most the same amount of space as the matrix. You'll find adjacency lists useful when attacking problems that are not explicitly about graphs. We'll elaborate more on this soon.</p>
        <p>Let's explore our classic Depth-First, but for 
        <strong>graphs</strong> this time! We'll be utilizing the 
        <code>GraphNode</code> and 
        <code>Adjacency List</code> implementations of the following graph:</p>
        <p>
            <img src="./DATA-Structures_files/graph.png" alt="graph" />
        </p>
        <p>Since we already discussed the differences between Depth-First and Breadth-First, we'll focus just on Depth-First here. We'll leave the Breadth-First exploration in the upcoming project.</p>
        <h3 class="mume-header" id="graph-traversal-w-graphnode">Graph Traversal w/ GraphNode</h3>
        <p>Let's begin by assuming we have our candidate graph implemented using our 
        <code>GraphNode</code> class:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">class</span> 
<span class="token class-name">GraphNode</span> 
<span class="token punctuation">{</span>
    
<span class="token function">constructor</span>
<span class="token punctuation">(</span>
<span class="token parameter">val</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">val</span> 
<span class="token operator">=</span> val
<span class="token punctuation">;</span>
        
<span class="token keyword">this</span>
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"a"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> b 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"b"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> c 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"c"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> d 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"d"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> e 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"e"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token keyword">let</span> f 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">GraphNode</span>
<span class="token punctuation">(</span>
<span class="token string">"f"</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
a
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>e
<span class="token punctuation">,</span> c
<span class="token punctuation">,</span> b
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
c
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>b
<span class="token punctuation">,</span> d
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
e
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>a
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
f
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span> 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>e
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>
</pre>
        <p>One thing we'll have to decide on is what node to begin our traversal. Depending on the structure of the graph, there may not be a suitable starting point. Remember that a graph may not have a "root". However in our candidate, 
        <code>F</code> is like a root. It is the only valid choice because it is the only node that may access all other nodes through some path of edges. We admit, the choice of 
        <code>F</code> is somewhat contrived and in a practical setting you may not have a nice starting point like this. We'll cover how to overcome this obstacle soon. For now we'll take 
        <code>F</code> .</p>
        <p>We want to build a recursive 
        <code>depthFirstRecur</code> function that accepts a node and performs a Depth-First traversal through the graph. Let's begin with a baseline solution, although it is not yet complete to handle all graphs: // broken</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">depthFirstRecur</span>
<span class="token punctuation">(</span>
<span class="token parameter">node</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    node
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">forEach</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">neighbor</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> 
<span class="token punctuation">{</span>
        
<span class="token function">depthFirstRecur</span>
<span class="token punctuation">(</span>neighbor
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <pre data-role="codeBlock" data-info="" class="language-">
<code>    depthFirstRecur(f);

Can you see where this code goes wrong? It will get caught in an infinite cycle `f, e, a, e, a, e, a, e, ...` ! To fix this, simply store which nodes we have visited already. Whenever we hit a node that has previously been visited, then return early. We'll use JavaScript [Sets](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) to store `visited` because they allow for constant time lookup.

    // using GraphNode representation
```js
    function depthFirstRecur(node, visited=new Set()) {
        // if this node has already been visited, then return early
        if (visited.has(node.val)) return;

        // otherwise it hasn't yet been visited,
        // so print it's val and mark it as visited.
        console.log(node.val);
        visited.add(node.val);

        // then explore each of its neighbors
        node.neighbors.forEach(neighbor =&gt; {
            depthFirstRecur(neighbor, visited);
        });
    }

</code>
</pre>
        <pre class="language-text">
depthFirstRecur(f);
</pre>
        <p>This code works well and will print the values in the order 
        <code>f, e, a, c, b, d</code> . Note that this strategy only works if the values are guaranteed to be unique.</p>
        <p>If you are averse to recursion (don't be), we can write an iterative version using the same principles:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">depthFirstIter</span>
<span class="token punctuation">(</span>
<span class="token parameter">node</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword">let</span> visited 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">Set</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token keyword">let</span> stack 
<span class="token operator">=</span> 
<span class="token punctuation">[</span>node
<span class="token punctuation">]</span>
<span class="token punctuation">;</span>

    
<span class="token keyword control-flow">while</span> 
<span class="token punctuation">(</span>stack
<span class="token punctuation">.</span>
<span class="token property-access">length</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">let</span> node 
<span class="token operator">=</span> stack
<span class="token punctuation">.</span>
<span class="token method function property-access">pop</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

        
<span class="token comment">// if this node has already been visited, then skip this node</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>visited
<span class="token punctuation">.</span>
<span class="token method function property-access">has</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">continue</span>
<span class="token punctuation">;</span>

        
<span class="token comment">// otherwise it hasn't yet been visited,</span>
        
<span class="token comment">// so print it's val and mark it as visited.</span>
        
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        visited
<span class="token punctuation">.</span>
<span class="token method function property-access">add</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">.</span>
<span class="token property-access">val</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

        
<span class="token comment">// then add its neighbors to the stack to be explored</span>
        stack
<span class="token punctuation">.</span>
<span class="token method function property-access">push</span>
<span class="token punctuation">(</span>
<span class="token spread operator">...</span>node
<span class="token punctuation">.</span>
<span class="token property-access">neighbors</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
        <pre class="language-text">
depthFirstIter(f);
</pre>
        <h3 class="mume-header" id="graph-traversal-w-adjacency-list">Graph Traversal w/ Adjacency List</h3>
        <p>Let's now assume our candidate graph in the form of an Adjacency List:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">let</span> graph 
<span class="token operator">=</span> 
<span class="token punctuation">{</span>
        
<span class="token string">'a'</span>
<span class="token operator">:</span> 
<span class="token punctuation">[</span>
<span class="token string">'b'</span>
<span class="token punctuation">,</span> 
<span class="token string">'c'</span>
<span class="token punctuation">,</span> 
<span class="token string">'e'</span>
<span class="token punctuation">]</span>
<span class="token punctuation">,</span>
        
<span class="token string">'b'</span>
<span class="token operator">:</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">,</span>
        
<span class="token string">'c'</span>
<span class="token operator">:</span> 
<span class="token punctuation">[</span>
<span class="token string">'b'</span>
<span class="token punctuation">,</span> 
<span class="token string">'d'</span>
<span class="token punctuation">]</span>
<span class="token punctuation">,</span>
        
<span class="token string">'d'</span>
<span class="token operator">:</span> 
<span class="token punctuation">[</span>
<span class="token punctuation">]</span>
<span class="token punctuation">,</span>
        
<span class="token string">'e'</span>
<span class="token operator">:</span> 
<span class="token punctuation">[</span>
<span class="token string">'a'</span>
<span class="token punctuation">]</span>
<span class="token punctuation">,</span>
        
<span class="token string">'f'</span>
<span class="token operator">:</span> 
<span class="token punctuation">[</span>
<span class="token string">'e'</span>
<span class="token punctuation">]</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">;</span>
</pre>
        <p>Bear in mind that the nodes are just strings now, not 
        <code>GraphNode</code> s. Other than that, the code shares many details from our previous implementations:</p>
        <pre class="language-text">
// using Adjacency List representation
</pre>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
<span class="token keyword">function</span> 
<span class="token function">depthFirstRecur</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">,</span> graph
<span class="token punctuation">,</span> visited 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">Set</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>visited
<span class="token punctuation">.</span>
<span class="token method function property-access">has</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">)</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>

    
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    visited
<span class="token punctuation">.</span>
<span class="token method function property-access">add</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

    graph
<span class="token punctuation">[</span>node
<span class="token punctuation">]</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">forEach</span>
<span class="token punctuation">(</span>
<span class="token punctuation">(</span>
<span class="token parameter">neighbor</span>
<span class="token punctuation">)</span> 
<span class="token arrow operator">=&gt;</span> 
<span class="token punctuation">{</span>
        
<span class="token function">depthFirstRecur</span>
<span class="token punctuation">(</span>neighbor
<span class="token punctuation">,</span> graph
<span class="token punctuation">,</span> visited
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
        <pre class="language-text">
depthFirstRecur('f', graph);
</pre>
        <p>Cool! We print values in the order 
        <code>f, e, a, b, c, d</code> . We'll leave the iterative version to you as an exercise for later.</p>
        <p>Instead, let's draw our attention to a point from before: having to choose 
        <code>f</code> as the starting point isn't dynamic enough to be impressive. Also, if we choose a poor initial node, some nodes may be unreachable. For example, choosing 
        <code>a</code> as the starting point with a call to 
        <code>depthFirstRecur('a', graph)</code> will only print 
        <code>a, b, c, d, e</code> . We missed out on 
        <code>f</code> . Bummer.</p>
        <p>We can fix this. A big advantage of using an Adjacency List is that it contains the full graph! We can use a surrounding loop to allow our traversal to jump between disconnected regions of the graph. Refactoring our code:</p>
        <pre data-role="codeBlock" data-info="js" class="language-javascript">
    
<span class="token keyword">function</span> 
<span class="token function">depthFirst</span>
<span class="token punctuation">(</span>
<span class="token parameter">graph</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword">let</span> visited 
<span class="token operator">=</span> 
<span class="token keyword">new</span> 
<span class="token class-name">Set</span>
<span class="token punctuation">(</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

        
<span class="token keyword control-flow">for</span> 
<span class="token punctuation">(</span>
<span class="token keyword">let</span> node 
<span class="token keyword">in</span> graph
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
            
<span class="token function">_depthFirstRecur</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">,</span> graph
<span class="token punctuation">,</span> visited
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
<span class="token template-string">
    <span class="token template-punctuation string">`</span>
    <span class="token template-punctuation string">`</span>
</span>`js
    
<span class="token keyword">function</span> 
<span class="token function">_depthFirstRecur</span>
<span class="token punctuation">(</span>
<span class="token parameter">node
<span class="token punctuation">,</span> graph
<span class="token punctuation">,</span> visited</span>
<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
        
<span class="token keyword control-flow">if</span> 
<span class="token punctuation">(</span>visited
<span class="token punctuation">.</span>
<span class="token method function property-access">has</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">)</span>
<span class="token punctuation">)</span> 
<span class="token keyword control-flow">return</span>
<span class="token punctuation">;</span>

        
<span class="token console class-name">console</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">log</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        visited
<span class="token punctuation">.</span>
<span class="token method function property-access">add</span>
<span class="token punctuation">(</span>node
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>

        graph
<span class="token punctuation">[</span>node
<span class="token punctuation">]</span>
<span class="token punctuation">.</span>
<span class="token method function property-access">forEach</span>
<span class="token punctuation">(</span>
<span class="token parameter">neighbor</span> 
<span class="token arrow operator">=&gt;</span> 
<span class="token punctuation">{</span>
            
<span class="token function">_depthFirstRecur</span>
<span class="token punctuation">(</span>neighbor
<span class="token punctuation">,</span> graph
<span class="token punctuation">,</span> visited
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
        
<span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

</pre>
        <pre class="language-text">
depthFirst(graph);
</pre>
        <p>Notice that our main function 
        <code>depthFirst</code> is iterative and accepts the entire Adjacency List as an arg. Our helper 
        <code>_depthFirstRecur</code> is recursive. 
        <code>_depthFirstRecur</code> serves the same job as before, it will explore a full connected region in a graph. The main 
        <code>depthFirst</code> method will allow us to "bridge" the gap between connection regions.</p>
        <p>Still fuzzy? Imagine we had the following graph. Before you ask, these are not two separate graphs. This is a 
        <strong>single</strong> graph that contains two connected components. Another term for a graph of this structure is a "Forest" because it contains multiple "Trees", ha:</p>
        <p>
            <img src="./DATA-Structures_files/forest.png" alt="forest" />
        </p>
        <p>It is easy to represent this graph using an Adjacency List. We can then pass the graph into our 
        <code>depthFirst</code> from above:</p>
        <pre class="language-text">
let graph = {
    'h': ['i', 'j'],
    'i': [],
    'j': ['k'],
    'k': [],
    'l': ['m'],
    'm': []
}
</pre>
        <pre data-role="codeBlock" data-info="" class="language-">
<code>    depthFirst(graph);
    // prints h, i, j, k, l, m

Here's the description for how `depthFirst` operates above. We enter `depthFirst` and the for loop begins on `h` . This means we enter our `_depthFirstRecur` , which will continue to explore the "local" region as far as possible. When this recursion ends, we would have explored the entire connected region of `h, i, j, k` (note that we add these nodes to visited as well). Our recursive call then returns to the main `depthFirst` function, where we continue the for loop. We iterate it until we hit an unvisited node ( `l` ) and then explore it's local region as far as possible using `_depthFirstRecur` , hitting the last node `m` .
</code>
</pre>
    </div>
    <div class="md-sidebar-toc">
        <ul>
            <li>
                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#efficient-sorting-algorithms">Efficient Sorting Algorithms</a>
                <ul>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#the-algorithm-divide-and-conquer">The Algorithm: "Divide and Conquer"</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#merge">Merge</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#merge-sort-recursion">Merge Sort Recursion</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-and-space-complexity-analysis">Time and Space Complexity Analysis</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-complexity-on-logn">Time Complexity: O(n log(n))</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#space-complexity-on">Space Complexity: O(n)</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#when-should-we-use-merge-sort">When should we use Merge Sort?</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#how-does-it-work">How does it work?</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#the-algorithm-divide-and-conquer-1">The Algorithm: "Divide and Conquer"</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#partition">Partition</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#quick-sort-recursion">Quick Sort Recursion</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#quicksort-sort-js-implementation">Quicksort Sort JS Implementation</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-and-space-complexity-analysis-1">Time and Space Complexity Analysis</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-complexity">Time Complexity</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#space-complexity">Space Complexity</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#when-should-we-use-quick-sort">When should we use Quick Sort?</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#end-of-efficient-sorting-algorithms">End of Efficient Sorting Algorithms</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#binary-search">Binary Search</a>
                <ul>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#the-algorithm-check-the-middle-and-half-the-search-space">The Algorithm: "check the middle and half the search space"</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#binary-search-recursion">Binary Search Recursion</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#binary-search-js-implementation">Binary Search JS Implementation</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-and-space-complexity-analysis-2">Time and Space Complexity Analysis</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-complexity-ologn">Time Complexity: O(log(n))</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#space-complexity-on-1">Space Complexity: O(n)</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#when-should-we-use-binary-search">When should we use Binary Search?</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#end-of-binary-search">End of Binary Search</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#memoization">Memoization</a>
                <ul>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#dynamic-programming">Dynamic Programming</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#memoization-1">Memoization</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#memoizing-factorial-kind-of">Memoizing Factorial (kind of)</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#memoizing-fib-actually">Memoizing Fib (actually)</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#the-memoization-formula">The Memoization Formula</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#end-of-memoization">end-of-memoization</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#tabulation">tabulation</a>
                <ul>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#tabulation-1">Tabulation</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#tabulating-fib">Tabulating Fib</a>
                                <ul>
                                    <li>
                                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#complexity-analysis">Complexity Analysis</a>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#aside-refactoring-for-o1-space">Aside: Refactoring for O(1) Space</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#the-tabulation-formula">The Tabulation Formula</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#end-of-tabulation">End of Tabulation</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#linked-lists">Linked-Lists</a>
                <ul>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#what-is-a-linked-list">What is a Linked List?</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#_sothis-sounds-a-lot-like-an-array_">
                                    <em>"So...this sounds a lot like an Array..."</em>
                                </a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#types-of-linked-lists">Types of Linked Lists</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#linked-list-methods">Linked List Methods</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-and-space-complexity-analysis-3">Time and Space Complexity Analysis</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-complexity-access-and-search">Time Complexity - Access and Search:</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#scenarios">Scenarios:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#discussion">Discussion:</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-complexity-insertion-and-deletion">Time Complexity - Insertion and Deletion:</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#scenarios-1">Scenarios:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#discussion-1">Discussion:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#note">NOTE:</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#space-complexity-1">Space Complexity:</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#scenarios-2">Scenarios:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#discussion-2">Discussion:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#note-1">NOTE:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#end-of-linked-list">End of Linked-List</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#stacks-and-queues">Stacks And Queue's</a>
                <ul>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#what-is-a-stack">What is a Stack?</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#what-is-a-queue">What is a Queue?</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#stack-and-queue-properties">Stack and Queue Properties</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#stack-methods">Stack Methods</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#stack-javascript-implementation">Stack JavaScript Implementation</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#queue-methods">Queue Methods</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#queue-javascript-implementation">Queue JavaScript Implementation</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-and-space-complexity-analysis-4">Time and Space Complexity Analysis</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-complexity-access-and-search-1">Time Complexity - Access and Search:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-complexity-insertion-and-deletion-1">Time Complexity - Insertion and Deletion:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#space-complexity-2">Space Complexity:</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#when-should-we-use-stacks-and-queues">When should we use Stacks and Queues?</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#stacks">Stacks:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#queues">Queues:</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#end-of-stacks-and-queues">End of Stacks And Queue's</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#binary-trees">Binary-Trees</a>
                <ul>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#what-is-a-graph">What is a Graph?</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#what-is-a-tree">What is a Tree?</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#what-is-a-binary-tree">What is a Binary Tree?</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#representing-a-tree-with-node-instances">Representing a Tree with Node Instances</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#basic-tree-terminology">Basic Tree Terminology</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#in-order">In-Order</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#post-order">Post-Order</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#end-of-binary-trees">End of Binary-Trees</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#binary-search-trees">Binary-Search-Trees</a>
                <ul>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#bst-definition">BST Definition</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#a-bst-is-a-sorted-data-structure">A BST is a Sorted Data Structure</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#naive-bst-implementation">Naive BST Implementation</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#implementing-binary-search-on-a-bst">Implementing Binary Search on a BST</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#height-balance">Height Balance</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#only-the-best-trees-have-logs">Only the Best Trees Have Logs</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#time-complexity-analysis-of-binary-search-for-bsts">Time Complexity Analysis of Binary Search for BSTs</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#space-complexity-analysis-of-binary-search-for-bsts">Space Complexity Analysis of Binary Search for BSTs</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#end-of-binary-search-trees">End of Binary-Search-Trees</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#depth-first">Depth-First</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#depth-first-implementation">Depth-First Implementation</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#breadth-first">Breadth-First</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#breadth-first-implementation">Breadth-First Implementation</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#graphs-graph-traversal">Graphs &amp; Graph Traversal</a>
                <ul>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#what-is-a-graph-1">What is a Graph?</a>
                    </li>
                    <li>
                        <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#graph-implementations">Graph Implementations</a>
                        <ul>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#graphnode-class">GraphNode Class</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#adjacency-matrix">Adjacency Matrix</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#adjacency-list">Adjacency List</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#graph-traversal-w-graphnode">Graph Traversal w/ GraphNode</a>
                            </li>
                            <li>
                                <a href="file:///C:/Users/bryan/AppData/Local/Temp/mume2021127-16056-iugj8b.cx6z.html#graph-traversal-w-adjacency-list">Graph Traversal w/ Adjacency List</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </div>
    <a id="sidebar-toc-btn">=</a> 
    <script type="text/javascript">

    var sidebarTOCBtn = document.getElementById( 'sidebar-toc-btn' )
    sidebarTOCBtn.addEventListener( 'click', function ( event ) {
      event.stopPropagation()
      if ( document.body.hasAttribute( 'html-show-sidebar-toc' ) ) {
        document.body.removeAttribute( 'html-show-sidebar-toc' )
      } else {
        document.body.setAttribute( 'html-show-sidebar-toc', true )
      }
    } );
  
</script></body>
</html>
