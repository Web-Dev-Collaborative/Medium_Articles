<!DOCTYPE html>
<html lang="en">


<head>


  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="content-language" content="en-us">
  <meta name="csrf-token" value="abI2zOnZnZ4lK2hhXDpfWnEsePWz7XmLPaj0IDqr">
  <title> | bgoonz | GistLog - Your dev blog delivered</title>

  <!-- Schema.org markup for Google+ -->
  <meta itemprop="name" content="">
  <meta itemprop="description" content="Basic definitions

String s matches the regex pattern /p/ whenever s contains the pattern &#039;p&#039;.

Example: abc matches /a/, /b/, /c/


For simplicity, we will use the matches verb loosely in a sense that

a">

  <!-- Open Graph data -->
  <meta property="og:title" content="">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://gistlog.co/bgoonz/c559a8e4d6fd2eb586b2e8452d6e233b">
  <meta property="og:description" content="Basic definitions

String s matches the regex pattern /p/ whenever s contains the pattern &#039;p&#039;.

Example: abc matches /a/, /b/, /c/


For simplicity, we will use the matches verb loosely in a sense that

a">
  <meta property="og:site_name" content="GistLog">


  <link rel="icon" type="image/png" href="https://gistlog.co/img/favicon.png">
  <link rel="stylesheet" href="http://brick.a.ssl.fastly.net/Roboto:100,300,400,700">
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
  <link href="https://gistlog.co/css/app.css" rel="stylesheet">


  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body class="font-sans border-t-8 border-blue-darker bg-grey-lightest">
  <div class="flex flex-col h-screen">
    <div id="app" class="flex-auto">
      <nav class="container mx-auto mt-4">
        <a href="https://gistlog.co/" title="GistLog by Tighten"
          class="w-full flex items-center text-blue-darker no-underline">
          <img width="50px" src="https://gistlog.co/img/gistlog-logo.svg" alt="GistLog logo." class="mr-2">
          <h1 class="text-2xl"><span class="font-bold">Gist</span>Log</h1>
        </a>
      </nav>


      <div class="container gistlog__container">
        <div class="avatar">
          <a href="https://gistlog.co/bgoonz" target="_blank">
            <img src="https://avatars.githubusercontent.com/u/66654881?v=4" alt="bgoonz - Laravel">
          </a>
        </div>
        <div class="py-8 gistlog sm:px-8">
          <article class="px-4 my-8 sm:px-8">
            <h1 class="gistlog__title" v-pre></h1>
            <span class="table mx-auto font-light" v-pre>
              by <a href="https://gistlog.co/bgoonz" class="font-bold no-underline text-blue-dark">bgoonz</a>
            </span>

            <div class="gistlog__content">
              <div v-pre>
                <h2>Basic definitions</h2>
                <ul>
                  <li>String <code>s</code> <em>matches</em> the regex pattern <code>/p/</code> whenever <code>s</code>
                    contains the pattern 'p'.
                    <ul>
                      <li>Example: <code>abc</code> matches <code>/a/</code>, <code>/b/</code>, <code>/c/</code></li>
                    </ul>
                  </li>
                  <li>For simplicity, we will use the <em>matches</em> verb loosely in a sense that
                    <ul>
                      <li>a string can <em>match</em> a regex (e.g. 'a' matches /a/)</li>
                      <li>a regex can <em>match</em> a string (e.g. /a/ matches 'a')</li>
                    </ul>
                  </li>
                  <li>A regex pattern consists of <em>literal characters</em> that match itself, and <em>metasyntax
                      characters</em></li>
                  <li>Literal characters can be <em>concatenated</em> in a regular expression. String <code>s</code>
                    matches <code>/ab/</code> if there is an <code>a</code> character *directly followed by a
                    <code>b</code> character.
                    <ul>
                      <li>Example: <code>abc</code> matches <code>/ab/</code>, <code>/bc/</code>, <code>/abc/</code>
                      </li>
                      <li>Example: <code>abc</code> does not match <code>/ac/</code>, <code>/cd/</code>,
                        <code>/abcd/</code></li>
                    </ul>
                  </li>
                  <li><em>Alternative execution</em> can be achieved with the metasyntax character <code>|</code>
                    <ul>
                      <li><code>/a|b/</code> means: match either <code>a</code> or <code>b</code></li>
                      <li>Example: 'ac', 'b', 'ab' match <code>/a|b/</code></li>
                      <li>Example: 'c' does not match <code>/a|b/</code></li>
                    </ul>
                  </li>
                  <li>Iteration is achieved using repeat modifiers. One repeat modifier is the <code>*</code> (asterisk)
                    metasyntax character.
                    <ul>
                      <li>Example: <code>/a*/</code> matches any string containing any number of <code>a</code>
                        characters</li>
                      <li>Example: <code>/a*/</code> matches any string, including <code>''</code>, because they all
                        contain at least zero <code>a</code> characters</li>
                    </ul>
                  </li>
                  <li>Matching is <em>greedy</em>. A <em>greedy</em> match attempts to stay in iterations as long as
                    possible.
                    <ul>
                      <li>Example: <code>s = 'baaa'</code> matches <code>/a*a/</code> in the following way:
                        <ul>
                          <li><code>s[0]</code>: <code>'b'</code> is discarded</li>
                          <li><code>s[1]</code>: <code>'a'</code> matches the pattern <code>a*</code></li>
                          <li><code>s[1] - s[2]</code>: <code>'aa'</code> matches the pattern <code>a*</code></li>
                          <li><code>s[1] - s[3]</code>: <code>'aaa'</code> matches the pattern <code>a*</code></li>
                          <li>as there are no more characters in <code>s</code> and there is a character yet to be
                            matched in the regex, we <em>backtrack</em> one character</li>
                          <li><code>s[1] - s[2]</code>: <code>'aa'</code> matches the pattern <code>a*</code>, and we
                            end investigating the <code>a*</code> pattern</li>
                          <li><code>s[3]</code>: <code>'a'</code> matches the <code>a</code> pattern</li>
                          <li>there is a complete match, <code>s[1] - s[2]</code> match the <code>a*</code> pattern, and
                            <code>s[3]</code> matches the <code>a</code> pattern. The returned match is <code>aaa</code>
                            starting at index <code>1</code> of string <code>s</code></li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>Backtracking is <em>minimal</em>. We attempt to backtrack one character at a time in the string,
                    and attempt to interpret the rest of the regex pattern on the remainder of the string.</li>
                </ul>
                <h2>Constructing a regex</h2>
                <ul>
                  <li>literal form: <code>/regex/</code></li>
                  <li>constructor: <code>new RegExp( 'regex' );</code>
                    <ul>
                      <li>escaping: <code>/\d/</code> becomes <code>new RegExp( '\\d' )</code></li>
                      <li>argument list: <code>new RegExp( pattern, modifiers );</code></li>
                    </ul>
                  </li>
                </ul>
                <p>Applying modifiers in literal form:</p>
                <pre><code>const regex1 = new RegExp( 'regex', 'ig' );
const regex2 = /regex/ig;
</code></pre>
                <ul>
                  <li><code>RegExp</code> constructor also accepts a regular expression:</li>
                </ul>
                <pre><code>&gt; new RegExp( /regex/, 'i' );
/regex/i
</code></pre>
                <h2>List of JavaScript regex modifiers</h2>
                <table role="table">
                  <thead>
                    <tr>
                      <th>Modifier</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td><code>i</code></td>
                      <td>non-case sensitive matching. Upper and lower cases don't matter.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>g</code></td>
                      <td>global match. We attempt to find all matches instead of just returning the first match. The
                        internal state of the regular expression stores where the last match was located, and matching
                        is resumed where it was left in the previous match.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>m</code></td>
                      <td>multiline match. It treats the <code>^</code> and <code>$</code> characters to match the
                        beginning and the end of each line of the tested string. A newline character is determined by
                        <code>\n</code> or <code>\r</code>.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>u</code></td>
                      <td>unicode search. The regex pattern is treated as a unicode sequence</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>y</code></td>
                      <td>Sticky search</td>
                    </tr>
                  </tbody>
                </table>
                <p>Example:</p>
                <pre><code>&gt; const str = 'Regular Expressions';

&gt; /re/.test( str );
false
&gt; /re/i.test( str ); // matches: 're', 'Re', 'rE', 'RE'
true
</code></pre>
                <h2>Regex API</h2>
                <ul>
                  <li><code>regex.exec( str )</code>: returns information on the first match. Exec allows iteration on
                    the regex for all matches if the <code>g</code> modifier is set for the regex</li>
                  <li><code>regex.test( str )</code>: true iff regex <em>matches</em> a string</li>
                </ul>
                <pre><code>&gt; const regex = /ab/;
&gt; const str = 'bbababb';
&gt; const noMatchStr = 'c';

&gt; regex.exec( str ); // first match is at index 2
[ 0: "ab", index: 2, input: "bbababb" ]
&gt; regex.exec( noMatchStr );
null

&gt; regex.test( str );
true
&gt; regex.test( noMatchStr );
false

&gt; regex.exec( noMatchStr );

&gt; const globalRegex = /ab/g;
&gt; globalRegex.exec( str );
&gt; globalRegex.exec( str );
[ 0: "ab", index: 2, input: "bbababb" ]
&gt; globalRegex.exec( str );
[ 0: "ab", index: 4, input: "bbababb" ]
&gt; globalRegex.exec( str );
null

&gt; let result;
&gt; while ( ( result = globalRegex.exec( str ) ) !== null ) {
      console.log( result );
  }
[ 0: "ab", index: 2, input: "bbababb" ]
[ 0: "ab", index: 4, input: "bbababb" ]  
</code></pre>
                <h2>String API</h2>
                <ul>
                  <li><code>str.match( regex )</code>: for non-global regular expression arguments, it returns the same
                    return value as <code>regex.exec( str )</code>. For global regular expressions, the return value is
                    an array containing all the matches. Returns <code>null</code> if no match has been found.</li>
                  <li><code>str.replace( regex, newString )</code>: replaces the first full match with
                    <code>newString</code>. If <code>regex</code> has a global modifier, <code>str.replace( regex,
                      newString )</code> replaces all matches with <code>newString</code>. Does not mutate the original
                    string <code>str</code>.</li>
                  <li><code>str.search( regex )</code>: returns the index of the first match. Returns <code>-1</code>
                    when no match is found. Does not consider the global modifier.</li>
                  <li><code>str.split( regex )</code>: does not consider the global modifier. Returns an array of
                    strings containing strings in-between matches.</li>
                </ul>
                <pre><code>&gt; const regex = /ab/;
&gt; const str = 'bbababb';
&gt; const noMatchStr = 'c';

&gt; str.match( regex );
["ab", index: 2, input: "bbababb"]

&gt; str.match( globalRegex );
["ab", "ab"]

&gt; noMatchStr.match( globalRegex );
null

&gt; str.replace( regex, 'X' );
"bbXabb"

&gt; str.replace( globalRegex, 'X' )
"bbXXb"

&gt; str.search( regex );
2

&gt; noMatchStr.search( regex );
-1

&gt; str.split( regex );
["bb", "", "b"]

&gt; noMatchStr.split( regex );
["c"]
</code></pre>
                <h2>Literal characters</h2>
                <p>A regex <em>literal character</em> matches itself. The expression <code>/a/</code> matches any string
                  that contains the <code>a</code> character. Example:</p>
                <pre><code>/a/.test( 'Andrea' )   // true, because the last character is 'a'
/a/.test( 'André' )    // false, because there is no 'a' in the string
/a/i.test( 'André')    // true, because 'A' matches /a/i with the case-insensitive flag `i` applied on `/a/`
</code></pre>
                <p>Literal characters are: all characters except metasyntax characters such as: <code>.</code>,
                  <code>*</code>, <code>^</code>, <code>$</code>, <code>[</code>, <code>]</code>, <code>(</code>,
                  <code>)</code>, <code>{</code>, <code>}</code>, <code>|</code>, <code>?</code>, <code>+</code>,
                  <code>\</code></p>
                <p>When you need a metasyntax character, place a backslash in front of it. Examples: <code>\.</code>,
                  <code>\\</code>, <code>\[</code>.</p>
                <p>Whitespaces:</p>
                <ul>
                  <li>behave as literal characters, exact match is required</li>
                  <li>use character classes for more flexibility, such as:
                    <ul>
                      <li><code>\n</code> for a newline</li>
                      <li><code>\t</code> for a tab</li>
                      <li><code>\b</code> for word boundaries</li>
                    </ul>
                  </li>
                </ul>
                <h2>Metasyntax characters</h2>
                <table role="table">
                  <thead>
                    <tr>
                      <th>Metasyntax character</th>
                      <th>Semantics</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td><code>.</code></td>
                      <td>arbitrary character class</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>[]</code></td>
                      <td>character sets, <code>[012]</code> means 0, or 1, or 2</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>^</code></td>
                      <td>(1) negation, e.g. in a character set <code>[^890]</code> means not 8, not 9, and not 10, (2)
                        anchor matching the start of the string or line</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>$</code></td>
                      <td>anchor matching the end of the string or line</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td>`</td>
                      <td>`</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>*</code></td>
                      <td>iteration: match any number of times</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>?</code></td>
                      <td>optional parts in the expression</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>+</code></td>
                      <td>match at least once</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>{}</code> and <code>{,}</code></td>
                      <td>specify a range for the number of times an expression has to match the string. Forms:
                        <code>{3}</code> exactly 3 times, <code>{3,}</code> at least 3 times, <code>{3,5}</code> between
                        3 and 5 times.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>()</code></td>
                      <td>(1) overriding precedence through grouping, (2) extracting substrings</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\</code></td>
                      <td>(1) before a metasyntax character: the next character becomes a literal character (e.g.
                        <code>\\</code>). (2) before a special character: the sequence is interpreted as a special
                        character sequence (e.g. <code>\d</code> as digit).</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>(?:</code>, <code>)</code></td>
                      <td>non-capturing parentheses. Anything in-between <code>(?:</code> and <code>)</code> is matched,
                        but not captured. Should be used to achieve only functionality (1) of <code>()</code>
                        parentheses.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>(?=</code>, <code>)</code></td>
                      <td>lookahead. E.g. <code>.(?=end)</code> matches an arbitrary character if it is followed by the
                        characters <code>end</code>. Only the character is returned in the match, <code>end</code> is
                        excluded.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>(?!</code>, <code>)</code></td>
                      <td>negative lookahead. E.g. <code>.(?!end)</code> matches an arbitrary character if it is
                        <strong>not</strong> followed by the characters <code>end</code>. Only the character is returned
                        in the match, <code>end</code> is excluded.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\b</code></td>
                      <td>word boundary. Zero length assertion. Matches the start or end position of a word. E.g.
                        <code>\bworld\b</code> matches the string <code>'the world'</code></td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>[\b]</code></td>
                      <td>matches a backspace character. This is <strong>not</strong> a character set including a word
                        boundary.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\B</code></td>
                      <td>not a word boundary.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\c</code></td>
                      <td><code>\c</code> is followed by character <code>x</code>. <code>\cx</code> matches <code>CTRL +
                          x</code>.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\d</code></td>
                      <td>digit. <code>[0-9]</code></td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\D</code></td>
                      <td>non-digit. <code>[^0-9]</code></td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\f</code></td>
                      <td>form feed character</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\n</code></td>
                      <td>newline character (line feed)</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\r</code></td>
                      <td>carriage return character</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\s</code></td>
                      <td>one arbitrary white space character</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\S</code></td>
                      <td>one non-whitespace character</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\t</code></td>
                      <td>tab character</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\u</code></td>
                      <td><code>\u</code> followed by four hexadecimal digits matches a unicode character described by
                        those four digits when the <code>u</code> flag is not set. When the <code>u</code> flag is set,
                        use the format <code>\u{0abc}</code>.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\v</code></td>
                      <td>vertical tab character</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\w</code></td>
                      <td>alphanumeric character. <code>[A-Za-z0-9_]</code></td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\W</code></td>
                      <td>non-alphanumeric character</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\x</code></td>
                      <td><code>\x</code> followed by two hexadecimal digits matches the character described by those
                        two digits.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\0</code></td>
                      <td>NULL character. Equivalent to <code>\x00</code> and <code>\u0000</code>. When the
                        <code>u</code> flag is set for the regex, it is equivalent to <code>\u{0000}</code>.</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>\1</code>, <code>\2</code>, ...</td>
                      <td>backreference. <code>\i</code> is a reference to the matched contents of the <em>i</em>th
                        capture group.</td>
                    </tr>
                  </tbody>
                </table>
                <p>Examples:</p>
                <pre><code>/.../.test( 'ab' )  // false, we need at least three arbitrary characters
/.a*/.test( 'a' )   // true, . matches 'a', and a* matches ''
/^a/.test( 'ba' )   // false, 'ba' does not start with a
/^a/.test( 'ab' )   // true, 'ab' starts with a
/a$/.test( 'ba' )   // true, 'ba' ends with a
/a$/.test( 'ab' )   // false, 'ab' does not end with a
/^a$/.test( 'ab' )  // false, 'ab' does not fully match a
/^a*$/.test( 'aa' ) // true, 'aa' fully matches a pattern consisting of
                    // a characters only
/[ab]/.test( 'b' )  // true, 'b' contains a character that is a
                    // member of the character class `[ab]`
/a|b/.test( 'b' )   // true, 'b' contains a character that is 
                    // either `a` or `b`
/ba?b/.test( 'bb' ) // true, the optional a is not included
/ba?b/.test( 'bab') // true, the optional a is included
/ba?b/.test( 'bcb') // false, only matches 'bb' or 'bab'
/a+/.test( '' )     // false, at least one `a` character is needed
/a+/.test( 'ba' )   // true, the `a` character was found
/a{3}/.test('baaab')// true, three consecutive 'a' characters were found  
/(a|b)c/.test('abc')// true, a `b` character is followed by `c`
/a(?=b)/.test('ab') // true. It matches 'a', because 'a' is followed by 'b'
/a(?!b)/.test('ab') // false, because 'a' is not followed by 'b'
/\ba/.test('bab')   // false, because 'a' is not the first character of a word
/\Ba/.test('bab')   // true, because 'a' is not the first character of a word
/(\d)\1/.test('55') // true. It matches two consecutive digits with the same value
</code></pre>
                <p>In the last example, notice the parentheses. As the <code>|</code> operator has the lowest precedence
                  out of all operators, parentheses made it possible to increase the prcedence of the alternative
                  execution <code>a|b</code> higher than concatenation <code>(a|b)c</code>.</p>
                <h2>Character sets, character classes</h2>
                <ul>
                  <li><code>[abc]</code> is <code>a|b|c</code></li>
                  <li><code>[a-c]</code> is <code>[abc]</code></li>
                  <li><code>[0-9a-fA-F]</code> is a case-insensitive hexadecimal digit</li>
                  <li><code>[^abc]</code> is an arbitrary character that is not <code>a</code>, not <code>b</code>, and
                    not <code>c</code></li>
                  <li><code>.</code>: arbitrary character class
                    <ul>
                      <li>Example: <code>/..e/</code>: three character sequence ending with <code>e</code></li>
                    </ul>
                  </li>
                  <li>other character classes such as digit (<code>\d</code>), not a digit (<code>\D</code>), word
                    (<code>\w</code>), not a word (<code>\W</code>), whitespace character (<code>\s</code>): check out
                    the section on metasyntax characters</li>
                </ul>
                <h2>Basic (greedy) Repeat modifiers</h2>
                <p>Matching is maximal. Backtracking is minimal, goes character by character.</p>
                <table role="table">
                  <thead>
                    <tr>
                      <th>Repeat modifier</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td><code>+</code></td>
                      <td>Match at least once</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>?</code></td>
                      <td>Match at most once</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>*</code></td>
                      <td>Match any number of times</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>{min,max}</code></td>
                      <td>match at least <code>min</code> times, and at most <code>max</code> times</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>{n}</code></td>
                      <td>Match exactly <code>n</code> times</td>
                    </tr>
                  </tbody>
                </table>
                <p>Examples:</p>
                <ul>
                  <li><code>/^a+$/</code> matches any string consisting of one or more <code>'a'</code> characters and
                    nothing else</li>
                  <li><code>/^a?$/</code> matches <code>''</code> or <code>'a'</code>. The string may contain at most
                    one <code>'a'</code> character</li>
                  <li><code>/^a*$/</code> matches the empty string and everything matched by <code>/^a+$/</code></li>
                  <li><code>/^a{3,5}$/</code> matches <code>'aaa'</code>, <code>'aaaa'</code>, and <code>'aaaaa'</code>
                  </li>
                  <li><code>/(ab){3}/</code> matches any string containing the substring <code>'ababab'</code></li>
                </ul>
                <h2>Lazy Repeat Modifiers</h2>
                <p>Matching is minimal. During backtracking, we add one character at a time.</p>
                <table role="table">
                  <thead>
                    <tr>
                      <th>Repeat modifier (PCRE)</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td><code>+?</code></td>
                      <td>Match at least once</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>??</code></td>
                      <td>Match at most once</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>*?</code></td>
                      <td>Match any number of times</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>{min,max}?</code></td>
                      <td>match at least <code>min</code> times, and at most <code>max</code> times</td>
                    </tr>
                    <tr>
                      <td></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td><code>{n}?</code></td>
                      <td>Match exactly <code>n</code> times</td>
                    </tr>
                  </tbody>
                </table>
                <p>Examples for lazy matching:</p>
                <ul>
                  <li><code>/^a+?$/</code> lazily matches any string consisting of one or more <code>'a'</code>
                    characters and nothing else</li>
                  <li><code>/^a??$/</code> lazily matches <code>''</code> or <code>'a'</code>. The string may contain at
                    most one <code>'a'</code> character</li>
                  <li><code>/^a*?$/</code> lazily matches the empty string and everything matched by <code>/^a+$/</code>
                  </li>
                  <li><code>/^a{3,5}?$/</code> lazily matches <code>'aaa'</code>, <code>'aaaa'</code>, and
                    <code>'aaaaa'</code></li>
                  <li><code>/(ab){3}?/</code> lazily matches any string containing the substring <code>'ababab'</code>
                  </li>
                </ul>
                <h2>Capture groups</h2>
                <ul>
                  <li><code>(</code> and <code>)</code> captures a substring inside a regex</li>
                  <li>Capture groups have a reference number equal to the order of the starting parentheses of the open
                    parentheses of the capture group starting with <code>1</code></li>
                  <li><code>(?:</code> and <code>)</code> act as non-capturing parentheses, they are not included in the
                    capture group numbering</li>
                </ul>
                <p>Example:</p>
                <pre><code>/a(b|c(d|(e))(f))$/
  ^   ^  ^   ^
  |   |  |   |
  1   2  3   4
</code></pre>
                <pre><code>&gt; console.table( /^a(b|c(d|(e))(f+))$/.exec( 'ab' ) )  
(index) Value
0       "ab"
1       "b"
2       undefined
3       undefined
4       undefined
index   0
input   "ab"

&gt; console.table( /^a(b|c(d|(e))(f+))$/.exec( 'aceff' ) )  
(index) Value
0       "aceff"
1       "ceff"
2       "e"
3       "e"
4       "ff"
index   0
input   "aceff"

&gt; console.table( /^a(b|c(?:d|(e))(f+))$/.exec( 'aceff' ) )  
(index) Value
0       "aceff"
1       "ceff"
2       "e"
3       "ff"
index   0
input   "aceff"
</code></pre>
                <h2>Lookahead and Lookbehind</h2>
                <table role="table">
                  <thead>
                    <tr>
                      <th>Lookahead type</th>
                      <th>JavaScript syntax</th>
                      <th>Remark</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>positive lookahead</td>
                      <td><code>(?=pattern)</code></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td>negative lookahead</td>
                      <td><code>(?!pattern)</code></td>
                      <td></td>
                    </tr>
                    <tr>
                      <td>positive lookbehind</td>
                      <td><code>(?&lt;=pattern)</code></td>
                      <td>only expected in ES2018</td>
                    </tr>
                    <tr>
                      <td>negative lookbehind</td>
                      <td><code>(?&lt;!pattern)</code></td>
                      <td>only expected in ES2018</td>
                    </tr>
                    <tr>
                      <td>word boundary</td>
                      <td><code>\b</code></td>
                      <td>used both as lookahead and lookbehind</td>
                    </tr>
                    <tr>
                      <td>start of string/line</td>
                      <td><code>^</code></td>
                      <td>used as a lookbehind</td>
                    </tr>
                    <tr>
                      <td>end of string/line</td>
                      <td><code>$</code></td>
                      <td>used as a lookbehind</td>
                    </tr>
                  </tbody>
                </table>
                <ul>
                  <li>Lookaheads and lookbehinds are non-capturing</li>
                  <li>Opposed to Perl 5, lookbehinds can be of variable length, because matching is implemented
                    backwards. This means no restrictions in lookbehind length
                    <ul>
                      <li>as a consequence of backwards matching, using capture groups inside lookbehinds are evaluated
                        according to the rules of backwards matching</li>
                    </ul>
                  </li>
                </ul>
                <p>Examples:</p>
                <pre><code>&gt; /a(?=b)/.exec( 'ab' )
["a", index: 0, input: "ab"]

&gt; /a(?!\d)/.exec( 'ab' )
["a", index: 0, input: "ab"]
&gt; /a(?!\d)/.exec( 'a0' )
null

&gt; /(?&lt;=a)b/.exec( 'ab' )
["b", index: 1, input: "ab"] // executed in latest Google Chrome

/(?&lt;!a)b/.exec( 'Ab' )
["b", index: 1, input: "Ab"] // executed in latest Google Chrome

/\bregex\b/.exec( 'This regex expression tests word boundaries.' )
["regex", index: 5, input: "This regex expression tests word boundaries."]

/^regex$/.exec( 'This\nregex\nexpression\ntests\nanchors.' )
null

/^regex$/m.exec( 'This\nregex\nexpression\ntests\nanchors.' )
["regex", index: 5, input: "This↵regex↵expression↵tests↵anchors."]
</code></pre>
                <h2>Possessive Repeat Modifiers</h2>
                <p>Attempts a maximal (greedy) match first. The loop does not backtrack though. It either accepts the
                  maximal match, or fails.</p>
                <p>Possessive repeat modifiers don't exist in JavaScript. However, there are workarounds.</p>
                <p>Assuming we don't have any other capture groups in front of the expression, use</p>
                <ul>
                  <li><code>(?=(a+))\1</code> instead of the generic PCRE pattern <code>a++</code></li>
                  <li><code>(?=(a*))\1</code> instead of the generic PCRE pattern <code>a*+</code></li>
                  <li>etc.</li>
                </ul>

                <div class="mt-8 mb-2 text-xs text-grey-darker">
                  Created 1 week ago |
                  Updated 1 week ago
                </div>

                <div>
                  <a class="text-xs no-underline text-blue"
                    href="https://gist.github.com/c559a8e4d6fd2eb586b2e8452d6e233b" target="_blank">View on GitHub</a>
                </div>
              </div>

              <div class="pt-4 mb-8">
                <h2 class="mb-2 text-2xl">Comments</h2>

                <form method="POST" class="flex flex-col mb-2 -mt-2 flex-end"
                  action="https://gistlog.co/comment/c559a8e4d6fd2eb586b2e8452d6e233b">
                  <input type="hidden" name="_token" value="abI2zOnZnZ4lK2hhXDpfWnEsePWz7XmLPaj0IDqr">
                  <label for="comment" class="hidden">Comment</label>
                  <textarea id="comment" name="comment"
                    class="w-full px-4 py-3 text-base border border-solid rounded text-grey border-grey"
                    placeholder="Join the discussion&hellip;" required></textarea>
                  <div class="flex justify-end flex-1">
                    <a class="btn-github" href="https://gistlog.co/auth/github">
                      <span class="w-6 mr-2 text-white fill-current">
                        <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 1024 1024"
                          enable-background="new 0 0 1024 1024" xml:space="preserve">
                          <path
                            d="M512 0C229.25 0 0 229.25 0 512c0 226.25 146.688 418.125 350.156 485.812 25.594 4.688 34.938-11.125 34.938-24.625 0-12.188-0.469-52.562-0.719-95.312C242 908.812 211.906 817.5 211.906 817.5c-23.312-59.125-56.844-74.875-56.844-74.875-46.531-31.75 3.53-31.125 3.53-31.125 51.406 3.562 78.47 52.75 78.47 52.75 45.688 78.25 119.875 55.625 149 42.5 4.654-33 17.904-55.625 32.5-68.375C304.906 725.438 185.344 681.5 185.344 485.312c0-55.938 19.969-101.562 52.656-137.406-5.219-13-22.844-65.094 5.062-135.562 0 0 42.938-13.75 140.812 52.5 40.812-11.406 84.594-17.031 128.125-17.219 43.5 0.188 87.312 5.875 128.188 17.281 97.688-66.312 140.688-52.5 140.688-52.5 28 70.531 10.375 122.562 5.125 135.5 32.812 35.844 52.625 81.469 52.625 137.406 0 196.688-119.75 240-233.812 252.688 18.438 15.875 34.75 47 34.75 94.75 0 68.438-0.688 123.625-0.688 140.5 0 13.625 9.312 29.562 35.25 24.562C877.438 930 1024 738.125 1024 512 1024 229.25 794.75 0 512 0z" />
                        </svg>
                      </span>
                      Sign in with GitHub
                    </a>
                  </div>
                </form>

                <gist-comments gist-author="bgoonz" gist-id="c559a8e4d6fd2eb586b2e8452d6e233b"></gist-comments>
              </div>
            </div>
          </article>
        </div>
      </div>
    </div>

    <div
      class="flex flex-col lg:flex-row bg-grey-darkest justify-center items-center text-xs md:text-sm text-white mt-4 py-4">
      <div>
        <a href="https://gistlog.co/" class="text-blue-lighter no-underline hover:text-white">GistLog</a>
        &copy; 2021
        <span class="hidden lg:inline-block">|&nbsp;</span>
      </div>

      <div>
        Brought to you by the lovely humans at
        <a href="https://tighten.co/" class="text-blue-lighter no-underline hover:text-white">Tighten</a>
      </div>
    </div>
  </div>

  <script src="https://gistlog.co/js/app.js"></script>
  <script>
    ( function () {
      autosize( document.querySelectorAll( 'textarea' ) );
    } )();
  </script>
  <script>
    ( function () {
      const alerts = document.querySelectorAll( '.js-auto_dismiss' );
      if ( typeof ( alerts ) !== undefined ) {
        alerts.forEach( ( el ) => setTimeout( () => fadeOut( el ), 4500 ) );
      }
    } )();

    function fadeOut( el ) {
      el.style.opacity = 1;
      ( function fade() {
        if ( ( el.style.opacity -= .1 ) < 0 ) {
          el.style.display = "none";
        } else {
          requestAnimationFrame( fade );
        }
      } )();
    }
  </script>
</body>


</html>
